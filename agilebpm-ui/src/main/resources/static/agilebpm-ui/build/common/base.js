/*! AGILE-BPM 版权所有，翻版必究 */
!function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}var installedModules={};__webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{configurable:!1,enumerable:!0,get:getter})},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=10)}([,function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1,eval)("this");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === "object")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2goZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxuXHRcdGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["$"] = __webpack_require__(12);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLWV4cG9zZWQ/ODJlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxRyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxbXCIkXCJdID0gcmVxdWlyZShcIi0hQzpcXFxcVXNlcnNcXFxcbWlhb19wY1xcXFxnaXRcXFxcYWdpbGVicG1cXFxcYnBtLWV4cGxvcmVyXFxcXG5vZGVfbW9kdWxlc1xcXFxleHBvc2UtbG9hZGVyXFxcXGluZGV4LmpzP2pRdWVyeSEuXFxcXGpxdWVyeS5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMtZXhwb3NlZFxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},,,,,,,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_expose_loader_jquery__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_expose_loader_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_expose_loader_jquery__);\n\r\n// 配置\r\n__webpack_require__(14);\r\n\r\n// css\r\n__webpack_require__(15);\r\n__webpack_require__(16);\r\n__webpack_require__(17);\r\n__webpack_require__(18);\r\n//平台css\r\n__webpack_require__(19);\r\n// 平台util\r\n__webpack_require__(20);\r\n\r\n__webpack_require__(21);\r\n__webpack_require__(22);\r\n\r\n__webpack_require__(23);\r\n\r\n// 弹框\r\n__webpack_require__(24);\r\n__webpack_require__(25);\r\n__webpack_require__(26);\r\n__webpack_require__(29);\r\n__webpack_require__(30);\r\n\r\n// 日期选择\r\n__webpack_require__(31);\r\n__webpack_require__(32);\r\n\r\n// ztree \r\n__webpack_require__(33);\r\n__webpack_require__(34);\r\n__webpack_require__(35);\r\n\r\n//两个比较小的列表页 的css这里放 base css中，减少列表页面 特殊css 引入了\r\n__webpack_require__(36);\r\n__webpack_require__(37);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvZW50cnkvY29tbW9uL2Jhc2UuanM/ZDBlYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQganF1ZXJ5IGZyb20gJ2V4cG9zZS1sb2FkZXI/JCFqcXVlcnknO1xyXG4vLyDphY3nva5cclxucmVxdWlyZSgnLi4vLi4vYXBwLWNvbmYuanMnKTtcclxuXHJcbi8vIGNzc1xyXG5yZXF1aXJlKCcuLi8uLi9jc3MvYm9vdHN0cmFwLm1pbi5jc3MnKTtcclxucmVxdWlyZSgnLi4vLi4vY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzJyk7XHJcbnJlcXVpcmUoJy4uLy4uL2Nzcy9hbmltYXRlLmNzcycpO1xyXG5yZXF1aXJlKCcuLi8uLi9qcy9wbHVnaW5zL2pxdWVyeS1xdGlwL2pxdWVyeS5xdGlwLmNzcycpO1xyXG4vL+W5s+WPsGNzc1xyXG5yZXF1aXJlKCcuLi8uLi9jc3Mvc3R5bGUuY3NzJyk7XHJcbi8vIOW5s+WPsHV0aWxcclxucmVxdWlyZSgnLi4vLi4vanMvY29tbW9uL3Rvb2xzL3V0aWwuanMnKTtcclxuXHJcbnJlcXVpcmUoJy4uLy4uL2pzL2Jvb3RzdHJhcC5taW4uanMnKTtcclxucmVxdWlyZSgnLi4vLi4vanMvcGx1Z2lucy9wZWl0eS9qcXVlcnkucGVpdHkubWluLmpzJyk7XHJcblxyXG5yZXF1aXJlKCcuLi8uLi9qcy9wbHVnaW5zL2pxdWVyeS1xdGlwL2pxdWVyeS5xdGlwLmpzJyk7XHJcblxyXG4vLyDlvLnmoYZcclxucmVxdWlyZSgnLi4vLi4vanMvY29tbW9uL3Rvb2xzL2RpYWxvZ0NyZWF0b3IuanMnKTtcclxucmVxdWlyZSgnLi4vLi4vanMvcGx1Z2lucy90b2FzdHIvdG9hc3RyLm1pbi5jc3MnKTtcclxucmVxdWlyZSgnZXhwb3NlLWxvYWRlcj90b2FzdHIhLi4vLi4vanMvcGx1Z2lucy90b2FzdHIvdG9hc3RyLm1pbi5qcycpO1xyXG5yZXF1aXJlKCcuLi8uLi9qcy9wbHVnaW5zL2xheWVyL2xheWVyLm1pbi5qcycpO1xyXG5yZXF1aXJlKCcuLi8uLi9qcy9wbHVnaW5zL2xheWVyL3NraW4vbGF5ZXIuY3NzJyk7XHJcblxyXG4vLyDml6XmnJ/pgInmi6lcclxucmVxdWlyZSgnLi4vLi4vanMvcGx1Z2lucy9sYXllci9sYXlkYXRlL2xheWRhdGUuanMnKTtcclxucmVxdWlyZSgnLi4vLi4vanMvcGx1Z2lucy9sYXllci9sYXlkYXRlL3RoZW1lL2RlZmF1bHQvbGF5ZGF0ZS5jc3MnKTtcclxuXHJcbi8vIHp0cmVlIFxyXG5yZXF1aXJlKCcuLi8uLi9qcy9wbHVnaW5zL3p0cmVlL2Nzcy96VHJlZVN0eWxlLmNzcycpO1xyXG5yZXF1aXJlKCcuLi8uLi9qcy9wbHVnaW5zL3p0cmVlL2pxdWVyeS56dHJlZS5hbGwubWluLmpzJyk7XHJcbnJlcXVpcmUoJy4uLy4uL2pzL3BsdWdpbnMvenRyZWUvenRyZWVDcmVhdG9yLmpzJyk7XHJcblxyXG4vL+S4pOS4quavlOi+g+Wwj+eahOWIl+ihqOmhtSDnmoRjc3Pov5nph4zmlL4gYmFzZSBjc3PkuK3vvIzlh4/lsJHliJfooajpobXpnaIg54m55q6KY3NzIOW8leWFpeS6hlxyXG5yZXF1aXJlKCcuLi8uLi9jc3MvcGx1Z2lucy9ib290c3RyYXAtdGFibGUvYm9vdHN0cmFwLXRhYmxlLm1pbi5jc3MnKTtcclxucmVxdWlyZSgnLi4vLi4vY3NzL2V4dGVuZHMvbGlzdC5jc3MnKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9lbnRyeS9jb21tb24vYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["$"] = __webpack_require__(2);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLWV4cG9zZWQ/NDk3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvRyIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiJFwiXSA9IHJlcXVpcmUoXCItIUM6XFxcXFVzZXJzXFxcXG1pYW9fcGNcXFxcZ2l0XFxcXGFnaWxlYnBtXFxcXGJwbS1leHBsb3JlclxcXFxub2RlX21vZHVsZXNcXFxcZXhwb3NlLWxvYWRlclxcXFxpbmRleC5qcz8kIUM6XFxcXFVzZXJzXFxcXG1pYW9fcGNcXFxcZ2l0XFxcXGFnaWxlYnBtXFxcXGJwbS1leHBsb3JlclxcXFxub2RlX21vZHVsZXNcXFxcZXhwb3NlLWxvYWRlclxcXFxpbmRleC5qcz9qUXVlcnkhLlxcXFxqcXVlcnkuanNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwb3NlLWxvYWRlcj8kIS4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcy1leHBvc2VkXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["jQuery"] = __webpack_require__(13);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLWV4cG9zZWQ/NzBmNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwwRyIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wialF1ZXJ5XCJdID0gcmVxdWlyZShcIi0hLlxcXFxqcXVlcnkuanNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhwb3NlLWxvYWRlcj9qUXVlcnkhLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLWV4cG9zZWRcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v2.1.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-04-28T16:01Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === "object" && typeof module.exports === "object" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( "jQuery requires a window with a document" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can\'t be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through "use strict" call chains. (#13335)\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = "2.1.4",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: "",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array\'s method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === "boolean" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== "object" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === "function";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|"")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not "[object Object]"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn\'t returned already, we\'re confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + "";\n\t\t}\n\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\treturn typeof obj === "object" || typeof obj === "function" ?\n\t\t\tclass2type[ toString.call(obj) ] || "object" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf("use strict") === 1 ) {\n\t\t\t\tscript = document.createElement("script");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE9-11+\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t"" :\n\t\t\t( text + "" ).replace( rtrim, "" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === "string" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === "string" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {\n\tclass2type[ "[object " + name + "]" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn\'t used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = "length" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === "function" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === "array" || length === 0 ||\n\t\ttypeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = "sizzle" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it\'s faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( "w", "w#" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = "\\\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n\t\t"*\\\\]",\n\n\tpseudos = ":(" + characterEncoding + ")(?:\\\\((" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\t\t// 3. anything else (capture 2)\n\t\t".*" +\n\t\t")\\\\)|)",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + "+", "g" ),\n\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n\trattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( "^" + identifier + "$" ),\n\n\tmatchExpr = {\n\t\t"ID": new RegExp( "^#(" + characterEncoding + ")" ),\n\t\t"CLASS": new RegExp( "^\\\\.(" + characterEncoding + ")" ),\n\t\t"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),\n\t\t"ATTR": new RegExp( "^" + attributes ),\n\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n\t\t\t"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n\t\t\t"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n\t\t\twhitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /\'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = "0x" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +"0x"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a "Permission Denied"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can\'t trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\tnodeType = context.nodeType;\n\n\tif ( typeof selector !== "string" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\tif ( !seed && documentIsHTML ) {\n\n\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle("#ID")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle("TAG")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(".CLASS")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn\'t work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute("id")) ) {\n\t\t\t\t\tnid = old.replace( rescape, "\\\\$&" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( "id", nid );\n\t\t\t\t}\n\t\t\t\tnid = "[id=\'" + nid + "\'] ";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(",");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute("id");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + " " ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement("div");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split("|"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === "input" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === "input" || name === "button") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn\'t yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== "HTML" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\tparent = doc.defaultView;\n\n\t// Support: IE>8\n\t// If iframe document is assigned to "document" variable and if iframe has been reloaded,\n\t// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( "unload", unloadHandler, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( "onunload", unloadHandler );\n\t\t}\n\t}\n\n\t/* Support tests\n\t---------------------------------------------------------------------- */\n\tdocumentIsHTML = !isXML( doc );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = "i";\n\t\treturn !div.getAttribute("className");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName("*") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment("") );\n\t\treturn !div.getElementsByTagName("*").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don\'t pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter["ID"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute("id") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find["ID"];\n\n\t\tExpr.filter["ID"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find["TAG"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === "*" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n\t\t\t\t"<select id=\'" + expando + "-\\f]\' msallowcapture=\'\'>" +\n\t\t\t\t"<option selected=\'\'></option></select>";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll("[msallowcapture^=\'\']").length ) {\n\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\tif ( !div.querySelectorAll("[selected]").length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\tif ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n\t\t\t\trbuggyQSA.push("~=");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(":checked").length ) {\n\t\t\t\trbuggyQSA.push(":checked");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {\n\t\t\t\trbuggyQSA.push(".#.+[+~]");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement("input");\n\t\t\tinput.setAttribute( "type", "hidden" );\n\t\t\tdiv.appendChild( input ).setAttribute( "name", "D" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll("[name=d]").length ) {\n\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(":enabled").length ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll("*,:x");\n\t\t\trbuggyQSA.push(",.*:");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, "div" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, "[s!=\'\']:x" );\n\t\t\trbuggyMatches.push( "!=", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = "",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === "string" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t">": { dir: "parentNode", first: true },\n\t\t" ": { dir: "parentNode" },\n\t\t"+": { dir: "previousSibling", first: true },\n\t\t"~": { dir: "previousSibling" }\n\t},\n\n\tpreFilter: {\n\t\t"ATTR": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === "~=" ) {\n\t\t\t\tmatch[3] = " " + match[3] + " ";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t"CHILD": function( match ) {\n\t\t\t/* matches from matchExpr["CHILD"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === "nth" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t"PSEUDO": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr["CHILD"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || "";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t"TAG": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === "*" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t"CLASS": function( className ) {\n\t\t\tvar pattern = classCache[ className + " " ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n\t\t\t\t});\n\t\t},\n\n\t\t"ATTR": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === "!=";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += "";\n\n\t\t\t\treturn operator === "=" ? result === check :\n\t\t\t\t\toperator === "!=" ? result !== check :\n\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t"CHILD": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n\t\t\t\tforward = type.slice( -4 ) !== "last",\n\t\t\t\tofType = what === "of-type";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t"PSEUDO": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t"not": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t"has": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t"contains": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// "Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element\'s language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name."\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t"lang": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || "") ) {\n\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t"target": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t"root": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t"focus": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t"enabled": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t"disabled": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t"checked": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n\t\t},\n\n\t\t"selected": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t"empty": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t"parent": function( elem ) {\n\t\t\treturn !Expr.pseudos["empty"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t"header": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t"input": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t"button": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t},\n\n\t\t"text": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n\t\t\t\telem.type === "text" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t"first": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t"last": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t"even": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"odd": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + " " ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, " " )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we\'re just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = "";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === "parentNode",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[" "],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n\t\t\t\t\t).replace( rtrim, "$1" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = "0",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be "00" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + " " ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === "function" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement("div") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = "<a href=\'#\'></a>";\n\treturn div.firstChild.getAttribute("href") === "#" ;\n}) ) {\n\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = "<input/>";\n\tdiv.firstChild.setAttribute( "value", "" );\n\treturn div.firstChild.getAttribute( "value" ) === "";\n}) ) {\n\taddHandle( "value", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute("disabled") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[":"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === "string" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = ":not(" + expr + ")";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== "string" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + " " + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === "string" ) {\n\t\t\tif ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== "undefined" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === "string" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, "parentNode" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, "parentNode", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, "nextSibling" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, "previousSibling" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, "nextSibling" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, "previousSibling" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, "nextSibling", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, "previousSibling", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== "Until" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === "string" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === "string" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === "function" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== "string" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we\'re not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],\n\t\t\t\t[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],\n\t\t\t\t[ "notify", "progress", jQuery.Callbacks("memory") ]\n\t\t\t],\n\t\t\tstate = "pending",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + "With" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we\'re not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we\'re already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( "ready" );\n\t\t\tjQuery( document ).off( "ready" );\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( "DOMContentLoaded", completed, false );\n\twindow.removeEventListener( "load", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// We once tried to use readyState "interactive" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === "complete" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( "DOMContentLoaded", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( "load", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === "object" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android<4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android<4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this "owner", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === "string" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the "read" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === "string") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the "set" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If "name" is an array of keys...\n\t\t\t\t// When data is initially created, via ("key", "val") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module\'s maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support "private" and "user" data.\n//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === "string" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === "true" ? true :\n\t\t\t\t\tdata === "false" ? false :\n\t\t\t\t\tdata === "null" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn\'t change the string\n\t\t\t\t\t+data + "" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( "data-" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, "hasDataAttrs", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === "object" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might\'ve been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf("-") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || "fx" ) + "queue";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || "fx";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === "inprogress" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === "fx" ) {\n\t\t\t\tqueue.unshift( "inprogress" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + "queueHooks";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks("once memory").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + "queue", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tdata = type;\n\t\t\ttype = "fx";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === "fx" && queue[0] !== "inprogress" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || "fx", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || "fx";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + "queueHooks" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( "div" ) ),\n\t\tinput = document.createElement( "input" );\n\n\t// Support: Safari<=5.1\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( "type", "radio" );\n\tinput.setAttribute( "checked", "checked" );\n\tinput.setAttribute( "name", "t" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari<=5.1, Android<4.2\n\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<=11+\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = "<textarea>x</textarea>";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = "onfocusin" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || "" ).match( rnotwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || "" ).split( "." ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(".")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we\'re the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || "" ).match( rnotwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || "" ).split( "." ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( "(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it\'s no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, "events" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, "type" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don\'t do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(".") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(".");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(":") < 0 && "on" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === "object" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(".");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== "click" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: "char charCode key keyCode".split(" "),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don\'t use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn\'t\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome<28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusin"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusout"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don\'t fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, "a" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor\'s stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the \'new\' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: Android<4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn\'t have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: "mouseover",\n\tmouseleave: "mouseout",\n\tpointerenter: "pointerover",\n\tpointerleave: "pointerout"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Support: Firefox, Chrome, Safari\n// Create "bubbling" focus and blur events\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === "object" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== "string" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === "string" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === "object" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === "function" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE9\n\t\toption: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n\n\t\tthead: [ 1, "<table>", "</table>" ],\n\t\tcol: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n\t\ttr: [ 2, "<table><tbody>", "</tbody></table>" ],\n\t\ttd: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n\t\t_default: [ 0, "", "" ]\n\t};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, "table" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?\n\n\t\telem.getElementsByTagName("tbody")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement("tbody") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute("type");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || "*" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === "input" || nodeName === "textarea" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, "script" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === "object" ) {\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement("div") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = "";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = "";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), "script" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || "" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type, key,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, "script" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = "";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, "<$1></$2>" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === "string" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, "script" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || "" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: "append",\n\tprependTo: "prepend",\n\tinsertBefore: "before",\n\tinsertAfter: "after",\n\treplaceAll: "replaceWith"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], "display" );\n\n\t// We don\'t have any data stored on the element,\n\t// so use "detach" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === "none" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( "<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don\'t choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t}\n\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css(\'filter\') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( "div" ),\n\t\tdiv = document.createElement( "div" );\n\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE9-11+\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = "content-box";\n\tdiv.cloneNode( true ).style.backgroundClip = "";\n\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\tcontainer.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +\n\t\t"position:absolute";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they\'re executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +\n\t\t\t"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +\n\t\t\t"border:1px;padding:1px;width:4px;position:absolute";\n\t\tdiv.innerHTML = "";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== "1%";\n\t\tboxSizingReliableVal = divStyle.width === "4px";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Support: node.js jsdom\n\t// Don\'t assume that getComputedStyle is a property of the global object\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( "div" ) );\n\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +\n\t\t\t\t\t"box-sizing:content-box;display:block;margin:0;border:0;padding:0";\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = "0";\n\t\t\t\tdiv.style.width = "1px";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\t\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),\n\trrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),\n\n\tcssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\tcssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t},\n\n\tcssPrefixes = [ "Webkit", "O", "Moz", "ms" ];\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? "border" : "content" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === "width" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === "margin" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === "content" ) {\n\t\t\t\tval -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn\'t border nor margin, so remove border\n\t\t\tif ( extra !== "margin" ) {\n\t\t\t\tval -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// At this point, extra isn\'t content, so add padding\n\t\t\tval += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn\'t content nor padding, so add border\n\t\t\tif ( extra !== "padding" ) {\n\t\t\t\tval += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === "width" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize "", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? "border" : "content" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + "px";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, "olddisplay" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === "none" ) {\n\t\t\t\telem.style.display = "";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === "" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== "none" || !hidden ) {\n\t\t\t\tdata_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === "none" || elem.style.display === "" ) {\n\t\t\telem.style.display = show ? values[ index ] || "" : "none";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, "opacity" );\n\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don\'t automatically add "px" to these possibly-unitless properties\n\tcssNumber: {\n\t\t"columnCount": true,\n\t\t"fillOpacity": true,\n\t\t"flexGrow": true,\n\t\t"flexShrink": true,\n\t\t"fontWeight": true,\n\t\t"lineHeight": true,\n\t\t"opacity": true,\n\t\t"order": true,\n\t\t"orphans": true,\n\t\t"widows": true,\n\t\t"zIndex": true,\n\t\t"zoom": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t"float": "cssFloat"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don\'t set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we\'re working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we\'re setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\tif ( type === "string" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = "number";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number, add \'px\' to the (except for certain CSS properties)\n\t\t\tif ( type === "number" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += "px";\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// background-* props affect original clone\'s values\n\t\t\tif ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n\t\t\t\tstyle[ name ] = "inherit";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we\'re working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && "get" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert "normal" to computed value\n\t\tif ( val === "normal" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === "" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ "height", "width" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn jQuery.swap( elem, { "display": "inline-block" },\n\t\t\t\tcurCSS, [ elem, "marginRight" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: "",\n\tpadding: "",\n\tborder: "Width"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split(" ") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === "boolean" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || "swing";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, "" );\n\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t"*": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t// Use string for doubling so we don\'t accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || ".5";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t// break the loop if scale is unchanged or perfect, or if we\'ve just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we\'re doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// We\'re done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, "fxshow" );\n\n\t// Handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, "fx" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, "fx" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// Height/width overflow pass\n\tif ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, "display" );\n\n\t\t// Test default display if display is currently "none"\n\t\tcheckDisplay = display === "none" ?\n\t\t\tdata_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {\n\t\t\tstyle.display = "inline-block";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = "hidden";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === "toggle";\n\t\t\tif ( value === ( hidden ? "hide" : "show" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( "hidden" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, "fxshow", {} );\n\t\t}\n\n\t\t// Store state if its toggle - enables .stop().toggle() to "reverse"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, "fxshow" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === "width" || prop === "height" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && "expand" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ "*" ];\n\t\t} else {\n\t\t\tprops = props.split(" ");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// Normalize opt.queue - true/undefined/null -> "fx"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = "fx";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( "opacity", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, "finish" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || "fx", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + "queueHooks",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || "fx";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + "queue" ],\n\t\t\t\thooks = data[ type + "queueHooks" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ "toggle", "show", "hide" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === "boolean" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx("show"),\n\tslideUp: genFx("hide"),\n\tslideToggle: genFx("toggle"),\n\tfadeIn: { opacity: "show" },\n\tfadeOut: { opacity: "hide" },\n\tfadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || "fx";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( "input" ),\n\t\tselect = document.createElement( "select" ),\n\t\topt = select.appendChild( document.createElement( "option" ) );\n\n\tinput.type = "checkbox";\n\n\t// Support: iOS<=5.1, Android<=4.2+\n\t// Default value for a checkbox should be "on"\n\tsupport.checkOn = input.value !== "";\n\n\t// Support: IE<=11+\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: Android<=2.3\n\t// Options inside disabled selects are incorrectly marked as disabled\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<=11+\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( "input" );\n\tinput.value = "t";\n\tinput.type = "radio";\n\tsupport.radioValue = input.value === "t";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don\'t get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + "" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === "radio" &&\n\t\t\t\t\tjQuery.nodeName( elem, "input" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( "type", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t"for": "htmlFor",\n\t\t"class": "className"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t"tabIndex",\n\t"readOnly",\n\t"maxLength",\n\t"cellSpacing",\n\t"cellPadding",\n\t"rowSpan",\n\t"colSpan",\n\t"useMap",\n\t"frameBorder",\n\t"contentEditable"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === "string" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || "" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( " " + elem.className + " " ).replace( rclass, " " ) :\n\t\t\t\t\t" "\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === "string" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || "" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( " " + elem.className + " " ).replace( rclass, " " ) :\n\t\t\t\t\t""\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( " " + clazz + " " ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( " " + clazz + " ", " " );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : "";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === "boolean" && type === "string" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === "string" ) {\n\t\t\t\t// Toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === "boolean" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, "__className__", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = " " + selector + " ",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === "string" ?\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace(rreturn, "") :\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? "" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = "";\n\n\t\t\t} else if ( typeof val === "number" ) {\n\t\t\t\tval += "";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, "value" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === "select-one" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ "radio", "checkbox" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute("value") === null ? "on" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +\n\t"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n\t"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + "" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, "text/xml" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\n\t\tjQuery.error( "Invalid XML: " + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol "*" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol "*" can be used\n\t * 3) selection will start with transport dataType and THEN go to "*" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat( "*" ),\n\n\t// Document location\n\tajaxLocation = window.location.href,\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to "*"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== "string" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = "*";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === "+" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || "*";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === "*" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader("Content-Type");\n\t\t}\n\t}\n\n\t// Check if we\'re dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\tif ( current === "*" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== "*" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( " " );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + " " + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ "* " + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ "throws" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: "success", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: "GET",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t"*": allTypes,\n\t\t\ttext: "text/plain",\n\t\t\thtml: "text/html",\n\t\t\txml: "application/xml, text/xml",\n\t\t\tjson: "application/json, text/javascript"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: "responseXML",\n\t\t\ttext: "responseText",\n\t\t\tjson: "responseJSON"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t"* text": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t"text html": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t"text json": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t"text xml": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn\'t be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn\'t be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === "object" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks("once memory"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== "string" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger("ajaxStart");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );\n\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a \'_\' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, "$1_=" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( "Content-Type", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t"Accept",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n\t\t\t\ts.accepts[ "*" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = "abort";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, "No Transport" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort("timeout");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is "done" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader("Last-Modified");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader("etag");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === "HEAD" ) {\n\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = "error";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger("ajaxStop");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, "json" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, "script" );\n\t}\n});\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: "GET",\n\t\tdataType: "script",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t"throws": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, "body" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( "&" ).replace( r20, "+" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, "elements" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( ":disabled" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( "onunload", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers["X-Requested-With"] ) {\n\t\t\t\t\theaders["X-Requested-With"] = "XMLHttpRequest";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === "abort" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === "error" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === "string" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback("error");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback("abort");\n\n\t\t\t\ttry {\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t"text script": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = "GET";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery("<script>").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t"load error",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === "error" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: "callback",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t"url" :\n\t\t\ttypeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"\n\t\t);\n\n\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters["script json"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + " was not called" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = "json";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn\'t screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn "script";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === "boolean" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== "string" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(" ");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it\'s a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it\'s the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === "object" ) {\n\t\ttype = "POST";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if "type" variable is undefined, then "GET" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: "html",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, "position" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === "static" ) {\n\t\t\telem.style.position = "relative";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, "top" );\n\t\tcurCSSLeft = jQuery.css( elem, "left" );\n\t\tcalculatePosition = ( position === "absolute" || position === "fixed" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf("auto") > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( "using" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it\'s not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t// If we don\'t have gBCR, just use 0,0 rather than error\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, "position" ) === "fixed" ) {\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n\tvar top = "pageYOffset" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Support: Safari<7+, Chrome<37+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + "px" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n\tjQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn\'t a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ "client" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ "scroll" + name ], doc[ "scroll" + name ],\n\t\t\t\t\t\telem.body[ "offset" + name ], doc[ "offset" + name ],\n\t\t\t\t\t\tdoc[ "client" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\treturn jQuery;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzP2VlZGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVE7QUFDUixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8seUVBQXlFO0FBQ2hGOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQXdEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUNBQW1DO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDJCQUEyQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDBCQUEwQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsUUFBUSxTQUFTLE1BQU0sYUFBYSxlQUFlO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQjtBQUM3RCwwQkFBMEIsY0FBYyxjQUFjLE9BQU87QUFDN0QsZUFBZSxZQUFZLFVBQVU7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsU0FBUyxRQUFRLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRSw2QkFBNkIsY0FBYyxTQUFTLFNBQVM7QUFDN0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLCtCQUErQixrQkFBa0IsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsV0FBVyxrQkFBa0I7QUFDN0IsY0FBYztBQUNkLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ04sTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsZUFBZSw2REFBNkQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBLENBQUMiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMS40XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMDUsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0wNC0yOFQxNjowMVpcbiAqL1xuXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy8gQ2FuJ3QgYmUgaW4gc3RyaWN0IG1vZGUsIHNldmVyYWwgbGlicyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vL1xuXG52YXIgYXJyID0gW107XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxudmFyXG5cdC8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcblx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cblx0dmVyc2lvbiA9IFwiMi4xLjRcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHQvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xuXHQvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrLCBhcmdzICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9KSk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcihudWxsKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICsgMSkgPj0gMDtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcblx0XHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjAsIGlPUzw2IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aW5kaXJlY3QgPSBldmFsO1xuXG5cdFx0Y29kZSA9IGpRdWVyeS50cmltKCBjb2RlICk7XG5cblx0XHRpZiAoIGNvZGUgKSB7XG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZihcInVzZSBzdHJpY3RcIikgPT09IDEgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxuXHRcdFx0Ly8gYW5kIHJlbW92YWwgYnkgdXNpbmcgYW4gaW5kaXJlY3QgZ2xvYmFsIGV2YWxcblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggb2JqICk7XG5cblx0XHRpZiAoIGFyZ3MgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5bGlrZSggT2JqZWN0KGFycikgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBlbGVtcyApLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0pO1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0FycmF5bGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4wLXByZVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE0LTEyLTE2XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xuXHRjaGFyYWN0ZXJFbmNvZGluZyA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcblx0Ly8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0Ly8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidypcIiApICsgXCIpXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsXG5cdFx0Ly8gUVNBIHZhcnNcblx0XHRpLCBncm91cHMsIG9sZCwgbmlkLCBuZXdDb250ZXh0LCBuZXdTZWxlY3RvcjtcblxuXHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cdG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZTtcblxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdGlmICggIXNlZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIHdoZW4gcG9zc2libGUgKGUuZy4sIG5vdCB1bmRlciBEb2N1bWVudEZyYWdtZW50KVxuXHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiI0lEXCIpXG5cdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxuXHRcdFx0XHRcdGlmICggY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiVEFHXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIi5DTEFTU1wiKVxuXHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBRU0EgcGF0aFxuXHRcdGlmICggc3VwcG9ydC5xc2EgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblx0XHRcdG5pZCA9IG9sZCA9IGV4cGFuZG87XG5cdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdG5ld1NlbGVjdG9yID0gbm9kZVR5cGUgIT09IDEgJiYgc2VsZWN0b3I7XG5cblx0XHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuXHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcblx0XHRcdFx0XHRuaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIG5pZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5pZCA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCI7XG5cblx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0O1xuXHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaChxc2FFcnJvcikge1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGF0dHJzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFNldCBvdXIgZG9jdW1lbnRcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRwYXJlbnQgPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0Ly8gU3VwcG9ydDogSUU+OFxuXHQvLyBJZiBpZnJhbWUgZG9jdW1lbnQgaXMgYXNzaWduZWQgdG8gXCJkb2N1bWVudFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXG5cdC8vIElFIHdpbGwgdGhyb3cgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gYWNjZXNzaW5nIFwiZG9jdW1lbnRcIiB2YXJpYWJsZSwgc2VlIGpRdWVyeSAjMTM5MzZcblx0Ly8gSUU2LTggZG8gbm90IHN1cHBvcnQgdGhlIGRlZmF1bHRWaWV3IHByb3BlcnR5IHNvIHBhcmVudCB3aWxsIGJlIHVuZGVmaW5lZFxuXHRpZiAoIHBhcmVudCAmJiBwYXJlbnQgIT09IHBhcmVudC50b3AgKSB7XG5cdFx0Ly8gSUUxMSBkb2VzIG5vdCBoYXZlIGF0dGFjaEV2ZW50LCBzbyBhbGwgbXVzdCBzdWZmZXJcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBTdXBwb3J0IHRlc3RzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvYyApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvYy5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcZl0nIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjIrLCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuNytcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2MuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IGRvZXMgbm90IGltcGxlbWVudCBpbmNsdXNpdmUgZGVzY2VuZGVudFxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvYyA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jO1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8IChwYXJlbnRbIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucyApIHtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzFdO1xuXG5cdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmICsrZGlmZiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGRpciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gb3V0ZXJDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIEtlZXAgYGlgIGEgc3RyaW5nIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBzbyBgbWF0Y2hlZENvdW50YCB3aWxsIGJlIFwiMDBcIiBiZWxvd1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgbm8gc2VlZCBhbmQgb25seSBvbmUgZ3JvdXBcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+PSAwICkgIT09IG5vdDtcblx0fSk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59KTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbMF0gPT09IFwiPFwiICYmIHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsxXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsxXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1swXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHJvb3RqUXVlcnkucmVhZHkgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRyb290alF1ZXJ5LnJlYWR5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0ZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KGN1cikgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlKFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXG5cdFx0KTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoIChjdXIgPSBjdXJbZGlyXSkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goe1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWUoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59KTtcbnZhciBybm90d2hpdGUgPSAoL1xcUysvZyk7XG5cblxuXG4vLyBTdHJpbmcgdG8gT2JqZWN0IG9wdGlvbnMgZm9ybWF0IGNhY2hlXG52YXIgb3B0aW9uc0NhY2hlID0ge307XG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHQoIG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdIHx8IGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBMYXN0IGZpcmUgdmFsdWUgKGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHMpXG5cdFx0bWVtb3J5LFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblx0XHQvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcblx0XHRmaXJpbmdTdGFydCxcblx0XHQvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcblx0XHRmaXJpbmdMZW5ndGgsXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCxcblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblx0XHQvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0c3RhY2sgPSAhb3B0aW9ucy5vbmNlICYmIFtdLFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0bWVtb3J5ID0gb3B0aW9ucy5tZW1vcnkgJiYgZGF0YTtcblx0XHRcdGZpcmVkID0gdHJ1ZTtcblx0XHRcdGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcblx0XHRcdGZpcmluZ1N0YXJ0ID0gMDtcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0ZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBkYXRhWyAwIF0sIGRhdGFbIDEgXSApID09PSBmYWxzZSAmJiBvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRpZiAoIHN0YWNrICkge1xuXHRcdFx0XHRcdGlmICggc3RhY2subGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZmlyZSggc3RhY2suc2hpZnQoKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdC8vIEZpcnN0LCB3ZSBzYXZlIHRoZSBjdXJyZW50IGxlbmd0aFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdChmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSkoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdC8vIERvIHdlIG5lZWQgdG8gYWRkIHRoZSBjYWxsYmFja3MgdG8gdGhlXG5cdFx0XHRcdFx0Ly8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRcdGZpcmluZ1N0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRmaXJlKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0xlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID8galF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6ICEhKCBsaXN0ICYmIGxpc3QubGVuZ3RoICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdGZpcmluZ0xlbmd0aCA9IDA7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBkaXNhYmxlZD9cblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblx0XHRcdC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdGFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGxvY2tlZD9cblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhc3RhY2s7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoIGxpc3QgJiYgKCAhZmlyZWQgfHwgc3RhY2sgKSApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0c3RhY2sucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBhcmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVqZWN0ZWRcIiBdLFxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsxXSBdKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcywgZm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0pLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsxXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8ICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC4gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIEFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5mYWlsKCBkZWZlcnJlZC5yZWplY3QgKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdDtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vKipcbiAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gV2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG5cdFx0Ly8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHRzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWR5TGlzdC5wcm9taXNlKCBvYmogKTtcbn07XG5cbi8vIEtpY2sgb2ZmIHRoZSBET00gcmVhZHkgY2hlY2sgZXZlbiBpZiB0aGUgdXNlciBkb2VzIG5vdFxualF1ZXJ5LnJlYWR5LnByb21pc2UoKTtcblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBqUXVlcnkuYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRqUXVlcnkuYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbCggZWxlbXNbaV0sIGksIGZuKCBlbGVtc1tpXSwga2V5ICkgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxuICovXG5qUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdC8qIGpzaGludCAtVzAxOCAqL1xuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NCxcblx0Ly8gT2xkIFdlYktpdCBkb2VzIG5vdCBoYXZlIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucy9mcmVlemUgbWV0aG9kLFxuXHQvLyByZXR1cm4gbmV3IGVtcHR5IG9iamVjdCBpbnN0ZWFkIHdpdGggbm8gW1tzZXRdXSBhY2Nlc3NvclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuY2FjaGUgPSB7fSwgMCwge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcbkRhdGEuYWNjZXB0cyA9IGpRdWVyeS5hY2NlcHREYXRhO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblx0a2V5OiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHQvLyBBbHdheXMgcmV0dXJuIHRoZSBrZXkgZm9yIGEgZnJvemVuIG9iamVjdC5cblx0XHRpZiAoICFEYXRhLmFjY2VwdHMoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IHt9LFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlIGtleVxuXHRcdFx0dW5sb2NrID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdW5sb2NrICkge1xuXHRcdFx0dW5sb2NrID0gRGF0YS51aWQrKztcblxuXHRcdFx0Ly8gU2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB7IHZhbHVlOiB1bmxvY2sgfTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NFxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gYSBsZXNzIHNlY3VyZSBkZWZpbml0aW9uXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0ZGVzY3JpcHRvclsgdGhpcy5leHBhbmRvIF0gPSB1bmxvY2s7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIG93bmVyLCBkZXNjcmlwdG9yICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRpZiAoICF0aGlzLmNhY2hlWyB1bmxvY2sgXSApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVubG9jaztcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Ly8gVGhlcmUgbWF5IGJlIGFuIHVubG9jayBhc3NpZ25lZCB0byB0aGlzIG5vZGUsXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBcIm93bmVyXCIsIGNyZWF0ZSBvbmUgaW5saW5lXG5cdFx0XHQvLyBhbmQgc2V0IHRoZSB1bmxvY2sgYXMgdGhvdWdoIGFuIG93bmVyIGVudHJ5IGhhZCBhbHdheXMgZXhpc3RlZFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBGcmVzaCBhc3NpZ25tZW50cyBieSBvYmplY3QgYXJlIHNoYWxsb3cgY29waWVkXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLmNhY2hlWyB1bmxvY2sgXSwgZGF0YSApO1xuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdC8vIEVpdGhlciBhIHZhbGlkIGNhY2hlIGlzIGZvdW5kLCBvciB3aWxsIGJlIGNyZWF0ZWQuXG5cdFx0Ly8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXG5cdFx0Ly8gYWxsb3dpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgbmV3bHkgY3JlYXRlZFxuXHRcdC8vIGVtcHR5IGRhdGEgb2JqZWN0LiBBIHZhbGlkIG93bmVyIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkLlxuXHRcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbIHRoaXMua2V5KCBvd25lciApIF07XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0Y2FjaGUgOiBjYWNoZVsga2V5IF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBzdG9yZWQ7XG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgKSB7XG5cblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cblx0XHRcdHJldHVybiBzdG9yZWQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZShrZXkpICk7XG5cdFx0fVxuXG5cdFx0Ly8gWypdV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdHVubG9jayA9IHRoaXMua2V5KCBvd25lciApLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLmNhY2hlWyB1bmxvY2sgXSA9IHt9O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IGtleS5jb25jYXQoIGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KFxuXHRcdFx0dGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF0gfHwge31cblx0XHQpO1xuXHR9LFxuXHRkaXNjYXJkOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0aWYgKCBvd25lclsgdGhpcy5leHBhbmRvIF0gKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59O1xudmFyIGRhdGFfcHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhX3VzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhX3VzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YV91c2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhX3ByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV91c2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFfcHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoNSkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YSxcblx0XHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBhcy1pc1xuXHRcdFx0XHRkYXRhID0gZGF0YV91c2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBjYW1lbEtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBjYW1lbEtleSwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YV91c2VyLmdldCggdGhpcywgY2FtZWxLZXkgKTtcblxuXHRcdFx0XHQvLyBGb3IgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZSBpbnRlcm9wLCB3ZSBoYXZlIHRvXG5cdFx0XHRcdC8vIHN0b3JlIHByb3BlcnR5IG5hbWVzIHdpdGggZGFzaGVzIGluIGEgY2FtZWxDYXNlIGZvcm0uXG5cdFx0XHRcdC8vIFRoaXMgbWlnaHQgbm90IGFwcGx5IHRvIGFsbCBwcm9wZXJ0aWVzLi4uKlxuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG5cdFx0XHRcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcblx0XHRcdFx0Ly8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKFwiLVwiKSAhPT0gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YV91c2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YV9wcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0pXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbMF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVswXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YV9wcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSk7XG52YXIgcG51bSA9ICgvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLykuc291cmNlO1xuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblx0XHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxudmFyIHJjaGVja2FibGVUeXBlID0gKC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pKTtcblxuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59KSgpO1xudmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQ7XG5cblxuXG5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IHN0cnVuZGVmaW5lZCAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKFwiLlwiKSA+PSAwICkge1xuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZV9yZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChjdXIgPSBldmVudFBhdGhbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBkYXRhX3ByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UpICYmXG5cdFx0XHRcdGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1swXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0pICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50Lm5hbWVzcGFjZV9yZSB8fCBldmVudC5uYW1lc3BhY2VfcmUudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSkuaGFuZGxlIHx8IGhhbmRsZU9iai5oYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0LmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiYgKCFldmVudC5idXR0b24gfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+PSAwIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdHByb3BzOiBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsIGNvcHksXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzWyB0eXBlIF07XG5cblx0XHRpZiAoICFmaXhIb29rICkge1xuXHRcdFx0dGhpcy5maXhIb29rc1sgdHlwZSBdID0gZml4SG9vayA9XG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XG5cdFx0XHRcdHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcblx0XHRcdFx0e307XG5cdFx0fVxuXHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGkgPSBjb3B5Lmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHByb3AgPSBjb3B5WyBpIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENvcmRvdmEgMi41IChXZWJLaXQpICgjMTMyNTUpXG5cdFx0Ly8gQWxsIGV2ZW50cyBzaG91bGQgaGF2ZSBhIHRhcmdldDsgQ29yZG92YSBkZXZpY2VyZWFkeSBkb2Vzbid0XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCssIENocm9tZTwyOFxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0aWYgKCBldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lLlxuXHRcdC8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZVxuXHRcdC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZSxcblx0XHRcdFx0b3JpZ2luYWxFdmVudDoge31cblx0XHRcdH1cblx0XHQpO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoIGVsZW0sIGUgKTtcblx0XHR9XG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlLCBmYWxzZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gU3VwcG9ydDogQ2hyb21lIDE1K1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94LCBDaHJvbWUsIFNhZmFyaVxuLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbmlmICggIXN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XG5cdGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICksIHRydWUgKTtcblx0XHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG5cdFx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxcblx0cnRhZ05hbWUgPSAvPChbXFx3Ol0rKS8sXG5cdHJodG1sID0gLzx8JiM/XFx3KzsvLFxuXHRybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZSA9IC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxcblxuXHQvLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxuXHR3cmFwTWFwID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0XHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdFx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0XHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdFx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG5cdH07XG5cbi8vIFN1cHBvcnQ6IElFOVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IDEueCBjb21wYXRpYmlsaXR5XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyggZWxlbS50eXBlICk7XG5cblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsgMSBdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFfcHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLCBcImdsb2JhbEV2YWxcIiwgIXJlZkVsZW1lbnRzIHx8IGRhdGFfcHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFfcHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFfcHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YV9wcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YV91c2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFfdXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cdHZhciByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0YnVpbGRGcmFnbWVudDogZnVuY3Rpb24oIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24gKSB7XG5cdFx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0XHRub2RlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcblxuXHRcdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgZWxlbS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0LCBQaGFudG9tSlNcblx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkge1xuXG5cdFx0XHQvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuXHRcdFx0Ly8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcblx0XHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gdG1wWyBqKysgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZyYWdtZW50O1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLCBrZXksXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1sgaSBdKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGtleSA9IGVsZW1bIGRhdGFfcHJpdi5leHBhbmRvIF07XG5cblx0XHRcdFx0aWYgKCBrZXkgJiYgKGRhdGEgPSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBkYXRhX3ByaXYuY2FjaGVbIGtleSBdICkge1xuXHRcdFx0XHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGBwcml2YXRlYCBkYXRhXG5cdFx0XHRcdFx0XHRkZWxldGUgZGF0YV9wcml2LmNhY2hlWyBrZXkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgdXNlcmAgZGF0YVxuXHRcdFx0ZGVsZXRlIGRhdGFfdXNlci5jYWNoZVsgZWxlbVsgZGF0YV91c2VyLmV4cGFuZG8gXSBdO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3Rvciwga2VlcERhdGEgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRlbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKSA6IHRoaXMsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHR0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXG5cdFx0XHRpZiAoIGFyZyApIHtcblx0XHRcdFx0YXJnLnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxuXHRcdHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNldCA9IHRoaXMsXG5cdFx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHNldC5lcSggaW5kZXggKTtcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMgKTtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggdGhpc1sgaSBdLCBub2RlLCBpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHRcdCFkYXRhX3ByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmIGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0pO1xuXG5cbnZhciBpZnJhbWUsXG5cdGVsZW1kaXNwbGF5ID0ge307XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XG4gKi9cbi8vIENhbGxlZCBvbmx5IGZyb20gd2l0aGluIGRlZmF1bHREaXNwbGF5XG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XG5cdHZhciBzdHlsZSxcblx0XHRlbGVtID0galF1ZXJ5KCBkb2MuY3JlYXRlRWxlbWVudCggbmFtZSApICkuYXBwZW5kVG8oIGRvYy5ib2R5ICksXG5cblx0XHQvLyBnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSBtaWdodCBiZSByZWxpYWJseSB1c2VkIG9ubHkgb24gYXR0YWNoZWQgZWxlbWVudFxuXHRcdGRpc3BsYXkgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgJiYgKCBzdHlsZSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSggZWxlbVsgMCBdICkgKSA/XG5cblx0XHRcdC8vIFVzZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBmaXggKG1vcmUgbGlrZSBvcHRpbWl6YXRpb24pIHVudGlsIHNvbWV0aGluZyBiZXR0ZXIgY29tZXMgYWxvbmcsXG5cdFx0XHQvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXG5cdFx0XHRzdHlsZS5kaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkpLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gaWZyYW1lWyAwIF0uY29udGVudERvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cbnZhciBybWFyZ2luID0gKC9ebWFyZ2luLyk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0aWYgKCBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcub3BlbmVyICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXHR9XG5cblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDwgNlxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBpT1MgPCA2IChhdCBsZWFzdCkgcmV0dXJucyBwZXJjZW50YWdlIGZvciBhIGxhcmdlciBzZXQgb2YgdmFsdWVzLCBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzXG5cdFx0Ly8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsXG5cdFx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweDtcIiArXG5cdFx0XCJwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpibG9jazttYXJnaW4tdG9wOjElO3RvcDoxJTtcIiArXG5cdFx0XHRcImJvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IG5vZGUuanMganNkb21cblx0Ly8gRG9uJ3QgYXNzdW1lIHRoYXQgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0XG5cdGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gVGhpcyB0ZXN0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZSBidXQgd2Ugc3RpbGwgZG8gbWVtb2l6aW5nXG5cdFx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHRcdC8vIE5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHRlc3Qgd2FzIGFscmVhZHkgcGVyZm9ybWVkLCB0aG91Z2guXG5cdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcblx0XHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0XHR9LFxuXHRcdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdFx0Y29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHRcdH0sXG5cdFx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdFx0Ly8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxuXHRcdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRcdG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFx0XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXHRcdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0XHRyZXQgPSAhcGFyc2VGbG9hdCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiwgbnVsbCApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdFx0ZG9jRWxlbS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSkoKTtcblxuXG4vLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxualF1ZXJ5LnN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXJcblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cdHJyZWxOdW0gPSBuZXcgUmVnRXhwKCBcIl4oWystXSk9KFwiICsgcG51bSArIFwiKVwiLCBcImlcIiApLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF07XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBzdHlsZSwgbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcblx0XHRvcmlnTmFtZSA9IG5hbWUsXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIHN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9yaWdOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSBycmVsTnVtLmV4ZWMoIHZhbHVlICkpICkge1xuXHRcdFx0XHR2YWx1ZSA9ICggcmV0WzFdICsgMSApICogcmV0WzJdICsgcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApICk7XG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIsIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdICkge1xuXHRcdFx0XHR2YWx1ZSArPSBcInB4XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBlbGVtLnN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiYgZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID9cblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCkgOiAwXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5zd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goe1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoXCIgXCIpIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IFwic3dpbmdcIjtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdGlmICggdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiZcblx0XHRcdFx0KCF0d2Vlbi5lbGVtLnN0eWxlIHx8IHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsKSApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5zdHlsZSAmJiAoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fVxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRyZnhudW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLyxcblx0YW5pbWF0aW9uUHJlZmlsdGVycyA9IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXHR0d2VlbmVycyA9IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLFxuXHRcdFx0XHR0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcblx0XHRcdFx0cGFydHMgPSByZnhudW0uZXhlYyggdmFsdWUgKSxcblx0XHRcdFx0dW5pdCA9IHBhcnRzICYmIHBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHRcdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRcdFx0c3RhcnQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK3RhcmdldCApICYmXG5cdFx0XHRcdFx0cmZ4bnVtLmV4ZWMoIGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHByb3AgKSApLFxuXHRcdFx0XHRzY2FsZSA9IDEsXG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAyMDtcblxuXHRcdFx0aWYgKCBzdGFydCAmJiBzdGFydFsgMyBdICE9PSB1bml0ICkge1xuXHRcdFx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0XHRcdHVuaXQgPSB1bml0IHx8IHN0YXJ0WyAzIF07XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdFx0XHRwYXJ0cyA9IHBhcnRzIHx8IFtdO1xuXG5cdFx0XHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0XHRcdHN0YXJ0ID0gK3RhcmdldCB8fCAxO1xuXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHByb3AsIHN0YXJ0ICsgdW5pdCApO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpLFxuXHRcdFx0XHQvLyBicmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXG5cdFx0XHRcdH0gd2hpbGUgKCBzY2FsZSAhPT0gKHNjYWxlID0gdHdlZW4uY3VyKCkgLyB0YXJnZXQpICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllc1xuXHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0c3RhcnQgPSB0d2Vlbi5zdGFydCA9ICtzdGFydCB8fCArdGFyZ2V0IHx8IDA7XG5cdFx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0dHdlZW4uZW5kID0gcGFydHNbIDEgXSA/XG5cdFx0XHRcdFx0c3RhcnQgKyAoIHBhcnRzWyAxIF0gKyAxICkgKiBwYXJ0c1sgMiBdIDpcblx0XHRcdFx0XHQrcGFydHNbIDIgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9O1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggdHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggdHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAodHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRTktMTAgZG8gbm90XG5cdFx0Ly8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXG5cdFx0Ly8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG5cdFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXG5cdFx0Ly8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgXCJub25lXCJcblx0XHRjaGVja0Rpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/XG5cdFx0XHRkYXRhX3ByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG5cdFx0aWYgKCBjaGVja0Rpc3BsYXkgPT09IFwiaW5saW5lXCIgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93IGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHQvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcblx0fSBlbHNlIGlmICggKGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkpID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBhbmltYXRpb25QcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0pO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2Uoe1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwgeyBzcGVjaWFsRWFzaW5nOiB7fSB9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSlcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMuc3BsaXQoXCIgXCIpO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdID0gdHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgPyBvcHQuZHVyYXRpb24gOlxuXHRcdG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhX3ByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3ByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCh7XG5cdHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxuXHRzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0Y2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogaU9TPD01LjEsIEFuZHJvaWQ8PTQuMitcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcblx0Ly8gT3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmUgaW5jb3JyZWN0bHkgbWFya2VkIGFzIGRpc2FibGVkXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSkoKTtcblxuXG52YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/XG5cdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdHJldDtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cmV0IDpcblx0XHRcdFx0KCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHRlbGVtWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5oYXNBdHRyaWJ1dGUoIFwidGFiaW5kZXhcIiApIHx8IHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8IGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0ZWxlbS50YWJJbmRleCA6XG5cdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaChbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRwcm9jZWVkID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Ly8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIiBcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gdmFsdWUgPyBqUXVlcnkudHJpbSggY3VyICkgOiBcIlwiO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoIChjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSkgKSB7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIjtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXNbaV0ubm9kZVR5cGUgPT09IDEgJiYgKFwiIFwiICsgdGhpc1tpXS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShyY2xhc3MsIFwiIFwiKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTYtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQoIHN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggKG9wdGlvbi5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KCBvcHRpb24udmFsdWUsIHZhbHVlcyApID49IDApICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSApID49IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6IHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59KTtcblxuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoL1xcPy8pO1xuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbi8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xufTtcblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgdG1wO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblx0cnVybCA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKD86W15cXC8/I10qQHwpKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gRG9jdW1lbnQgbG9jYXRpb25cblx0YWpheExvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLmhyZWYsXG5cblx0Ly8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5cdGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkge1xuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWzBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKGRlZXAgPSB7fSkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHNbIFwidGhyb3dzXCIgXSApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogYWpheExvY2F0aW9uLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC94bWwvLFxuXHRcdFx0aHRtbDogL2h0bWwvLFxuXHRcdFx0anNvbjogL2pzb24vXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblx0XHRcdC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xuXHRcdFx0cGFydHMsXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbiApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sgMSBdICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB3ZSBoYXZlIGEgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHRwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0cy5jcm9zc0RvbWFpbiA9ICEhKCBwYXJ0cyAmJlxuXHRcdFx0XHQoIHBhcnRzWyAxIF0gIT09IGFqYXhMb2NQYXJ0c1sgMSBdIHx8IHBhcnRzWyAyIF0gIT09IGFqYXhMb2NQYXJ0c1sgMiBdIHx8XG5cdFx0XHRcdFx0KCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgIT09XG5cdFx0XHRcdFx0XHQoIGFqYXhMb2NQYXJ0c1sgMyBdIHx8ICggYWpheExvY1BhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApIClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0pO1xuXHR9O1xufSk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHR1cmw6IHVybCxcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0pLmVuZCgpO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMDtcbn07XG5qUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiggZWxlbSApO1xufTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiID8gaSA6IFwiXCIgKSArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG5cdFx0XHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApID8gdmFsdWUoKSA6ICggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXG5cdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9KTtcblxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoKCBlICkge31cbn07XG5cbnZhciB4aHJJZCA9IDAsXG5cdHhockNhbGxiYWNrcyA9IHt9LFxuXHR4aHJTdWNjZXNzU3RhdHVzID0ge1xuXHRcdC8vIGZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIE9wZW4gcmVxdWVzdHMgbXVzdCBiZSBtYW51YWxseSBhYm9ydGVkIG9uIHVubG9hZCAoIzUyODApXG4vLyBTZWUgaHR0cHM6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20va2IvMjg1Njc0NiBmb3IgbW9yZSBpbmZvXG5pZiAoIHdpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0d2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSgpO1xuXHRcdH1cblx0fSk7XG59XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCksXG5cdFx0XHRcdFx0aWQgPSArK3hocklkO1xuXG5cdFx0XHRcdHhoci5vcGVuKCBvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkICk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0geGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBY2Nlc3NpbmcgYmluYXJ5LWRhdGEgcmVzcG9uc2VUZXh0IHRocm93cyBhbiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHRcdC8vICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiA/IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dDogeGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0fSA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdHhoci5vbmVycm9yID0gY2FsbGJhY2soXCJlcnJvclwiKTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0geGhyQ2FsbGJhY2tzWyBpZCBdID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogLyg/OmphdmF8ZWNtYSlzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpLnByb3Aoe1xuXHRcdFx0XHRcdGFzeW5jOiB0cnVlLFxuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0pLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG5cdGlmICggb2ZmID49IDAgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdH0pLmNvbXBsZXRlKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbIFwiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCIgXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSkubGVuZ3RoO1xufTtcblxuXG5cblxudmFyIGRvY0VsZW0gPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKFwiYXV0b1wiKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fVxuXHRcdHdpbiA9IGdldFdpbmRvdyggZG9jICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LCBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudCwgXCJodG1sXCIgKSAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblx0XHRcdHZhciB3aW4gPSBnZXRXaW5kb3coIGVsZW0gKTtcblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8NyssIENocm9tZTwzNytcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTI4MFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0pO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9KTtcbn0pO1xuXG5cbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5qUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0pO1xufVxuXG5cblxuXG52YXJcblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n')},function(module,exports){eval('window.__ctx = "";\n\n////跨域时修改 此 ctx \n//window.__ctx = "http://localhost:8080/agile-bpm-platform";\n\n//jQuery 跨域处理\njQuery(function () {  //, headers: { \'x-requested-with\': \'XMLHttpRequest\' }\n    $.ajaxSetup({crossDomain: true, xhrFields: {withCredentials: true}});\n}); \n\n/**\n * @url 如果不含ctx，添加ctx\n * @replacePageParam true /false\n * eg:user/getData?userId={userId}, 当前页面：userEdit.html?userId=1\n * 这时候会将1 赋值给userId\n * \n */\n\nwindow.getCtxUrl = function(url,replaceRequestParam){\n\tif(url && !url.startWith(__ctx) && !url.startWith("http")){\n\t\turl.startWith("/")?"":url = "/"+url;\n\t\turl = __ctx + url;\n\t\t\n\t\t//如果URL含?且需要替换页面请求参数，则进行格式化\n\t\tif(replaceRequestParam && url.indexOf("?")!=-1){\n\t\t\turl = url.format($.getParams());\n\t\t}\n\t}\n\treturn url;\n}\n\nwindow.getProjectUrl = function(url){\n\tif(url && url.indexOf("http://")==-1 && url.substring(0,1)==="/"){\n\t\t var pathname =window.document.location.pathname;\n\t\t var projectPath = pathname.substring(0,pathname.substr(1).indexOf(\'/\')+1);\n\t\t // 特殊处理下流程设计器\n\t\t if("/bus,/bpm,/sys,/org,/form,/flow-editor".indexOf(projectPath)!= -1){\n\t\t\t return url;\n\t\t }\n\t\tif(url.startWith(projectPath)){\n\t\t\treturn url;\n\t\t}\n\t\t return projectPath+url;\n\t}\n\treturn url;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwLWNvbmYuanM/MjM1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxpQkFBaUIsK0JBQStCLHVCQUF1QjtBQUN2RSxDQUFDLEU7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIndpbmRvdy5fX2N0eCA9IFwiXCI7XG5cbi8vLy/ot6jln5/ml7bkv67mlLkg5q2kIGN0eCBcbi8vd2luZG93Ll9fY3R4ID0gXCJodHRwOi8vbG9jYWxob3N0OjgwODAvYWdpbGUtYnBtLXBsYXRmb3JtXCI7XG5cbi8valF1ZXJ5IOi3qOWfn+WkhOeQhlxualF1ZXJ5KGZ1bmN0aW9uICgpIHsgIC8vLCBoZWFkZXJzOiB7ICd4LXJlcXVlc3RlZC13aXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyB9XG4gICAgJC5hamF4U2V0dXAoe2Nyb3NzRG9tYWluOiB0cnVlLCB4aHJGaWVsZHM6IHt3aXRoQ3JlZGVudGlhbHM6IHRydWV9fSk7XG59KTsgXG5cbi8qKlxuICogQHVybCDlpoLmnpzkuI3lkKtjdHjvvIzmt7vliqBjdHhcbiAqIEByZXBsYWNlUGFnZVBhcmFtIHRydWUgL2ZhbHNlXG4gKiBlZzp1c2VyL2dldERhdGE/dXNlcklkPXt1c2VySWR9LCDlvZPliY3pobXpnaLvvJp1c2VyRWRpdC5odG1sP3VzZXJJZD0xXG4gKiDov5nml7blgJnkvJrlsIYxIOi1i+WAvOe7mXVzZXJJZFxuICogXG4gKi9cblxud2luZG93LmdldEN0eFVybCA9IGZ1bmN0aW9uKHVybCxyZXBsYWNlUmVxdWVzdFBhcmFtKXtcblx0aWYodXJsICYmICF1cmwuc3RhcnRXaXRoKF9fY3R4KSAmJiAhdXJsLnN0YXJ0V2l0aChcImh0dHBcIikpe1xuXHRcdHVybC5zdGFydFdpdGgoXCIvXCIpP1wiXCI6dXJsID0gXCIvXCIrdXJsO1xuXHRcdHVybCA9IF9fY3R4ICsgdXJsO1xuXHRcdFxuXHRcdC8v5aaC5p6cVVJM5ZCrP+S4lOmcgOimgeabv+aNoumhtemdouivt+axguWPguaVsO+8jOWImei/m+ihjOagvOW8j+WMllxuXHRcdGlmKHJlcGxhY2VSZXF1ZXN0UGFyYW0gJiYgdXJsLmluZGV4T2YoXCI/XCIpIT0tMSl7XG5cdFx0XHR1cmwgPSB1cmwuZm9ybWF0KCQuZ2V0UGFyYW1zKCkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdXJsO1xufVxuXG53aW5kb3cuZ2V0UHJvamVjdFVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdGlmKHVybCAmJiB1cmwuaW5kZXhPZihcImh0dHA6Ly9cIik9PS0xICYmIHVybC5zdWJzdHJpbmcoMCwxKT09PVwiL1wiKXtcblx0XHQgdmFyIHBhdGhuYW1lID13aW5kb3cuZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG5cdFx0IHZhciBwcm9qZWN0UGF0aCA9IHBhdGhuYW1lLnN1YnN0cmluZygwLHBhdGhuYW1lLnN1YnN0cigxKS5pbmRleE9mKCcvJykrMSk7XG5cdFx0IC8vIOeJueauiuWkhOeQhuS4i+a1geeoi+iuvuiuoeWZqFxuXHRcdCBpZihcIi9idXMsL2JwbSwvc3lzLC9vcmcsL2Zvcm0sL2Zsb3ctZWRpdG9yXCIuaW5kZXhPZihwcm9qZWN0UGF0aCkhPSAtMSl7XG5cdFx0XHQgcmV0dXJuIHVybDtcblx0XHQgfVxuXHRcdGlmKHVybC5zdGFydFdpdGgocHJvamVjdFBhdGgpKXtcblx0XHRcdHJldHVybiB1cmw7XG5cdFx0fVxuXHRcdCByZXR1cm4gcHJvamVjdFBhdGgrdXJsO1xuXHR9XG5cdHJldHVybiB1cmw7XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2FwcC1jb25mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzdiZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2Nzcy9ib290c3RyYXAubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzPzhiYTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FuaW1hdGUuY3NzPzM0ZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2Nzcy9hbmltYXRlLmNzc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy9qcXVlcnktcXRpcC9qcXVlcnkucXRpcC5jc3M/OGM0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvanMvcGx1Z2lucy9qcXVlcnktcXRpcC9qcXVlcnkucXRpcC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL3N0eWxlLmNzcz80NzU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9jc3Mvc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n")},function(module,exports){eval('var $ = jQuery;\njQuery.extend({\n\t/**\n\t * 判断是否是IE浏览器\n\t * \n\t * @returns {Boolean}\n\t */\n\tisIE : function() {\n\t\tvar appName = navigator.appName;\n\t\tvar idx = appName.indexOf("Microsoft");\n\t\treturn idx == 0;\n\t},\n\t/**\n\t * 判断是否是IE6浏览器\n\t * \n\t * @returns {Boolean}\n\t */\n\tisIE6 : function() {\n\t\tif (($.browser.msie && $.browser.version == \'6.0\') && !$.support.style)\n\t\t\treturn true;\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * <img src="img/logo.png" onload="$.fixPNG(this);"/> 解决图片在ie中背景透明的问题。\n\t * \n\t * @param imgObj\n\t */\n\tfixPNG : function(imgObj) {\n\t\tvar arVersion = navigator.appVersion.split("MSIE");\n\t\tvar version = parseFloat(arVersion[1]);\n\t\tif ((version >= 5.5) && (version < 7) && (document.body.filters)) {\n\t\t\tvar imgID = (imgObj.id) ? "id=\'" + imgObj.id + "\' " : "";\n\t\t\tvar imgClass = (imgObj.className) ? "class=\'" + imgObj.className\n\t\t\t\t\t+ "\' " : "";\n\t\t\tvar imgTitle = (imgObj.title)\n\t\t\t\t\t? "title=\'" + imgObj.title + "\' "\n\t\t\t\t\t: "title=\'" + imgObj.alt + "\' ";\n\t\t\tvar imgStyle = "display:inline-block;" + imgObj.style.cssText;\n\t\t\tvar strNewHTML = "<span "\n\t\t\t\t\t+ imgID\n\t\t\t\t\t+ imgClass\n\t\t\t\t\t+ imgTitle\n\t\t\t\t\t+ " style=\\""\n\t\t\t\t\t+ "width:"\n\t\t\t\t\t+ imgObj.width\n\t\t\t\t\t+ "px; height:"\n\t\t\t\t\t+ imgObj.height\n\t\t\t\t\t+ "px;"\n\t\t\t\t\t+ imgStyle\n\t\t\t\t\t+ ";"\n\t\t\t\t\t+ "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader"\n\t\t\t\t\t+ "(src=\\\'" + imgObj.src\n\t\t\t\t\t+ "\\\', sizingMethod=\'scale\');\\"></span>";\n\t\t\timgObj.outerHTML = strNewHTML;\n\t\t}\n\t},\n\t/**\n\t * 获取当前路径中指定键的参数值。\n\t * \n\t * @param key\n\t * @returns\n\t */\n\tgetParameter : function(key) {\n\t\tvar parameters = unescape(window.location.search.substr(1)).split("&");\n\t\tfor (var i = 0; i < parameters.length; i++) {\n\t\t\tvar paramCell = parameters[i].split("=");\n\t\t\tif (paramCell.length == 2\n\t\t\t\t\t&& paramCell[0].toUpperCase() == key.toUpperCase()) {\n\t\t\t\treturn paramCell[1];\n\t\t\t}\n\t\t}\n\t\treturn "";\n\t},\n\t/**\n\t * 根据年份和月份获取某个月的天数。\n\t * \n\t * @param year\n\t * @param month\n\t * @returns\n\t */\n\tgetMonthDays : function(year, month) {\n\t\tif (month < 0 || month > 11) {\n\t\t\treturn 30;\n\t\t}\n\t\tvar arrMon = new Array(12);\n\t\tarrMon[0] = 31;\n\t\tif (year % 4 == 0) {\n\t\t\tarrMon[1] = 29;\n\t\t} else {\n\t\t\tarrMon[1] = 28;\n\t\t}\n\t\tarrMon[2] = 31;\n\t\tarrMon[3] = 30;\n\t\tarrMon[4] = 31;\n\t\tarrMon[5] = 30;\n\t\tarrMon[6] = 31;\n\t\tarrMon[7] = 31;\n\t\tarrMon[8] = 30;\n\t\tarrMon[9] = 31;\n\t\tarrMon[10] = 30;\n\t\tarrMon[11] = 31;\n\t\treturn arrMon[month];\n\t},\n\t/**\n\t * 计算日期为当年的第几周\n\t * \n\t * @param year\n\t * @param month\n\t * @param day\n\t * @returns\n\t */\n\tweekOfYear : function(year, month, day) {\n\t\t// year 年\n\t\t// month 月\n\t\t// day 日\n\t\t// 每周从周日开始\n\t\tvar date1 = new Date(year, 0, 1);\n\t\tvar date2 = new Date(year, month - 1, day, 1);\n\t\tvar dayMS = 24 * 60 * 60 * 1000;\n\t\tvar firstDay = (7 - date1.getDay()) * dayMS;\n\t\tvar weekMS = 7 * dayMS;\n\t\tdate1 = date1.getTime();\n\t\tdate2 = date2.getTime();\n\t\treturn Math.ceil((date2 - date1 - firstDay) / weekMS) + 1;\n\t},\n\t/**\n\t * 时间差计算\n\t */\n\ttimeLag:function(difference){\n\t\tvar  r ="",\n\t\t////计算出相差天数\n\t\tdays=Math.floor(difference/(24*3600*1000)),\n\t\t//计算出小时数\n\t\tleave1=difference%(24*3600*1000),   //计算天数后剩余的毫秒数\n\t\thours=Math.floor(leave1/(3600*1000)),\n\t\t//计算相差分钟数\n\t\tleave2=leave1%(3600*1000),      //计算小时数后剩余的毫秒数\n\t\tminutes=Math.floor(leave2/(60*1000)),\n\t\t//计算相差秒数\n\t\tleave3=leave2%(60*1000),    //计算分钟数后剩余的毫秒数\n\t\tseconds=Math.round(leave3/1000);\n\t\tif(days>0) r +=days+"天";\n\t\tif(hours>0) r +=hours+"小时";\n\t\tif(minutes>0) r +=minutes+"分钟";\n\t\tif(seconds>0) r +=seconds+"秒";\n\t\t\n\t\tif(r){\n\t\t\treturn r;\n\t\t}\n\t\t\n\t\tif(leave3){\n\t\t\treturn difference+"毫秒";\n\t\t}\n\t\treturn ""\n\t},\n\t/**\n\t * 时间差计算\n\t * date1 开始时间 毫秒数\n\t * date2 结束时间 毫秒数\n\t */\n\ttimeDifference:function(date1,date2){\n\t\treturn $.timeLag(date2-date1);\n\t},\n\t/**\n\t * 添加书签\n\t * \n\t * @param title\n\t * @param url\n\t * @returns {Boolean}\n\t */\n\taddBookmark : function(title, url) {\n\t\tif (window.sidebar) {\n\t\t\twindow.sidebar.addPanel(title, url, "");\n\t\t} else if (document.all) {\n\t\t\twindow.external.AddFavorite(url, title);\n\t\t} else if (window.opera && window.print) {\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t * 设置cookie\n\t * \n\t * @param name\n\t * @param value\n\t */\n\tsetCookie : function(name, value) {\n\t\tvar expdate = new Date();\n\t\tvar argv = arguments;\n\t\tvar argc = arguments.length;\n\t\tvar expires = (argc > 2) ? argv[2] : null;\n\t\tvar path = (argc > 3) ? argv[3] : null;\n\t\tvar domain = (argc > 4) ? argv[4] : null;\n\t\tvar secure = (argc > 5) ? argv[5] : false;\n\t\tif (expires != null)\n\t\t\texpdate.setTime(expdate.getTime() + (expires * 1000));\n\n\t\tdocument.cookie = name\n\t\t\t\t+ "="\n\t\t\t\t+ escape(value)\n\t\t\t\t+ ((expires == null) ? "" : (";  expires=" + expdate\n\t\t\t\t\t\t.toGMTString()))\n\t\t\t\t+ ((path == null) ? "" : (";  path=" + path))\n\t\t\t\t+ ((domain == null) ? "" : (";  domain=" + domain))\n\t\t\t\t+ ((secure == true) ? ";  secure" : "");\n\n\t},\n\t/**\n\t * 删除cookie\n\t * \n\t * @param name\n\t */\n\tdelCookie : function(name) {\n\t\tvar exp = new Date();\n\t\texp.setTime(exp.getTime() - 1);\n\t\tvar cval = getCookie(name);\n\t\tdocument.cookie = name + "=" + cval + ";  expires=" + exp.toGMTString();\n\n\t},\n\t/**\n\t * 读取cookie\n\t * \n\t * @param name\n\t * @returns\n\t */\n\tgetCookie : function(name) {\n\t\tvar arg = name + "=";\n\t\tvar alen = arg.length;\n\t\tvar clen = document.cookie.length;\n\t\tvar i = 0;\n\t\twhile (i < clen) {\n\t\t\tvar j = i + alen;\n\t\t\tif (document.cookie.substring(i, j) == arg)\n\t\t\t\treturn $.getCookieVal(j);\n\t\t\ti = document.cookie.indexOf("  ", i) + 1;\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\n\t},\n\tgetCookieVal : function(offset)\n\n\t{\n\t\tvar endstr = document.cookie.indexOf(";", offset);\n\t\tif (endstr == -1)\n\t\t\tendstr = document.cookie.length;\n\t\treturn unescape(document.cookie.substring(offset, endstr));\n\t},\n\t/**\n\t * 打开全屏的窗口\n\t * @param url\n\t * @returns\n\t */\n\topenFullWindow : function(url) {\n\t\tvar h = screen.availHeight - 65;\n\t\tvar w = screen.availWidth - 5;\n\t\tvar vars = "top=0,left=0,height="\n\t\t\t\t+ h\n\t\t\t\t+ ",width="\n\t\t\t\t+ w\n\t\t\t\t+ ",status=no,toolbar=no,menubar=no,location=no,resizable=1,scrollbars=1";\n\n\t\tvar win = window.open($.handProjectUrl(url), "", vars, true);\n\t\treturn win;\n\t},\n\thandProjectUrl : function(url){\n\t\tif(url && url.indexOf("http://")==-1 && url.substring(0,1)==="/"){\n\t\t\t var pathname =window.document.location.pathname;\n\t\t\t var projectPath = pathname.substring(0,pathname.substr(1).indexOf(\'/\')+1);\n\t\t\t \n\t\t\t if(projectPath === \'/flow-editor\' || projectPath === "/bpm" || projectPath === "/sys" || projectPath === "/org" || projectPath === "/form"){\n\t\t\t\t return url;\n\t\t\t }\n\t\t\t \n\t\t\t return projectPath+url;\n\t\t}\n\t\treturn url;\n\t},\n\t/**\n\t * 如果传入的值是null、undefined或空字符串，则返回true。（可选的）\n\t * \n\t * @param {Mixed}\n\t *            value 要验证的值。\n\t * @param {Boolean}\n\t *            allowBlank （可选的） 如果该值为true，则空字符串不会当作空而返回true。\n\t * @return {Boolean}\n\t */\n\tisEmpty : function(v, allowBlank) {\n\t\treturn v === null || v === undefined\n\t\t\t\t|| (!allowBlank ? v === \'\' : false);\n\t},\n\t/**\n\t * 将数字转换成人名币大写。\n\t * \n\t * @param currencyDigits\n\t * @returns\n\t */\n\tconvertCurrency : function(currencyDigits) {\n\n\t\tvar MAXIMUM_NUMBER = 99999999999.99;\n\t\tvar CN_ZERO = "零";\n\t\tvar CN_ONE = "壹";\n\t\tvar CN_TWO = "贰";\n\t\tvar CN_THREE = "叁";\n\t\tvar CN_FOUR = "肆";\n\t\tvar CN_FIVE = "伍";\n\t\tvar CN_SIX = "陆";\n\t\tvar CN_SEVEN = "柒";\n\t\tvar CN_EIGHT = "捌";\n\t\tvar CN_NINE = "玖";\n\t\tvar CN_TEN = "拾";\n\t\tvar CN_HUNDRED = "佰";\n\t\tvar CN_THOUSAND = "仟";\n\t\tvar CN_TEN_THOUSAND = "万";\n\t\tvar CN_HUNDRED_MILLION = "亿";\n\t\tvar CN_SYMBOL = "";\n\t\tvar CN_DOLLAR = "元";\n\t\tvar CN_TEN_CENT = "角";\n\t\tvar CN_CENT = "分";\n\t\tvar CN_INTEGER = "整";\n\t\tvar integral;\n\t\tvar decimal;\n\t\tvar outputCharacters;\n\t\tvar parts;\n\t\tvar digits, radices, bigRadices, decimals;\n\t\tvar zeroCount;\n\t\tvar i, p, d;\n\t\tvar quotient, modulus;\n\t\tcurrencyDigits = currencyDigits.toString();\n\t\tif (currencyDigits == "") {\n\t\t\treturn "";\n\t\t}\n\t\tif (currencyDigits.match(/[^,.\\d]/) != null) {\n\t\t\treturn "";\n\t\t}\n\t\tif ((currencyDigits)\n\t\t\t\t.match(/^((\\d{1,3}(,\\d{3})*(.((\\d{3},)*\\d{1,3}))?)|(\\d+(.\\d+)?))$/) == null) {\n\t\t\treturn "";\n\t\t}\n\t\tcurrencyDigits = currencyDigits.replace(/,/g, "");\n\t\tcurrencyDigits = currencyDigits.replace(/^0+/, "");\n\n\t\tif (Number(currencyDigits) > MAXIMUM_NUMBER) {\n\t\t\treturn "";\n\t\t}\n\n\t\tparts = currencyDigits.split(".");\n\t\tif (parts.length > 1) {\n\t\t\tintegral = parts[0];\n\t\t\tdecimal = parts[1];\n\n\t\t\tdecimal = decimal.substr(0, 2);\n\t\t} else {\n\t\t\tintegral = parts[0];\n\t\t\tdecimal = "";\n\t\t}\n\n\t\tdigits = new Array(CN_ZERO, CN_ONE, CN_TWO, CN_THREE, CN_FOUR, CN_FIVE,\n\t\t\t\tCN_SIX, CN_SEVEN, CN_EIGHT, CN_NINE);\n\t\tradices = new Array("", CN_TEN, CN_HUNDRED, CN_THOUSAND);\n\t\tbigRadices = new Array("", CN_TEN_THOUSAND, CN_HUNDRED_MILLION);\n\t\tdecimals = new Array(CN_TEN_CENT, CN_CENT);\n\n\t\toutputCharacters = "";\n\n\t\tif (Number(integral) > 0) {\n\t\t\tzeroCount = 0;\n\t\t\tfor (i = 0; i < integral.length; i++) {\n\t\t\t\tp = integral.length - i - 1;\n\t\t\t\td = integral.substr(i, 1);\n\t\t\t\tquotient = p / 4;\n\t\t\t\tmodulus = p % 4;\n\t\t\t\tif (d == "0") {\n\t\t\t\t\tzeroCount++;\n\t\t\t\t} else {\n\t\t\t\t\tif (zeroCount > 0) {\n\t\t\t\t\t\toutputCharacters += digits[0];\n\t\t\t\t\t}\n\t\t\t\t\tzeroCount = 0;\n\t\t\t\t\toutputCharacters += digits[Number(d)] + radices[modulus];\n\t\t\t\t}\n\t\t\t\tif (modulus == 0 && zeroCount < 4) {\n\t\t\t\t\toutputCharacters += bigRadices[quotient];\n\t\t\t\t}\n\t\t\t}\n\t\t\toutputCharacters += CN_DOLLAR;\n\t\t}\n\n\t\tif (decimal != "") {\n\t\t\tfor (i = 0; i < decimal.length; i++) {\n\t\t\t\td = decimal.substr(i, 1);\n\t\t\t\tif (d != "0") {\n\t\t\t\t\toutputCharacters += digits[Number(d)] + decimals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (outputCharacters == "") {\n\t\t\toutputCharacters = CN_ZERO + CN_DOLLAR;\n\t\t}\n\t\tif (decimal == "") {\n\t\t\toutputCharacters += CN_INTEGER;\n\t\t}\n\t\toutputCharacters = CN_SYMBOL + outputCharacters;\n\t\treturn outputCharacters;\n\t}\n\t,\n\t/**\n\t * 克隆对象。\n\t */\n\tcloneObject : function(obj) {\n\t\tvar o = obj.constructor === Array ? [] : {};\n\t\tfor (var i in obj) {\n\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\to[i] = typeof obj[i] === "object"\n\t\t\t\t\t\t? cloneObject(obj[i])\n\t\t\t\t\t\t: obj[i];\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t},\n\tgetFileExtName : function(fileName) {\n\t\tvar pos = fileName.lastIndexOf(".");\n\t\tif (pos == -1)\n\t\t\treturn "";\n\t\treturn fileName.substring(pos + 1);\n\t},\n\t// 转成千分位。\n\tcomdify : function(v) {\n\t\tif (v && v != \'\') {\n\t\t\tn = v + "";\n\t\t\tvar re = /\\d{1,3}(?=(\\d{3})+$)/g;\n\t\t\tvar n1 = n.trim().replace(/^(\\d+)((\\.\\d+)?)$/, function(s, s1, s2) {\n\t\t\t\t\t\treturn s1.replace(re, "$&,") + s2;\n\t\t\t\t\t});\n\t\t\treturn n1;\n\t\t}\n\t\treturn v;\n\t},\n\ttoNumber : function(v) {\n\t\tif (v && v != \'\') {\n\t\t\tif (v.indexOf(\',\') == -1)\n\t\t\t\treturn v;\n\t\t\tvar ary = v.split(\',\');\n\t\t\tvar val = ary.join("");\n\t\t\treturn val;\n\t\t}\n\t\treturn 0;\n\t},\n\tgetParams : function(){\n\t\tvar locUrl = window.location.search.substr(1);\n\t\tvar aryParams=locUrl.split("&");\n\t\tvar json={};\n\t\tfor(var i=0;i<aryParams.length;i++){\n\t\t\tvar pair=aryParams[i];\n\t\t\tvar aryEnt=pair.split("=");\n\t\t\tvar key=aryEnt[0];\n\t\t\tvar val=aryEnt[1];\n\t\t\tif(json[key]){\n\t\t\t\tjson[key]=json[key] +"," + val;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tjson[key]=val;\n\t\t\t}\n\t\t}\n\t\treturn json;\n\t},\n\tgetParam : function(name){\n\t\t\tvar locUrl = window.location.search.substr(1);\n\t\t\tvar aryParams=locUrl.split("&");\n\t\t\tvar rtn="";\n\t\t\tfor(var i=0;i<aryParams.length;i++){\n\t\t\t\tvar pair=aryParams[i];\n\t\t\t\tvar aryEnt=pair.split("=");\n\t\t\t\tvar key=aryEnt[0];\n\t\t\t\tvar val=aryEnt[1];\n\t\t\t\tif(key!=name) continue;\n\t\t\t\tif(rtn==""){\n\t\t\t\t\trtn=val;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trtn+="," + val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rtn;\n\t},\n\t/**\n\t * @说明 获取请求响应的数据\n\t * @失败 默认toast 提示错误信息\n\t * @成功 不展示成功信息自己处理\n\t * @isFastJson 是否触发FastJson格式化，默认false\n\t */\n\tgetResultData : function(defer,fn,msgType,isFastJson){\n\t\tdefer.then(function(result){\n\t\t\t$.getResult(result,fn,msgType,null,null,isFastJson);\n\t\t\t},function(status){\n\t\t\t\tif(status ==!0){\n\t\t\t\t\t$.Dialog.alert("加载失败！"+status,2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t);\n\t},\n\t/**\n\t * @说明 获取请求响应的结果信息\n\t * @失败 默认alert 提示错误信息\n\t * @成功 默认alert 展示成功信息，并确定后回调调用者\n\t * @isFastJson 是否触发FastJson格式化，默认false\n\t */\n\tgetResultMsg : function(defer,fn,errorFn,isFastJson){\n\t\tdefer.then(function(result){\n\t\t\t\t$.getResult(result,fn,"alert","alert",errorFn,isFastJson);\n\t\t\t},function(status){\n\t\t\t\tif(errorFn){\n\t\t\t\t\terrorFn(status);\n\t\t\t\t}\n\t\t\t\t$.Dialog.alert("加载失败！"+status,2);\n\t\t\t}\n\t\t);\n\t},\n\t/**\n\t * 获取请求响应的结果信息\n\t * @result 服务器返回的常规数据\n\t * @fn 回调函数\n\t * @errMsgType 错误时的显示类型 alert，toast（默认）\n\t * @sucMsgType 成功时的显示类型 alert（在确定后触发回调fn），toast（不触发回调fn），为空时直接触发回调fn\n\t * @isFastJson 是否触发FastJson格式化，默认false\n\t */\n\tgetResult : function(result,fn,errMsgType,sucMsgType,errorFn,isFastJson){\n\t\tif(typeof(result) !== "object"){\n\t\t\tif(!result.startWith("{") && !result.startWith("[")){\n\t\t\t\tresult = {"isOk":false,msg:"服务器反馈数据格式存在异常，无法解析反馈结果！","cause":result}\n\t\t\t}else{\n\t\t\t\tvar result\t= eval(\'(\' + result + \')\');\n\t\t\t}\n\t\t}\n\t\tif(isFastJson){\n\t\t\tFastJson.format(result);//处理json循环索引的问题\n\t\t}\n\t\tif(!result.isOk){\n\t\t\tif(!errMsgType || errMsgType ===\'toast\'){\n\t\t\t\t$.Toast.error(result.msg);\n\t\t\t}else if (errMsgType === \'alert\'){\n\t\t\t\t$.Dialog.alert(result.msg,2);\n\t\t\t}\n\t\t\tconsole.error(result);\n\t\t\tif(errorFn){errorFn(result)};\n\t\t\treturn;\n\t\t}else{\n\t\t\tif(!sucMsgType){//不需要任何显示\n\t\t\t\tif(fn){\n\t\t\t\t\tfn(result.data);\n\t\t\t\t}\n\t\t\t}else if(sucMsgType ===\'toast\'){\n\t\t\t\t$.Toast.success(result.msg);\n\t\t\t\tif(fn){\n\t\t\t\t\tfn(result.data);\n\t\t\t\t}\n\t\t\t}else if (errMsgType === \'alert\'){\n\t\t\t\t$.Dialog.alert(result.msg,function(){\n\t\t\t\t\tif(fn){\n\t\t\t\t\t\tfn(result.data);\n\t\t\t\t\t}\n\t\t\t\t},1);\n\t\t\t}\n\t\t}\n\t},\n\tgetPageSize:function() { \n\t\tvar winW, winH; \n\t\tif(window.innerHeight) {// all except IE \n\t\t\twinW = window.innerWidth; \n\t\t\twinH = window.innerHeight; \n\t\t} else if (document.documentElement && document.documentElement.clientHeight) {// IE 6 Strict Mode \n\t\t\twinW = document.documentElement.clientWidth; \n\t\t\twinH = document.documentElement.clientHeight; \n\t\t} else if (document.body) { // other \n\t\t\twinW = document.body.clientWidth; \n\t\t\twinH = document.body.clientHeight; \n\t\t}  // for small pages with total size less then the viewport  \n\t\treturn {width:winW, height:winH}; \n\t}\n\t\n});\n\n\n/**\n * 功能：移除首尾空格\n */\nString.prototype.trim = function() {\n\treturn this.replace(/(^\\s*)|(\\s*$)/g, "");\n};\n/**\n * 功能:移除左边空格\n */\nString.prototype.lTrim = function() {\n\treturn this.replace(/(^\\s*)/g, "");\n};\n/**\n * 功能:移除右边空格\n */\nString.prototype.rTrim = function() {\n\treturn this.replace(/(\\s*$)/g, "");\n};\n/**\n * 判断文件名是否是图片\n */\nString.prototype.isPicture = function(){\n    //判断是否是图片 - strFilter必须是小写列举\n    var strFilter=".jpeg|.gif|.jpg|.png|.bmp|.pic|"\n    if(this.indexOf(".")>-1)\n    {\n        var p = this.lastIndexOf(".");\n        var strPostfix=this.substring(p,this.length) + \'|\';        \n        strPostfix = strPostfix.toLowerCase();\n        if(strFilter.indexOf(strPostfix)>-1){\n            return true;\n        }\n    }        \n    return false;            \n}\n/**\n * 去除数组中的重复项\n * @function [method] 判断对象是否相同的方法(可选参数，默认实现是深度匹配两个对象是否相同)，示例：function(x,y){if(x.id===y.id)return true;}\n */\nArray.prototype.unique=function(method){\n\tif(!angular.isArray(this))return this;\n\tvar sameObj = method || function(a, b) {\n        var tag = true;\n        for (var x in a) {\n            if (!b[x])\n                return false;\n            if (typeof(a[x]) === \'object\') {\n                tag = sameObj(a[x], b[x]);\n            } else {\n                if (a[x] !== b[x])\n                    return false;\n            }\n        }\n        return tag;\n    }\n\t\n\tvar flag, that = this.slice(0);\n\tthis.length = 0;\n\tfor (var i = 0; i < that.length; i++) {\n\t    var x = that[i];\n\t    flag = true;\n\t    for (var j = 0; j < this.length; j++) {\n\t        y = this[j];\n\t        if (sameObj(x, y)) {\n\t            flag = false;\n\t            break;\n\t        }\n\t    }\n\t    if (flag) this[this.length] = x;\n\t}\n\treturn this;\n}\n\n\n/**\n * 判断结束是否相等\n * \n * @param str\n * @param isCasesensitive\n * @returns {Boolean}\n */\nString.prototype.endWith = function(str, isCasesensitive) {\n\tif (str == null || str == "" || this.length == 0\n\t\t\t|| str.length > this.length)\n\t\treturn false;\n\tvar tmp = this.substring(this.length - str.length);\n\tif (isCasesensitive == undefined || isCasesensitive) {\n\t\treturn tmp == str;\n\t} else {\n\t\treturn tmp.toLowerCase() == str.toLowerCase();\n\t}\n\n};\n\n/**\n * 判断开始是否相等\n * \n * @param str\n * @param isCasesensitive\n * @returns {Boolean}\n */\nString.prototype.startWith = function(str, isCasesensitive) {\n\tif (str == null || str == "" || this.length == 0\n\t\t\t|| str.length > this.length)\n\t\treturn false;\n\tvar tmp = this.substr(0, str.length);\n\tif (isCasesensitive == undefined || isCasesensitive) {\n\t\treturn tmp == str;\n\t} else {\n\t\treturn tmp.toLowerCase() == str.toLowerCase();\n\t}\n};\n\n/**\n * 对html字符进行编码 用法： str=str.htmlEncode();\n * \n * @returns\n */\nString.prototype.htmlEncode = function() {\n\treturn this.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g,\n\t\t\t"&gt;").replace(/\\"/g, "&#34;").replace(/\\\'/g, "&#39;");\n};\n\n/**\n * 对html字符串解码 用法： str=str.htmlDecode();\n * \n * @returns\n */\nString.prototype.htmlDecode = function() {\n\treturn this.replace(/\\&amp\\;/g, \'\\&\').replace(/\\&gt\\;/g, \'\\>\').replace(\n\t\t\t/\\&lt\\;/g, \'\\<\').replace(/\\&quot\\;/g, \'\\\'\').replace(/\\&\\#39\\;/g,\n\t\t\t\'\\\'\');\n};\n\n/**\n * 对json中的特殊字符进行转义\n */\nString.prototype.jsonEscape = function() {\n\treturn this.replace(/\\"/g, "&quot;").replace(/\\n/g, "&nuot;");\n};\n\n/**\n * 对json中的特殊字符进行转义\n */\nString.prototype.jsonUnescape = function() {\n\treturn this.replace(/&quot;/g, "\\"").replace(/&nuot;/g, "\\n");\n};\n\n/**\n * 字符串替换\n * \n * @param s1\n *            需要替换的字符\n * @param s2\n *            替换的字符。\n * @returns\n */\nString.prototype.replaceAll = function(s1, s2) {\n\treturn this.replace(new RegExp(s1, "gm"), s2);\n};\n\n/**\n * 移除数组中指定对象\n */\nArray.prototype.remove = function(val) {\n    for (var i = 0; i < this.length; i++) {\n        if (this[i] === val) {\n            this.splice(i, 1);\n            i--;\n        }\n    }\n    return this;\n};\nArray.prototype.insert = function (index, item) {\n\tthis.splice(index, 0, item);\n\treturn this;\n};\n\n/**\n * 格式化字符串\n * eg: var aaa = "myName is {name} my wife name is {wife.name}".format({"name":"苗继方",wife:{name:"柠檬"})\n *    alert (aaa);\n */\nString.prototype.format = function (context) {\n\t  return _stringRender(this, context);\n};\n\nwindow._stringRender = function(template, scopeData) {\n\t \n\t  var tokenReg = /(\\\\)?\\{([^\\{\\}\\\\]+)(\\\\)?\\}/g;\n\t \n\t  return template.replace(tokenReg, function (word, slash1, token, slash2) {\n\t    if (slash1 || slash2) { \n\t      return word.replace(\'\\\\\', \'\');\n\t    }\n\t \n\t    var variables = token.replace(/\\s/g, \'\').split(\'.\');\n\t    var currentObject = scopeData;\n\t    var i, length, variable;\n\t    \n\t    for(var i=0,key;key=variables[i++];){\n\t    \tcurrentObject = currentObject[key];\n\t    \tif (currentObject === undefined || currentObject === null) return \'\';\n\t    }\n\t    \n\t    return currentObject;\n\t  })\n}\n\n\n\n\n/**\n * 日期格式化。\n * 日期格式：\n * yyyy，yy 年份\n * MM 大写表示月份\n * dd 表示日期\n * HH 表示小时\n * mm 表示分钟\n * ss 表示秒\n * q  表示季度\n * 实例如下：\n * var now = new Date(); \n * var nowStr = now.format("yyyy-MM-dd HH:mm:ss"); \n */\nDate.prototype.format = function(format){ \n\tvar o = { \n\t\t"M+" : this.getMonth()+1, //month \n\t\t"d+" : this.getDate(), //day \n\t\t"H+" : this.getHours(), //hour \n\t\t"m+" : this.getMinutes(), //minute \n\t\t"s+" : this.getSeconds(), //second \n\t\t"q+" : Math.floor((this.getMonth()+3)/3), //quarter \n\t\t"S" : this.getMilliseconds() //millisecond \n\t} \n\t\n\tif(/(y+)/.test(format)) { \n\t\tformat = format.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); \n\t} \n\n\tfor(var k in o) { \n\t\tif(new RegExp("("+ k +")").test(format)) { \n\t\t\tformat = format.replace(RegExp.$1, RegExp.$1.length==1 ? o[k] : ("00"+ o[k]).substr((""+ o[k]).length)); \n\t\t} \n\t} \n\treturn format; \n} \n\n\n/**\n * 求两个时间的天数差 日期格式为 yyyy-MM-dd 或 YYYY-MM-dd HH:mm:ss\n */\nfunction daysBetween(DateOne, DateTwo) {\n\tvar dayOne = \'\';\n\tvar dayTwo = \'\';\n\tvar timeOne = \'\';\n\tvar timeTwo = \'\';\n\n\tif (DateOne != null && DateOne != \'\') {\n\t\tvar arrOne = DateOne.split(\' \');\n\t\tdayOne = arrOne[0];\n\t\tif (arrOne.length > 1) {\n\t\t\ttimeOne = arrOne[1];\n\t\t}\n\t}\n\n\tif (DateTwo != null && DateTwo != \'\') {\n\t\tvar arrTwo = DateTwo.split(\' \');\n\t\tdayTwo = arrTwo[0];\n\t\tif (arrTwo.length > 1) {\n\t\t\ttimeTwo = arrTwo[1];\n\t\t}\n\t}\n\n\tvar OneMonth = 0;\n\tvar OneDay = 0;\n\tvar OneYear = 0;\n\tif (dayOne != null && dayOne != \'\') {\n\t\tvar arrDate = dayOne.split(\'-\');\n\t\tOneYear = parseInt(arrDate[0], 10);\n\t\tOneMonth = parseInt(arrDate[1], 10);\n\t\tOneDay = parseInt(arrDate[2], 10);\n\t}\n\n\tvar TwoMonth = 0;\n\tvar TwoDay = 0;\n\tvar TwoYear = 0;\n\tif (dayTwo != null && dayTwo != \'\') {\n\t\tvar arrDate = dayTwo.split(\'-\');\n\t\tTwoYear = parseInt(arrDate[0], 10);\n\t\tTwoMonth = parseInt(arrDate[1], 10);\n\t\tTwoDay = parseInt(arrDate[2], 10);\n\t}\n\n\tvar OneHour = 0;\n\tvar OneMin = 0;\n\tvar OneSec = 0;\n\tif (timeOne != null && timeOne != \'\') {\n\t\tvar arrTiem = timeOne.split(\':\');\n\t\tOneHour = parseInt(arrTiem[0]);\n\t\tOneMin = parseInt(arrTiem[1]);\n\t\tOneSec = parseInt(arrTiem[2]);\n\t}\n\n\tvar TwoHour = 0;\n\tvar TwoMin = 0;\n\tvar TwoSec = 0;\n\tif (timeTwo != null && timeTwo != \'\') {\n\t\tvar arrTiem = timeTwo.split(\':\');\n\t\tTwoHour = parseInt(arrTiem[0]);\n\t\tTwoMin = parseInt(arrTiem[1]);\n\t\tTwoSec = parseInt(arrTiem[2]);\n\t}\n\n\tvar vflag = TwoYear > OneYear ? true : false;\n\tif (!vflag) {\n\t\tvflag = TwoMonth > OneMonth ? true : false;\n\t\tif (!vflag) {\n\t\t\tvflag = TwoDay > OneDay ? true : false;\n\n\t\t\tif (!vflag) {\n\t\t\t\tif (OneDay == TwoDay) {\n\t\t\t\t\tvflag = TwoHour > OneHour ? true : false;\n\t\t\t\t\tif (!vflag) {\n\t\t\t\t\t\tvflag = TwoMin > OneMin ? true : false;\n\t\t\t\t\t\tif (!vflag) {\n\t\t\t\t\t\t\tvflag = TwoSec >= OneSec ? true : false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vflag;\n};\n\n// 禁用刷新。通过传入浏览器类型 来指定禁用某个浏览器的刷新\nfunction forbidF5(exp) {\n\tvar currentExplorer = window.navigator.userAgent;\n\t// ie "MSIE" ,, firefox "Firefox" ,,Chrome "Chrome",,Opera "Opera",,Safari\n\t// "Safari"\n\tif (currentExplorer.indexOf(exp) >= 0) {\n\t\tdocument.onkeydown = function(e) {\n\t\t\tvar ev = window.event || e;\n\t\t\tvar code = ev.keyCode || ev.which;\n\t\t\tif (code == 116) {\n\t\t\t\tev.keyCode ? ev.keyCode = 0 : ev.which = 0;\n\t\t\t\tcancelBubble = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t}\n}\n\n//产生随机数\nwindow.GetRandomNum = function(Min, Max) {\n\tvar Range = Max - Min;\n\tvar Rand = Math.random();\n\treturn (Min + Math.round(Rand * Range));\n}\n//产生随机字符串\nwindow.GetRandomStr = function(len) {\n　　len = len || 32;\n　　var $chars = \'ABCDEFGHJKLMNOPQRSTUVWXYZabcdefhijklmnoprstuvwxyz\';\n　　var maxPos = $chars.length;\n　　var pwd = \'\';\n　　for (var i = 0; i < len; i++) {\n　　　　pwd += $chars.charAt(Math.floor(Math.random() * maxPos));\n　　}\n　　return pwd;\n}\n\nvar JsonUtil = {\n\t//定义换行符\n\tn : "\\n",\n\t//定义制表符\n\tt : "\\t",\n\t//转换String\n\tconvertToString : function(obj) {\n\t\treturn JsonUtil.__writeObj(obj, 1);\n\t},\n\t//写对象\n\t__writeObj : function(obj //对象\n\t\t\t, level //层次（基数为1）\n\t\t\t, isInArray) { //此对象是否在一个集合内\n\t\t//如果为空，直接输出null\n\t\tif (obj == null) {\n\t\t\treturn "null";\n\t\t}\n\t\t//为普通类型，直接输出值\n\t\tif (obj.constructor == Number || obj.constructor == Date\n\t\t\t\t|| obj.constructor == String || obj.constructor == Boolean) {\n\t\t\tvar v = obj.toString();\n\t\t\tvar tab = isInArray\n\t\t\t\t\t? JsonUtil.__repeatStr(JsonUtil.t, level - 1)\n\t\t\t\t\t: "";\n\t\t\tif (obj.constructor == String || obj.constructor == Date) {\n\t\t\t\t//时间格式化只是单纯输出字符串，而不是Date对象\n\t\t\t\treturn tab + ("\\"" + v + "\\"");\n\t\t\t} else if (obj.constructor == Boolean) {\n\t\t\t\treturn tab + v.toLowerCase();\n\t\t\t} else {\n\t\t\t\treturn tab + (v);\n\t\t\t}\n\t\t}\n\n\t\t//写Json对象，缓存字符串\n\t\tvar currentObjStrings = [];\n\t\t//遍历属性\n\t\tfor (var name in obj) {\n\t\t\tvar temp = [];\n\t\t\t//格式化Tab\n\t\t\tvar paddingTab = JsonUtil.__repeatStr(JsonUtil.t, level);\n\t\t\ttemp.push(paddingTab);\n\t\t\t//写出属性名\n\t\t\ttemp.push(name + " : ");\n\n\t\t\tvar val = obj[name];\n\t\t\tif (val == null) {\n\t\t\t\ttemp.push("null");\n\t\t\t} else {\n\t\t\t\tvar c = val.constructor;\n\n\t\t\t\tif (c == Array) { //如果为集合，循环内部对象\n\t\t\t\t\ttemp.push(JsonUtil.n + paddingTab + "[" + JsonUtil.n);\n\t\t\t\t\tvar levelUp = level + 2; //层级+2\n\n\t\t\t\t\tvar tempArrValue = []; //集合元素相关字符串缓存片段\n\t\t\t\t\tfor (var i = 0; i < val.length; i++) {\n\t\t\t\t\t\t//递归写对象                         \n\t\t\t\t\t\ttempArrValue.push(JsonUtil.__writeObj(val[i], levelUp,\n\t\t\t\t\t\t\t\ttrue));\n\t\t\t\t\t}\n\n\t\t\t\t\ttemp.push(tempArrValue.join("," + JsonUtil.n));\n\t\t\t\t\ttemp.push(JsonUtil.n + paddingTab + "]");\n\t\t\t\t} else if (c == Function) {\n\t\t\t\t\ttemp.push(val);\n\t\t\t\t} else {\n\t\t\t\t\t//递归写对象\n\t\t\t\t\ttemp.push(JsonUtil.__writeObj(val, level + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//加入当前对象“属性”字符串\n\t\t\tcurrentObjStrings.push(temp.join(""));\n\t\t}\n\t\treturn (level > 1 && !isInArray ? JsonUtil.n : "") //如果Json对象是内部，就要换行格式化\n\t\t\t\t+ JsonUtil.__repeatStr(JsonUtil.t, level - 1) + "{" + JsonUtil.n //加层次Tab格式化\n\t\t\t\t+ currentObjStrings.join("," + JsonUtil.n) //串联所有属性值\n\t\t\t\t+ JsonUtil.n + JsonUtil.__repeatStr(JsonUtil.t, level - 1) + "}"; //封闭对象\n\t},\n\t__isArray : function(obj) {\n\t\tif (obj) {\n\t\t\treturn obj.constructor == Array;\n\t\t}\n\t\treturn false;\n\t},\n\t__repeatStr : function(str, times) {\n\t\tvar newStr = [];\n\t\tif (times > 0) {\n\t\t\tfor (var i = 0; i < times; i++) {\n\t\t\t\tnewStr.push(str);\n\t\t\t}\n\t\t}\n\t\treturn newStr.join("");\n\t}\n};\n\n/**\n * 将字符串转为json对象。\n * @param jsonStr\n * @param type  可不填写\n * @returns\n */\nwindow.parseToJson = function(jsonStr){\n\tif(jsonStr === "") return ;\n\treturn eval("("+jsonStr+")");\n}\n\nwindow.CacheUtil={};\n/**\n * 设置缓存。\n */\nCacheUtil.set=function(key,value){\n\tlocalStorage[key]=value;\n}\n\n/**\n * 获取缓存\n */\nCacheUtil.get=function(key){\n\treturn localStorage[key];\n}\n\n/**\n * 删除缓存\n */\nCacheUtil.clean=function(key){\n\tlocalStorage.rmStorage(key);\n}\n\n/**\n * 设置缓存，value 为JSON对象。\n */\nCacheUtil.setJSON=function(key,value){\n\tvar json=JSON.stringify(value)\n\tlocalStorage[key]=json;\n}\n\n/**\n * 根据键获取json对象。\n */\nCacheUtil.getJSON=function(key){\n\tvar json=localStorage[key];\n\tif(json==undefined) return null;\n\treturn JSON.parse(json);\n}\n\n\nwindow.CloneUtil = {\n\t\t/**\n\t\t * 深复制【可以迭代】\n\t\t */\n\t\tdeep:function(obj){\n\t\t\treturn jQuery.extend(true,{}, obj);\n\t\t},\n\t\t/**\n\t\t * 浅复制【不能迭代】\n\t\t */\n\t\tshallow:function(obj){\n\t\t\treturn jQuery.extend({}, obj);\n\t\t},\n\t\t/**\n\t\t * 数组复制\n\t\t */\n\t\tlist:function(obj){\n\t\t\treturn $.map(obj, function (n) { return n; });\n\t\t}\n}\n\n/**\n * 遍历树工具\n */\nwindow.TraverseTreeUtil = {\n\t/**\n\t * 遍历树 node：跟节点 nodeAttrName:子节点的属性名字\n\t * eg:TraverseTreeUtil.traverse(relation,"children",function(node){\n\t * \t\t$scope.allRelations.push(node); \n\t * });\n\t * \n\t */\n\ttraverse:function(node,nodeAttrName,callback){\n\t    if (!node) {\n\t        return;\n\t    }\n\t    //处理回调\n\t    callback(node);\n\t    \n\t    //递归\n\t    if (node[nodeAttrName] && node[nodeAttrName].length > 0) {\n\t        for (var i = 0; i < node[nodeAttrName].length; i++) {\n\t        \tTraverseTreeUtil.traverse(node[nodeAttrName][i],nodeAttrName,callback);\n\t        }\n\t    }\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvY29tbW9uL3Rvb2xzL3V0aWwuanM/NzU1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyw0QkFBNEI7O0FBRTVCLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSSxPQUFPLEVBQUU7QUFDN0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsY0FBYztBQUNkLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsRUFBRTtBQUNGLHlCO0FBQ0EsaUI7QUFDQSwwQkFBMEI7QUFDMUIsNEI7QUFDQSw2QjtBQUNBLEdBQUcsOEVBQThFO0FBQ2pGLCtDO0FBQ0EsZ0Q7QUFDQSxHQUFHLDBCQUEwQjtBQUM3QixvQztBQUNBLHFDO0FBQ0EsR0FBRztBQUNILFVBQVUseUI7QUFDVjs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBLGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZELFFBQVEsd0JBQXdCLHdCQUF3QjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUJBQXlCO0FBQ3RELFVBQVUsMkJBQTJCLDJCQUEyQjtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxrQkFBa0IsVUFBVSxVQUFVLG1CQUFtQixVQUFVO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLEtBQUssRUFBRSxZQUFZOztBQUU3QztBQUNBLDRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCO0FBQ0Esa0Q7QUFDQTtBQUNBLHlDO0FBQ0EsVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7QUFFQSwwQjtBQUNBLDJGO0FBQ0EsRTs7QUFFQSxrQjtBQUNBLDRDO0FBQ0EsMkc7QUFDQSxHO0FBQ0EsRTtBQUNBLGU7QUFDQSxDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0EsNkJBQTZCOztBQUU3QiwyQkFBMkI7QUFDM0Isb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxtRUFBbUUsRUFBRTtBQUNyRSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxFQUFFO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJCA9IGpRdWVyeTtcbmpRdWVyeS5leHRlbmQoe1xuXHQvKipcblx0ICog5Yik5pat5piv5ZCm5pivSUXmtY/op4jlmahcblx0ICogXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKi9cblx0aXNJRSA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcHBOYW1lID0gbmF2aWdhdG9yLmFwcE5hbWU7XG5cdFx0dmFyIGlkeCA9IGFwcE5hbWUuaW5kZXhPZihcIk1pY3Jvc29mdFwiKTtcblx0XHRyZXR1cm4gaWR4ID09IDA7XG5cdH0sXG5cdC8qKlxuXHQgKiDliKTmlq3mmK/lkKbmmK9JRTbmtY/op4jlmahcblx0ICogXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKi9cblx0aXNJRTYgOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoKCQuYnJvd3Nlci5tc2llICYmICQuYnJvd3Nlci52ZXJzaW9uID09ICc2LjAnKSAmJiAhJC5zdXBwb3J0LnN0eWxlKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIDxpbWcgc3JjPVwiaW1nL2xvZ28ucG5nXCIgb25sb2FkPVwiJC5maXhQTkcodGhpcyk7XCIvPiDop6PlhrPlm77niYflnKhpZeS4reiDjOaZr+mAj+aYjueahOmXrumimOOAglxuXHQgKiBcblx0ICogQHBhcmFtIGltZ09ialxuXHQgKi9cblx0Zml4UE5HIDogZnVuY3Rpb24oaW1nT2JqKSB7XG5cdFx0dmFyIGFyVmVyc2lvbiA9IG5hdmlnYXRvci5hcHBWZXJzaW9uLnNwbGl0KFwiTVNJRVwiKTtcblx0XHR2YXIgdmVyc2lvbiA9IHBhcnNlRmxvYXQoYXJWZXJzaW9uWzFdKTtcblx0XHRpZiAoKHZlcnNpb24gPj0gNS41KSAmJiAodmVyc2lvbiA8IDcpICYmIChkb2N1bWVudC5ib2R5LmZpbHRlcnMpKSB7XG5cdFx0XHR2YXIgaW1nSUQgPSAoaW1nT2JqLmlkKSA/IFwiaWQ9J1wiICsgaW1nT2JqLmlkICsgXCInIFwiIDogXCJcIjtcblx0XHRcdHZhciBpbWdDbGFzcyA9IChpbWdPYmouY2xhc3NOYW1lKSA/IFwiY2xhc3M9J1wiICsgaW1nT2JqLmNsYXNzTmFtZVxuXHRcdFx0XHRcdCsgXCInIFwiIDogXCJcIjtcblx0XHRcdHZhciBpbWdUaXRsZSA9IChpbWdPYmoudGl0bGUpXG5cdFx0XHRcdFx0PyBcInRpdGxlPSdcIiArIGltZ09iai50aXRsZSArIFwiJyBcIlxuXHRcdFx0XHRcdDogXCJ0aXRsZT0nXCIgKyBpbWdPYmouYWx0ICsgXCInIFwiO1xuXHRcdFx0dmFyIGltZ1N0eWxlID0gXCJkaXNwbGF5OmlubGluZS1ibG9jaztcIiArIGltZ09iai5zdHlsZS5jc3NUZXh0O1xuXHRcdFx0dmFyIHN0ck5ld0hUTUwgPSBcIjxzcGFuIFwiXG5cdFx0XHRcdFx0KyBpbWdJRFxuXHRcdFx0XHRcdCsgaW1nQ2xhc3Ncblx0XHRcdFx0XHQrIGltZ1RpdGxlXG5cdFx0XHRcdFx0KyBcIiBzdHlsZT1cXFwiXCJcblx0XHRcdFx0XHQrIFwid2lkdGg6XCJcblx0XHRcdFx0XHQrIGltZ09iai53aWR0aFxuXHRcdFx0XHRcdCsgXCJweDsgaGVpZ2h0OlwiXG5cdFx0XHRcdFx0KyBpbWdPYmouaGVpZ2h0XG5cdFx0XHRcdFx0KyBcInB4O1wiXG5cdFx0XHRcdFx0KyBpbWdTdHlsZVxuXHRcdFx0XHRcdCsgXCI7XCJcblx0XHRcdFx0XHQrIFwiZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYUltYWdlTG9hZGVyXCJcblx0XHRcdFx0XHQrIFwiKHNyYz1cXCdcIiArIGltZ09iai5zcmNcblx0XHRcdFx0XHQrIFwiXFwnLCBzaXppbmdNZXRob2Q9J3NjYWxlJyk7XFxcIj48L3NwYW4+XCI7XG5cdFx0XHRpbWdPYmoub3V0ZXJIVE1MID0gc3RyTmV3SFRNTDtcblx0XHR9XG5cdH0sXG5cdC8qKlxuXHQgKiDojrflj5blvZPliY3ot6/lvoTkuK3mjIflrprplK7nmoTlj4LmlbDlgLzjgIJcblx0ICogXG5cdCAqIEBwYXJhbSBrZXlcblx0ICogQHJldHVybnNcblx0ICovXG5cdGdldFBhcmFtZXRlciA6IGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBwYXJhbWV0ZXJzID0gdW5lc2NhcGUod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkpLnNwbGl0KFwiJlwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwYXJhbUNlbGwgPSBwYXJhbWV0ZXJzW2ldLnNwbGl0KFwiPVwiKTtcblx0XHRcdGlmIChwYXJhbUNlbGwubGVuZ3RoID09IDJcblx0XHRcdFx0XHQmJiBwYXJhbUNlbGxbMF0udG9VcHBlckNhc2UoKSA9PSBrZXkudG9VcHBlckNhc2UoKSkge1xuXHRcdFx0XHRyZXR1cm4gcGFyYW1DZWxsWzFdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gXCJcIjtcblx0fSxcblx0LyoqXG5cdCAqIOagueaNruW5tOS7veWSjOaciOS7veiOt+WPluafkOS4quaciOeahOWkqeaVsOOAglxuXHQgKiBcblx0ICogQHBhcmFtIHllYXJcblx0ICogQHBhcmFtIG1vbnRoXG5cdCAqIEByZXR1cm5zXG5cdCAqL1xuXHRnZXRNb250aERheXMgOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuXHRcdGlmIChtb250aCA8IDAgfHwgbW9udGggPiAxMSkge1xuXHRcdFx0cmV0dXJuIDMwO1xuXHRcdH1cblx0XHR2YXIgYXJyTW9uID0gbmV3IEFycmF5KDEyKTtcblx0XHRhcnJNb25bMF0gPSAzMTtcblx0XHRpZiAoeWVhciAlIDQgPT0gMCkge1xuXHRcdFx0YXJyTW9uWzFdID0gMjk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyck1vblsxXSA9IDI4O1xuXHRcdH1cblx0XHRhcnJNb25bMl0gPSAzMTtcblx0XHRhcnJNb25bM10gPSAzMDtcblx0XHRhcnJNb25bNF0gPSAzMTtcblx0XHRhcnJNb25bNV0gPSAzMDtcblx0XHRhcnJNb25bNl0gPSAzMTtcblx0XHRhcnJNb25bN10gPSAzMTtcblx0XHRhcnJNb25bOF0gPSAzMDtcblx0XHRhcnJNb25bOV0gPSAzMTtcblx0XHRhcnJNb25bMTBdID0gMzA7XG5cdFx0YXJyTW9uWzExXSA9IDMxO1xuXHRcdHJldHVybiBhcnJNb25bbW9udGhdO1xuXHR9LFxuXHQvKipcblx0ICog6K6h566X5pel5pyf5Li65b2T5bm055qE56ys5Yeg5ZGoXG5cdCAqIFxuXHQgKiBAcGFyYW0geWVhclxuXHQgKiBAcGFyYW0gbW9udGhcblx0ICogQHBhcmFtIGRheVxuXHQgKiBAcmV0dXJuc1xuXHQgKi9cblx0d2Vla09mWWVhciA6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXkpIHtcblx0XHQvLyB5ZWFyIOW5tFxuXHRcdC8vIG1vbnRoIOaciFxuXHRcdC8vIGRheSDml6Vcblx0XHQvLyDmr4/lkajku47lkajml6XlvIDlp4tcblx0XHR2YXIgZGF0ZTEgPSBuZXcgRGF0ZSh5ZWFyLCAwLCAxKTtcblx0XHR2YXIgZGF0ZTIgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMSk7XG5cdFx0dmFyIGRheU1TID0gMjQgKiA2MCAqIDYwICogMTAwMDtcblx0XHR2YXIgZmlyc3REYXkgPSAoNyAtIGRhdGUxLmdldERheSgpKSAqIGRheU1TO1xuXHRcdHZhciB3ZWVrTVMgPSA3ICogZGF5TVM7XG5cdFx0ZGF0ZTEgPSBkYXRlMS5nZXRUaW1lKCk7XG5cdFx0ZGF0ZTIgPSBkYXRlMi5nZXRUaW1lKCk7XG5cdFx0cmV0dXJuIE1hdGguY2VpbCgoZGF0ZTIgLSBkYXRlMSAtIGZpcnN0RGF5KSAvIHdlZWtNUykgKyAxO1xuXHR9LFxuXHQvKipcblx0ICog5pe26Ze05beu6K6h566XXG5cdCAqL1xuXHR0aW1lTGFnOmZ1bmN0aW9uKGRpZmZlcmVuY2Upe1xuXHRcdHZhciAgciA9XCJcIixcblx0XHQvLy8v6K6h566X5Ye655u45beu5aSp5pWwXG5cdFx0ZGF5cz1NYXRoLmZsb29yKGRpZmZlcmVuY2UvKDI0KjM2MDAqMTAwMCkpLFxuXHRcdC8v6K6h566X5Ye65bCP5pe25pWwXG5cdFx0bGVhdmUxPWRpZmZlcmVuY2UlKDI0KjM2MDAqMTAwMCksICAgLy/orqHnrpflpKnmlbDlkI7liankvZnnmoTmr6vnp5LmlbBcblx0XHRob3Vycz1NYXRoLmZsb29yKGxlYXZlMS8oMzYwMCoxMDAwKSksXG5cdFx0Ly/orqHnrpfnm7jlt67liIbpkp/mlbBcblx0XHRsZWF2ZTI9bGVhdmUxJSgzNjAwKjEwMDApLCAgICAgIC8v6K6h566X5bCP5pe25pWw5ZCO5Ymp5L2Z55qE5q+r56eS5pWwXG5cdFx0bWludXRlcz1NYXRoLmZsb29yKGxlYXZlMi8oNjAqMTAwMCkpLFxuXHRcdC8v6K6h566X55u45beu56eS5pWwXG5cdFx0bGVhdmUzPWxlYXZlMiUoNjAqMTAwMCksICAgIC8v6K6h566X5YiG6ZKf5pWw5ZCO5Ymp5L2Z55qE5q+r56eS5pWwXG5cdFx0c2Vjb25kcz1NYXRoLnJvdW5kKGxlYXZlMy8xMDAwKTtcblx0XHRpZihkYXlzPjApIHIgKz1kYXlzK1wi5aSpXCI7XG5cdFx0aWYoaG91cnM+MCkgciArPWhvdXJzK1wi5bCP5pe2XCI7XG5cdFx0aWYobWludXRlcz4wKSByICs9bWludXRlcytcIuWIhumSn1wiO1xuXHRcdGlmKHNlY29uZHM+MCkgciArPXNlY29uZHMrXCLnp5JcIjtcblx0XHRcblx0XHRpZihyKXtcblx0XHRcdHJldHVybiByO1xuXHRcdH1cblx0XHRcblx0XHRpZihsZWF2ZTMpe1xuXHRcdFx0cmV0dXJuIGRpZmZlcmVuY2UrXCLmr6vnp5JcIjtcblx0XHR9XG5cdFx0cmV0dXJuIFwiXCJcblx0fSxcblx0LyoqXG5cdCAqIOaXtumXtOW3ruiuoeeul1xuXHQgKiBkYXRlMSDlvIDlp4vml7bpl7Qg5q+r56eS5pWwXG5cdCAqIGRhdGUyIOe7k+adn+aXtumXtCDmr6vnp5LmlbBcblx0ICovXG5cdHRpbWVEaWZmZXJlbmNlOmZ1bmN0aW9uKGRhdGUxLGRhdGUyKXtcblx0XHRyZXR1cm4gJC50aW1lTGFnKGRhdGUyLWRhdGUxKTtcblx0fSxcblx0LyoqXG5cdCAqIOa3u+WKoOS5puetvlxuXHQgKiBcblx0ICogQHBhcmFtIHRpdGxlXG5cdCAqIEBwYXJhbSB1cmxcblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqL1xuXHRhZGRCb29rbWFyayA6IGZ1bmN0aW9uKHRpdGxlLCB1cmwpIHtcblx0XHRpZiAod2luZG93LnNpZGViYXIpIHtcblx0XHRcdHdpbmRvdy5zaWRlYmFyLmFkZFBhbmVsKHRpdGxlLCB1cmwsIFwiXCIpO1xuXHRcdH0gZWxzZSBpZiAoZG9jdW1lbnQuYWxsKSB7XG5cdFx0XHR3aW5kb3cuZXh0ZXJuYWwuQWRkRmF2b3JpdGUodXJsLCB0aXRsZSk7XG5cdFx0fSBlbHNlIGlmICh3aW5kb3cub3BlcmEgJiYgd2luZG93LnByaW50KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIOiuvue9rmNvb2tpZVxuXHQgKiBcblx0ICogQHBhcmFtIG5hbWVcblx0ICogQHBhcmFtIHZhbHVlXG5cdCAqL1xuXHRzZXRDb29raWUgOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXHRcdHZhciBleHBkYXRlID0gbmV3IERhdGUoKTtcblx0XHR2YXIgYXJndiA9IGFyZ3VtZW50cztcblx0XHR2YXIgYXJnYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0dmFyIGV4cGlyZXMgPSAoYXJnYyA+IDIpID8gYXJndlsyXSA6IG51bGw7XG5cdFx0dmFyIHBhdGggPSAoYXJnYyA+IDMpID8gYXJndlszXSA6IG51bGw7XG5cdFx0dmFyIGRvbWFpbiA9IChhcmdjID4gNCkgPyBhcmd2WzRdIDogbnVsbDtcblx0XHR2YXIgc2VjdXJlID0gKGFyZ2MgPiA1KSA/IGFyZ3ZbNV0gOiBmYWxzZTtcblx0XHRpZiAoZXhwaXJlcyAhPSBudWxsKVxuXHRcdFx0ZXhwZGF0ZS5zZXRUaW1lKGV4cGRhdGUuZ2V0VGltZSgpICsgKGV4cGlyZXMgKiAxMDAwKSk7XG5cblx0XHRkb2N1bWVudC5jb29raWUgPSBuYW1lXG5cdFx0XHRcdCsgXCI9XCJcblx0XHRcdFx0KyBlc2NhcGUodmFsdWUpXG5cdFx0XHRcdCsgKChleHBpcmVzID09IG51bGwpID8gXCJcIiA6IChcIjsgIGV4cGlyZXM9XCIgKyBleHBkYXRlXG5cdFx0XHRcdFx0XHQudG9HTVRTdHJpbmcoKSkpXG5cdFx0XHRcdCsgKChwYXRoID09IG51bGwpID8gXCJcIiA6IChcIjsgIHBhdGg9XCIgKyBwYXRoKSlcblx0XHRcdFx0KyAoKGRvbWFpbiA9PSBudWxsKSA/IFwiXCIgOiAoXCI7ICBkb21haW49XCIgKyBkb21haW4pKVxuXHRcdFx0XHQrICgoc2VjdXJlID09IHRydWUpID8gXCI7ICBzZWN1cmVcIiA6IFwiXCIpO1xuXG5cdH0sXG5cdC8qKlxuXHQgKiDliKDpmaRjb29raWVcblx0ICogXG5cdCAqIEBwYXJhbSBuYW1lXG5cdCAqL1xuXHRkZWxDb29raWUgOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIGV4cCA9IG5ldyBEYXRlKCk7XG5cdFx0ZXhwLnNldFRpbWUoZXhwLmdldFRpbWUoKSAtIDEpO1xuXHRcdHZhciBjdmFsID0gZ2V0Q29va2llKG5hbWUpO1xuXHRcdGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyBcIj1cIiArIGN2YWwgKyBcIjsgIGV4cGlyZXM9XCIgKyBleHAudG9HTVRTdHJpbmcoKTtcblxuXHR9LFxuXHQvKipcblx0ICog6K+75Y+WY29va2llXG5cdCAqIFxuXHQgKiBAcGFyYW0gbmFtZVxuXHQgKiBAcmV0dXJuc1xuXHQgKi9cblx0Z2V0Q29va2llIDogZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciBhcmcgPSBuYW1lICsgXCI9XCI7XG5cdFx0dmFyIGFsZW4gPSBhcmcubGVuZ3RoO1xuXHRcdHZhciBjbGVuID0gZG9jdW1lbnQuY29va2llLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKGkgPCBjbGVuKSB7XG5cdFx0XHR2YXIgaiA9IGkgKyBhbGVuO1xuXHRcdFx0aWYgKGRvY3VtZW50LmNvb2tpZS5zdWJzdHJpbmcoaSwgaikgPT0gYXJnKVxuXHRcdFx0XHRyZXR1cm4gJC5nZXRDb29raWVWYWwoaik7XG5cdFx0XHRpID0gZG9jdW1lbnQuY29va2llLmluZGV4T2YoXCIgIFwiLCBpKSArIDE7XG5cdFx0XHRpZiAoaSA9PSAwKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fSxcblx0Z2V0Q29va2llVmFsIDogZnVuY3Rpb24ob2Zmc2V0KVxuXG5cdHtcblx0XHR2YXIgZW5kc3RyID0gZG9jdW1lbnQuY29va2llLmluZGV4T2YoXCI7XCIsIG9mZnNldCk7XG5cdFx0aWYgKGVuZHN0ciA9PSAtMSlcblx0XHRcdGVuZHN0ciA9IGRvY3VtZW50LmNvb2tpZS5sZW5ndGg7XG5cdFx0cmV0dXJuIHVuZXNjYXBlKGRvY3VtZW50LmNvb2tpZS5zdWJzdHJpbmcob2Zmc2V0LCBlbmRzdHIpKTtcblx0fSxcblx0LyoqXG5cdCAqIOaJk+W8gOWFqOWxj+eahOeql+WPo1xuXHQgKiBAcGFyYW0gdXJsXG5cdCAqIEByZXR1cm5zXG5cdCAqL1xuXHRvcGVuRnVsbFdpbmRvdyA6IGZ1bmN0aW9uKHVybCkge1xuXHRcdHZhciBoID0gc2NyZWVuLmF2YWlsSGVpZ2h0IC0gNjU7XG5cdFx0dmFyIHcgPSBzY3JlZW4uYXZhaWxXaWR0aCAtIDU7XG5cdFx0dmFyIHZhcnMgPSBcInRvcD0wLGxlZnQ9MCxoZWlnaHQ9XCJcblx0XHRcdFx0KyBoXG5cdFx0XHRcdCsgXCIsd2lkdGg9XCJcblx0XHRcdFx0KyB3XG5cdFx0XHRcdCsgXCIsc3RhdHVzPW5vLHRvb2xiYXI9bm8sbWVudWJhcj1ubyxsb2NhdGlvbj1ubyxyZXNpemFibGU9MSxzY3JvbGxiYXJzPTFcIjtcblxuXHRcdHZhciB3aW4gPSB3aW5kb3cub3BlbigkLmhhbmRQcm9qZWN0VXJsKHVybCksIFwiXCIsIHZhcnMsIHRydWUpO1xuXHRcdHJldHVybiB3aW47XG5cdH0sXG5cdGhhbmRQcm9qZWN0VXJsIDogZnVuY3Rpb24odXJsKXtcblx0XHRpZih1cmwgJiYgdXJsLmluZGV4T2YoXCJodHRwOi8vXCIpPT0tMSAmJiB1cmwuc3Vic3RyaW5nKDAsMSk9PT1cIi9cIil7XG5cdFx0XHQgdmFyIHBhdGhuYW1lID13aW5kb3cuZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG5cdFx0XHQgdmFyIHByb2plY3RQYXRoID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAscGF0aG5hbWUuc3Vic3RyKDEpLmluZGV4T2YoJy8nKSsxKTtcblx0XHRcdCBcblx0XHRcdCBpZihwcm9qZWN0UGF0aCA9PT0gJy9mbG93LWVkaXRvcicgfHwgcHJvamVjdFBhdGggPT09IFwiL2JwbVwiIHx8IHByb2plY3RQYXRoID09PSBcIi9zeXNcIiB8fCBwcm9qZWN0UGF0aCA9PT0gXCIvb3JnXCIgfHwgcHJvamVjdFBhdGggPT09IFwiL2Zvcm1cIil7XG5cdFx0XHRcdCByZXR1cm4gdXJsO1xuXHRcdFx0IH1cblx0XHRcdCBcblx0XHRcdCByZXR1cm4gcHJvamVjdFBhdGgrdXJsO1xuXHRcdH1cblx0XHRyZXR1cm4gdXJsO1xuXHR9LFxuXHQvKipcblx0ICog5aaC5p6c5Lyg5YWl55qE5YC85pivbnVsbOOAgXVuZGVmaW5lZOaIluepuuWtl+espuS4su+8jOWImei/lOWbnnRydWXjgILvvIjlj6/pgInnmoTvvIlcblx0ICogXG5cdCAqIEBwYXJhbSB7TWl4ZWR9XG5cdCAqICAgICAgICAgICAgdmFsdWUg6KaB6aqM6K+B55qE5YC844CCXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn1cblx0ICogICAgICAgICAgICBhbGxvd0JsYW5rIO+8iOWPr+mAieeahO+8iSDlpoLmnpzor6XlgLzkuLp0cnVl77yM5YiZ56m65a2X56ym5Liy5LiN5Lya5b2T5L2c56m66ICM6L+U5ZuedHJ1ZeOAglxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0aXNFbXB0eSA6IGZ1bmN0aW9uKHYsIGFsbG93QmxhbmspIHtcblx0XHRyZXR1cm4gdiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWRcblx0XHRcdFx0fHwgKCFhbGxvd0JsYW5rID8gdiA9PT0gJycgOiBmYWxzZSk7XG5cdH0sXG5cdC8qKlxuXHQgKiDlsIbmlbDlrZfovazmjaLmiJDkurrlkI3luIHlpKflhpnjgIJcblx0ICogXG5cdCAqIEBwYXJhbSBjdXJyZW5jeURpZ2l0c1xuXHQgKiBAcmV0dXJuc1xuXHQgKi9cblx0Y29udmVydEN1cnJlbmN5IDogZnVuY3Rpb24oY3VycmVuY3lEaWdpdHMpIHtcblxuXHRcdHZhciBNQVhJTVVNX05VTUJFUiA9IDk5OTk5OTk5OTk5Ljk5O1xuXHRcdHZhciBDTl9aRVJPID0gXCLpm7ZcIjtcblx0XHR2YXIgQ05fT05FID0gXCLlo7lcIjtcblx0XHR2YXIgQ05fVFdPID0gXCLotLBcIjtcblx0XHR2YXIgQ05fVEhSRUUgPSBcIuWPgVwiO1xuXHRcdHZhciBDTl9GT1VSID0gXCLogoZcIjtcblx0XHR2YXIgQ05fRklWRSA9IFwi5LyNXCI7XG5cdFx0dmFyIENOX1NJWCA9IFwi6ZmGXCI7XG5cdFx0dmFyIENOX1NFVkVOID0gXCLmn5JcIjtcblx0XHR2YXIgQ05fRUlHSFQgPSBcIuaNjFwiO1xuXHRcdHZhciBDTl9OSU5FID0gXCLnjpZcIjtcblx0XHR2YXIgQ05fVEVOID0gXCLmi75cIjtcblx0XHR2YXIgQ05fSFVORFJFRCA9IFwi5L2wXCI7XG5cdFx0dmFyIENOX1RIT1VTQU5EID0gXCLku59cIjtcblx0XHR2YXIgQ05fVEVOX1RIT1VTQU5EID0gXCLkuIdcIjtcblx0XHR2YXIgQ05fSFVORFJFRF9NSUxMSU9OID0gXCLkur9cIjtcblx0XHR2YXIgQ05fU1lNQk9MID0gXCJcIjtcblx0XHR2YXIgQ05fRE9MTEFSID0gXCLlhYNcIjtcblx0XHR2YXIgQ05fVEVOX0NFTlQgPSBcIuinklwiO1xuXHRcdHZhciBDTl9DRU5UID0gXCLliIZcIjtcblx0XHR2YXIgQ05fSU5URUdFUiA9IFwi5pW0XCI7XG5cdFx0dmFyIGludGVncmFsO1xuXHRcdHZhciBkZWNpbWFsO1xuXHRcdHZhciBvdXRwdXRDaGFyYWN0ZXJzO1xuXHRcdHZhciBwYXJ0cztcblx0XHR2YXIgZGlnaXRzLCByYWRpY2VzLCBiaWdSYWRpY2VzLCBkZWNpbWFscztcblx0XHR2YXIgemVyb0NvdW50O1xuXHRcdHZhciBpLCBwLCBkO1xuXHRcdHZhciBxdW90aWVudCwgbW9kdWx1cztcblx0XHRjdXJyZW5jeURpZ2l0cyA9IGN1cnJlbmN5RGlnaXRzLnRvU3RyaW5nKCk7XG5cdFx0aWYgKGN1cnJlbmN5RGlnaXRzID09IFwiXCIpIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0XHRpZiAoY3VycmVuY3lEaWdpdHMubWF0Y2goL1teLC5cXGRdLykgIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdGlmICgoY3VycmVuY3lEaWdpdHMpXG5cdFx0XHRcdC5tYXRjaCgvXigoXFxkezEsM30oLFxcZHszfSkqKC4oKFxcZHszfSwpKlxcZHsxLDN9KSk/KXwoXFxkKyguXFxkKyk/KSkkLykgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdGN1cnJlbmN5RGlnaXRzID0gY3VycmVuY3lEaWdpdHMucmVwbGFjZSgvLC9nLCBcIlwiKTtcblx0XHRjdXJyZW5jeURpZ2l0cyA9IGN1cnJlbmN5RGlnaXRzLnJlcGxhY2UoL14wKy8sIFwiXCIpO1xuXG5cdFx0aWYgKE51bWJlcihjdXJyZW5jeURpZ2l0cykgPiBNQVhJTVVNX05VTUJFUikge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXG5cdFx0cGFydHMgPSBjdXJyZW5jeURpZ2l0cy5zcGxpdChcIi5cIik7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGludGVncmFsID0gcGFydHNbMF07XG5cdFx0XHRkZWNpbWFsID0gcGFydHNbMV07XG5cblx0XHRcdGRlY2ltYWwgPSBkZWNpbWFsLnN1YnN0cigwLCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW50ZWdyYWwgPSBwYXJ0c1swXTtcblx0XHRcdGRlY2ltYWwgPSBcIlwiO1xuXHRcdH1cblxuXHRcdGRpZ2l0cyA9IG5ldyBBcnJheShDTl9aRVJPLCBDTl9PTkUsIENOX1RXTywgQ05fVEhSRUUsIENOX0ZPVVIsIENOX0ZJVkUsXG5cdFx0XHRcdENOX1NJWCwgQ05fU0VWRU4sIENOX0VJR0hULCBDTl9OSU5FKTtcblx0XHRyYWRpY2VzID0gbmV3IEFycmF5KFwiXCIsIENOX1RFTiwgQ05fSFVORFJFRCwgQ05fVEhPVVNBTkQpO1xuXHRcdGJpZ1JhZGljZXMgPSBuZXcgQXJyYXkoXCJcIiwgQ05fVEVOX1RIT1VTQU5ELCBDTl9IVU5EUkVEX01JTExJT04pO1xuXHRcdGRlY2ltYWxzID0gbmV3IEFycmF5KENOX1RFTl9DRU5ULCBDTl9DRU5UKTtcblxuXHRcdG91dHB1dENoYXJhY3RlcnMgPSBcIlwiO1xuXG5cdFx0aWYgKE51bWJlcihpbnRlZ3JhbCkgPiAwKSB7XG5cdFx0XHR6ZXJvQ291bnQgPSAwO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGludGVncmFsLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHAgPSBpbnRlZ3JhbC5sZW5ndGggLSBpIC0gMTtcblx0XHRcdFx0ZCA9IGludGVncmFsLnN1YnN0cihpLCAxKTtcblx0XHRcdFx0cXVvdGllbnQgPSBwIC8gNDtcblx0XHRcdFx0bW9kdWx1cyA9IHAgJSA0O1xuXHRcdFx0XHRpZiAoZCA9PSBcIjBcIikge1xuXHRcdFx0XHRcdHplcm9Db3VudCsrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh6ZXJvQ291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRvdXRwdXRDaGFyYWN0ZXJzICs9IGRpZ2l0c1swXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0emVyb0NvdW50ID0gMDtcblx0XHRcdFx0XHRvdXRwdXRDaGFyYWN0ZXJzICs9IGRpZ2l0c1tOdW1iZXIoZCldICsgcmFkaWNlc1ttb2R1bHVzXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobW9kdWx1cyA9PSAwICYmIHplcm9Db3VudCA8IDQpIHtcblx0XHRcdFx0XHRvdXRwdXRDaGFyYWN0ZXJzICs9IGJpZ1JhZGljZXNbcXVvdGllbnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXRDaGFyYWN0ZXJzICs9IENOX0RPTExBUjtcblx0XHR9XG5cblx0XHRpZiAoZGVjaW1hbCAhPSBcIlwiKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVjaW1hbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkID0gZGVjaW1hbC5zdWJzdHIoaSwgMSk7XG5cdFx0XHRcdGlmIChkICE9IFwiMFwiKSB7XG5cdFx0XHRcdFx0b3V0cHV0Q2hhcmFjdGVycyArPSBkaWdpdHNbTnVtYmVyKGQpXSArIGRlY2ltYWxzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG91dHB1dENoYXJhY3RlcnMgPT0gXCJcIikge1xuXHRcdFx0b3V0cHV0Q2hhcmFjdGVycyA9IENOX1pFUk8gKyBDTl9ET0xMQVI7XG5cdFx0fVxuXHRcdGlmIChkZWNpbWFsID09IFwiXCIpIHtcblx0XHRcdG91dHB1dENoYXJhY3RlcnMgKz0gQ05fSU5URUdFUjtcblx0XHR9XG5cdFx0b3V0cHV0Q2hhcmFjdGVycyA9IENOX1NZTUJPTCArIG91dHB1dENoYXJhY3RlcnM7XG5cdFx0cmV0dXJuIG91dHB1dENoYXJhY3RlcnM7XG5cdH1cblx0LFxuXHQvKipcblx0ICog5YWL6ZqG5a+56LGh44CCXG5cdCAqL1xuXHRjbG9uZU9iamVjdCA6IGZ1bmN0aW9uKG9iaikge1xuXHRcdHZhciBvID0gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDoge307XG5cdFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0b1tpXSA9IHR5cGVvZiBvYmpbaV0gPT09IFwib2JqZWN0XCJcblx0XHRcdFx0XHRcdD8gY2xvbmVPYmplY3Qob2JqW2ldKVxuXHRcdFx0XHRcdFx0OiBvYmpbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvO1xuXHR9LFxuXHRnZXRGaWxlRXh0TmFtZSA6IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XG5cdFx0dmFyIHBvcyA9IGZpbGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKTtcblx0XHRpZiAocG9zID09IC0xKVxuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0cmV0dXJuIGZpbGVOYW1lLnN1YnN0cmluZyhwb3MgKyAxKTtcblx0fSxcblx0Ly8g6L2s5oiQ5Y2D5YiG5L2N44CCXG5cdGNvbWRpZnkgOiBmdW5jdGlvbih2KSB7XG5cdFx0aWYgKHYgJiYgdiAhPSAnJykge1xuXHRcdFx0biA9IHYgKyBcIlwiO1xuXHRcdFx0dmFyIHJlID0gL1xcZHsxLDN9KD89KFxcZHszfSkrJCkvZztcblx0XHRcdHZhciBuMSA9IG4udHJpbSgpLnJlcGxhY2UoL14oXFxkKykoKFxcLlxcZCspPykkLywgZnVuY3Rpb24ocywgczEsIHMyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gczEucmVwbGFjZShyZSwgXCIkJixcIikgKyBzMjtcblx0XHRcdFx0XHR9KTtcblx0XHRcdHJldHVybiBuMTtcblx0XHR9XG5cdFx0cmV0dXJuIHY7XG5cdH0sXG5cdHRvTnVtYmVyIDogZnVuY3Rpb24odikge1xuXHRcdGlmICh2ICYmIHYgIT0gJycpIHtcblx0XHRcdGlmICh2LmluZGV4T2YoJywnKSA9PSAtMSlcblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR2YXIgYXJ5ID0gdi5zcGxpdCgnLCcpO1xuXHRcdFx0dmFyIHZhbCA9IGFyeS5qb2luKFwiXCIpO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cdGdldFBhcmFtcyA6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGxvY1VybCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpO1xuXHRcdHZhciBhcnlQYXJhbXM9bG9jVXJsLnNwbGl0KFwiJlwiKTtcblx0XHR2YXIganNvbj17fTtcblx0XHRmb3IodmFyIGk9MDtpPGFyeVBhcmFtcy5sZW5ndGg7aSsrKXtcblx0XHRcdHZhciBwYWlyPWFyeVBhcmFtc1tpXTtcblx0XHRcdHZhciBhcnlFbnQ9cGFpci5zcGxpdChcIj1cIik7XG5cdFx0XHR2YXIga2V5PWFyeUVudFswXTtcblx0XHRcdHZhciB2YWw9YXJ5RW50WzFdO1xuXHRcdFx0aWYoanNvbltrZXldKXtcblx0XHRcdFx0anNvbltrZXldPWpzb25ba2V5XSArXCIsXCIgKyB2YWw7XG5cdFx0XHR9XG5cdFx0XHRlbHNle1xuXHRcdFx0XHRqc29uW2tleV09dmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ganNvbjtcblx0fSxcblx0Z2V0UGFyYW0gOiBmdW5jdGlvbihuYW1lKXtcblx0XHRcdHZhciBsb2NVcmwgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKTtcblx0XHRcdHZhciBhcnlQYXJhbXM9bG9jVXJsLnNwbGl0KFwiJlwiKTtcblx0XHRcdHZhciBydG49XCJcIjtcblx0XHRcdGZvcih2YXIgaT0wO2k8YXJ5UGFyYW1zLmxlbmd0aDtpKyspe1xuXHRcdFx0XHR2YXIgcGFpcj1hcnlQYXJhbXNbaV07XG5cdFx0XHRcdHZhciBhcnlFbnQ9cGFpci5zcGxpdChcIj1cIik7XG5cdFx0XHRcdHZhciBrZXk9YXJ5RW50WzBdO1xuXHRcdFx0XHR2YXIgdmFsPWFyeUVudFsxXTtcblx0XHRcdFx0aWYoa2V5IT1uYW1lKSBjb250aW51ZTtcblx0XHRcdFx0aWYocnRuPT1cIlwiKXtcblx0XHRcdFx0XHRydG49dmFsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2V7XG5cdFx0XHRcdFx0cnRuKz1cIixcIiArIHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ0bjtcblx0fSxcblx0LyoqXG5cdCAqIEDor7TmmI4g6I635Y+W6K+35rGC5ZON5bqU55qE5pWw5o2uXG5cdCAqIEDlpLHotKUg6buY6K6kdG9hc3Qg5o+Q56S66ZSZ6K+v5L+h5oGvXG5cdCAqIEDmiJDlip8g5LiN5bGV56S65oiQ5Yqf5L+h5oGv6Ieq5bex5aSE55CGXG5cdCAqIEBpc0Zhc3RKc29uIOaYr+WQpuinpuWPkUZhc3RKc29u5qC85byP5YyW77yM6buY6K6kZmFsc2Vcblx0ICovXG5cdGdldFJlc3VsdERhdGEgOiBmdW5jdGlvbihkZWZlcixmbixtc2dUeXBlLGlzRmFzdEpzb24pe1xuXHRcdGRlZmVyLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcblx0XHRcdCQuZ2V0UmVzdWx0KHJlc3VsdCxmbixtc2dUeXBlLG51bGwsbnVsbCxpc0Zhc3RKc29uKTtcblx0XHRcdH0sZnVuY3Rpb24oc3RhdHVzKXtcblx0XHRcdFx0aWYoc3RhdHVzID09ITApe1xuXHRcdFx0XHRcdCQuRGlhbG9nLmFsZXJ0KFwi5Yqg6L295aSx6LSl77yBXCIrc3RhdHVzLDIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cdC8qKlxuXHQgKiBA6K+05piOIOiOt+WPluivt+axguWTjeW6lOeahOe7k+aenOS/oeaBr1xuXHQgKiBA5aSx6LSlIOm7mOiupGFsZXJ0IOaPkOekuumUmeivr+S/oeaBr1xuXHQgKiBA5oiQ5YqfIOm7mOiupGFsZXJ0IOWxleekuuaIkOWKn+S/oeaBr++8jOW5tuehruWumuWQjuWbnuiwg+iwg+eUqOiAhVxuXHQgKiBAaXNGYXN0SnNvbiDmmK/lkKbop6blj5FGYXN0SnNvbuagvOW8j+WMlu+8jOm7mOiupGZhbHNlXG5cdCAqL1xuXHRnZXRSZXN1bHRNc2cgOiBmdW5jdGlvbihkZWZlcixmbixlcnJvckZuLGlzRmFzdEpzb24pe1xuXHRcdGRlZmVyLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcblx0XHRcdFx0JC5nZXRSZXN1bHQocmVzdWx0LGZuLFwiYWxlcnRcIixcImFsZXJ0XCIsZXJyb3JGbixpc0Zhc3RKc29uKTtcblx0XHRcdH0sZnVuY3Rpb24oc3RhdHVzKXtcblx0XHRcdFx0aWYoZXJyb3JGbil7XG5cdFx0XHRcdFx0ZXJyb3JGbihzdGF0dXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuRGlhbG9nLmFsZXJ0KFwi5Yqg6L295aSx6LSl77yBXCIrc3RhdHVzLDIpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cdC8qKlxuXHQgKiDojrflj5bor7fmsYLlk43lupTnmoTnu5Pmnpzkv6Hmga9cblx0ICogQHJlc3VsdCDmnI3liqHlmajov5Tlm57nmoTluLjop4TmlbDmja5cblx0ICogQGZuIOWbnuiwg+WHveaVsFxuXHQgKiBAZXJyTXNnVHlwZSDplJnor6/ml7bnmoTmmL7npLrnsbvlnosgYWxlcnTvvIx0b2FzdO+8iOm7mOiupO+8iVxuXHQgKiBAc3VjTXNnVHlwZSDmiJDlip/ml7bnmoTmmL7npLrnsbvlnosgYWxlcnTvvIjlnKjnoa7lrprlkI7op6blj5Hlm57osINmbu+8ie+8jHRvYXN077yI5LiN6Kem5Y+R5Zue6LCDZm7vvInvvIzkuLrnqbrml7bnm7TmjqXop6blj5Hlm57osINmblxuXHQgKiBAaXNGYXN0SnNvbiDmmK/lkKbop6blj5FGYXN0SnNvbuagvOW8j+WMlu+8jOm7mOiupGZhbHNlXG5cdCAqL1xuXHRnZXRSZXN1bHQgOiBmdW5jdGlvbihyZXN1bHQsZm4sZXJyTXNnVHlwZSxzdWNNc2dUeXBlLGVycm9yRm4saXNGYXN0SnNvbil7XG5cdFx0aWYodHlwZW9mKHJlc3VsdCkgIT09IFwib2JqZWN0XCIpe1xuXHRcdFx0aWYoIXJlc3VsdC5zdGFydFdpdGgoXCJ7XCIpICYmICFyZXN1bHQuc3RhcnRXaXRoKFwiW1wiKSl7XG5cdFx0XHRcdHJlc3VsdCA9IHtcImlzT2tcIjpmYWxzZSxtc2c6XCLmnI3liqHlmajlj43ppojmlbDmja7moLzlvI/lrZjlnKjlvILluLjvvIzml6Dms5Xop6PmnpDlj43ppojnu5PmnpzvvIFcIixcImNhdXNlXCI6cmVzdWx0fVxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHZhciByZXN1bHRcdD0gZXZhbCgnKCcgKyByZXN1bHQgKyAnKScpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihpc0Zhc3RKc29uKXtcblx0XHRcdEZhc3RKc29uLmZvcm1hdChyZXN1bHQpOy8v5aSE55CGanNvbuW+queOr+e0ouW8leeahOmXrumimFxuXHRcdH1cblx0XHRpZighcmVzdWx0LmlzT2spe1xuXHRcdFx0aWYoIWVyck1zZ1R5cGUgfHwgZXJyTXNnVHlwZSA9PT0ndG9hc3QnKXtcblx0XHRcdFx0JC5Ub2FzdC5lcnJvcihyZXN1bHQubXNnKTtcblx0XHRcdH1lbHNlIGlmIChlcnJNc2dUeXBlID09PSAnYWxlcnQnKXtcblx0XHRcdFx0JC5EaWFsb2cuYWxlcnQocmVzdWx0Lm1zZywyKTtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUuZXJyb3IocmVzdWx0KTtcblx0XHRcdGlmKGVycm9yRm4pe2Vycm9yRm4ocmVzdWx0KX07XG5cdFx0XHRyZXR1cm47XG5cdFx0fWVsc2V7XG5cdFx0XHRpZighc3VjTXNnVHlwZSl7Ly/kuI3pnIDopoHku7vkvZXmmL7npLpcblx0XHRcdFx0aWYoZm4pe1xuXHRcdFx0XHRcdGZuKHJlc3VsdC5kYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2UgaWYoc3VjTXNnVHlwZSA9PT0ndG9hc3QnKXtcblx0XHRcdFx0JC5Ub2FzdC5zdWNjZXNzKHJlc3VsdC5tc2cpO1xuXHRcdFx0XHRpZihmbil7XG5cdFx0XHRcdFx0Zm4ocmVzdWx0LmRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZSBpZiAoZXJyTXNnVHlwZSA9PT0gJ2FsZXJ0Jyl7XG5cdFx0XHRcdCQuRGlhbG9nLmFsZXJ0KHJlc3VsdC5tc2csZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZihmbil7XG5cdFx0XHRcdFx0XHRmbihyZXN1bHQuZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0Z2V0UGFnZVNpemU6ZnVuY3Rpb24oKSB7IFxuXHRcdHZhciB3aW5XLCB3aW5IOyBcblx0XHRpZih3aW5kb3cuaW5uZXJIZWlnaHQpIHsvLyBhbGwgZXhjZXB0IElFIFxuXHRcdFx0d2luVyA9IHdpbmRvdy5pbm5lcldpZHRoOyBcblx0XHRcdHdpbkggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7IFxuXHRcdH0gZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHsvLyBJRSA2IFN0cmljdCBNb2RlIFxuXHRcdFx0d2luVyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDsgXG5cdFx0XHR3aW5IID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDsgXG5cdFx0fSBlbHNlIGlmIChkb2N1bWVudC5ib2R5KSB7IC8vIG90aGVyIFxuXHRcdFx0d2luVyA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7IFxuXHRcdFx0d2luSCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyBcblx0XHR9ICAvLyBmb3Igc21hbGwgcGFnZXMgd2l0aCB0b3RhbCBzaXplIGxlc3MgdGhlbiB0aGUgdmlld3BvcnQgIFxuXHRcdHJldHVybiB7d2lkdGg6d2luVywgaGVpZ2h0Ondpbkh9OyBcblx0fVxuXHRcbn0pO1xuXG5cbi8qKlxuICog5Yqf6IO977ya56e76Zmk6aaW5bC+56m65qC8XG4gKi9cblN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5yZXBsYWNlKC8oXlxccyopfChcXHMqJCkvZywgXCJcIik7XG59O1xuLyoqXG4gKiDlip/og70656e76Zmk5bem6L6556m65qC8XG4gKi9cblN0cmluZy5wcm90b3R5cGUubFRyaW0gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucmVwbGFjZSgvKF5cXHMqKS9nLCBcIlwiKTtcbn07XG4vKipcbiAqIOWKn+iDvTrnp7vpmaTlj7PovrnnqbrmoLxcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5yVHJpbSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5yZXBsYWNlKC8oXFxzKiQpL2csIFwiXCIpO1xufTtcbi8qKlxuICog5Yik5pat5paH5Lu25ZCN5piv5ZCm5piv5Zu+54mHXG4gKi9cblN0cmluZy5wcm90b3R5cGUuaXNQaWN0dXJlID0gZnVuY3Rpb24oKXtcbiAgICAvL+WIpOaWreaYr+WQpuaYr+WbvueJhyAtIHN0ckZpbHRlcuW/hemhu+aYr+Wwj+WGmeWIl+S4vlxuICAgIHZhciBzdHJGaWx0ZXI9XCIuanBlZ3wuZ2lmfC5qcGd8LnBuZ3wuYm1wfC5waWN8XCJcbiAgICBpZih0aGlzLmluZGV4T2YoXCIuXCIpPi0xKVxuICAgIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgdmFyIHN0clBvc3RmaXg9dGhpcy5zdWJzdHJpbmcocCx0aGlzLmxlbmd0aCkgKyAnfCc7ICAgICAgICBcbiAgICAgICAgc3RyUG9zdGZpeCA9IHN0clBvc3RmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYoc3RyRmlsdGVyLmluZGV4T2Yoc3RyUG9zdGZpeCk+LTEpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9ICAgICAgICBcbiAgICByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgXG59XG4vKipcbiAqIOWOu+mZpOaVsOe7hOS4reeahOmHjeWkjemhuVxuICogQGZ1bmN0aW9uIFttZXRob2RdIOWIpOaWreWvueixoeaYr+WQpuebuOWQjOeahOaWueazlSjlj6/pgInlj4LmlbDvvIzpu5jorqTlrp7njrDmmK/mt7HluqbljLnphY3kuKTkuKrlr7nosaHmmK/lkKbnm7jlkIwp77yM56S65L6L77yaZnVuY3Rpb24oeCx5KXtpZih4LmlkPT09eS5pZClyZXR1cm4gdHJ1ZTt9XG4gKi9cbkFycmF5LnByb3RvdHlwZS51bmlxdWU9ZnVuY3Rpb24obWV0aG9kKXtcblx0aWYoIWFuZ3VsYXIuaXNBcnJheSh0aGlzKSlyZXR1cm4gdGhpcztcblx0dmFyIHNhbWVPYmogPSBtZXRob2QgfHwgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICB2YXIgdGFnID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoIWJbeF0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihhW3hdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0YWcgPSBzYW1lT2JqKGFbeF0sIGJbeF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYVt4XSAhPT0gYlt4XSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuXHRcblx0dmFyIGZsYWcsIHRoYXQgPSB0aGlzLnNsaWNlKDApO1xuXHR0aGlzLmxlbmd0aCA9IDA7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHggPSB0aGF0W2ldO1xuXHQgICAgZmxhZyA9IHRydWU7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICB5ID0gdGhpc1tqXTtcblx0ICAgICAgICBpZiAoc2FtZU9iaih4LCB5KSkge1xuXHQgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChmbGFnKSB0aGlzW3RoaXMubGVuZ3RoXSA9IHg7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiDliKTmlq3nu5PmnZ/mmK/lkKbnm7jnrYlcbiAqIFxuICogQHBhcmFtIHN0clxuICogQHBhcmFtIGlzQ2FzZXNlbnNpdGl2ZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblN0cmluZy5wcm90b3R5cGUuZW5kV2l0aCA9IGZ1bmN0aW9uKHN0ciwgaXNDYXNlc2Vuc2l0aXZlKSB7XG5cdGlmIChzdHIgPT0gbnVsbCB8fCBzdHIgPT0gXCJcIiB8fCB0aGlzLmxlbmd0aCA9PSAwXG5cdFx0XHR8fCBzdHIubGVuZ3RoID4gdGhpcy5sZW5ndGgpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR2YXIgdG1wID0gdGhpcy5zdWJzdHJpbmcodGhpcy5sZW5ndGggLSBzdHIubGVuZ3RoKTtcblx0aWYgKGlzQ2FzZXNlbnNpdGl2ZSA9PSB1bmRlZmluZWQgfHwgaXNDYXNlc2Vuc2l0aXZlKSB7XG5cdFx0cmV0dXJuIHRtcCA9PSBzdHI7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRtcC50b0xvd2VyQ2FzZSgpID09IHN0ci50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cbn07XG5cbi8qKlxuICog5Yik5pat5byA5aeL5piv5ZCm55u4562JXG4gKiBcbiAqIEBwYXJhbSBzdHJcbiAqIEBwYXJhbSBpc0Nhc2VzZW5zaXRpdmVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5TdHJpbmcucHJvdG90eXBlLnN0YXJ0V2l0aCA9IGZ1bmN0aW9uKHN0ciwgaXNDYXNlc2Vuc2l0aXZlKSB7XG5cdGlmIChzdHIgPT0gbnVsbCB8fCBzdHIgPT0gXCJcIiB8fCB0aGlzLmxlbmd0aCA9PSAwXG5cdFx0XHR8fCBzdHIubGVuZ3RoID4gdGhpcy5sZW5ndGgpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR2YXIgdG1wID0gdGhpcy5zdWJzdHIoMCwgc3RyLmxlbmd0aCk7XG5cdGlmIChpc0Nhc2VzZW5zaXRpdmUgPT0gdW5kZWZpbmVkIHx8IGlzQ2FzZXNlbnNpdGl2ZSkge1xuXHRcdHJldHVybiB0bXAgPT0gc3RyO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0bXAudG9Mb3dlckNhc2UoKSA9PSBzdHIudG9Mb3dlckNhc2UoKTtcblx0fVxufTtcblxuLyoqXG4gKiDlr7lodG1s5a2X56ym6L+b6KGM57yW56CBIOeUqOazle+8miBzdHI9c3RyLmh0bWxFbmNvZGUoKTtcbiAqIFxuICogQHJldHVybnNcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5odG1sRW5jb2RlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csXG5cdFx0XHRcIiZndDtcIikucmVwbGFjZSgvXFxcIi9nLCBcIiYjMzQ7XCIpLnJlcGxhY2UoL1xcJy9nLCBcIiYjMzk7XCIpO1xufTtcblxuLyoqXG4gKiDlr7lodG1s5a2X56ym5Liy6Kej56CBIOeUqOazle+8miBzdHI9c3RyLmh0bWxEZWNvZGUoKTtcbiAqIFxuICogQHJldHVybnNcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5odG1sRGVjb2RlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnJlcGxhY2UoL1xcJmFtcFxcOy9nLCAnXFwmJykucmVwbGFjZSgvXFwmZ3RcXDsvZywgJ1xcPicpLnJlcGxhY2UoXG5cdFx0XHQvXFwmbHRcXDsvZywgJ1xcPCcpLnJlcGxhY2UoL1xcJnF1b3RcXDsvZywgJ1xcJycpLnJlcGxhY2UoL1xcJlxcIzM5XFw7L2csXG5cdFx0XHQnXFwnJyk7XG59O1xuXG4vKipcbiAqIOWvuWpzb27kuK3nmoTnibnmrorlrZfnrKbov5vooYzovazkuYlcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5qc29uRXNjYXBlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnJlcGxhY2UoL1xcXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvXFxuL2csIFwiJm51b3Q7XCIpO1xufTtcblxuLyoqXG4gKiDlr7lqc29u5Lit55qE54m55q6K5a2X56ym6L+b6KGM6L2s5LmJXG4gKi9cblN0cmluZy5wcm90b3R5cGUuanNvblVuZXNjYXBlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnJlcGxhY2UoLyZxdW90Oy9nLCBcIlxcXCJcIikucmVwbGFjZSgvJm51b3Q7L2csIFwiXFxuXCIpO1xufTtcblxuLyoqXG4gKiDlrZfnrKbkuLLmm7/mjaJcbiAqIFxuICogQHBhcmFtIHMxXG4gKiAgICAgICAgICAgIOmcgOimgeabv+aNoueahOWtl+esplxuICogQHBhcmFtIHMyXG4gKiAgICAgICAgICAgIOabv+aNoueahOWtl+espuOAglxuICogQHJldHVybnNcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsID0gZnVuY3Rpb24oczEsIHMyKSB7XG5cdHJldHVybiB0aGlzLnJlcGxhY2UobmV3IFJlZ0V4cChzMSwgXCJnbVwiKSwgczIpO1xufTtcblxuLyoqXG4gKiDnp7vpmaTmlbDnu4TkuK3mjIflrprlr7nosaFcbiAqL1xuQXJyYXkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5BcnJheS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG5cdHRoaXMuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIOagvOW8j+WMluWtl+espuS4slxuICogZWc6IHZhciBhYWEgPSBcIm15TmFtZSBpcyB7bmFtZX0gbXkgd2lmZSBuYW1lIGlzIHt3aWZlLm5hbWV9XCIuZm9ybWF0KHtcIm5hbWVcIjpcIuiLl+e7p+aWuVwiLHdpZmU6e25hbWU6XCLmn6DmqqxcIn0pXG4gKiAgICBhbGVydCAoYWFhKTtcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgIHJldHVybiBfc3RyaW5nUmVuZGVyKHRoaXMsIGNvbnRleHQpO1xufTtcblxud2luZG93Ll9zdHJpbmdSZW5kZXIgPSBmdW5jdGlvbih0ZW1wbGF0ZSwgc2NvcGVEYXRhKSB7XG5cdCBcblx0ICB2YXIgdG9rZW5SZWcgPSAvKFxcXFwpP1xceyhbXlxce1xcfVxcXFxdKykoXFxcXCk/XFx9L2c7XG5cdCBcblx0ICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSh0b2tlblJlZywgZnVuY3Rpb24gKHdvcmQsIHNsYXNoMSwgdG9rZW4sIHNsYXNoMikge1xuXHQgICAgaWYgKHNsYXNoMSB8fCBzbGFzaDIpIHsgXG5cdCAgICAgIHJldHVybiB3b3JkLnJlcGxhY2UoJ1xcXFwnLCAnJyk7XG5cdCAgICB9XG5cdCBcblx0ICAgIHZhciB2YXJpYWJsZXMgPSB0b2tlbi5yZXBsYWNlKC9cXHMvZywgJycpLnNwbGl0KCcuJyk7XG5cdCAgICB2YXIgY3VycmVudE9iamVjdCA9IHNjb3BlRGF0YTtcblx0ICAgIHZhciBpLCBsZW5ndGgsIHZhcmlhYmxlO1xuXHQgICAgXG5cdCAgICBmb3IodmFyIGk9MCxrZXk7a2V5PXZhcmlhYmxlc1tpKytdOyl7XG5cdCAgICBcdGN1cnJlbnRPYmplY3QgPSBjdXJyZW50T2JqZWN0W2tleV07XG5cdCAgICBcdGlmIChjdXJyZW50T2JqZWN0ID09PSB1bmRlZmluZWQgfHwgY3VycmVudE9iamVjdCA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXHQgICAgfVxuXHQgICAgXG5cdCAgICByZXR1cm4gY3VycmVudE9iamVjdDtcblx0ICB9KVxufVxuXG5cblxuXG4vKipcbiAqIOaXpeacn+agvOW8j+WMluOAglxuICog5pel5pyf5qC85byP77yaXG4gKiB5eXl577yMeXkg5bm05Lu9XG4gKiBNTSDlpKflhpnooajnpLrmnIjku71cbiAqIGRkIOihqOekuuaXpeacn1xuICogSEgg6KGo56S65bCP5pe2XG4gKiBtbSDooajnpLrliIbpkp9cbiAqIHNzIOihqOekuuenklxuICogcSAg6KGo56S65a2j5bqmXG4gKiDlrp7kvovlpoLkuIvvvJpcbiAqIHZhciBub3cgPSBuZXcgRGF0ZSgpOyBcbiAqIHZhciBub3dTdHIgPSBub3cuZm9ybWF0KFwieXl5eS1NTS1kZCBISDptbTpzc1wiKTsgXG4gKi9cbkRhdGUucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCl7IFxuXHR2YXIgbyA9IHsgXG5cdFx0XCJNK1wiIDogdGhpcy5nZXRNb250aCgpKzEsIC8vbW9udGggXG5cdFx0XCJkK1wiIDogdGhpcy5nZXREYXRlKCksIC8vZGF5IFxuXHRcdFwiSCtcIiA6IHRoaXMuZ2V0SG91cnMoKSwgLy9ob3VyIFxuXHRcdFwibStcIiA6IHRoaXMuZ2V0TWludXRlcygpLCAvL21pbnV0ZSBcblx0XHRcInMrXCIgOiB0aGlzLmdldFNlY29uZHMoKSwgLy9zZWNvbmQgXG5cdFx0XCJxK1wiIDogTWF0aC5mbG9vcigodGhpcy5nZXRNb250aCgpKzMpLzMpLCAvL3F1YXJ0ZXIgXG5cdFx0XCJTXCIgOiB0aGlzLmdldE1pbGxpc2Vjb25kcygpIC8vbWlsbGlzZWNvbmQgXG5cdH0gXG5cdFxuXHRpZigvKHkrKS8udGVzdChmb3JtYXQpKSB7IFxuXHRcdGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFJlZ0V4cC4kMSwgKHRoaXMuZ2V0RnVsbFllYXIoKStcIlwiKS5zdWJzdHIoNCAtIFJlZ0V4cC4kMS5sZW5ndGgpKTsgXG5cdH0gXG5cblx0Zm9yKHZhciBrIGluIG8pIHsgXG5cdFx0aWYobmV3IFJlZ0V4cChcIihcIisgayArXCIpXCIpLnRlc3QoZm9ybWF0KSkgeyBcblx0XHRcdGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFJlZ0V4cC4kMSwgUmVnRXhwLiQxLmxlbmd0aD09MSA/IG9ba10gOiAoXCIwMFwiKyBvW2tdKS5zdWJzdHIoKFwiXCIrIG9ba10pLmxlbmd0aCkpOyBcblx0XHR9IFxuXHR9IFxuXHRyZXR1cm4gZm9ybWF0OyBcbn0gXG5cblxuLyoqXG4gKiDmsYLkuKTkuKrml7bpl7TnmoTlpKnmlbDlt64g5pel5pyf5qC85byP5Li6IHl5eXktTU0tZGQg5oiWIFlZWVktTU0tZGQgSEg6bW06c3NcbiAqL1xuZnVuY3Rpb24gZGF5c0JldHdlZW4oRGF0ZU9uZSwgRGF0ZVR3bykge1xuXHR2YXIgZGF5T25lID0gJyc7XG5cdHZhciBkYXlUd28gPSAnJztcblx0dmFyIHRpbWVPbmUgPSAnJztcblx0dmFyIHRpbWVUd28gPSAnJztcblxuXHRpZiAoRGF0ZU9uZSAhPSBudWxsICYmIERhdGVPbmUgIT0gJycpIHtcblx0XHR2YXIgYXJyT25lID0gRGF0ZU9uZS5zcGxpdCgnICcpO1xuXHRcdGRheU9uZSA9IGFyck9uZVswXTtcblx0XHRpZiAoYXJyT25lLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRpbWVPbmUgPSBhcnJPbmVbMV07XG5cdFx0fVxuXHR9XG5cblx0aWYgKERhdGVUd28gIT0gbnVsbCAmJiBEYXRlVHdvICE9ICcnKSB7XG5cdFx0dmFyIGFyclR3byA9IERhdGVUd28uc3BsaXQoJyAnKTtcblx0XHRkYXlUd28gPSBhcnJUd29bMF07XG5cdFx0aWYgKGFyclR3by5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aW1lVHdvID0gYXJyVHdvWzFdO1xuXHRcdH1cblx0fVxuXG5cdHZhciBPbmVNb250aCA9IDA7XG5cdHZhciBPbmVEYXkgPSAwO1xuXHR2YXIgT25lWWVhciA9IDA7XG5cdGlmIChkYXlPbmUgIT0gbnVsbCAmJiBkYXlPbmUgIT0gJycpIHtcblx0XHR2YXIgYXJyRGF0ZSA9IGRheU9uZS5zcGxpdCgnLScpO1xuXHRcdE9uZVllYXIgPSBwYXJzZUludChhcnJEYXRlWzBdLCAxMCk7XG5cdFx0T25lTW9udGggPSBwYXJzZUludChhcnJEYXRlWzFdLCAxMCk7XG5cdFx0T25lRGF5ID0gcGFyc2VJbnQoYXJyRGF0ZVsyXSwgMTApO1xuXHR9XG5cblx0dmFyIFR3b01vbnRoID0gMDtcblx0dmFyIFR3b0RheSA9IDA7XG5cdHZhciBUd29ZZWFyID0gMDtcblx0aWYgKGRheVR3byAhPSBudWxsICYmIGRheVR3byAhPSAnJykge1xuXHRcdHZhciBhcnJEYXRlID0gZGF5VHdvLnNwbGl0KCctJyk7XG5cdFx0VHdvWWVhciA9IHBhcnNlSW50KGFyckRhdGVbMF0sIDEwKTtcblx0XHRUd29Nb250aCA9IHBhcnNlSW50KGFyckRhdGVbMV0sIDEwKTtcblx0XHRUd29EYXkgPSBwYXJzZUludChhcnJEYXRlWzJdLCAxMCk7XG5cdH1cblxuXHR2YXIgT25lSG91ciA9IDA7XG5cdHZhciBPbmVNaW4gPSAwO1xuXHR2YXIgT25lU2VjID0gMDtcblx0aWYgKHRpbWVPbmUgIT0gbnVsbCAmJiB0aW1lT25lICE9ICcnKSB7XG5cdFx0dmFyIGFyclRpZW0gPSB0aW1lT25lLnNwbGl0KCc6Jyk7XG5cdFx0T25lSG91ciA9IHBhcnNlSW50KGFyclRpZW1bMF0pO1xuXHRcdE9uZU1pbiA9IHBhcnNlSW50KGFyclRpZW1bMV0pO1xuXHRcdE9uZVNlYyA9IHBhcnNlSW50KGFyclRpZW1bMl0pO1xuXHR9XG5cblx0dmFyIFR3b0hvdXIgPSAwO1xuXHR2YXIgVHdvTWluID0gMDtcblx0dmFyIFR3b1NlYyA9IDA7XG5cdGlmICh0aW1lVHdvICE9IG51bGwgJiYgdGltZVR3byAhPSAnJykge1xuXHRcdHZhciBhcnJUaWVtID0gdGltZVR3by5zcGxpdCgnOicpO1xuXHRcdFR3b0hvdXIgPSBwYXJzZUludChhcnJUaWVtWzBdKTtcblx0XHRUd29NaW4gPSBwYXJzZUludChhcnJUaWVtWzFdKTtcblx0XHRUd29TZWMgPSBwYXJzZUludChhcnJUaWVtWzJdKTtcblx0fVxuXG5cdHZhciB2ZmxhZyA9IFR3b1llYXIgPiBPbmVZZWFyID8gdHJ1ZSA6IGZhbHNlO1xuXHRpZiAoIXZmbGFnKSB7XG5cdFx0dmZsYWcgPSBUd29Nb250aCA+IE9uZU1vbnRoID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdGlmICghdmZsYWcpIHtcblx0XHRcdHZmbGFnID0gVHdvRGF5ID4gT25lRGF5ID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdFx0XHRpZiAoIXZmbGFnKSB7XG5cdFx0XHRcdGlmIChPbmVEYXkgPT0gVHdvRGF5KSB7XG5cdFx0XHRcdFx0dmZsYWcgPSBUd29Ib3VyID4gT25lSG91ciA/IHRydWUgOiBmYWxzZTtcblx0XHRcdFx0XHRpZiAoIXZmbGFnKSB7XG5cdFx0XHRcdFx0XHR2ZmxhZyA9IFR3b01pbiA+IE9uZU1pbiA/IHRydWUgOiBmYWxzZTtcblx0XHRcdFx0XHRcdGlmICghdmZsYWcpIHtcblx0XHRcdFx0XHRcdFx0dmZsYWcgPSBUd29TZWMgPj0gT25lU2VjID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2ZmxhZztcbn07XG5cbi8vIOemgeeUqOWIt+aWsOOAgumAmui/h+S8oOWFpea1j+iniOWZqOexu+WeiyDmnaXmjIflrprnpoHnlKjmn5DkuKrmtY/op4jlmajnmoTliLfmlrBcbmZ1bmN0aW9uIGZvcmJpZEY1KGV4cCkge1xuXHR2YXIgY3VycmVudEV4cGxvcmVyID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cdC8vIGllIFwiTVNJRVwiICwsIGZpcmVmb3ggXCJGaXJlZm94XCIgLCxDaHJvbWUgXCJDaHJvbWVcIiwsT3BlcmEgXCJPcGVyYVwiLCxTYWZhcmlcblx0Ly8gXCJTYWZhcmlcIlxuXHRpZiAoY3VycmVudEV4cGxvcmVyLmluZGV4T2YoZXhwKSA+PSAwKSB7XG5cdFx0ZG9jdW1lbnQub25rZXlkb3duID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGV2ID0gd2luZG93LmV2ZW50IHx8IGU7XG5cdFx0XHR2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XG5cdFx0XHRpZiAoY29kZSA9PSAxMTYpIHtcblx0XHRcdFx0ZXYua2V5Q29kZSA/IGV2LmtleUNvZGUgPSAwIDogZXYud2hpY2ggPSAwO1xuXHRcdFx0XHRjYW5jZWxCdWJibGUgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufVxuXG4vL+S6p+eUn+maj+acuuaVsFxud2luZG93LkdldFJhbmRvbU51bSA9IGZ1bmN0aW9uKE1pbiwgTWF4KSB7XG5cdHZhciBSYW5nZSA9IE1heCAtIE1pbjtcblx0dmFyIFJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuXHRyZXR1cm4gKE1pbiArIE1hdGgucm91bmQoUmFuZCAqIFJhbmdlKSk7XG59XG4vL+S6p+eUn+maj+acuuWtl+espuS4slxud2luZG93LkdldFJhbmRvbVN0ciA9IGZ1bmN0aW9uKGxlbikge1xu44CA44CAbGVuID0gbGVuIHx8IDMyO1xu44CA44CAdmFyICRjaGFycyA9ICdBQkNERUZHSEpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmaGlqa2xtbm9wcnN0dXZ3eHl6JztcbuOAgOOAgHZhciBtYXhQb3MgPSAkY2hhcnMubGVuZ3RoO1xu44CA44CAdmFyIHB3ZCA9ICcnO1xu44CA44CAZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xu44CA44CA44CA44CAcHdkICs9ICRjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4UG9zKSk7XG7jgIDjgIB9XG7jgIDjgIByZXR1cm4gcHdkO1xufVxuXG52YXIgSnNvblV0aWwgPSB7XG5cdC8v5a6a5LmJ5o2i6KGM56ymXG5cdG4gOiBcIlxcblwiLFxuXHQvL+WumuS5ieWItuihqOesplxuXHR0IDogXCJcXHRcIixcblx0Ly/ovazmjaJTdHJpbmdcblx0Y29udmVydFRvU3RyaW5nIDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0cmV0dXJuIEpzb25VdGlsLl9fd3JpdGVPYmoob2JqLCAxKTtcblx0fSxcblx0Ly/lhpnlr7nosaFcblx0X193cml0ZU9iaiA6IGZ1bmN0aW9uKG9iaiAvL+WvueixoVxuXHRcdFx0LCBsZXZlbCAvL+Wxguasoe+8iOWfuuaVsOS4ujHvvIlcblx0XHRcdCwgaXNJbkFycmF5KSB7IC8v5q2k5a+56LGh5piv5ZCm5Zyo5LiA5Liq6ZuG5ZCI5YaFXG5cdFx0Ly/lpoLmnpzkuLrnqbrvvIznm7TmjqXovpPlh7pudWxsXG5cdFx0aWYgKG9iaiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gXCJudWxsXCI7XG5cdFx0fVxuXHRcdC8v5Li65pmu6YCa57G75Z6L77yM55u05o6l6L6T5Ye65YC8XG5cdFx0aWYgKG9iai5jb25zdHJ1Y3RvciA9PSBOdW1iZXIgfHwgb2JqLmNvbnN0cnVjdG9yID09IERhdGVcblx0XHRcdFx0fHwgb2JqLmNvbnN0cnVjdG9yID09IFN0cmluZyB8fCBvYmouY29uc3RydWN0b3IgPT0gQm9vbGVhbikge1xuXHRcdFx0dmFyIHYgPSBvYmoudG9TdHJpbmcoKTtcblx0XHRcdHZhciB0YWIgPSBpc0luQXJyYXlcblx0XHRcdFx0XHQ/IEpzb25VdGlsLl9fcmVwZWF0U3RyKEpzb25VdGlsLnQsIGxldmVsIC0gMSlcblx0XHRcdFx0XHQ6IFwiXCI7XG5cdFx0XHRpZiAob2JqLmNvbnN0cnVjdG9yID09IFN0cmluZyB8fCBvYmouY29uc3RydWN0b3IgPT0gRGF0ZSkge1xuXHRcdFx0XHQvL+aXtumXtOagvOW8j+WMluWPquaYr+WNlee6r+i+k+WHuuWtl+espuS4su+8jOiAjOS4jeaYr0RhdGXlr7nosaFcblx0XHRcdFx0cmV0dXJuIHRhYiArIChcIlxcXCJcIiArIHYgKyBcIlxcXCJcIik7XG5cdFx0XHR9IGVsc2UgaWYgKG9iai5jb25zdHJ1Y3RvciA9PSBCb29sZWFuKSB7XG5cdFx0XHRcdHJldHVybiB0YWIgKyB2LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGFiICsgKHYpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8v5YaZSnNvbuWvueixoe+8jOe8k+WtmOWtl+espuS4slxuXHRcdHZhciBjdXJyZW50T2JqU3RyaW5ncyA9IFtdO1xuXHRcdC8v6YGN5Y6G5bGe5oCnXG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdHZhciB0ZW1wID0gW107XG5cdFx0XHQvL+agvOW8j+WMllRhYlxuXHRcdFx0dmFyIHBhZGRpbmdUYWIgPSBKc29uVXRpbC5fX3JlcGVhdFN0cihKc29uVXRpbC50LCBsZXZlbCk7XG5cdFx0XHR0ZW1wLnB1c2gocGFkZGluZ1RhYik7XG5cdFx0XHQvL+WGmeWHuuWxnuaAp+WQjVxuXHRcdFx0dGVtcC5wdXNoKG5hbWUgKyBcIiA6IFwiKTtcblxuXHRcdFx0dmFyIHZhbCA9IG9ialtuYW1lXTtcblx0XHRcdGlmICh2YWwgPT0gbnVsbCkge1xuXHRcdFx0XHR0ZW1wLnB1c2goXCJudWxsXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGMgPSB2YWwuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGMgPT0gQXJyYXkpIHsgLy/lpoLmnpzkuLrpm4blkIjvvIzlvqrnjq/lhoXpg6jlr7nosaFcblx0XHRcdFx0XHR0ZW1wLnB1c2goSnNvblV0aWwubiArIHBhZGRpbmdUYWIgKyBcIltcIiArIEpzb25VdGlsLm4pO1xuXHRcdFx0XHRcdHZhciBsZXZlbFVwID0gbGV2ZWwgKyAyOyAvL+Wxgue6pysyXG5cblx0XHRcdFx0XHR2YXIgdGVtcEFyclZhbHVlID0gW107IC8v6ZuG5ZCI5YWD57Sg55u45YWz5a2X56ym5Liy57yT5a2Y54mH5q61XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdC8v6YCS5b2S5YaZ5a+56LGhICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHRcdFx0XHRcdFx0dGVtcEFyclZhbHVlLnB1c2goSnNvblV0aWwuX193cml0ZU9iaih2YWxbaV0sIGxldmVsVXAsXG5cdFx0XHRcdFx0XHRcdFx0dHJ1ZSkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRlbXAucHVzaCh0ZW1wQXJyVmFsdWUuam9pbihcIixcIiArIEpzb25VdGlsLm4pKTtcblx0XHRcdFx0XHR0ZW1wLnB1c2goSnNvblV0aWwubiArIHBhZGRpbmdUYWIgKyBcIl1cIik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PSBGdW5jdGlvbikge1xuXHRcdFx0XHRcdHRlbXAucHVzaCh2YWwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8v6YCS5b2S5YaZ5a+56LGhXG5cdFx0XHRcdFx0dGVtcC5wdXNoKEpzb25VdGlsLl9fd3JpdGVPYmoodmFsLCBsZXZlbCArIDEpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly/liqDlhaXlvZPliY3lr7nosaHigJzlsZ7mgKfigJ3lrZfnrKbkuLJcblx0XHRcdGN1cnJlbnRPYmpTdHJpbmdzLnB1c2godGVtcC5qb2luKFwiXCIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIChsZXZlbCA+IDEgJiYgIWlzSW5BcnJheSA/IEpzb25VdGlsLm4gOiBcIlwiKSAvL+WmguaenEpzb27lr7nosaHmmK/lhoXpg6jvvIzlsLHopoHmjaLooYzmoLzlvI/ljJZcblx0XHRcdFx0KyBKc29uVXRpbC5fX3JlcGVhdFN0cihKc29uVXRpbC50LCBsZXZlbCAtIDEpICsgXCJ7XCIgKyBKc29uVXRpbC5uIC8v5Yqg5bGC5qyhVGFi5qC85byP5YyWXG5cdFx0XHRcdCsgY3VycmVudE9ialN0cmluZ3Muam9pbihcIixcIiArIEpzb25VdGlsLm4pIC8v5Liy6IGU5omA5pyJ5bGe5oCn5YC8XG5cdFx0XHRcdCsgSnNvblV0aWwubiArIEpzb25VdGlsLl9fcmVwZWF0U3RyKEpzb25VdGlsLnQsIGxldmVsIC0gMSkgKyBcIn1cIjsgLy/lsIHpl63lr7nosaFcblx0fSxcblx0X19pc0FycmF5IDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0cmV0dXJuIG9iai5jb25zdHJ1Y3RvciA9PSBBcnJheTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRfX3JlcGVhdFN0ciA6IGZ1bmN0aW9uKHN0ciwgdGltZXMpIHtcblx0XHR2YXIgbmV3U3RyID0gW107XG5cdFx0aWYgKHRpbWVzID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lczsgaSsrKSB7XG5cdFx0XHRcdG5ld1N0ci5wdXNoKHN0cik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXdTdHIuam9pbihcIlwiKTtcblx0fVxufTtcblxuLyoqXG4gKiDlsIblrZfnrKbkuLLovazkuLpqc29u5a+56LGh44CCXG4gKiBAcGFyYW0ganNvblN0clxuICogQHBhcmFtIHR5cGUgIOWPr+S4jeWhq+WGmVxuICogQHJldHVybnNcbiAqL1xud2luZG93LnBhcnNlVG9Kc29uID0gZnVuY3Rpb24oanNvblN0cil7XG5cdGlmKGpzb25TdHIgPT09IFwiXCIpIHJldHVybiA7XG5cdHJldHVybiBldmFsKFwiKFwiK2pzb25TdHIrXCIpXCIpO1xufVxuXG53aW5kb3cuQ2FjaGVVdGlsPXt9O1xuLyoqXG4gKiDorr7nva7nvJPlrZjjgIJcbiAqL1xuQ2FjaGVVdGlsLnNldD1mdW5jdGlvbihrZXksdmFsdWUpe1xuXHRsb2NhbFN0b3JhZ2Vba2V5XT12YWx1ZTtcbn1cblxuLyoqXG4gKiDojrflj5bnvJPlrZhcbiAqL1xuQ2FjaGVVdGlsLmdldD1mdW5jdGlvbihrZXkpe1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlW2tleV07XG59XG5cbi8qKlxuICog5Yig6Zmk57yT5a2YXG4gKi9cbkNhY2hlVXRpbC5jbGVhbj1mdW5jdGlvbihrZXkpe1xuXHRsb2NhbFN0b3JhZ2Uucm1TdG9yYWdlKGtleSk7XG59XG5cbi8qKlxuICog6K6+572u57yT5a2Y77yMdmFsdWUg5Li6SlNPTuWvueixoeOAglxuICovXG5DYWNoZVV0aWwuc2V0SlNPTj1mdW5jdGlvbihrZXksdmFsdWUpe1xuXHR2YXIganNvbj1KU09OLnN0cmluZ2lmeSh2YWx1ZSlcblx0bG9jYWxTdG9yYWdlW2tleV09anNvbjtcbn1cblxuLyoqXG4gKiDmoLnmja7plK7ojrflj5Zqc29u5a+56LGh44CCXG4gKi9cbkNhY2hlVXRpbC5nZXRKU09OPWZ1bmN0aW9uKGtleSl7XG5cdHZhciBqc29uPWxvY2FsU3RvcmFnZVtrZXldO1xuXHRpZihqc29uPT11bmRlZmluZWQpIHJldHVybiBudWxsO1xuXHRyZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbn1cblxuXG53aW5kb3cuQ2xvbmVVdGlsID0ge1xuXHRcdC8qKlxuXHRcdCAqIOa3seWkjeWItuOAkOWPr+S7pei/reS7o+OAkVxuXHRcdCAqL1xuXHRcdGRlZXA6ZnVuY3Rpb24ob2JqKXtcblx0XHRcdHJldHVybiBqUXVlcnkuZXh0ZW5kKHRydWUse30sIG9iaik7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiDmtYXlpI3liLbjgJDkuI3og73ov63ku6PjgJFcblx0XHQgKi9cblx0XHRzaGFsbG93OmZ1bmN0aW9uKG9iail7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV4dGVuZCh7fSwgb2JqKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIOaVsOe7hOWkjeWItlxuXHRcdCAqL1xuXHRcdGxpc3Q6ZnVuY3Rpb24ob2JqKXtcblx0XHRcdHJldHVybiAkLm1hcChvYmosIGZ1bmN0aW9uIChuKSB7IHJldHVybiBuOyB9KTtcblx0XHR9XG59XG5cbi8qKlxuICog6YGN5Y6G5qCR5bel5YW3XG4gKi9cbndpbmRvdy5UcmF2ZXJzZVRyZWVVdGlsID0ge1xuXHQvKipcblx0ICog6YGN5Y6G5qCRIG5vZGXvvJrot5/oioLngrkgbm9kZUF0dHJOYW1lOuWtkOiKgueCueeahOWxnuaAp+WQjeWtl1xuXHQgKiBlZzpUcmF2ZXJzZVRyZWVVdGlsLnRyYXZlcnNlKHJlbGF0aW9uLFwiY2hpbGRyZW5cIixmdW5jdGlvbihub2RlKXtcblx0ICogXHRcdCRzY29wZS5hbGxSZWxhdGlvbnMucHVzaChub2RlKTsgXG5cdCAqIH0pO1xuXHQgKiBcblx0ICovXG5cdHRyYXZlcnNlOmZ1bmN0aW9uKG5vZGUsbm9kZUF0dHJOYW1lLGNhbGxiYWNrKXtcblx0ICAgIGlmICghbm9kZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8v5aSE55CG5Zue6LCDXG5cdCAgICBjYWxsYmFjayhub2RlKTtcblx0ICAgIFxuXHQgICAgLy/pgJLlvZJcblx0ICAgIGlmIChub2RlW25vZGVBdHRyTmFtZV0gJiYgbm9kZVtub2RlQXR0ck5hbWVdLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVbbm9kZUF0dHJOYW1lXS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIFx0VHJhdmVyc2VUcmVlVXRpbC50cmF2ZXJzZShub2RlW25vZGVBdHRyTmFtZV1baV0sbm9kZUF0dHJOYW1lLGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9qcy9jb21tb24vdG9vbHMvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n')},function(module,exports){eval('/*!\n * Bootstrap v3.3.6 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under the MIT license\n */\nif("undefined"==typeof jQuery)throw new Error("Bootstrap\'s JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1||b[0]>2)throw new Error("Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c=\'[data-dismiss="alert"]\',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.6",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.6",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest(\'[data-toggle="buttons"]\');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")?(c.prop("checked")&&(a=!1),b.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==c.prop("type")&&(c.prop("checked")!==this.$element.hasClass("active")&&(a=!1),this.$element.toggleClass("active")),c.prop("checked",this.$element.hasClass("active")),a&&c.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",\'[data-toggle^="button"]\',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),a(c.target).is(\'input[type="radio"]\')||a(c.target).is(\'input[type="checkbox"]\')||c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",\'[data-toggle^="button"]\',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a(\'[data-ride="carousel"]\').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a(\'[data-toggle="collapse"][href="#\'+b.id+\'"],[data-toggle="collapse"][data-target="#\'+b.id+\'"]\'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.6",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find(\'[data-toggle="collapse"][data-parent="\'+this.options.parent+\'"]\').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",\'[data-toggle="collapse"]\',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass("open")&&(c&&"click"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event("hide.bs.dropdown",f)),c.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger(a.Event("hidden.bs.dropdown",f)))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f=\'[data-toggle="dropdown"]\',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.6",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=b(e),g=f.hasClass("open");if(c(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",c);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger(a.Event("shown.bs.dropdown",h))}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(".disabled, :disabled")){var e=b(d),g=e.hasClass("open");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find(".dropdown-menu"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",c).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",\'[data-dismiss="modal"]\',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in"),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+e).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",\'[data-toggle="modal"]\',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",a,b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:\'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>\',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusin"==b.type?"focus":"hover"]=!0),c.tip().hasClass("in")||"in"==c.hoverState?void(c.hoverState="in"):(clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusout"==b.type?"focus":"hover"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\\s?auto?\\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h="bottom"==h&&k.bottom+m>o.bottom?"top":"top"==h&&k.top-m<o.top?"bottom":"right"==h&&k.right+l>o.width?"left":"left"==h&&k.left-l<o.left?"right":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.6",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:\'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>\'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.6",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+\'[data-target="\'+b+\'"],\'+this.selector+\'[href="\'+b+\'"]\',d=a(c).parents("li").addClass("active");\nd.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a(\'[data-spy="scroll"]\').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find(\'[data-toggle="tab"]\').attr("aria-expanded",!1),b.addClass("active").find(\'[data-toggle="tab"]\').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find(\'[data-toggle="tab"]\').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",\'[data-toggle="tab"]\',e).on("click.bs.tab.data-api",\'[data-toggle="pill"]\',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.6",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a(\'[data-spy="affix"]\').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYm9vdHN0cmFwLm1pbi5qcz82YTNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsYUFBYSxhQUFhLDJDQUEyQyxnS0FBZ0ssc0JBQXNCLGFBQWEsYUFBYSw2Q0FBNkMsNklBQTZJLDZDQUE2QyxVQUFVLFNBQVMsc0NBQXNDLGdCQUFnQix5Q0FBeUMsS0FBSyxFQUFFLGlCQUFpQiwyQ0FBMkMsNEJBQTRCLGNBQWMsaUZBQWlGLDJGQUEyRiw4RUFBOEUsRUFBRSxFQUFFLHNCQUFzQixhQUFhLGNBQWMsNEJBQTRCLG1DQUFtQyxxRUFBcUUsRUFBRSw2Q0FBNkMsK0JBQStCLDBFQUEwRSxhQUFhLCtDQUErQyxzQ0FBc0MsMERBQTBELFdBQVcsa1FBQWtRLGlCQUFpQix1RUFBdUUseUJBQXlCLCtEQUErRCxzQkFBc0IsYUFBYSxjQUFjLDRCQUE0Qiw0REFBNEQsK0VBQStFLEVBQUUsb0JBQW9CLDJDQUEyQyxrQ0FBa0MsOEJBQThCLHlCQUF5QixrQ0FBa0MseUVBQXlFLHNGQUFzRixzS0FBc0ssVUFBVSwrQkFBK0IsNERBQTRELGFBQWEsa0NBQWtDLHNVQUFzVSwrR0FBK0csa0JBQWtCLDBFQUEwRSwwQkFBMEIsaUZBQWlGLGtCQUFrQixnS0FBZ0ssOEZBQThGLDZFQUE2RSxFQUFFLHNCQUFzQixhQUFhLGNBQWMsNEJBQTRCLG1EQUFtRCwyRUFBMkUsMkdBQTJHLEVBQUUsb0JBQW9CLHVkQUF1ZCx3REFBd0QsK0NBQStDLGlDQUFpQyw4Q0FBOEMsZ0JBQWdCLG9CQUFvQixNQUFNLG9CQUFvQixNQUFNLGVBQWUsb0JBQW9CLCtCQUErQiw0TEFBNEwsc0NBQXNDLG1GQUFtRiwrQ0FBK0Msa0ZBQWtGLGtDQUFrQyxnREFBZ0QseUJBQXlCLDRCQUE0QixnRkFBZ0YsdUdBQXVHLFFBQVEsNEVBQTRFLCtCQUErQiw2TUFBNk0sNkJBQTZCLDhDQUE4Qyw2QkFBNkIsOENBQThDLGlDQUFpQyw4SEFBOEgsK0NBQStDLDBDQUEwQyw0QkFBNEIsRUFBRSxxREFBcUQsNERBQTRELHVEQUF1RCwyREFBMkQsd0JBQXdCLGtDQUFrQyw0QkFBNEIsRUFBRSw0SkFBNEosMkhBQTJILHNCQUFzQixJQUFJLDhKQUE4SixvQkFBb0IsZ0ZBQWdGLDZCQUE2QixrQkFBa0IsK0ZBQStGLDJCQUEyQixpQkFBaUIsOENBQThDLG1GQUFtRixrSkFBa0osNENBQTRDLGNBQWMsbUJBQW1CLEVBQUUsRUFBRSxzQkFBc0IsYUFBYSxjQUFjLGtGQUFrRixZQUFZLGNBQWMsNEJBQTRCLG1EQUFtRCw0Q0FBNEMscUhBQXFILEVBQUUsb0JBQW9CLDJDQUEyQyx3U0FBd1Msd0RBQXdELFVBQVUsa0NBQWtDLHNDQUFzQywwQkFBMEIsNkJBQTZCLHVEQUF1RCxtRkFBbUYsaUVBQWlFLGtDQUFrQyxxREFBcUQsOERBQThELHVCQUF1QixpTEFBaUwsaUJBQWlCLHdJQUF3SSw2Q0FBNkMsMENBQTBDLDRIQUE0SCw2QkFBNkIsc0RBQXNELGtDQUFrQyxxREFBcUQsdUJBQXVCLGdPQUFnTyxpQkFBaUIsaUhBQWlILHVKQUF1SiwrQkFBK0IsbURBQW1ELGtDQUFrQyxpSUFBaUksV0FBVyxzQ0FBc0MsY0FBYyxvREFBb0QsdUJBQXVCLGlGQUFpRixvQkFBb0IsZ0ZBQWdGLDRCQUE0QixvRkFBb0YsY0FBYywwQ0FBMEMseURBQXlELFlBQVksRUFBRSxzQkFBc0IsYUFBYSxjQUFjLDRCQUE0QiwrRUFBK0UsY0FBYyxnQ0FBZ0MsY0FBYyxvREFBb0Qsd0JBQXdCLG9CQUFvQixxUkFBcVIsR0FBRyxjQUFjLDRCQUE0QixzQ0FBc0Msd0VBQXdFLEVBQUUsc0VBQXNFLDBDQUEwQyxpREFBaUQsY0FBYyxrQ0FBa0MsZ0NBQWdDLFdBQVcsK0tBQStLLE9BQU8sb0JBQW9CLDRFQUE0RSw4R0FBOEcsVUFBVSxpQ0FBaUMsNkVBQTZFLGNBQWMseUVBQXlFLGdDQUFnQyxxR0FBcUcsa0VBQWtFLGFBQWEsd0JBQXdCLDRGQUE0RixvQkFBb0IsZ0ZBQWdGLDRCQUE0Qiw2R0FBNkcsb0JBQW9CLHlMQUF5TCxzQkFBc0IsYUFBYSxnQkFBZ0IsNEJBQTRCLGdEQUFnRCw0Q0FBNEMsbUZBQW1GLEVBQUUsb0JBQW9CLHVVQUF1VSx5Q0FBeUMsU0FBUywyRkFBMkYsZ0NBQWdDLGdDQUFnQyw2Q0FBNkMsOEJBQThCLHNDQUFzQyxnQkFBZ0IsRUFBRSw0VUFBNFUsc0RBQXNELHVEQUF1RCxFQUFFLDJCQUEyQix3REFBd0QsaUxBQWlMLGdDQUFnQyxnQkFBZ0IsRUFBRSw2Q0FBNkMsdUNBQXVDLHFGQUFxRixHQUFHLDhCQUE4QixvZ0JBQW9nQixxQ0FBcUMsOEVBQThFLGdHQUFnRyxRQUFRLCtCQUErQixvR0FBb0cseUJBQXlCLG9FQUFvRSwrQkFBK0IsOEdBQThHLGtDQUFrQyxXQUFXLDhDQUE4QyxnSEFBZ0gsRUFBRSx1Q0FBdUMsNERBQTRELGtDQUFrQyxzREFBc0Qsd0NBQXdDLDhCQUE4QixvS0FBb0ssMktBQTJLLGlGQUFpRixtR0FBbUcsdUNBQXVDLGlDQUFpQyxpQkFBaUIsMkJBQTJCLHNKQUFzSixZQUFZLHFDQUFxQyxvQkFBb0IscUNBQXFDLDBFQUEwRSxtQkFBbUIsNkhBQTZILEVBQUUseUNBQXlDLG1CQUFtQiwrQkFBK0IsRUFBRSx1Q0FBdUMsd0JBQXdCLE9BQU8sdURBQXVELDJCQUEyQiwrRkFBK0YscUNBQXFDLHNEQUFzRCx3SUFBd0ksdUNBQXVDLHFEQUFxRCx5Q0FBeUMsb0NBQW9DLDJEQUEyRCxrQ0FBa0MsdUNBQXVDLGlCQUFpQix1RUFBdUUseUJBQXlCLDhFQUE4RSxxSUFBcUksdUJBQXVCLG9CQUFvQixnRUFBZ0UsMkRBQTJELHFDQUFxQyxFQUFFLG1CQUFtQixFQUFFLHNCQUFzQixhQUFhLGNBQWMsNEJBQTRCLDZEQUE2RCxtR0FBbUcsRUFBRSxvQkFBb0IseUpBQXlKLHdEQUF3RCx1T0FBdU8sMkJBQTJCLGtDQUFrQyxrUkFBa1IsMkJBQTJCLCtMQUErTCxxREFBcUQsSUFBSSxFQUFFLFdBQVcsbUdBQW1HLHFCQUFxQiw2RUFBNkUsbUtBQW1LLCtDQUErQyxlQUFlLDZCQUE2QixrQkFBa0Isb0NBQW9DLGtCQUFrQixvQ0FBb0Msb0JBQW9CLHlGQUF5RiwwQkFBMEIsSUFBSSwyQ0FBMkMsUUFBUSxzQkFBc0IseURBQXlELGtCQUFrQixJQUFJLCtCQUErQiwrRUFBK0UsMFhBQTBYLDZCQUE2QixrQ0FBa0Msc0NBQXNDLHNEQUFzRCxTQUFTLCtCQUErQiwrRUFBK0Usa1ZBQWtWLDhCQUE4QixrQ0FBa0MsNkJBQTZCLG9DQUFvQyxvQ0FBb0MseUJBQXlCLGtGQUFrRixxQ0FBcUMsaURBQWlELHFIQUFxSCw0SkFBNEosOENBQThDLDZCQUE2QixnTEFBZ0wsZ0VBQWdFLE1BQU0sMkNBQTJDLGlMQUFpTCx3Q0FBd0MseUJBQXlCLGlCQUFpQixtQkFBbUIsK0VBQStFLDZIQUE2SCwwQ0FBMEMsK0hBQStILHFGQUFxRixrQkFBa0IsT0FBTyw4Q0FBOEMsR0FBRyx3QkFBd0IsMkNBQTJDLGtDQUFrQyw2Q0FBNkMsbUNBQW1DLHlGQUF5RiwyQ0FBMkMsMENBQTBDLHVFQUF1RSxtQ0FBbUMsbUNBQW1DLDRHQUE0Ryw4QkFBOEIsYUFBYSw2R0FBNkcsMERBQTBELGtPQUFrTyxpQ0FBaUMsb0JBQW9CLHNJQUFzSSxtQ0FBbUMsdUJBQXVCLHFDQUFxQyxtQkFBbUIsMkRBQTJELDZCQUE2QixJQUFJLDJDQUEyQyxHQUFHLFNBQVMsYUFBYSxlQUFlLG1GQUFtRixNQUFNLGtEQUFrRCxNQUFNLGtCQUFrQixVQUFVLG1EQUFtRCxtQkFBbUIsNkNBQTZDLFdBQVcsc0NBQXNDLFlBQVksdUNBQXVDLEVBQUUsOENBQThDLHdEQUF3RCxPQUFPLGNBQWMsNEJBQTRCLGlHQUFpRyx5QkFBeUIsNENBQTRDLGlFQUFpRSxLQUFLLDRCQUE0Qiw4REFBOEQsU0FBUyxpQ0FBaUMscUNBQXFDLGdHQUFnRyxnQ0FBZ0MsNEJBQTRCLGtDQUFrQyxTQUFTLDRCQUE0QixxS0FBcUssaUJBQWlCLDhCQUE4QixrRUFBa0UsK0JBQStCLGdCQUFnQixnQ0FBZ0MsZ0JBQWdCLHNDQUFzQywyQkFBMkIsZ0NBQWdDLFdBQVcsNFJBQTRSLGdDQUFnQyxXQUFXLGdEQUFnRCx1SEFBdUgsR0FBRyxtQkFBbUIsNkVBQTZFLDRCQUE0QixzQkFBc0IsYUFBYSxjQUFjLDRCQUE0Qiw2REFBNkQsbUdBQW1HLEVBQUUsb0JBQW9CLDBCQUEwQixnRUFBZ0Usd0NBQXdDLG9DQUFvQyw4TEFBOEwseUJBQXlCLGtHQUFrRyxrQkFBa0IsbUNBQW1DLHVEQUF1RCxrU0FBa1MsbUNBQW1DLDBDQUEwQyxtQ0FBbUMsbUNBQW1DLDZGQUE2Riw4QkFBOEIsMkRBQTJELG1CQUFtQiw2RUFBNkUsNEJBQTRCLHNCQUFzQixhQUFhLGdCQUFnQiwyR0FBMkcsd1BBQXdQLGNBQWMsNEJBQTRCLCtEQUErRCxxRUFBcUUsRUFBRSw4QkFBOEIsVUFBVSx3Q0FBd0MsdUhBQXVILGdDQUFnQywwQkFBMEIsNE1BQTRNLHVFQUF1RSwrREFBK0QscUJBQXFCLGlCQUFpQixrQkFBa0IsZ0RBQWdELEVBQUUsZ0NBQWdDLDRMQUE0TCwyRkFBMkYsd0RBQXdELGVBQWUsSUFBSSxvRUFBb0Usa0NBQWtDLGlDQUFpQztBQUMvbytCLHNIQUFzSCw4QkFBOEIsb0ZBQW9GLHFCQUFxQixtRkFBbUYsNkJBQTZCLHNEQUFzRCx5Q0FBeUMsY0FBYyxtQkFBbUIsRUFBRSxFQUFFLHNCQUFzQixhQUFhLGNBQWMsNEJBQTRCLGlDQUFpQyw2REFBNkQsRUFBRSxrQkFBa0IsbUJBQW1CLHdFQUF3RSw0RUFBNEUsaUdBQWlHLHdEQUF3RCxtQkFBbUIsMkJBQTJCLG1CQUFtQixFQUFFLCtFQUErRSxXQUFXLHVFQUF1RSxXQUFXLHdDQUF3QyxhQUFhLHVDQUF1QyxFQUFFLElBQUksc0NBQXNDLGFBQWEsbWFBQW1hLGdIQUFnSCw0R0FBNEcsZUFBZSxpRUFBaUUsd0JBQXdCLGtCQUFrQiwyQ0FBMkMscUhBQXFILHNCQUFzQixhQUFhLGNBQWMsNEJBQTRCLDJEQUEyRCxpRUFBaUUsRUFBRSxvQkFBb0Isd0JBQXdCLGlTQUFpUyxxRUFBcUUsdUJBQXVCLHdDQUF3QyxnRkFBZ0Ysb0RBQW9ELDhGQUE4Riw2Q0FBNkMseURBQXlELHdDQUF3Qyw4Q0FBOEMscURBQXFELHdEQUF3RCxpQ0FBaUMsbURBQW1ELCtDQUErQyxzQ0FBc0MsaUNBQWlDLGlJQUFpSSw2SEFBNkgsNkJBQTZCLG9CQUFvQiw4Q0FBOEMsb0RBQW9ELDBEQUEwRCxtS0FBbUssbUNBQW1DLFVBQVUsSUFBSSxpQkFBaUIsdUVBQXVFLHlCQUF5QixnQ0FBZ0Msd0NBQXdDLHlCQUF5QixxQkFBcUIsa0hBQWtILEVBQUUsRUFBRSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQm9vdHN0cmFwIHYzLjMuNiAoaHR0cDovL2dldGJvb3RzdHJhcC5jb20pXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pZihcInVuZGVmaW5lZFwiPT10eXBlb2YgalF1ZXJ5KXRocm93IG5ldyBFcnJvcihcIkJvb3RzdHJhcCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5XCIpOytmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjt2YXIgYj1hLmZuLmpxdWVyeS5zcGxpdChcIiBcIilbMF0uc3BsaXQoXCIuXCIpO2lmKGJbMF08MiYmYlsxXTw5fHwxPT1iWzBdJiY5PT1iWzFdJiZiWzJdPDF8fGJbMF0+Mil0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeSB2ZXJzaW9uIDEuOS4xIG9yIGhpZ2hlciwgYnV0IGxvd2VyIHRoYW4gdmVyc2lvbiAzXCIpfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJvb3RzdHJhcFwiKSxiPXtXZWJraXRUcmFuc2l0aW9uOlwid2Via2l0VHJhbnNpdGlvbkVuZFwiLE1velRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCIsT1RyYW5zaXRpb246XCJvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZFwiLHRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCJ9O2Zvcih2YXIgYyBpbiBiKWlmKHZvaWQgMCE9PWEuc3R5bGVbY10pcmV0dXJue2VuZDpiW2NdfTtyZXR1cm4hMX1hLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kPWZ1bmN0aW9uKGIpe3ZhciBjPSExLGQ9dGhpczthKHRoaXMpLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Yz0hMH0pO3ZhciBlPWZ1bmN0aW9uKCl7Y3x8YShkKS50cmlnZ2VyKGEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCl9O3JldHVybiBzZXRUaW1lb3V0KGUsYiksdGhpc30sYShmdW5jdGlvbigpe2Euc3VwcG9ydC50cmFuc2l0aW9uPWIoKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmKGEuZXZlbnQuc3BlY2lhbC5ic1RyYW5zaXRpb25FbmQ9e2JpbmRUeXBlOmEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxkZWxlZ2F0ZVR5cGU6YS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLGhhbmRsZTpmdW5jdGlvbihiKXtyZXR1cm4gYShiLnRhcmdldCkuaXModGhpcyk/Yi5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dm9pZCAwfX0pfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZT1jLmRhdGEoXCJicy5hbGVydFwiKTtlfHxjLmRhdGEoXCJicy5hbGVydFwiLGU9bmV3IGQodGhpcykpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdLmNhbGwoYyl9KX12YXIgYz0nW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJyxkPWZ1bmN0aW9uKGIpe2EoYikub24oXCJjbGlja1wiLGMsdGhpcy5jbG9zZSl9O2QuVkVSU0lPTj1cIjMuMy42XCIsZC5UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxkLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7Zy5kZXRhY2goKS50cmlnZ2VyKFwiY2xvc2VkLmJzLmFsZXJ0XCIpLnJlbW92ZSgpfXZhciBlPWEodGhpcyksZj1lLmF0dHIoXCJkYXRhLXRhcmdldFwiKTtmfHwoZj1lLmF0dHIoXCJocmVmXCIpLGY9ZiYmZi5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKTt2YXIgZz1hKGYpO2ImJmIucHJldmVudERlZmF1bHQoKSxnLmxlbmd0aHx8KGc9ZS5jbG9zZXN0KFwiLmFsZXJ0XCIpKSxnLnRyaWdnZXIoYj1hLkV2ZW50KFwiY2xvc2UuYnMuYWxlcnRcIikpLGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fChnLnJlbW92ZUNsYXNzKFwiaW5cIiksYS5zdXBwb3J0LnRyYW5zaXRpb24mJmcuaGFzQ2xhc3MoXCJmYWRlXCIpP2cub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYykuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKTpjKCkpfTt2YXIgZT1hLmZuLmFsZXJ0O2EuZm4uYWxlcnQ9YixhLmZuLmFsZXJ0LkNvbnN0cnVjdG9yPWQsYS5mbi5hbGVydC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uYWxlcnQ9ZSx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmFsZXJ0LmRhdGEtYXBpXCIsYyxkLnByb3RvdHlwZS5jbG9zZSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5idXR0b25cIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYiYmYjtlfHxkLmRhdGEoXCJicy5idXR0b25cIixlPW5ldyBjKHRoaXMsZikpLFwidG9nZ2xlXCI9PWI/ZS50b2dnbGUoKTpiJiZlLnNldFN0YXRlKGIpfSl9dmFyIGM9ZnVuY3Rpb24oYixkKXt0aGlzLiRlbGVtZW50PWEoYiksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LGMuREVGQVVMVFMsZCksdGhpcy5pc0xvYWRpbmc9ITF9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5ERUZBVUxUUz17bG9hZGluZ1RleHQ6XCJsb2FkaW5nLi4uXCJ9LGMucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGIpe3ZhciBjPVwiZGlzYWJsZWRcIixkPXRoaXMuJGVsZW1lbnQsZT1kLmlzKFwiaW5wdXRcIik/XCJ2YWxcIjpcImh0bWxcIixmPWQuZGF0YSgpO2IrPVwiVGV4dFwiLG51bGw9PWYucmVzZXRUZXh0JiZkLmRhdGEoXCJyZXNldFRleHRcIixkW2VdKCkpLHNldFRpbWVvdXQoYS5wcm94eShmdW5jdGlvbigpe2RbZV0obnVsbD09ZltiXT90aGlzLm9wdGlvbnNbYl06ZltiXSksXCJsb2FkaW5nVGV4dFwiPT1iPyh0aGlzLmlzTG9hZGluZz0hMCxkLmFkZENsYXNzKGMpLmF0dHIoYyxjKSk6dGhpcy5pc0xvYWRpbmcmJih0aGlzLmlzTG9hZGluZz0hMSxkLnJlbW92ZUNsYXNzKGMpLnJlbW92ZUF0dHIoYykpfSx0aGlzKSwwKX0sYy5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKCl7dmFyIGE9ITAsYj10aGlzLiRlbGVtZW50LmNsb3Nlc3QoJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0nKTtpZihiLmxlbmd0aCl7dmFyIGM9dGhpcy4kZWxlbWVudC5maW5kKFwiaW5wdXRcIik7XCJyYWRpb1wiPT1jLnByb3AoXCJ0eXBlXCIpPyhjLnByb3AoXCJjaGVja2VkXCIpJiYoYT0hMSksYi5maW5kKFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiYWN0aXZlXCIpKTpcImNoZWNrYm94XCI9PWMucHJvcChcInR5cGVcIikmJihjLnByb3AoXCJjaGVja2VkXCIpIT09dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImFjdGl2ZVwiKSYmKGE9ITEpLHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJhY3RpdmVcIikpLGMucHJvcChcImNoZWNrZWRcIix0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiYWN0aXZlXCIpKSxhJiZjLnRyaWdnZXIoXCJjaGFuZ2VcIil9ZWxzZSB0aGlzLiRlbGVtZW50LmF0dHIoXCJhcmlhLXByZXNzZWRcIiwhdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImFjdGl2ZVwiKSksdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyhcImFjdGl2ZVwiKX07dmFyIGQ9YS5mbi5idXR0b247YS5mbi5idXR0b249YixhLmZuLmJ1dHRvbi5Db25zdHJ1Y3Rvcj1jLGEuZm4uYnV0dG9uLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5idXR0b249ZCx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmJ1dHRvbi5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJyxmdW5jdGlvbihjKXt2YXIgZD1hKGMudGFyZ2V0KTtkLmhhc0NsYXNzKFwiYnRuXCIpfHwoZD1kLmNsb3Nlc3QoXCIuYnRuXCIpKSxiLmNhbGwoZCxcInRvZ2dsZVwiKSxhKGMudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cInJhZGlvXCJdJyl8fGEoYy50YXJnZXQpLmlzKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKXx8Yy5wcmV2ZW50RGVmYXVsdCgpfSkub24oXCJmb2N1cy5icy5idXR0b24uZGF0YS1hcGkgYmx1ci5icy5idXR0b24uZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsZnVuY3Rpb24oYil7YShiLnRhcmdldCkuY2xvc2VzdChcIi5idG5cIikudG9nZ2xlQ2xhc3MoXCJmb2N1c1wiLC9eZm9jdXMoaW4pPyQvLnRlc3QoYi50eXBlKSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLmNhcm91c2VsXCIpLGY9YS5leHRlbmQoe30sYy5ERUZBVUxUUyxkLmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgYiYmYiksZz1cInN0cmluZ1wiPT10eXBlb2YgYj9iOmYuc2xpZGU7ZXx8ZC5kYXRhKFwiYnMuY2Fyb3VzZWxcIixlPW5ldyBjKHRoaXMsZikpLFwibnVtYmVyXCI9PXR5cGVvZiBiP2UudG8oYik6Zz9lW2ddKCk6Zi5pbnRlcnZhbCYmZS5wYXVzZSgpLmN5Y2xlKCl9KX12YXIgYz1mdW5jdGlvbihiLGMpe3RoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLiRpbmRpY2F0b3JzPXRoaXMuJGVsZW1lbnQuZmluZChcIi5jYXJvdXNlbC1pbmRpY2F0b3JzXCIpLHRoaXMub3B0aW9ucz1jLHRoaXMucGF1c2VkPW51bGwsdGhpcy5zbGlkaW5nPW51bGwsdGhpcy5pbnRlcnZhbD1udWxsLHRoaXMuJGFjdGl2ZT1udWxsLHRoaXMuJGl0ZW1zPW51bGwsdGhpcy5vcHRpb25zLmtleWJvYXJkJiZ0aGlzLiRlbGVtZW50Lm9uKFwia2V5ZG93bi5icy5jYXJvdXNlbFwiLGEucHJveHkodGhpcy5rZXlkb3duLHRoaXMpKSxcImhvdmVyXCI9PXRoaXMub3B0aW9ucy5wYXVzZSYmIShcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSYmdGhpcy4kZWxlbWVudC5vbihcIm1vdXNlZW50ZXIuYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMucGF1c2UsdGhpcykpLm9uKFwibW91c2VsZWF2ZS5icy5jYXJvdXNlbFwiLGEucHJveHkodGhpcy5jeWNsZSx0aGlzKSl9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTYwMCxjLkRFRkFVTFRTPXtpbnRlcnZhbDo1ZTMscGF1c2U6XCJob3ZlclwiLHdyYXA6ITAsa2V5Ym9hcmQ6ITB9LGMucHJvdG90eXBlLmtleWRvd249ZnVuY3Rpb24oYSl7aWYoIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoYS50YXJnZXQudGFnTmFtZSkpe3N3aXRjaChhLndoaWNoKXtjYXNlIDM3OnRoaXMucHJldigpO2JyZWFrO2Nhc2UgMzk6dGhpcy5uZXh0KCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm59YS5wcmV2ZW50RGVmYXVsdCgpfX0sYy5wcm90b3R5cGUuY3ljbGU9ZnVuY3Rpb24oYil7cmV0dXJuIGJ8fCh0aGlzLnBhdXNlZD0hMSksdGhpcy5pbnRlcnZhbCYmY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKSx0aGlzLm9wdGlvbnMuaW50ZXJ2YWwmJiF0aGlzLnBhdXNlZCYmKHRoaXMuaW50ZXJ2YWw9c2V0SW50ZXJ2YWwoYS5wcm94eSh0aGlzLm5leHQsdGhpcyksdGhpcy5vcHRpb25zLmludGVydmFsKSksdGhpc30sYy5wcm90b3R5cGUuZ2V0SXRlbUluZGV4PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLiRpdGVtcz1hLnBhcmVudCgpLmNoaWxkcmVuKFwiLml0ZW1cIiksdGhpcy4kaXRlbXMuaW5kZXgoYXx8dGhpcy4kYWN0aXZlKX0sYy5wcm90b3R5cGUuZ2V0SXRlbUZvckRpcmVjdGlvbj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0SXRlbUluZGV4KGIpLGQ9XCJwcmV2XCI9PWEmJjA9PT1jfHxcIm5leHRcIj09YSYmYz09dGhpcy4kaXRlbXMubGVuZ3RoLTE7aWYoZCYmIXRoaXMub3B0aW9ucy53cmFwKXJldHVybiBiO3ZhciBlPVwicHJldlwiPT1hPy0xOjEsZj0oYytlKSV0aGlzLiRpdGVtcy5sZW5ndGg7cmV0dXJuIHRoaXMuJGl0ZW1zLmVxKGYpfSxjLnByb3RvdHlwZS50bz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9dGhpcy5nZXRJdGVtSW5kZXgodGhpcy4kYWN0aXZlPXRoaXMuJGVsZW1lbnQuZmluZChcIi5pdGVtLmFjdGl2ZVwiKSk7cmV0dXJuIGE+dGhpcy4kaXRlbXMubGVuZ3RoLTF8fDA+YT92b2lkIDA6dGhpcy5zbGlkaW5nP3RoaXMuJGVsZW1lbnQub25lKFwic2xpZC5icy5jYXJvdXNlbFwiLGZ1bmN0aW9uKCl7Yi50byhhKX0pOmM9PWE/dGhpcy5wYXVzZSgpLmN5Y2xlKCk6dGhpcy5zbGlkZShhPmM/XCJuZXh0XCI6XCJwcmV2XCIsdGhpcy4kaXRlbXMuZXEoYSkpfSxjLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbihiKXtyZXR1cm4gYnx8KHRoaXMucGF1c2VkPSEwKSx0aGlzLiRlbGVtZW50LmZpbmQoXCIubmV4dCwgLnByZXZcIikubGVuZ3RoJiZhLnN1cHBvcnQudHJhbnNpdGlvbiYmKHRoaXMuJGVsZW1lbnQudHJpZ2dlcihhLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpLHRoaXMuY3ljbGUoITApKSx0aGlzLmludGVydmFsPWNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCksdGhpc30sYy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWRpbmc/dm9pZCAwOnRoaXMuc2xpZGUoXCJuZXh0XCIpfSxjLnByb3RvdHlwZS5wcmV2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpZGluZz92b2lkIDA6dGhpcy5zbGlkZShcInByZXZcIil9LGMucHJvdG90eXBlLnNsaWRlPWZ1bmN0aW9uKGIsZCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFwiLml0ZW0uYWN0aXZlXCIpLGY9ZHx8dGhpcy5nZXRJdGVtRm9yRGlyZWN0aW9uKGIsZSksZz10aGlzLmludGVydmFsLGg9XCJuZXh0XCI9PWI/XCJsZWZ0XCI6XCJyaWdodFwiLGk9dGhpcztpZihmLmhhc0NsYXNzKFwiYWN0aXZlXCIpKXJldHVybiB0aGlzLnNsaWRpbmc9ITE7dmFyIGo9ZlswXSxrPWEuRXZlbnQoXCJzbGlkZS5icy5jYXJvdXNlbFwiLHtyZWxhdGVkVGFyZ2V0OmosZGlyZWN0aW9uOmh9KTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoayksIWsuaXNEZWZhdWx0UHJldmVudGVkKCkpe2lmKHRoaXMuc2xpZGluZz0hMCxnJiZ0aGlzLnBhdXNlKCksdGhpcy4kaW5kaWNhdG9ycy5sZW5ndGgpe3RoaXMuJGluZGljYXRvcnMuZmluZChcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7dmFyIGw9YSh0aGlzLiRpbmRpY2F0b3JzLmNoaWxkcmVuKClbdGhpcy5nZXRJdGVtSW5kZXgoZildKTtsJiZsLmFkZENsYXNzKFwiYWN0aXZlXCIpfXZhciBtPWEuRXZlbnQoXCJzbGlkLmJzLmNhcm91c2VsXCIse3JlbGF0ZWRUYXJnZXQ6aixkaXJlY3Rpb246aH0pO3JldHVybiBhLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcInNsaWRlXCIpPyhmLmFkZENsYXNzKGIpLGZbMF0ub2Zmc2V0V2lkdGgsZS5hZGRDbGFzcyhoKSxmLmFkZENsYXNzKGgpLGUub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZnVuY3Rpb24oKXtmLnJlbW92ZUNsYXNzKFtiLGhdLmpvaW4oXCIgXCIpKS5hZGRDbGFzcyhcImFjdGl2ZVwiKSxlLnJlbW92ZUNsYXNzKFtcImFjdGl2ZVwiLGhdLmpvaW4oXCIgXCIpKSxpLnNsaWRpbmc9ITEsc2V0VGltZW91dChmdW5jdGlvbigpe2kuJGVsZW1lbnQudHJpZ2dlcihtKX0sMCl9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pKTooZS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKSxmLmFkZENsYXNzKFwiYWN0aXZlXCIpLHRoaXMuc2xpZGluZz0hMSx0aGlzLiRlbGVtZW50LnRyaWdnZXIobSkpLGcmJnRoaXMuY3ljbGUoKSx0aGlzfX07dmFyIGQ9YS5mbi5jYXJvdXNlbDthLmZuLmNhcm91c2VsPWIsYS5mbi5jYXJvdXNlbC5Db25zdHJ1Y3Rvcj1jLGEuZm4uY2Fyb3VzZWwubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmNhcm91c2VsPWQsdGhpc307dmFyIGU9ZnVuY3Rpb24oYyl7dmFyIGQsZT1hKHRoaXMpLGY9YShlLmF0dHIoXCJkYXRhLXRhcmdldFwiKXx8KGQ9ZS5hdHRyKFwiaHJlZlwiKSkmJmQucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLyxcIlwiKSk7aWYoZi5oYXNDbGFzcyhcImNhcm91c2VsXCIpKXt2YXIgZz1hLmV4dGVuZCh7fSxmLmRhdGEoKSxlLmRhdGEoKSksaD1lLmF0dHIoXCJkYXRhLXNsaWRlLXRvXCIpO2gmJihnLmludGVydmFsPSExKSxiLmNhbGwoZixnKSxoJiZmLmRhdGEoXCJicy5jYXJvdXNlbFwiKS50byhoKSxjLnByZXZlbnREZWZhdWx0KCl9fTthKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpXCIsXCJbZGF0YS1zbGlkZV1cIixlKS5vbihcImNsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpXCIsXCJbZGF0YS1zbGlkZS10b11cIixlKSxhKHdpbmRvdykub24oXCJsb2FkXCIsZnVuY3Rpb24oKXthKCdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKTtiLmNhbGwoYyxjLmRhdGEoKSl9KX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3ZhciBjLGQ9Yi5hdHRyKFwiZGF0YS10YXJnZXRcIil8fChjPWIuYXR0cihcImhyZWZcIikpJiZjLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIik7cmV0dXJuIGEoZCl9ZnVuY3Rpb24gYyhiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxlPWMuZGF0YShcImJzLmNvbGxhcHNlXCIpLGY9YS5leHRlbmQoe30sZC5ERUZBVUxUUyxjLmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgYiYmYik7IWUmJmYudG9nZ2xlJiYvc2hvd3xoaWRlLy50ZXN0KGIpJiYoZi50b2dnbGU9ITEpLGV8fGMuZGF0YShcImJzLmNvbGxhcHNlXCIsZT1uZXcgZCh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGQ9ZnVuY3Rpb24oYixjKXt0aGlzLiRlbGVtZW50PWEoYiksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LGQuREVGQVVMVFMsYyksdGhpcy4kdHJpZ2dlcj1hKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIycrYi5pZCsnXCJdLFtkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtdGFyZ2V0PVwiIycrYi5pZCsnXCJdJyksdGhpcy50cmFuc2l0aW9uaW5nPW51bGwsdGhpcy5vcHRpb25zLnBhcmVudD90aGlzLiRwYXJlbnQ9dGhpcy5nZXRQYXJlbnQoKTp0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLiRlbGVtZW50LHRoaXMuJHRyaWdnZXIpLHRoaXMub3B0aW9ucy50b2dnbGUmJnRoaXMudG9nZ2xlKCl9O2QuVkVSU0lPTj1cIjMuMy42XCIsZC5UUkFOU0lUSU9OX0RVUkFUSU9OPTM1MCxkLkRFRkFVTFRTPXt0b2dnbGU6ITB9LGQucHJvdG90eXBlLmRpbWVuc2lvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJ3aWR0aFwiKTtyZXR1cm4gYT9cIndpZHRoXCI6XCJoZWlnaHRcIn0sZC5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbigpe2lmKCF0aGlzLnRyYW5zaXRpb25pbmcmJiF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiaW5cIikpe3ZhciBiLGU9dGhpcy4kcGFyZW50JiZ0aGlzLiRwYXJlbnQuY2hpbGRyZW4oXCIucGFuZWxcIikuY2hpbGRyZW4oXCIuaW4sIC5jb2xsYXBzaW5nXCIpO2lmKCEoZSYmZS5sZW5ndGgmJihiPWUuZGF0YShcImJzLmNvbGxhcHNlXCIpLGImJmIudHJhbnNpdGlvbmluZykpKXt2YXIgZj1hLkV2ZW50KFwic2hvdy5icy5jb2xsYXBzZVwiKTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoZiksIWYuaXNEZWZhdWx0UHJldmVudGVkKCkpe2UmJmUubGVuZ3RoJiYoYy5jYWxsKGUsXCJoaWRlXCIpLGJ8fGUuZGF0YShcImJzLmNvbGxhcHNlXCIsbnVsbCkpO3ZhciBnPXRoaXMuZGltZW5zaW9uKCk7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbGxhcHNlXCIpLmFkZENsYXNzKFwiY29sbGFwc2luZ1wiKVtnXSgwKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSx0aGlzLiR0cmlnZ2VyLnJlbW92ZUNsYXNzKFwiY29sbGFwc2VkXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLHRoaXMudHJhbnNpdGlvbmluZz0xO3ZhciBoPWZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbGxhcHNpbmdcIikuYWRkQ2xhc3MoXCJjb2xsYXBzZSBpblwiKVtnXShcIlwiKSx0aGlzLnRyYW5zaXRpb25pbmc9MCx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJzaG93bi5icy5jb2xsYXBzZVwiKX07aWYoIWEuc3VwcG9ydC50cmFuc2l0aW9uKXJldHVybiBoLmNhbGwodGhpcyk7dmFyIGk9YS5jYW1lbENhc2UoW1wic2Nyb2xsXCIsZ10uam9pbihcIi1cIikpO3RoaXMuJGVsZW1lbnQub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYS5wcm94eShoLHRoaXMpKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChkLlRSQU5TSVRJT05fRFVSQVRJT04pW2ddKHRoaXMuJGVsZW1lbnRbMF1baV0pfX19fSxkLnByb3RvdHlwZS5oaWRlPWZ1bmN0aW9uKCl7aWYoIXRoaXMudHJhbnNpdGlvbmluZyYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImluXCIpKXt2YXIgYj1hLkV2ZW50KFwiaGlkZS5icy5jb2xsYXBzZVwiKTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoYiksIWIuaXNEZWZhdWx0UHJldmVudGVkKCkpe3ZhciBjPXRoaXMuZGltZW5zaW9uKCk7dGhpcy4kZWxlbWVudFtjXSh0aGlzLiRlbGVtZW50W2NdKCkpWzBdLm9mZnNldEhlaWdodCx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiY29sbGFwc2luZ1wiKS5yZW1vdmVDbGFzcyhcImNvbGxhcHNlIGluXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLHRoaXMuJHRyaWdnZXIuYWRkQ2xhc3MoXCJjb2xsYXBzZWRcIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMSksdGhpcy50cmFuc2l0aW9uaW5nPTE7dmFyIGU9ZnVuY3Rpb24oKXt0aGlzLnRyYW5zaXRpb25pbmc9MCx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiY29sbGFwc2luZ1wiKS5hZGRDbGFzcyhcImNvbGxhcHNlXCIpLnRyaWdnZXIoXCJoaWRkZW4uYnMuY29sbGFwc2VcIil9O3JldHVybiBhLnN1cHBvcnQudHJhbnNpdGlvbj92b2lkIHRoaXMuJGVsZW1lbnRbY10oMCkub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYS5wcm94eShlLHRoaXMpKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChkLlRSQU5TSVRJT05fRFVSQVRJT04pOmUuY2FsbCh0aGlzKX19fSxkLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oKXt0aGlzW3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJpblwiKT9cImhpZGVcIjpcInNob3dcIl0oKX0sZC5wcm90b3R5cGUuZ2V0UGFyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcy5vcHRpb25zLnBhcmVudCkuZmluZCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCInK3RoaXMub3B0aW9ucy5wYXJlbnQrJ1wiXScpLmVhY2goYS5wcm94eShmdW5jdGlvbihjLGQpe3ZhciBlPWEoZCk7dGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoYihlKSxlKX0sdGhpcykpLmVuZCgpfSxkLnByb3RvdHlwZS5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3M9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmhhc0NsYXNzKFwiaW5cIik7YS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLGMpLGIudG9nZ2xlQ2xhc3MoXCJjb2xsYXBzZWRcIiwhYykuYXR0cihcImFyaWEtZXhwYW5kZWRcIixjKX07dmFyIGU9YS5mbi5jb2xsYXBzZTthLmZuLmNvbGxhcHNlPWMsYS5mbi5jb2xsYXBzZS5Db25zdHJ1Y3Rvcj1kLGEuZm4uY29sbGFwc2Uubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmNvbGxhcHNlPWUsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsZnVuY3Rpb24oZCl7dmFyIGU9YSh0aGlzKTtlLmF0dHIoXCJkYXRhLXRhcmdldFwiKXx8ZC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBmPWIoZSksZz1mLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxoPWc/XCJ0b2dnbGVcIjplLmRhdGEoKTtjLmNhbGwoZixoKX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3ZhciBjPWIuYXR0cihcImRhdGEtdGFyZ2V0XCIpO2N8fChjPWIuYXR0cihcImhyZWZcIiksYz1jJiYvI1tBLVphLXpdLy50ZXN0KGMpJiZjLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sXCJcIikpO3ZhciBkPWMmJmEoYyk7cmV0dXJuIGQmJmQubGVuZ3RoP2Q6Yi5wYXJlbnQoKX1mdW5jdGlvbiBjKGMpe2MmJjM9PT1jLndoaWNofHwoYShlKS5yZW1vdmUoKSxhKGYpLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9YihkKSxmPXtyZWxhdGVkVGFyZ2V0OnRoaXN9O2UuaGFzQ2xhc3MoXCJvcGVuXCIpJiYoYyYmXCJjbGlja1wiPT1jLnR5cGUmJi9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoYy50YXJnZXQudGFnTmFtZSkmJmEuY29udGFpbnMoZVswXSxjLnRhcmdldCl8fChlLnRyaWdnZXIoYz1hLkV2ZW50KFwiaGlkZS5icy5kcm9wZG93blwiLGYpKSxjLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwoZC5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLFwiZmFsc2VcIiksZS5yZW1vdmVDbGFzcyhcIm9wZW5cIikudHJpZ2dlcihhLkV2ZW50KFwiaGlkZGVuLmJzLmRyb3Bkb3duXCIsZikpKSkpfSkpfWZ1bmN0aW9uIGQoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZD1jLmRhdGEoXCJicy5kcm9wZG93blwiKTtkfHxjLmRhdGEoXCJicy5kcm9wZG93blwiLGQ9bmV3IGcodGhpcykpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZkW2JdLmNhbGwoYyl9KX12YXIgZT1cIi5kcm9wZG93bi1iYWNrZHJvcFwiLGY9J1tkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJyxnPWZ1bmN0aW9uKGIpe2EoYikub24oXCJjbGljay5icy5kcm9wZG93blwiLHRoaXMudG9nZ2xlKX07Zy5WRVJTSU9OPVwiMy4zLjZcIixnLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oZCl7dmFyIGU9YSh0aGlzKTtpZighZS5pcyhcIi5kaXNhYmxlZCwgOmRpc2FibGVkXCIpKXt2YXIgZj1iKGUpLGc9Zi5oYXNDbGFzcyhcIm9wZW5cIik7aWYoYygpLCFnKXtcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiYhZi5jbG9zZXN0KFwiLm5hdmJhci1uYXZcIikubGVuZ3RoJiZhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKFwiZHJvcGRvd24tYmFja2Ryb3BcIikuaW5zZXJ0QWZ0ZXIoYSh0aGlzKSkub24oXCJjbGlja1wiLGMpO3ZhciBoPXtyZWxhdGVkVGFyZ2V0OnRoaXN9O2lmKGYudHJpZ2dlcihkPWEuRXZlbnQoXCJzaG93LmJzLmRyb3Bkb3duXCIsaCkpLGQuaXNEZWZhdWx0UHJldmVudGVkKCkpcmV0dXJuO2UudHJpZ2dlcihcImZvY3VzXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsXCJ0cnVlXCIpLGYudG9nZ2xlQ2xhc3MoXCJvcGVuXCIpLnRyaWdnZXIoYS5FdmVudChcInNob3duLmJzLmRyb3Bkb3duXCIsaCkpfXJldHVybiExfX0sZy5wcm90b3R5cGUua2V5ZG93bj1mdW5jdGlvbihjKXtpZigvKDM4fDQwfDI3fDMyKS8udGVzdChjLndoaWNoKSYmIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoYy50YXJnZXQudGFnTmFtZSkpe3ZhciBkPWEodGhpcyk7aWYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksIWQuaXMoXCIuZGlzYWJsZWQsIDpkaXNhYmxlZFwiKSl7dmFyIGU9YihkKSxnPWUuaGFzQ2xhc3MoXCJvcGVuXCIpO2lmKCFnJiYyNyE9Yy53aGljaHx8ZyYmMjc9PWMud2hpY2gpcmV0dXJuIDI3PT1jLndoaWNoJiZlLmZpbmQoZikudHJpZ2dlcihcImZvY3VzXCIpLGQudHJpZ2dlcihcImNsaWNrXCIpO3ZhciBoPVwiIGxpOm5vdCguZGlzYWJsZWQpOnZpc2libGUgYVwiLGk9ZS5maW5kKFwiLmRyb3Bkb3duLW1lbnVcIitoKTtpZihpLmxlbmd0aCl7dmFyIGo9aS5pbmRleChjLnRhcmdldCk7Mzg9PWMud2hpY2gmJmo+MCYmai0tLDQwPT1jLndoaWNoJiZqPGkubGVuZ3RoLTEmJmorKyx+anx8KGo9MCksaS5lcShqKS50cmlnZ2VyKFwiZm9jdXNcIil9fX19O3ZhciBoPWEuZm4uZHJvcGRvd247YS5mbi5kcm9wZG93bj1kLGEuZm4uZHJvcGRvd24uQ29uc3RydWN0b3I9ZyxhLmZuLmRyb3Bkb3duLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5kcm9wZG93bj1oLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGlcIixjKS5vbihcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsXCIuZHJvcGRvd24gZm9ybVwiLGZ1bmN0aW9uKGEpe2Euc3RvcFByb3BhZ2F0aW9uKCl9KS5vbihcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsZixnLnByb3RvdHlwZS50b2dnbGUpLm9uKFwia2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaVwiLGYsZy5wcm90b3R5cGUua2V5ZG93bikub24oXCJrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsXCIuZHJvcGRvd24tbWVudVwiLGcucHJvdG90eXBlLmtleWRvd24pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIsZCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPWEodGhpcyksZj1lLmRhdGEoXCJicy5tb2RhbFwiKSxnPWEuZXh0ZW5kKHt9LGMuREVGQVVMVFMsZS5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpO2Z8fGUuZGF0YShcImJzLm1vZGFsXCIsZj1uZXcgYyh0aGlzLGcpKSxcInN0cmluZ1wiPT10eXBlb2YgYj9mW2JdKGQpOmcuc2hvdyYmZi5zaG93KGQpfSl9dmFyIGM9ZnVuY3Rpb24oYixjKXt0aGlzLm9wdGlvbnM9Yyx0aGlzLiRib2R5PWEoZG9jdW1lbnQuYm9keSksdGhpcy4kZWxlbWVudD1hKGIpLHRoaXMuJGRpYWxvZz10aGlzLiRlbGVtZW50LmZpbmQoXCIubW9kYWwtZGlhbG9nXCIpLHRoaXMuJGJhY2tkcm9wPW51bGwsdGhpcy5pc1Nob3duPW51bGwsdGhpcy5vcmlnaW5hbEJvZHlQYWQ9bnVsbCx0aGlzLnNjcm9sbGJhcldpZHRoPTAsdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrPSExLHRoaXMub3B0aW9ucy5yZW1vdGUmJnRoaXMuJGVsZW1lbnQuZmluZChcIi5tb2RhbC1jb250ZW50XCIpLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSxhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFwibG9hZGVkLmJzLm1vZGFsXCIpfSx0aGlzKSl9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTMwMCxjLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT049MTUwLGMuREVGQVVMVFM9e2JhY2tkcm9wOiEwLGtleWJvYXJkOiEwLHNob3c6ITB9LGMucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc1Nob3duP3RoaXMuaGlkZSgpOnRoaXMuc2hvdyhhKX0sYy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbihiKXt2YXIgZD10aGlzLGU9YS5FdmVudChcInNob3cuYnMubW9kYWxcIix7cmVsYXRlZFRhcmdldDpifSk7dGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpLHRoaXMuaXNTaG93bnx8ZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KHRoaXMuaXNTaG93bj0hMCx0aGlzLmNoZWNrU2Nyb2xsYmFyKCksdGhpcy5zZXRTY3JvbGxiYXIoKSx0aGlzLiRib2R5LmFkZENsYXNzKFwibW9kYWwtb3BlblwiKSx0aGlzLmVzY2FwZSgpLHRoaXMucmVzaXplKCksdGhpcy4kZWxlbWVudC5vbihcImNsaWNrLmRpc21pc3MuYnMubW9kYWxcIiwnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJyxhLnByb3h5KHRoaXMuaGlkZSx0aGlzKSksdGhpcy4kZGlhbG9nLm9uKFwibW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWxcIixmdW5jdGlvbigpe2QuJGVsZW1lbnQub25lKFwibW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsXCIsZnVuY3Rpb24oYil7YShiLnRhcmdldCkuaXMoZC4kZWxlbWVudCkmJihkLmlnbm9yZUJhY2tkcm9wQ2xpY2s9ITApfSl9KSx0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uKCl7dmFyIGU9YS5zdXBwb3J0LnRyYW5zaXRpb24mJmQuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmYWRlXCIpO2QuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RofHxkLiRlbGVtZW50LmFwcGVuZFRvKGQuJGJvZHkpLGQuJGVsZW1lbnQuc2hvdygpLnNjcm9sbFRvcCgwKSxkLmFkanVzdERpYWxvZygpLGUmJmQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGgsZC4kZWxlbWVudC5hZGRDbGFzcyhcImluXCIpLGQuZW5mb3JjZUZvY3VzKCk7dmFyIGY9YS5FdmVudChcInNob3duLmJzLm1vZGFsXCIse3JlbGF0ZWRUYXJnZXQ6Yn0pO2U/ZC4kZGlhbG9nLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7ZC4kZWxlbWVudC50cmlnZ2VyKFwiZm9jdXNcIikudHJpZ2dlcihmKX0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6ZC4kZWxlbWVudC50cmlnZ2VyKFwiZm9jdXNcIikudHJpZ2dlcihmKX0pKX0sYy5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbihiKXtiJiZiLnByZXZlbnREZWZhdWx0KCksYj1hLkV2ZW50KFwiaGlkZS5icy5tb2RhbFwiKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoYiksdGhpcy5pc1Nob3duJiYhYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmKHRoaXMuaXNTaG93bj0hMSx0aGlzLmVzY2FwZSgpLHRoaXMucmVzaXplKCksYShkb2N1bWVudCkub2ZmKFwiZm9jdXNpbi5icy5tb2RhbFwiKSx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiaW5cIikub2ZmKFwiY2xpY2suZGlzbWlzcy5icy5tb2RhbFwiKS5vZmYoXCJtb3VzZXVwLmRpc21pc3MuYnMubW9kYWxcIiksdGhpcy4kZGlhbG9nLm9mZihcIm1vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIpLGEuc3VwcG9ydC50cmFuc2l0aW9uJiZ0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKT90aGlzLiRlbGVtZW50Lm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkodGhpcy5oaWRlTW9kYWwsdGhpcykpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6dGhpcy5oaWRlTW9kYWwoKSl9LGMucHJvdG90eXBlLmVuZm9yY2VGb2N1cz1mdW5jdGlvbigpe2EoZG9jdW1lbnQpLm9mZihcImZvY3VzaW4uYnMubW9kYWxcIikub24oXCJmb2N1c2luLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXt0aGlzLiRlbGVtZW50WzBdPT09YS50YXJnZXR8fHRoaXMuJGVsZW1lbnQuaGFzKGEudGFyZ2V0KS5sZW5ndGh8fHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpfSx0aGlzKSl9LGMucHJvdG90eXBlLmVzY2FwZT1mdW5jdGlvbigpe3RoaXMuaXNTaG93biYmdGhpcy5vcHRpb25zLmtleWJvYXJkP3RoaXMuJGVsZW1lbnQub24oXCJrZXlkb3duLmRpc21pc3MuYnMubW9kYWxcIixhLnByb3h5KGZ1bmN0aW9uKGEpezI3PT1hLndoaWNoJiZ0aGlzLmhpZGUoKX0sdGhpcykpOnRoaXMuaXNTaG93bnx8dGhpcy4kZWxlbWVudC5vZmYoXCJrZXlkb3duLmRpc21pc3MuYnMubW9kYWxcIil9LGMucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbigpe3RoaXMuaXNTaG93bj9hKHdpbmRvdykub24oXCJyZXNpemUuYnMubW9kYWxcIixhLnByb3h5KHRoaXMuaGFuZGxlVXBkYXRlLHRoaXMpKTphKHdpbmRvdykub2ZmKFwicmVzaXplLmJzLm1vZGFsXCIpfSxjLnByb3RvdHlwZS5oaWRlTW9kYWw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuJGVsZW1lbnQuaGlkZSgpLHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24oKXthLiRib2R5LnJlbW92ZUNsYXNzKFwibW9kYWwtb3BlblwiKSxhLnJlc2V0QWRqdXN0bWVudHMoKSxhLnJlc2V0U2Nyb2xsYmFyKCksYS4kZWxlbWVudC50cmlnZ2VyKFwiaGlkZGVuLmJzLm1vZGFsXCIpfSl9LGMucHJvdG90eXBlLnJlbW92ZUJhY2tkcm9wPWZ1bmN0aW9uKCl7dGhpcy4kYmFja2Ryb3AmJnRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpLHRoaXMuJGJhY2tkcm9wPW51bGx9LGMucHJvdG90eXBlLmJhY2tkcm9wPWZ1bmN0aW9uKGIpe3ZhciBkPXRoaXMsZT10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKT9cImZhZGVcIjpcIlwiO2lmKHRoaXMuaXNTaG93biYmdGhpcy5vcHRpb25zLmJhY2tkcm9wKXt2YXIgZj1hLnN1cHBvcnQudHJhbnNpdGlvbiYmZTtpZih0aGlzLiRiYWNrZHJvcD1hKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKFwibW9kYWwtYmFja2Ryb3AgXCIrZSkuYXBwZW5kVG8odGhpcy4kYm9keSksdGhpcy4kZWxlbWVudC5vbihcImNsaWNrLmRpc21pc3MuYnMubW9kYWxcIixhLnByb3h5KGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2s/dm9pZCh0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2s9ITEpOnZvaWQoYS50YXJnZXQ9PT1hLmN1cnJlbnRUYXJnZXQmJihcInN0YXRpY1wiPT10aGlzLm9wdGlvbnMuYmFja2Ryb3A/dGhpcy4kZWxlbWVudFswXS5mb2N1cygpOnRoaXMuaGlkZSgpKSl9LHRoaXMpKSxmJiZ0aGlzLiRiYWNrZHJvcFswXS5vZmZzZXRXaWR0aCx0aGlzLiRiYWNrZHJvcC5hZGRDbGFzcyhcImluXCIpLCFiKXJldHVybjtmP3RoaXMuJGJhY2tkcm9wLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGIpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTik6YigpfWVsc2UgaWYoIXRoaXMuaXNTaG93biYmdGhpcy4kYmFja2Ryb3Ape3RoaXMuJGJhY2tkcm9wLnJlbW92ZUNsYXNzKFwiaW5cIik7dmFyIGc9ZnVuY3Rpb24oKXtkLnJlbW92ZUJhY2tkcm9wKCksYiYmYigpfTthLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/dGhpcy4kYmFja2Ryb3Aub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZykuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKTpnKCl9ZWxzZSBiJiZiKCl9LGMucHJvdG90eXBlLmhhbmRsZVVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuYWRqdXN0RGlhbG9nKCl9LGMucHJvdG90eXBlLmFkanVzdERpYWxvZz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0PmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7dGhpcy4kZWxlbWVudC5jc3Moe3BhZGRpbmdMZWZ0OiF0aGlzLmJvZHlJc092ZXJmbG93aW5nJiZhP3RoaXMuc2Nyb2xsYmFyV2lkdGg6XCJcIixwYWRkaW5nUmlnaHQ6dGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmIWE/dGhpcy5zY3JvbGxiYXJXaWR0aDpcIlwifSl9LGMucHJvdG90eXBlLnJlc2V0QWRqdXN0bWVudHM9ZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50LmNzcyh7cGFkZGluZ0xlZnQ6XCJcIixwYWRkaW5nUmlnaHQ6XCJcIn0pfSxjLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhcj1mdW5jdGlvbigpe3ZhciBhPXdpbmRvdy5pbm5lcldpZHRoO2lmKCFhKXt2YXIgYj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7YT1iLnJpZ2h0LU1hdGguYWJzKGIubGVmdCl9dGhpcy5ib2R5SXNPdmVyZmxvd2luZz1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoPGEsdGhpcy5zY3JvbGxiYXJXaWR0aD10aGlzLm1lYXN1cmVTY3JvbGxiYXIoKX0sYy5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIGE9cGFyc2VJbnQodGhpcy4kYm9keS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpfHwwLDEwKTt0aGlzLm9yaWdpbmFsQm9keVBhZD1kb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodHx8XCJcIix0aGlzLmJvZHlJc092ZXJmbG93aW5nJiZ0aGlzLiRib2R5LmNzcyhcInBhZGRpbmctcmlnaHRcIixhK3RoaXMuc2Nyb2xsYmFyV2lkdGgpfSxjLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhcj1mdW5jdGlvbigpe3RoaXMuJGJvZHkuY3NzKFwicGFkZGluZy1yaWdodFwiLHRoaXMub3JpZ2luYWxCb2R5UGFkKX0sYy5wcm90b3R5cGUubWVhc3VyZVNjcm9sbGJhcj1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YS5jbGFzc05hbWU9XCJtb2RhbC1zY3JvbGxiYXItbWVhc3VyZVwiLHRoaXMuJGJvZHkuYXBwZW5kKGEpO3ZhciBiPWEub2Zmc2V0V2lkdGgtYS5jbGllbnRXaWR0aDtyZXR1cm4gdGhpcy4kYm9keVswXS5yZW1vdmVDaGlsZChhKSxifTt2YXIgZD1hLmZuLm1vZGFsO2EuZm4ubW9kYWw9YixhLmZuLm1vZGFsLkNvbnN0cnVjdG9yPWMsYS5mbi5tb2RhbC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4ubW9kYWw9ZCx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLm1vZGFsLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJyxmdW5jdGlvbihjKXt2YXIgZD1hKHRoaXMpLGU9ZC5hdHRyKFwiaHJlZlwiKSxmPWEoZC5hdHRyKFwiZGF0YS10YXJnZXRcIil8fGUmJmUucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLyxcIlwiKSksZz1mLmRhdGEoXCJicy5tb2RhbFwiKT9cInRvZ2dsZVwiOmEuZXh0ZW5kKHtyZW1vdGU6IS8jLy50ZXN0KGUpJiZlfSxmLmRhdGEoKSxkLmRhdGEoKSk7ZC5pcyhcImFcIikmJmMucHJldmVudERlZmF1bHQoKSxmLm9uZShcInNob3cuYnMubW9kYWxcIixmdW5jdGlvbihhKXthLmlzRGVmYXVsdFByZXZlbnRlZCgpfHxmLm9uZShcImhpZGRlbi5icy5tb2RhbFwiLGZ1bmN0aW9uKCl7ZC5pcyhcIjp2aXNpYmxlXCIpJiZkLnRyaWdnZXIoXCJmb2N1c1wiKX0pfSksYi5jYWxsKGYsZyx0aGlzKX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMudG9vbHRpcFwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBiJiZiOyhlfHwhL2Rlc3Ryb3l8aGlkZS8udGVzdChiKSkmJihlfHxkLmRhdGEoXCJicy50b29sdGlwXCIsZT1uZXcgYyh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpKX0pfXZhciBjPWZ1bmN0aW9uKGEsYil7dGhpcy50eXBlPW51bGwsdGhpcy5vcHRpb25zPW51bGwsdGhpcy5lbmFibGVkPW51bGwsdGhpcy50aW1lb3V0PW51bGwsdGhpcy5ob3ZlclN0YXRlPW51bGwsdGhpcy4kZWxlbWVudD1udWxsLHRoaXMuaW5TdGF0ZT1udWxsLHRoaXMuaW5pdChcInRvb2x0aXBcIixhLGIpfTtjLlZFUlNJT049XCIzLjMuNlwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsYy5ERUZBVUxUUz17YW5pbWF0aW9uOiEwLHBsYWNlbWVudDpcInRvcFwiLHNlbGVjdG9yOiExLHRlbXBsYXRlOic8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsdHJpZ2dlcjpcImhvdmVyIGZvY3VzXCIsdGl0bGU6XCJcIixkZWxheTowLGh0bWw6ITEsY29udGFpbmVyOiExLHZpZXdwb3J0OntzZWxlY3RvcjpcImJvZHlcIixwYWRkaW5nOjB9fSxjLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGIsYyxkKXtpZih0aGlzLmVuYWJsZWQ9ITAsdGhpcy50eXBlPWIsdGhpcy4kZWxlbWVudD1hKGMpLHRoaXMub3B0aW9ucz10aGlzLmdldE9wdGlvbnMoZCksdGhpcy4kdmlld3BvcnQ9dGhpcy5vcHRpb25zLnZpZXdwb3J0JiZhKGEuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMudmlld3BvcnQpP3RoaXMub3B0aW9ucy52aWV3cG9ydC5jYWxsKHRoaXMsdGhpcy4kZWxlbWVudCk6dGhpcy5vcHRpb25zLnZpZXdwb3J0LnNlbGVjdG9yfHx0aGlzLm9wdGlvbnMudmlld3BvcnQpLHRoaXMuaW5TdGF0ZT17Y2xpY2s6ITEsaG92ZXI6ITEsZm9jdXM6ITF9LHRoaXMuJGVsZW1lbnRbMF1pbnN0YW5jZW9mIGRvY3VtZW50LmNvbnN0cnVjdG9yJiYhdGhpcy5vcHRpb25zLnNlbGVjdG9yKXRocm93IG5ldyBFcnJvcihcImBzZWxlY3RvcmAgb3B0aW9uIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gaW5pdGlhbGl6aW5nIFwiK3RoaXMudHlwZStcIiBvbiB0aGUgd2luZG93LmRvY3VtZW50IG9iamVjdCFcIik7Zm9yKHZhciBlPXRoaXMub3B0aW9ucy50cmlnZ2VyLnNwbGl0KFwiIFwiKSxmPWUubGVuZ3RoO2YtLTspe3ZhciBnPWVbZl07aWYoXCJjbGlja1wiPT1nKXRoaXMuJGVsZW1lbnQub24oXCJjbGljay5cIit0aGlzLnR5cGUsdGhpcy5vcHRpb25zLnNlbGVjdG9yLGEucHJveHkodGhpcy50b2dnbGUsdGhpcykpO2Vsc2UgaWYoXCJtYW51YWxcIiE9Zyl7dmFyIGg9XCJob3ZlclwiPT1nP1wibW91c2VlbnRlclwiOlwiZm9jdXNpblwiLGk9XCJob3ZlclwiPT1nP1wibW91c2VsZWF2ZVwiOlwiZm9jdXNvdXRcIjt0aGlzLiRlbGVtZW50Lm9uKGgrXCIuXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMuZW50ZXIsdGhpcykpLHRoaXMuJGVsZW1lbnQub24oaStcIi5cIit0aGlzLnR5cGUsdGhpcy5vcHRpb25zLnNlbGVjdG9yLGEucHJveHkodGhpcy5sZWF2ZSx0aGlzKSl9fXRoaXMub3B0aW9ucy5zZWxlY3Rvcj90aGlzLl9vcHRpb25zPWEuZXh0ZW5kKHt9LHRoaXMub3B0aW9ucyx7dHJpZ2dlcjpcIm1hbnVhbFwiLHNlbGVjdG9yOlwiXCJ9KTp0aGlzLmZpeFRpdGxlKCl9LGMucHJvdG90eXBlLmdldERlZmF1bHRzPWZ1bmN0aW9uKCl7cmV0dXJuIGMuREVGQVVMVFN9LGMucHJvdG90eXBlLmdldE9wdGlvbnM9ZnVuY3Rpb24oYil7cmV0dXJuIGI9YS5leHRlbmQoe30sdGhpcy5nZXREZWZhdWx0cygpLHRoaXMuJGVsZW1lbnQuZGF0YSgpLGIpLGIuZGVsYXkmJlwibnVtYmVyXCI9PXR5cGVvZiBiLmRlbGF5JiYoYi5kZWxheT17c2hvdzpiLmRlbGF5LGhpZGU6Yi5kZWxheX0pLGJ9LGMucHJvdG90eXBlLmdldERlbGVnYXRlT3B0aW9ucz1mdW5jdGlvbigpe3ZhciBiPXt9LGM9dGhpcy5nZXREZWZhdWx0cygpO3JldHVybiB0aGlzLl9vcHRpb25zJiZhLmVhY2godGhpcy5fb3B0aW9ucyxmdW5jdGlvbihhLGQpe2NbYV0hPWQmJihiW2FdPWQpfSksYn0sYy5wcm90b3R5cGUuZW50ZXI9ZnVuY3Rpb24oYil7dmFyIGM9YiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/YjphKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSk7cmV0dXJuIGN8fChjPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGIuY3VycmVudFRhcmdldCx0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKSxhKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSxjKSksYiBpbnN0YW5jZW9mIGEuRXZlbnQmJihjLmluU3RhdGVbXCJmb2N1c2luXCI9PWIudHlwZT9cImZvY3VzXCI6XCJob3ZlclwiXT0hMCksYy50aXAoKS5oYXNDbGFzcyhcImluXCIpfHxcImluXCI9PWMuaG92ZXJTdGF0ZT92b2lkKGMuaG92ZXJTdGF0ZT1cImluXCIpOihjbGVhclRpbWVvdXQoYy50aW1lb3V0KSxjLmhvdmVyU3RhdGU9XCJpblwiLGMub3B0aW9ucy5kZWxheSYmYy5vcHRpb25zLmRlbGF5LnNob3c/dm9pZChjLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe1wiaW5cIj09Yy5ob3ZlclN0YXRlJiZjLnNob3coKX0sYy5vcHRpb25zLmRlbGF5LnNob3cpKTpjLnNob3coKSl9LGMucHJvdG90eXBlLmlzSW5TdGF0ZVRydWU9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5pblN0YXRlKWlmKHRoaXMuaW5TdGF0ZVthXSlyZXR1cm4hMDtyZXR1cm4hMX0sYy5wcm90b3R5cGUubGVhdmU9ZnVuY3Rpb24oYil7dmFyIGM9YiBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/YjphKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSk7cmV0dXJuIGN8fChjPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGIuY3VycmVudFRhcmdldCx0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKSxhKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSxjKSksYiBpbnN0YW5jZW9mIGEuRXZlbnQmJihjLmluU3RhdGVbXCJmb2N1c291dFwiPT1iLnR5cGU/XCJmb2N1c1wiOlwiaG92ZXJcIl09ITEpLGMuaXNJblN0YXRlVHJ1ZSgpP3ZvaWQgMDooY2xlYXJUaW1lb3V0KGMudGltZW91dCksYy5ob3ZlclN0YXRlPVwib3V0XCIsYy5vcHRpb25zLmRlbGF5JiZjLm9wdGlvbnMuZGVsYXkuaGlkZT92b2lkKGMudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XCJvdXRcIj09Yy5ob3ZlclN0YXRlJiZjLmhpZGUoKX0sYy5vcHRpb25zLmRlbGF5LmhpZGUpKTpjLmhpZGUoKSl9LGMucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oKXt2YXIgYj1hLkV2ZW50KFwic2hvdy5icy5cIit0aGlzLnR5cGUpO2lmKHRoaXMuaGFzQ29udGVudCgpJiZ0aGlzLmVuYWJsZWQpe3RoaXMuJGVsZW1lbnQudHJpZ2dlcihiKTt2YXIgZD1hLmNvbnRhaW5zKHRoaXMuJGVsZW1lbnRbMF0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdGhpcy4kZWxlbWVudFswXSk7aWYoYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8IWQpcmV0dXJuO3ZhciBlPXRoaXMsZj10aGlzLnRpcCgpLGc9dGhpcy5nZXRVSUQodGhpcy50eXBlKTt0aGlzLnNldENvbnRlbnQoKSxmLmF0dHIoXCJpZFwiLGcpLHRoaXMuJGVsZW1lbnQuYXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIixnKSx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uJiZmLmFkZENsYXNzKFwiZmFkZVwiKTt2YXIgaD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50P3RoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLGZbMF0sdGhpcy4kZWxlbWVudFswXSk6dGhpcy5vcHRpb25zLnBsYWNlbWVudCxpPS9cXHM/YXV0bz9cXHM/L2ksaj1pLnRlc3QoaCk7aiYmKGg9aC5yZXBsYWNlKGksXCJcIil8fFwidG9wXCIpLGYuZGV0YWNoKCkuY3NzKHt0b3A6MCxsZWZ0OjAsZGlzcGxheTpcImJsb2NrXCJ9KS5hZGRDbGFzcyhoKS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlLHRoaXMpLHRoaXMub3B0aW9ucy5jb250YWluZXI/Zi5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuY29udGFpbmVyKTpmLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcImluc2VydGVkLmJzLlwiK3RoaXMudHlwZSk7dmFyIGs9dGhpcy5nZXRQb3NpdGlvbigpLGw9ZlswXS5vZmZzZXRXaWR0aCxtPWZbMF0ub2Zmc2V0SGVpZ2h0O2lmKGope3ZhciBuPWgsbz10aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KTtoPVwiYm90dG9tXCI9PWgmJmsuYm90dG9tK20+by5ib3R0b20/XCJ0b3BcIjpcInRvcFwiPT1oJiZrLnRvcC1tPG8udG9wP1wiYm90dG9tXCI6XCJyaWdodFwiPT1oJiZrLnJpZ2h0K2w+by53aWR0aD9cImxlZnRcIjpcImxlZnRcIj09aCYmay5sZWZ0LWw8by5sZWZ0P1wicmlnaHRcIjpoLGYucmVtb3ZlQ2xhc3MobikuYWRkQ2xhc3MoaCl9dmFyIHA9dGhpcy5nZXRDYWxjdWxhdGVkT2Zmc2V0KGgsayxsLG0pO3RoaXMuYXBwbHlQbGFjZW1lbnQocCxoKTt2YXIgcT1mdW5jdGlvbigpe3ZhciBhPWUuaG92ZXJTdGF0ZTtlLiRlbGVtZW50LnRyaWdnZXIoXCJzaG93bi5icy5cIitlLnR5cGUpLGUuaG92ZXJTdGF0ZT1udWxsLFwib3V0XCI9PWEmJmUubGVhdmUoZSl9O2Euc3VwcG9ydC50cmFuc2l0aW9uJiZ0aGlzLiR0aXAuaGFzQ2xhc3MoXCJmYWRlXCIpP2Yub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIscSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpxKCl9fSxjLnByb3RvdHlwZS5hcHBseVBsYWNlbWVudD1mdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMudGlwKCksZT1kWzBdLm9mZnNldFdpZHRoLGY9ZFswXS5vZmZzZXRIZWlnaHQsZz1wYXJzZUludChkLmNzcyhcIm1hcmdpbi10b3BcIiksMTApLGg9cGFyc2VJbnQoZC5jc3MoXCJtYXJnaW4tbGVmdFwiKSwxMCk7aXNOYU4oZykmJihnPTApLGlzTmFOKGgpJiYoaD0wKSxiLnRvcCs9ZyxiLmxlZnQrPWgsYS5vZmZzZXQuc2V0T2Zmc2V0KGRbMF0sYS5leHRlbmQoe3VzaW5nOmZ1bmN0aW9uKGEpe2QuY3NzKHt0b3A6TWF0aC5yb3VuZChhLnRvcCksbGVmdDpNYXRoLnJvdW5kKGEubGVmdCl9KX19LGIpLDApLGQuYWRkQ2xhc3MoXCJpblwiKTt2YXIgaT1kWzBdLm9mZnNldFdpZHRoLGo9ZFswXS5vZmZzZXRIZWlnaHQ7XCJ0b3BcIj09YyYmaiE9ZiYmKGIudG9wPWIudG9wK2Ytaik7dmFyIGs9dGhpcy5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEoYyxiLGksaik7ay5sZWZ0P2IubGVmdCs9ay5sZWZ0OmIudG9wKz1rLnRvcDt2YXIgbD0vdG9wfGJvdHRvbS8udGVzdChjKSxtPWw/MiprLmxlZnQtZStpOjIqay50b3AtZitqLG49bD9cIm9mZnNldFdpZHRoXCI6XCJvZmZzZXRIZWlnaHRcIjtkLm9mZnNldChiKSx0aGlzLnJlcGxhY2VBcnJvdyhtLGRbMF1bbl0sbCl9LGMucHJvdG90eXBlLnJlcGxhY2VBcnJvdz1mdW5jdGlvbihhLGIsYyl7dGhpcy5hcnJvdygpLmNzcyhjP1wibGVmdFwiOlwidG9wXCIsNTAqKDEtYS9iKStcIiVcIikuY3NzKGM/XCJ0b3BcIjpcImxlZnRcIixcIlwiKX0sYy5wcm90b3R5cGUuc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMudGlwKCksYj10aGlzLmdldFRpdGxlKCk7YS5maW5kKFwiLnRvb2x0aXAtaW5uZXJcIilbdGhpcy5vcHRpb25zLmh0bWw/XCJodG1sXCI6XCJ0ZXh0XCJdKGIpLGEucmVtb3ZlQ2xhc3MoXCJmYWRlIGluIHRvcCBib3R0b20gbGVmdCByaWdodFwiKX0sYy5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBkKCl7XCJpblwiIT1lLmhvdmVyU3RhdGUmJmYuZGV0YWNoKCksZS4kZWxlbWVudC5yZW1vdmVBdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiKS50cmlnZ2VyKFwiaGlkZGVuLmJzLlwiK2UudHlwZSksYiYmYigpfXZhciBlPXRoaXMsZj1hKHRoaXMuJHRpcCksZz1hLkV2ZW50KFwiaGlkZS5icy5cIit0aGlzLnR5cGUpO3JldHVybiB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZyksZy5pc0RlZmF1bHRQcmV2ZW50ZWQoKT92b2lkIDA6KGYucmVtb3ZlQ2xhc3MoXCJpblwiKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmZi5oYXNDbGFzcyhcImZhZGVcIik/Zi5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixkKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmQoKSx0aGlzLmhvdmVyU3RhdGU9bnVsbCx0aGlzKX0sYy5wcm90b3R5cGUuZml4VGl0bGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50OyhhLmF0dHIoXCJ0aXRsZVwiKXx8XCJzdHJpbmdcIiE9dHlwZW9mIGEuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIikpJiZhLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIsYS5hdHRyKFwidGl0bGVcIil8fFwiXCIpLmF0dHIoXCJ0aXRsZVwiLFwiXCIpfSxjLnByb3RvdHlwZS5oYXNDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VGl0bGUoKX0sYy5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oYil7Yj1ifHx0aGlzLiRlbGVtZW50O3ZhciBjPWJbMF0sZD1cIkJPRFlcIj09Yy50YWdOYW1lLGU9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtudWxsPT1lLndpZHRoJiYoZT1hLmV4dGVuZCh7fSxlLHt3aWR0aDplLnJpZ2h0LWUubGVmdCxoZWlnaHQ6ZS5ib3R0b20tZS50b3B9KSk7dmFyIGY9ZD97dG9wOjAsbGVmdDowfTpiLm9mZnNldCgpLGc9e3Njcm9sbDpkP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B8fGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wOmIuc2Nyb2xsVG9wKCl9LGg9ZD97d2lkdGg6YSh3aW5kb3cpLndpZHRoKCksaGVpZ2h0OmEod2luZG93KS5oZWlnaHQoKX06bnVsbDtyZXR1cm4gYS5leHRlbmQoe30sZSxnLGgsZil9LGMucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQ9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuXCJib3R0b21cIj09YT97dG9wOmIudG9wK2IuaGVpZ2h0LGxlZnQ6Yi5sZWZ0K2Iud2lkdGgvMi1jLzJ9OlwidG9wXCI9PWE/e3RvcDpiLnRvcC1kLGxlZnQ6Yi5sZWZ0K2Iud2lkdGgvMi1jLzJ9OlwibGVmdFwiPT1hP3t0b3A6Yi50b3ArYi5oZWlnaHQvMi1kLzIsbGVmdDpiLmxlZnQtY306e3RvcDpiLnRvcCtiLmhlaWdodC8yLWQvMixsZWZ0OmIubGVmdCtiLndpZHRofX0sYy5wcm90b3R5cGUuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXt0b3A6MCxsZWZ0OjB9O2lmKCF0aGlzLiR2aWV3cG9ydClyZXR1cm4gZTt2YXIgZj10aGlzLm9wdGlvbnMudmlld3BvcnQmJnRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nfHwwLGc9dGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydCk7aWYoL3JpZ2h0fGxlZnQvLnRlc3QoYSkpe3ZhciBoPWIudG9wLWYtZy5zY3JvbGwsaT1iLnRvcCtmLWcuc2Nyb2xsK2Q7aDxnLnRvcD9lLnRvcD1nLnRvcC1oOmk+Zy50b3ArZy5oZWlnaHQmJihlLnRvcD1nLnRvcCtnLmhlaWdodC1pKX1lbHNle3ZhciBqPWIubGVmdC1mLGs9Yi5sZWZ0K2YrYztqPGcubGVmdD9lLmxlZnQ9Zy5sZWZ0LWo6az5nLnJpZ2h0JiYoZS5sZWZ0PWcubGVmdCtnLndpZHRoLWspfXJldHVybiBlfSxjLnByb3RvdHlwZS5nZXRUaXRsZT1mdW5jdGlvbigpe3ZhciBhLGI9dGhpcy4kZWxlbWVudCxjPXRoaXMub3B0aW9ucztyZXR1cm4gYT1iLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYy50aXRsZT9jLnRpdGxlLmNhbGwoYlswXSk6Yy50aXRsZSl9LGMucHJvdG90eXBlLmdldFVJRD1mdW5jdGlvbihhKXtkbyBhKz1+figxZTYqTWF0aC5yYW5kb20oKSk7d2hpbGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSkpO3JldHVybiBhfSxjLnByb3RvdHlwZS50aXA9ZnVuY3Rpb24oKXtpZighdGhpcy4kdGlwJiYodGhpcy4kdGlwPWEodGhpcy5vcHRpb25zLnRlbXBsYXRlKSwxIT10aGlzLiR0aXAubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IodGhpcy50eXBlK1wiIGB0ZW1wbGF0ZWAgb3B0aW9uIG11c3QgY29uc2lzdCBvZiBleGFjdGx5IDEgdG9wLWxldmVsIGVsZW1lbnQhXCIpO3JldHVybiB0aGlzLiR0aXB9LGMucHJvdG90eXBlLmFycm93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGFycm93PXRoaXMuJGFycm93fHx0aGlzLnRpcCgpLmZpbmQoXCIudG9vbHRpcC1hcnJvd1wiKX0sYy5wcm90b3R5cGUuZW5hYmxlPWZ1bmN0aW9uKCl7dGhpcy5lbmFibGVkPSEwfSxjLnByb3RvdHlwZS5kaXNhYmxlPWZ1bmN0aW9uKCl7dGhpcy5lbmFibGVkPSExfSxjLnByb3RvdHlwZS50b2dnbGVFbmFibGVkPWZ1bmN0aW9uKCl7dGhpcy5lbmFibGVkPSF0aGlzLmVuYWJsZWR9LGMucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbihiKXt2YXIgYz10aGlzO2ImJihjPWEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlKSxjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpKSxiPyhjLmluU3RhdGUuY2xpY2s9IWMuaW5TdGF0ZS5jbGljayxjLmlzSW5TdGF0ZVRydWUoKT9jLmVudGVyKGMpOmMubGVhdmUoYykpOmMudGlwKCkuaGFzQ2xhc3MoXCJpblwiKT9jLmxlYXZlKGMpOmMuZW50ZXIoYyl9LGMucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2NsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLHRoaXMuaGlkZShmdW5jdGlvbigpe2EuJGVsZW1lbnQub2ZmKFwiLlwiK2EudHlwZSkucmVtb3ZlRGF0YShcImJzLlwiK2EudHlwZSksYS4kdGlwJiZhLiR0aXAuZGV0YWNoKCksYS4kdGlwPW51bGwsYS4kYXJyb3c9bnVsbCxhLiR2aWV3cG9ydD1udWxsfSl9O3ZhciBkPWEuZm4udG9vbHRpcDthLmZuLnRvb2x0aXA9YixhLmZuLnRvb2x0aXAuQ29uc3RydWN0b3I9YyxhLmZuLnRvb2x0aXAubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnRvb2x0aXA9ZCx0aGlzfX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnBvcG92ZXJcIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYiYmYjsoZXx8IS9kZXN0cm95fGhpZGUvLnRlc3QoYikpJiYoZXx8ZC5kYXRhKFwiYnMucG9wb3ZlclwiLGU9bmV3IGModGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKSl9KX12YXIgYz1mdW5jdGlvbihhLGIpe3RoaXMuaW5pdChcInBvcG92ZXJcIixhLGIpfTtpZighYS5mbi50b29sdGlwKXRocm93IG5ldyBFcnJvcihcIlBvcG92ZXIgcmVxdWlyZXMgdG9vbHRpcC5qc1wiKTtjLlZFUlNJT049XCIzLjMuNlwiLGMuREVGQVVMVFM9YS5leHRlbmQoe30sYS5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLHtwbGFjZW1lbnQ6XCJyaWdodFwiLHRyaWdnZXI6XCJjbGlja1wiLGNvbnRlbnQ6XCJcIix0ZW1wbGF0ZTonPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnRcIj48L2Rpdj48L2Rpdj4nfSksYy5wcm90b3R5cGU9YS5leHRlbmQoe30sYS5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSksYy5wcm90b3R5cGUuY29uc3RydWN0b3I9YyxjLnByb3RvdHlwZS5nZXREZWZhdWx0cz1mdW5jdGlvbigpe3JldHVybiBjLkRFRkFVTFRTfSxjLnByb3RvdHlwZS5zZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50aXAoKSxiPXRoaXMuZ2V0VGl0bGUoKSxjPXRoaXMuZ2V0Q29udGVudCgpO2EuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpW3RoaXMub3B0aW9ucy5odG1sP1wiaHRtbFwiOlwidGV4dFwiXShiKSxhLmZpbmQoXCIucG9wb3Zlci1jb250ZW50XCIpLmNoaWxkcmVuKCkuZGV0YWNoKCkuZW5kKClbdGhpcy5vcHRpb25zLmh0bWw/XCJzdHJpbmdcIj09dHlwZW9mIGM/XCJodG1sXCI6XCJhcHBlbmRcIjpcInRleHRcIl0oYyksYS5yZW1vdmVDbGFzcyhcImZhZGUgdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0IGluXCIpLGEuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpLmh0bWwoKXx8YS5maW5kKFwiLnBvcG92ZXItdGl0bGVcIikuaGlkZSgpfSxjLnByb3RvdHlwZS5oYXNDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VGl0bGUoKXx8dGhpcy5nZXRDb250ZW50KCl9LGMucHJvdG90eXBlLmdldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50LGI9dGhpcy5vcHRpb25zO3JldHVybiBhLmF0dHIoXCJkYXRhLWNvbnRlbnRcIil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBiLmNvbnRlbnQ/Yi5jb250ZW50LmNhbGwoYVswXSk6Yi5jb250ZW50KX0sYy5wcm90b3R5cGUuYXJyb3c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kYXJyb3c9dGhpcy4kYXJyb3d8fHRoaXMudGlwKCkuZmluZChcIi5hcnJvd1wiKX07dmFyIGQ9YS5mbi5wb3BvdmVyO2EuZm4ucG9wb3Zlcj1iLGEuZm4ucG9wb3Zlci5Db25zdHJ1Y3Rvcj1jLGEuZm4ucG9wb3Zlci5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4ucG9wb3Zlcj1kLHRoaXN9fShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGMsZCl7dGhpcy4kYm9keT1hKGRvY3VtZW50LmJvZHkpLHRoaXMuJHNjcm9sbEVsZW1lbnQ9YShhKGMpLmlzKGRvY3VtZW50LmJvZHkpP3dpbmRvdzpjKSx0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sYi5ERUZBVUxUUyxkKSx0aGlzLnNlbGVjdG9yPSh0aGlzLm9wdGlvbnMudGFyZ2V0fHxcIlwiKStcIiAubmF2IGxpID4gYVwiLHRoaXMub2Zmc2V0cz1bXSx0aGlzLnRhcmdldHM9W10sdGhpcy5hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLnNjcm9sbEhlaWdodD0wLHRoaXMuJHNjcm9sbEVsZW1lbnQub24oXCJzY3JvbGwuYnMuc2Nyb2xsc3B5XCIsYS5wcm94eSh0aGlzLnByb2Nlc3MsdGhpcykpLHRoaXMucmVmcmVzaCgpLHRoaXMucHJvY2VzcygpfWZ1bmN0aW9uIGMoYyl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5zY3JvbGxzcHlcIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYyYmYztlfHxkLmRhdGEoXCJicy5zY3JvbGxzcHlcIixlPW5ldyBiKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBjJiZlW2NdKCl9KX1iLlZFUlNJT049XCIzLjMuNlwiLGIuREVGQVVMVFM9e29mZnNldDoxMH0sYi5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0fHxNYXRoLm1heCh0aGlzLiRib2R5WzBdLnNjcm9sbEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KX0sYi5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3ZhciBiPXRoaXMsYz1cIm9mZnNldFwiLGQ9MDt0aGlzLm9mZnNldHM9W10sdGhpcy50YXJnZXRzPVtdLHRoaXMuc2Nyb2xsSGVpZ2h0PXRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCksYS5pc1dpbmRvdyh0aGlzLiRzY3JvbGxFbGVtZW50WzBdKXx8KGM9XCJwb3NpdGlvblwiLGQ9dGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSksdGhpcy4kYm9keS5maW5kKHRoaXMuc2VsZWN0b3IpLm1hcChmdW5jdGlvbigpe3ZhciBiPWEodGhpcyksZT1iLmRhdGEoXCJ0YXJnZXRcIil8fGIuYXR0cihcImhyZWZcIiksZj0vXiMuLy50ZXN0KGUpJiZhKGUpO3JldHVybiBmJiZmLmxlbmd0aCYmZi5pcyhcIjp2aXNpYmxlXCIpJiZbW2ZbY10oKS50b3ArZCxlXV18fG51bGx9KS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGFbMF0tYlswXX0pLmVhY2goZnVuY3Rpb24oKXtiLm9mZnNldHMucHVzaCh0aGlzWzBdKSxiLnRhcmdldHMucHVzaCh0aGlzWzFdKX0pfSxiLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpK3RoaXMub3B0aW9ucy5vZmZzZXQsYz10aGlzLmdldFNjcm9sbEhlaWdodCgpLGQ9dGhpcy5vcHRpb25zLm9mZnNldCtjLXRoaXMuJHNjcm9sbEVsZW1lbnQuaGVpZ2h0KCksZT10aGlzLm9mZnNldHMsZj10aGlzLnRhcmdldHMsZz10aGlzLmFjdGl2ZVRhcmdldDtpZih0aGlzLnNjcm9sbEhlaWdodCE9YyYmdGhpcy5yZWZyZXNoKCksYj49ZClyZXR1cm4gZyE9KGE9ZltmLmxlbmd0aC0xXSkmJnRoaXMuYWN0aXZhdGUoYSk7aWYoZyYmYjxlWzBdKXJldHVybiB0aGlzLmFjdGl2ZVRhcmdldD1udWxsLHRoaXMuY2xlYXIoKTtmb3IoYT1lLmxlbmd0aDthLS07KWchPWZbYV0mJmI+PWVbYV0mJih2b2lkIDA9PT1lW2ErMV18fGI8ZVthKzFdKSYmdGhpcy5hY3RpdmF0ZShmW2FdKX0sYi5wcm90b3R5cGUuYWN0aXZhdGU9ZnVuY3Rpb24oYil7dGhpcy5hY3RpdmVUYXJnZXQ9Yix0aGlzLmNsZWFyKCk7dmFyIGM9dGhpcy5zZWxlY3RvcisnW2RhdGEtdGFyZ2V0PVwiJytiKydcIl0sJyt0aGlzLnNlbGVjdG9yKydbaHJlZj1cIicrYisnXCJdJyxkPWEoYykucGFyZW50cyhcImxpXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuZC5wYXJlbnQoXCIuZHJvcGRvd24tbWVudVwiKS5sZW5ndGgmJihkPWQuY2xvc2VzdChcImxpLmRyb3Bkb3duXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpKSxkLnRyaWdnZXIoXCJhY3RpdmF0ZS5icy5zY3JvbGxzcHlcIil9LGIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7YSh0aGlzLnNlbGVjdG9yKS5wYXJlbnRzVW50aWwodGhpcy5vcHRpb25zLnRhcmdldCxcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIil9O3ZhciBkPWEuZm4uc2Nyb2xsc3B5O2EuZm4uc2Nyb2xsc3B5PWMsYS5mbi5zY3JvbGxzcHkuQ29uc3RydWN0b3I9YixhLmZuLnNjcm9sbHNweS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uc2Nyb2xsc3B5PWQsdGhpc30sYSh3aW5kb3cpLm9uKFwibG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGlcIixmdW5jdGlvbigpe2EoJ1tkYXRhLXNweT1cInNjcm9sbFwiXScpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpO2MuY2FsbChiLGIuZGF0YSgpKX0pfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy50YWJcIik7ZXx8ZC5kYXRhKFwiYnMudGFiXCIsZT1uZXcgYyh0aGlzKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKX0pfXZhciBjPWZ1bmN0aW9uKGIpe3RoaXMuZWxlbWVudD1hKGIpfTtjLlZFUlNJT049XCIzLjMuNlwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsYy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbigpe3ZhciBiPXRoaXMuZWxlbWVudCxjPWIuY2xvc2VzdChcInVsOm5vdCguZHJvcGRvd24tbWVudSlcIiksZD1iLmRhdGEoXCJ0YXJnZXRcIik7aWYoZHx8KGQ9Yi5hdHRyKFwiaHJlZlwiKSxkPWQmJmQucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLyxcIlwiKSksIWIucGFyZW50KFwibGlcIikuaGFzQ2xhc3MoXCJhY3RpdmVcIikpe3ZhciBlPWMuZmluZChcIi5hY3RpdmU6bGFzdCBhXCIpLGY9YS5FdmVudChcImhpZGUuYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6YlswXX0pLGc9YS5FdmVudChcInNob3cuYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6ZVswXX0pO2lmKGUudHJpZ2dlcihmKSxiLnRyaWdnZXIoZyksIWcuaXNEZWZhdWx0UHJldmVudGVkKCkmJiFmLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgaD1hKGQpO3RoaXMuYWN0aXZhdGUoYi5jbG9zZXN0KFwibGlcIiksYyksdGhpcy5hY3RpdmF0ZShoLGgucGFyZW50KCksZnVuY3Rpb24oKXtlLnRyaWdnZXIoe3R5cGU6XCJoaWRkZW4uYnMudGFiXCIscmVsYXRlZFRhcmdldDpiWzBdfSksYi50cmlnZ2VyKHt0eXBlOlwic2hvd24uYnMudGFiXCIscmVsYXRlZFRhcmdldDplWzBdfSl9KX19fSxjLnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbihiLGQsZSl7ZnVuY3Rpb24gZigpe2cucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIikuZmluZChcIj4gLmRyb3Bkb3duLW1lbnUgPiAuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLmVuZCgpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLGIuYWRkQ2xhc3MoXCJhY3RpdmVcIikuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJykuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksaD8oYlswXS5vZmZzZXRXaWR0aCxiLmFkZENsYXNzKFwiaW5cIikpOmIucmVtb3ZlQ2xhc3MoXCJmYWRlXCIpLGIucGFyZW50KFwiLmRyb3Bkb3duLW1lbnVcIikubGVuZ3RoJiZiLmNsb3Nlc3QoXCJsaS5kcm9wZG93blwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKS5lbmQoKS5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSxlJiZlKCl9dmFyIGc9ZC5maW5kKFwiPiAuYWN0aXZlXCIpLGg9ZSYmYS5zdXBwb3J0LnRyYW5zaXRpb24mJihnLmxlbmd0aCYmZy5oYXNDbGFzcyhcImZhZGVcIil8fCEhZC5maW5kKFwiPiAuZmFkZVwiKS5sZW5ndGgpO2cubGVuZ3RoJiZoP2cub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZikuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpmKCksZy5yZW1vdmVDbGFzcyhcImluXCIpfTt2YXIgZD1hLmZuLnRhYjthLmZuLnRhYj1iLGEuZm4udGFiLkNvbnN0cnVjdG9yPWMsYS5mbi50YWIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnRhYj1kLHRoaXN9O3ZhciBlPWZ1bmN0aW9uKGMpe2MucHJldmVudERlZmF1bHQoKSxiLmNhbGwoYSh0aGlzKSxcInNob3dcIil9O2EoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMudGFiLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScsZSkub24oXCJjbGljay5icy50YWIuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsZSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5hZmZpeFwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBiJiZiO2V8fGQuZGF0YShcImJzLmFmZml4XCIsZT1uZXcgYyh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGM9ZnVuY3Rpb24oYixkKXt0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sYy5ERUZBVUxUUyxkKSx0aGlzLiR0YXJnZXQ9YSh0aGlzLm9wdGlvbnMudGFyZ2V0KS5vbihcInNjcm9sbC5icy5hZmZpeC5kYXRhLWFwaVwiLGEucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLHRoaXMpKS5vbihcImNsaWNrLmJzLmFmZml4LmRhdGEtYXBpXCIsYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLHRoaXMpKSx0aGlzLiRlbGVtZW50PWEoYiksdGhpcy5hZmZpeGVkPW51bGwsdGhpcy51bnBpbj1udWxsLHRoaXMucGlubmVkT2Zmc2V0PW51bGwsdGhpcy5jaGVja1Bvc2l0aW9uKCl9O2MuVkVSU0lPTj1cIjMuMy42XCIsYy5SRVNFVD1cImFmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b21cIixjLkRFRkFVTFRTPXtvZmZzZXQ6MCx0YXJnZXQ6d2luZG93fSxjLnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKCksZj10aGlzLiRlbGVtZW50Lm9mZnNldCgpLGc9dGhpcy4kdGFyZ2V0LmhlaWdodCgpO2lmKG51bGwhPWMmJlwidG9wXCI9PXRoaXMuYWZmaXhlZClyZXR1cm4gYz5lP1widG9wXCI6ITE7aWYoXCJib3R0b21cIj09dGhpcy5hZmZpeGVkKXJldHVybiBudWxsIT1jP2UrdGhpcy51bnBpbjw9Zi50b3A/ITE6XCJib3R0b21cIjphLWQ+PWUrZz8hMTpcImJvdHRvbVwiO3ZhciBoPW51bGw9PXRoaXMuYWZmaXhlZCxpPWg/ZTpmLnRvcCxqPWg/ZzpiO3JldHVybiBudWxsIT1jJiZjPj1lP1widG9wXCI6bnVsbCE9ZCYmaStqPj1hLWQ/XCJib3R0b21cIjohMX0sYy5wcm90b3R5cGUuZ2V0UGlubmVkT2Zmc2V0PWZ1bmN0aW9uKCl7aWYodGhpcy5waW5uZWRPZmZzZXQpcmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0O3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoYy5SRVNFVCkuYWRkQ2xhc3MoXCJhZmZpeFwiKTt2YXIgYT10aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKCksYj10aGlzLiRlbGVtZW50Lm9mZnNldCgpO3JldHVybiB0aGlzLnBpbm5lZE9mZnNldD1iLnRvcC1hfSxjLnByb3RvdHlwZS5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcD1mdW5jdGlvbigpe3NldFRpbWVvdXQoYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sdGhpcyksMSl9LGMucHJvdG90eXBlLmNoZWNrUG9zaXRpb249ZnVuY3Rpb24oKXtpZih0aGlzLiRlbGVtZW50LmlzKFwiOnZpc2libGVcIikpe3ZhciBiPXRoaXMuJGVsZW1lbnQuaGVpZ2h0KCksZD10aGlzLm9wdGlvbnMub2Zmc2V0LGU9ZC50b3AsZj1kLmJvdHRvbSxnPU1hdGgubWF4KGEoZG9jdW1lbnQpLmhlaWdodCgpLGEoZG9jdW1lbnQuYm9keSkuaGVpZ2h0KCkpO1wib2JqZWN0XCIhPXR5cGVvZiBkJiYoZj1lPWQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihlPWQudG9wKHRoaXMuJGVsZW1lbnQpKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBmJiYoZj1kLmJvdHRvbSh0aGlzLiRlbGVtZW50KSk7dmFyIGg9dGhpcy5nZXRTdGF0ZShnLGIsZSxmKTtpZih0aGlzLmFmZml4ZWQhPWgpe251bGwhPXRoaXMudW5waW4mJnRoaXMuJGVsZW1lbnQuY3NzKFwidG9wXCIsXCJcIik7dmFyIGk9XCJhZmZpeFwiKyhoP1wiLVwiK2g6XCJcIiksaj1hLkV2ZW50KGkrXCIuYnMuYWZmaXhcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGopLGouaXNEZWZhdWx0UHJldmVudGVkKCkpcmV0dXJuO3RoaXMuYWZmaXhlZD1oLHRoaXMudW5waW49XCJib3R0b21cIj09aD90aGlzLmdldFBpbm5lZE9mZnNldCgpOm51bGwsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjLlJFU0VUKS5hZGRDbGFzcyhpKS50cmlnZ2VyKGkucmVwbGFjZShcImFmZml4XCIsXCJhZmZpeGVkXCIpK1wiLmJzLmFmZml4XCIpfVwiYm90dG9tXCI9PWgmJnRoaXMuJGVsZW1lbnQub2Zmc2V0KHt0b3A6Zy1iLWZ9KX19O3ZhciBkPWEuZm4uYWZmaXg7YS5mbi5hZmZpeD1iLGEuZm4uYWZmaXguQ29uc3RydWN0b3I9YyxhLmZuLmFmZml4Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5hZmZpeD1kLHRoaXN9LGEod2luZG93KS5vbihcImxvYWRcIixmdW5jdGlvbigpe2EoJ1tkYXRhLXNweT1cImFmZml4XCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZD1jLmRhdGEoKTtkLm9mZnNldD1kLm9mZnNldHx8e30sbnVsbCE9ZC5vZmZzZXRCb3R0b20mJihkLm9mZnNldC5ib3R0b209ZC5vZmZzZXRCb3R0b20pLG51bGwhPWQub2Zmc2V0VG9wJiYoZC5vZmZzZXQudG9wPWQub2Zmc2V0VG9wKSxiLmNhbGwoYyxkKX0pfSl9KGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9qcy9ib290c3RyYXAubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n')},function(module,exports){eval('// Peity jQuery plugin version 2.0.3\n// (c) 2014 Ben Pickles\n//\n// http://benpickles.github.io/peity\n//\n// Released under MIT license.\n(function(e,q,h){var o=function(a,b){var c=q.createElementNS("http://www.w3.org/2000/svg",a);e.each(b,function(a,b){c.setAttribute(a,b)});return c},t="createElementNS"in q&&o("svg",{}).createSVGRect,r=1/(window.devicePixelRatio||1),j=e.fn.peity=function(a,b){t&&this.each(function(){var c=e(this),d=c.data("peity");if(d)a&&(d.type=a),e.extend(d.opts,b);else{var f=j.defaults[a],g={};e.each(c.data(),function(a,b){a in f&&(g[a]=b)});var h=e.extend({},f,g,b),d=new s(c,a,h);c.change(function(){d.draw()}).data("peity",\n    d)}d.draw()});return this},s=function(a,b,c){this.$el=a;this.type=b;this.opts=c},m=s.prototype;m.draw=function(){j.graphers[this.type].call(this,this.opts)};m.fill=function(){var a=this.opts.fill,b=a;e.isFunction(b)||(b=function(b,d){return a[d%a.length]});return b};m.prepare=function(a,b){var c;this.svg?c=e(this.svg).empty():(this.svg=o("svg",{"class":"peity"}),this.$el.hide().after(this.svg),c=e(this.svg).data("peity",this));this.svg.setAttribute("height",b);this.svg.setAttribute("width",a);return c};\n    m.values=function(){return e.map(this.$el.text().split(this.opts.delimiter),function(a){return parseFloat(a)})};j.defaults={};j.graphers={};j.register=function(a,b,c){this.defaults[a]=b;this.graphers[a]=c};j.register("pie",{delimiter:null,diameter:16,fill:["#ff9900","#fff4dd","#ffc66e"]},function(a){if(!a.delimiter){var b=this.$el.text().match(/[^0-9\\.]/);a.delimiter=b?b[0]:","}b=this.values();if("/"==a.delimiter)var c=b[0],b=[c,h.max(0,b[1]-c)];for(var d=0,c=b.length,f=0;d<c;d++)f+=b[d];for(var a=\n        this.prepare(a.width||a.diameter,a.height||a.diameter),d=a.width(),g=a.height(),a=d/2,g=g/2,p=h.min(a,g),e=h.PI,j=this.fill(),i=-e/2,d=0;d<c;d++){var n=b[d],l=n/f,k;if(0!=l){if(1==l)k=o("circle",{cx:a,cy:g,r:p});else{k=2*l*e;var l=i+k,m=p*h.cos(i)+a,i=p*h.sin(i)+g,q=p*h.cos(l)+a,r=p*h.sin(l)+g;k=o("path",{d:["M",a,g,"L",m,i,"A",p,p,0,k>e?1:0,1,q,r,"Z"].join(" ")});i=l}k.setAttribute("fill",j.call(this,n,d,b));this.svg.appendChild(k)}}});j.register("line",{delimiter:",",fill:"#c6d9fd",height:16,max:null,\n        min:0,stroke:"#4d89f9",strokeWidth:1,width:32},function(a){var b=this.values();1==b.length&&b.push(b[0]);for(var c=h.max.apply(h,b.concat([a.max])),d=h.min.apply(h,b.concat([a.min])),f=this.prepare(a.width,a.height),g=f.width(),f=f.height()-a.strokeWidth,e=g/(b.length-1),c=c-d,j=0==c?f:f/c,m=f+d*j,c=[0,m],i=0;i<b.length;i++)c.push(i*e,f-j*(b[i]-d)+a.strokeWidth/2);c.push(g,m);b=o("polygon",{fill:a.fill,points:c.join(" ")});this.svg.appendChild(b);a.strokeWidth&&(a=o("polyline",{fill:"transparent",\n        points:c.slice(2,c.length-2).join(" "),stroke:a.stroke,"stroke-width":a.strokeWidth,"stroke-linecap":"square"}),this.svg.appendChild(a))});j.register("bar",{delimiter:",",fill:["#4D89F9"],gap:1,height:16,max:null,min:0,width:32},function(a){for(var b=this.values(),c=h.max.apply(h,b.concat([a.max])),d=h.min.apply(h,b.concat([a.min])),f=this.prepare(a.width,a.height),g=f.width(),f=f.height(),e=c-d,j=0==e?0:f/e,a=a.gap,g=(g+a)/b.length,m=this.fill(),i=0;i<b.length;i++){var n=b[i],l=f-j*(n-d),k=j*n;if(0==\n        k){if(k=r,0>=d&&0<c||0==e)l-=r}else 0>k&&(l+=k,k=-k);n=o("rect",{fill:m.call(this,n,i,b),x:i*g,y:l,width:g-a,height:k});this.svg.appendChild(n)}})})(jQuery,document,Math);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy9wZWl0eS9qcXVlcnkucGVpdHkubWluLmpzP2I4NGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQix3REFBd0QsdUJBQXVCLG9CQUFvQixFQUFFLFNBQVMsb0NBQW9DLDRFQUE0RSx3QkFBd0IsZ0NBQWdDLHNDQUFzQyxLQUFLLHlCQUF5Qiw4QkFBOEIsaUJBQWlCLEVBQUUsaUJBQWlCLHVCQUF1QixvQkFBb0IsU0FBUztBQUNyZixPQUFPLFNBQVMsRUFBRSxZQUFZLG1CQUFtQixXQUFXLFlBQVksWUFBWSxlQUFlLGtCQUFrQiw0Q0FBNEMsa0JBQWtCLHlCQUF5QixrQ0FBa0MscUJBQXFCLEVBQUUsVUFBVSx3QkFBd0IsTUFBTSxrREFBa0QsZ0JBQWdCLG9FQUFvRSxrQ0FBa0MsaUNBQWlDO0FBQ3RmLHdCQUF3QixvRUFBb0UscUJBQXFCLEdBQUcsY0FBYyxjQUFjLDJCQUEyQixtQkFBbUIsb0JBQW9CLGtCQUFrQixnRUFBZ0UsYUFBYSxpQkFBaUIsd0NBQXdDLHVCQUF1QixnQkFBZ0IscURBQXFELDJCQUEyQixJQUFJLFlBQVk7QUFDamYsaUpBQWlKLElBQUksS0FBSyxtQkFBbUIsU0FBUyxzQkFBc0IsY0FBYyxFQUFFLEtBQUssUUFBUSxzRUFBc0UsWUFBWSwwREFBMEQsRUFBRSxJQUFJLDBDQUEwQywwQkFBMEIsRUFBRSxtQkFBbUI7QUFDcGQsc0RBQXNELGFBQWEsb0JBQW9CLDBCQUEwQiw4TUFBOE0sV0FBVyw2Q0FBNkMsWUFBWSxlQUFlLCtCQUErQixFQUFFLHdCQUF3QixnQ0FBZ0M7QUFDM2Usc0hBQXNILDJCQUEyQixFQUFFLGtCQUFrQix1RUFBdUUsYUFBYSxzTkFBc04sV0FBVyxLQUFLLDZCQUE2QjtBQUM1ZixXQUFXLDRCQUE0QixzQkFBc0IsWUFBWSxxREFBcUQsRUFBRSx5QkFBeUIsRUFBRSIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFBlaXR5IGpRdWVyeSBwbHVnaW4gdmVyc2lvbiAyLjAuM1xuLy8gKGMpIDIwMTQgQmVuIFBpY2tsZXNcbi8vXG4vLyBodHRwOi8vYmVucGlja2xlcy5naXRodWIuaW8vcGVpdHlcbi8vXG4vLyBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbihmdW5jdGlvbihlLHEsaCl7dmFyIG89ZnVuY3Rpb24oYSxiKXt2YXIgYz1xLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsYSk7ZS5lYWNoKGIsZnVuY3Rpb24oYSxiKXtjLnNldEF0dHJpYnV0ZShhLGIpfSk7cmV0dXJuIGN9LHQ9XCJjcmVhdGVFbGVtZW50TlNcImluIHEmJm8oXCJzdmdcIix7fSkuY3JlYXRlU1ZHUmVjdCxyPTEvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKSxqPWUuZm4ucGVpdHk9ZnVuY3Rpb24oYSxiKXt0JiZ0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1lKHRoaXMpLGQ9Yy5kYXRhKFwicGVpdHlcIik7aWYoZClhJiYoZC50eXBlPWEpLGUuZXh0ZW5kKGQub3B0cyxiKTtlbHNle3ZhciBmPWouZGVmYXVsdHNbYV0sZz17fTtlLmVhY2goYy5kYXRhKCksZnVuY3Rpb24oYSxiKXthIGluIGYmJihnW2FdPWIpfSk7dmFyIGg9ZS5leHRlbmQoe30sZixnLGIpLGQ9bmV3IHMoYyxhLGgpO2MuY2hhbmdlKGZ1bmN0aW9uKCl7ZC5kcmF3KCl9KS5kYXRhKFwicGVpdHlcIixcbiAgICBkKX1kLmRyYXcoKX0pO3JldHVybiB0aGlzfSxzPWZ1bmN0aW9uKGEsYixjKXt0aGlzLiRlbD1hO3RoaXMudHlwZT1iO3RoaXMub3B0cz1jfSxtPXMucHJvdG90eXBlO20uZHJhdz1mdW5jdGlvbigpe2ouZ3JhcGhlcnNbdGhpcy50eXBlXS5jYWxsKHRoaXMsdGhpcy5vcHRzKX07bS5maWxsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRzLmZpbGwsYj1hO2UuaXNGdW5jdGlvbihiKXx8KGI9ZnVuY3Rpb24oYixkKXtyZXR1cm4gYVtkJWEubGVuZ3RoXX0pO3JldHVybiBifTttLnByZXBhcmU9ZnVuY3Rpb24oYSxiKXt2YXIgYzt0aGlzLnN2Zz9jPWUodGhpcy5zdmcpLmVtcHR5KCk6KHRoaXMuc3ZnPW8oXCJzdmdcIix7XCJjbGFzc1wiOlwicGVpdHlcIn0pLHRoaXMuJGVsLmhpZGUoKS5hZnRlcih0aGlzLnN2ZyksYz1lKHRoaXMuc3ZnKS5kYXRhKFwicGVpdHlcIix0aGlzKSk7dGhpcy5zdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsYik7dGhpcy5zdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIixhKTtyZXR1cm4gY307XG4gICAgbS52YWx1ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gZS5tYXAodGhpcy4kZWwudGV4dCgpLnNwbGl0KHRoaXMub3B0cy5kZWxpbWl0ZXIpLGZ1bmN0aW9uKGEpe3JldHVybiBwYXJzZUZsb2F0KGEpfSl9O2ouZGVmYXVsdHM9e307ai5ncmFwaGVycz17fTtqLnJlZ2lzdGVyPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmRlZmF1bHRzW2FdPWI7dGhpcy5ncmFwaGVyc1thXT1jfTtqLnJlZ2lzdGVyKFwicGllXCIse2RlbGltaXRlcjpudWxsLGRpYW1ldGVyOjE2LGZpbGw6W1wiI2ZmOTkwMFwiLFwiI2ZmZjRkZFwiLFwiI2ZmYzY2ZVwiXX0sZnVuY3Rpb24oYSl7aWYoIWEuZGVsaW1pdGVyKXt2YXIgYj10aGlzLiRlbC50ZXh0KCkubWF0Y2goL1teMC05XFwuXS8pO2EuZGVsaW1pdGVyPWI/YlswXTpcIixcIn1iPXRoaXMudmFsdWVzKCk7aWYoXCIvXCI9PWEuZGVsaW1pdGVyKXZhciBjPWJbMF0sYj1bYyxoLm1heCgwLGJbMV0tYyldO2Zvcih2YXIgZD0wLGM9Yi5sZW5ndGgsZj0wO2Q8YztkKyspZis9YltkXTtmb3IodmFyIGE9XG4gICAgICAgIHRoaXMucHJlcGFyZShhLndpZHRofHxhLmRpYW1ldGVyLGEuaGVpZ2h0fHxhLmRpYW1ldGVyKSxkPWEud2lkdGgoKSxnPWEuaGVpZ2h0KCksYT1kLzIsZz1nLzIscD1oLm1pbihhLGcpLGU9aC5QSSxqPXRoaXMuZmlsbCgpLGk9LWUvMixkPTA7ZDxjO2QrKyl7dmFyIG49YltkXSxsPW4vZixrO2lmKDAhPWwpe2lmKDE9PWwpaz1vKFwiY2lyY2xlXCIse2N4OmEsY3k6ZyxyOnB9KTtlbHNle2s9MipsKmU7dmFyIGw9aStrLG09cCpoLmNvcyhpKSthLGk9cCpoLnNpbihpKStnLHE9cCpoLmNvcyhsKSthLHI9cCpoLnNpbihsKStnO2s9byhcInBhdGhcIix7ZDpbXCJNXCIsYSxnLFwiTFwiLG0saSxcIkFcIixwLHAsMCxrPmU/MTowLDEscSxyLFwiWlwiXS5qb2luKFwiIFwiKX0pO2k9bH1rLnNldEF0dHJpYnV0ZShcImZpbGxcIixqLmNhbGwodGhpcyxuLGQsYikpO3RoaXMuc3ZnLmFwcGVuZENoaWxkKGspfX19KTtqLnJlZ2lzdGVyKFwibGluZVwiLHtkZWxpbWl0ZXI6XCIsXCIsZmlsbDpcIiNjNmQ5ZmRcIixoZWlnaHQ6MTYsbWF4Om51bGwsXG4gICAgICAgIG1pbjowLHN0cm9rZTpcIiM0ZDg5ZjlcIixzdHJva2VXaWR0aDoxLHdpZHRoOjMyfSxmdW5jdGlvbihhKXt2YXIgYj10aGlzLnZhbHVlcygpOzE9PWIubGVuZ3RoJiZiLnB1c2goYlswXSk7Zm9yKHZhciBjPWgubWF4LmFwcGx5KGgsYi5jb25jYXQoW2EubWF4XSkpLGQ9aC5taW4uYXBwbHkoaCxiLmNvbmNhdChbYS5taW5dKSksZj10aGlzLnByZXBhcmUoYS53aWR0aCxhLmhlaWdodCksZz1mLndpZHRoKCksZj1mLmhlaWdodCgpLWEuc3Ryb2tlV2lkdGgsZT1nLyhiLmxlbmd0aC0xKSxjPWMtZCxqPTA9PWM/ZjpmL2MsbT1mK2QqaixjPVswLG1dLGk9MDtpPGIubGVuZ3RoO2krKyljLnB1c2goaSplLGYtaiooYltpXS1kKSthLnN0cm9rZVdpZHRoLzIpO2MucHVzaChnLG0pO2I9byhcInBvbHlnb25cIix7ZmlsbDphLmZpbGwscG9pbnRzOmMuam9pbihcIiBcIil9KTt0aGlzLnN2Zy5hcHBlbmRDaGlsZChiKTthLnN0cm9rZVdpZHRoJiYoYT1vKFwicG9seWxpbmVcIix7ZmlsbDpcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIHBvaW50czpjLnNsaWNlKDIsYy5sZW5ndGgtMikuam9pbihcIiBcIiksc3Ryb2tlOmEuc3Ryb2tlLFwic3Ryb2tlLXdpZHRoXCI6YS5zdHJva2VXaWR0aCxcInN0cm9rZS1saW5lY2FwXCI6XCJzcXVhcmVcIn0pLHRoaXMuc3ZnLmFwcGVuZENoaWxkKGEpKX0pO2oucmVnaXN0ZXIoXCJiYXJcIix7ZGVsaW1pdGVyOlwiLFwiLGZpbGw6W1wiIzREODlGOVwiXSxnYXA6MSxoZWlnaHQ6MTYsbWF4Om51bGwsbWluOjAsd2lkdGg6MzJ9LGZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLnZhbHVlcygpLGM9aC5tYXguYXBwbHkoaCxiLmNvbmNhdChbYS5tYXhdKSksZD1oLm1pbi5hcHBseShoLGIuY29uY2F0KFthLm1pbl0pKSxmPXRoaXMucHJlcGFyZShhLndpZHRoLGEuaGVpZ2h0KSxnPWYud2lkdGgoKSxmPWYuaGVpZ2h0KCksZT1jLWQsaj0wPT1lPzA6Zi9lLGE9YS5nYXAsZz0oZythKS9iLmxlbmd0aCxtPXRoaXMuZmlsbCgpLGk9MDtpPGIubGVuZ3RoO2krKyl7dmFyIG49YltpXSxsPWYtaioobi1kKSxrPWoqbjtpZigwPT1cbiAgICAgICAgayl7aWYoaz1yLDA+PWQmJjA8Y3x8MD09ZSlsLT1yfWVsc2UgMD5rJiYobCs9ayxrPS1rKTtuPW8oXCJyZWN0XCIse2ZpbGw6bS5jYWxsKHRoaXMsbixpLGIpLHg6aSpnLHk6bCx3aWR0aDpnLWEsaGVpZ2h0Omt9KTt0aGlzLnN2Zy5hcHBlbmRDaGlsZChuKX19KX0pKGpRdWVyeSxkb2N1bWVudCxNYXRoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2pzL3BsdWdpbnMvcGVpdHkvanF1ZXJ5LnBlaXR5Lm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n')},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * qTip2 - Pretty powerful tooltips - @@vVERSION\n * http://qtip2.com\n *\n * Copyright (c) 2014 Craig Michael Thompson\n * Released under the MIT, GPL licenses\n * http://jquery.org/license\n *\n * Date: Fri Jul 25 2014 01:12 EDT-0400\n@@BUILDPROPS */\n/*global window: false, jQuery: false, console: false, define: false */\n\n/* Cache window, document, undefined */\n(function( window, document, undefined ) {\n\n// Uses AMD or browser globals to create a jQuery plugin.\n(function( factory ) {\n\t\"use strict\";\n\tif(true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse if(jQuery && !jQuery.fn.qtip) {\n\t\tfactory(jQuery);\n\t}\n}\n(function($) {\n\t\"use strict\"; // Enable ECMAScript \"strict\" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/\n\n;// Munge the primitives - Paul Irish tip\nvar TRUE = true,\nFALSE = false,\nNULL = null,\n\n// Common variables\nX = 'x', Y = 'y',\nWIDTH = 'width',\nHEIGHT = 'height',\n\n// Positioning sides\nTOP = 'top',\nLEFT = 'left',\nBOTTOM = 'bottom',\nRIGHT = 'right',\nCENTER = 'center',\n\n// Position adjustment types\nFLIP = 'flip',\nFLIPINVERT = 'flipinvert',\nSHIFT = 'shift',\n\n// Shortcut vars\nQTIP, PROTOTYPE, CORNER, CHECKS,\nPLUGINS = {},\nNAMESPACE = 'qtip',\nATTR_HAS = 'data-hasqtip',\nATTR_ID = 'data-qtip-id',\nWIDGET = ['ui-widget', 'ui-tooltip'],\nSELECTOR = '.'+NAMESPACE,\nINACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),\n\nCLASS_FIXED = NAMESPACE+'-fixed',\nCLASS_DEFAULT = NAMESPACE + '-default',\nCLASS_FOCUS = NAMESPACE + '-focus',\nCLASS_HOVER = NAMESPACE + '-hover',\nCLASS_DISABLED = NAMESPACE+'-disabled',\n\nreplaceSuffix = '_replacedByqTip',\noldtitle = 'oldtitle',\ntrackingBound,\n\n// Browser detection\nBROWSER = {\n\t/*\n\t * IE version detection\n\t *\n\t * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment\n\t * Credit to James Padolsey for the original implemntation!\n\t */\n\tie: (function(){\n\t\tvar v = 3, div = document.createElement('div');\n\t\twhile ((div.innerHTML = '\x3c!--[if gt IE '+(++v)+']><i></i><![endif]--\x3e')) {\n\t\t\tif(!div.getElementsByTagName('i')[0]) { break; }\n\t\t}\n\t\treturn v > 4 ? v : NaN;\n\t}()),\n \n\t/*\n\t * iOS version detection\n\t */\n\tiOS: parseFloat( \n\t\t('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])\n\t\t.replace('undefined', '3_2').replace('_', '.').replace('_', '')\n\t) || FALSE\n};\n\n;function QTip(target, options, id, attr) {\n\t// Elements and ID\n\tthis.id = id;\n\tthis.target = target;\n\tthis.tooltip = NULL;\n\tthis.elements = { target: target };\n\n\t// Internal constructs\n\tthis._id = NAMESPACE + '-' + id;\n\tthis.timers = { img: {} };\n\tthis.options = options;\n\tthis.plugins = {};\n\n\t// Cache object\n\tthis.cache = {\n\t\tevent: {},\n\t\ttarget: $(),\n\t\tdisabled: FALSE,\n\t\tattr: attr,\n\t\tonTooltip: FALSE,\n\t\tlastClass: ''\n\t};\n\n\t// Set the initial flags\n\tthis.rendered = this.destroyed = this.disabled = this.waiting = \n\t\tthis.hiddenDuringWait = this.positioning = this.triggering = FALSE;\n}\nPROTOTYPE = QTip.prototype;\n\nPROTOTYPE._when = function(deferreds) {\n\treturn $.when.apply($, deferreds);\n};\n\nPROTOTYPE.render = function(show) {\n\tif(this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit\n\n\tvar self = this,\n\t\toptions = this.options,\n\t\tcache = this.cache,\n\t\telements = this.elements,\n\t\ttext = options.content.text,\n\t\ttitle = options.content.title,\n\t\tbutton = options.content.button,\n\t\tposOptions = options.position,\n\t\tnamespace = '.'+this._id+' ',\n\t\tdeferreds = [],\n\t\ttooltip;\n\n\t// Add ARIA attributes to target\n\t$.attr(this.target[0], 'aria-describedby', this._id);\n\n\t// Create tooltip element\n\tthis.tooltip = elements.tooltip = tooltip = $('<div/>', {\n\t\t'id': this._id,\n\t\t'class': [ NAMESPACE, CLASS_DEFAULT, options.style.classes, NAMESPACE + '-pos-' + options.position.my.abbrev() ].join(' '),\n\t\t'width': options.style.width || '',\n\t\t'height': options.style.height || '',\n\t\t'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,\n\n\t\t/* ARIA specific attributes */\n\t\t'role': 'alert',\n\t\t'aria-live': 'polite',\n\t\t'aria-atomic': FALSE,\n\t\t'aria-describedby': this._id + '-content',\n\t\t'aria-hidden': TRUE\n\t})\n\t.toggleClass(CLASS_DISABLED, this.disabled)\n\t.attr(ATTR_ID, this.id)\n\t.data(NAMESPACE, this)\n\t.appendTo(posOptions.container)\n\t.append(\n\t\t// Create content element\n\t\telements.content = $('<div />', {\n\t\t\t'class': NAMESPACE + '-content',\n\t\t\t'id': this._id + '-content',\n\t\t\t'aria-atomic': TRUE\n\t\t})\n\t);\n\n\t// Set rendered flag and prevent redundant reposition calls for now\n\tthis.rendered = -1;\n\tthis.positioning = TRUE;\n\n\t// Create title...\n\tif(title) {\n\t\tthis._createTitle();\n\n\t\t// Update title only if its not a callback (called in toggle if so)\n\t\tif(!$.isFunction(title)) {\n\t\t\tdeferreds.push( this._updateTitle(title, FALSE) );\n\t\t}\n\t}\n\n\t// Create button\n\tif(button) { this._createButton(); }\n\n\t// Set proper rendered flag and update content if not a callback function (called in toggle)\n\tif(!$.isFunction(text)) {\n\t\tdeferreds.push( this._updateContent(text, FALSE) );\n\t}\n\tthis.rendered = TRUE;\n\n\t// Setup widget classes\n\tthis._setWidget();\n\n\t// Initialize 'render' plugins\n\t$.each(PLUGINS, function(name) {\n\t\tvar instance;\n\t\tif(this.initialize === 'render' && (instance = this(self))) {\n\t\t\tself.plugins[name] = instance;\n\t\t}\n\t});\n\n\t// Unassign initial events and assign proper events\n\tthis._unassignEvents();\n\tthis._assignEvents();\n\n\t// When deferreds have completed\n\tthis._when(deferreds).then(function() {\n\t\t// tooltiprender event\n\t\tself._trigger('render');\n\n\t\t// Reset flags\n\t\tself.positioning = FALSE;\n\n\t\t// Show tooltip if not hidden during wait period\n\t\tif(!self.hiddenDuringWait && (options.show.ready || show)) {\n\t\t\tself.toggle(TRUE, cache.event, FALSE);\n\t\t}\n\t\tself.hiddenDuringWait = FALSE;\n\t});\n\n\t// Expose API\n\tQTIP.api[this.id] = this;\n\n\treturn this;\n};\n\nPROTOTYPE.destroy = function(immediate) {\n\t// Set flag the signify destroy is taking place to plugins\n\t// and ensure it only gets destroyed once!\n\tif(this.destroyed) { return this.target; }\n\n\tfunction process() {\n\t\tif(this.destroyed) { return; }\n\t\tthis.destroyed = TRUE;\n\t\t\n\t\tvar target = this.target,\n\t\t\ttitle = target.attr(oldtitle);\n\n\t\t// Destroy tooltip if rendered\n\t\tif(this.rendered) {\n\t\t\tthis.tooltip.stop(1,0).find('*').remove().end().remove();\n\t\t}\n\n\t\t// Destroy all plugins\n\t\t$.each(this.plugins, function(name) {\n\t\t\tthis.destroy && this.destroy();\n\t\t});\n\n\t\t// Clear timers and remove bound events\n\t\tclearTimeout(this.timers.show);\n\t\tclearTimeout(this.timers.hide);\n\t\tthis._unassignEvents();\n\n\t\t// Remove api object and ARIA attributes\n\t\ttarget.removeData(NAMESPACE)\n\t\t\t.removeAttr(ATTR_ID)\n\t\t\t.removeAttr(ATTR_HAS)\n\t\t\t.removeAttr('aria-describedby');\n\n\t\t// Reset old title attribute if removed\n\t\tif(this.options.suppress && title) {\n\t\t\ttarget.attr('title', title).removeAttr(oldtitle);\n\t\t}\n\n\t\t// Remove qTip events associated with this API\n\t\tthis._unbind(target);\n\n\t\t// Remove ID from used id objects, and delete object references\n\t\t// for better garbage collection and leak protection\n\t\tthis.options = this.elements = this.cache = this.timers = \n\t\t\tthis.plugins = this.mouse = NULL;\n\n\t\t// Delete epoxsed API object\n\t\tdelete QTIP.api[this.id];\n\t}\n\n\t// If an immediate destory is needed\n\tif((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {\n\t\tthis.tooltip.one('tooltiphidden', $.proxy(process, this));\n\t\t!this.triggering && this.hide();\n\t}\n\n\t// If we're not in the process of hiding... process\n\telse { process.call(this); }\n\n\treturn this.target;\n};\n\n;function invalidOpt(a) {\n\treturn a === NULL || $.type(a) !== 'object';\n}\n\nfunction invalidContent(c) {\n\treturn !( $.isFunction(c) || (c && c.attr) || c.length || ($.type(c) === 'object' && (c.jquery || c.then) ));\n}\n\n// Option object sanitizer\nfunction sanitizeOptions(opts) {\n\tvar content, text, ajax, once;\n\n\tif(invalidOpt(opts)) { return FALSE; }\n\n\tif(invalidOpt(opts.metadata)) {\n\t\topts.metadata = { type: opts.metadata };\n\t}\n\n\tif('content' in opts) {\n\t\tcontent = opts.content;\n\n\t\tif(invalidOpt(content) || content.jquery || content.done) {\n\t\t\tcontent = opts.content = {\n\t\t\t\ttext: (text = invalidContent(content) ? FALSE : content)\n\t\t\t};\n\t\t}\n\t\telse { text = content.text; }\n\n\t\t// DEPRECATED - Old content.ajax plugin functionality\n\t\t// Converts it into the proper Deferred syntax\n\t\tif('ajax' in content) {\n\t\t\tajax = content.ajax;\n\t\t\tonce = ajax && ajax.once !== FALSE;\n\t\t\tdelete content.ajax;\n\n\t\t\tcontent.text = function(event, api) {\n\t\t\t\tvar loading = text || $(this).attr(api.options.content.attr) || 'Loading...',\n\n\t\t\t\tdeferred = $.ajax(\n\t\t\t\t\t$.extend({}, ajax, { context: api })\n\t\t\t\t)\n\t\t\t\t.then(ajax.success, NULL, ajax.error)\n\t\t\t\t.then(function(content) {\n\t\t\t\t\tif(content && once) { api.set('content.text', content); }\n\t\t\t\t\treturn content;\n\t\t\t\t},\n\t\t\t\tfunction(xhr, status, error) {\n\t\t\t\t\tif(api.destroyed || xhr.status === 0) { return; }\n\t\t\t\t\tapi.set('content.text', status + ': ' + error);\n\t\t\t\t});\n\n\t\t\t\treturn !once ? (api.set('content.text', loading), deferred) : loading;\n\t\t\t};\n\t\t}\n\n\t\tif('title' in content) {\n\t\t\tif(!invalidOpt(content.title)) {\n\t\t\t\tcontent.button = content.title.button;\n\t\t\t\tcontent.title = content.title.text;\n\t\t\t}\n\n\t\t\tif(invalidContent(content.title || FALSE)) {\n\t\t\t\tcontent.title = FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif('position' in opts && invalidOpt(opts.position)) {\n\t\topts.position = { my: opts.position, at: opts.position };\n\t}\n\n\tif('show' in opts && invalidOpt(opts.show)) {\n\t\topts.show = opts.show.jquery ? { target: opts.show } : \n\t\t\topts.show === TRUE ? { ready: TRUE } : { event: opts.show };\n\t}\n\n\tif('hide' in opts && invalidOpt(opts.hide)) {\n\t\topts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };\n\t}\n\n\tif('style' in opts && invalidOpt(opts.style)) {\n\t\topts.style = { classes: opts.style };\n\t}\n\n\t// Sanitize plugin options\n\t$.each(PLUGINS, function() {\n\t\tthis.sanitize && this.sanitize(opts);\n\t});\n\n\treturn opts;\n}\n\n// Setup builtin .set() option checks\nCHECKS = PROTOTYPE.checks = {\n\tbuiltin: {\n\t\t// Core checks\n\t\t'^id$': function(obj, o, v, prev) {\n\t\t\tvar id = v === TRUE ? QTIP.nextid : v,\n\t\t\t\tnew_id = NAMESPACE + '-' + id;\n\n\t\t\tif(id !== FALSE && id.length > 0 && !$('#'+new_id).length) {\n\t\t\t\tthis._id = new_id;\n\n\t\t\t\tif(this.rendered) {\n\t\t\t\t\tthis.tooltip[0].id = this._id;\n\t\t\t\t\tthis.elements.content[0].id = this._id + '-content';\n\t\t\t\t\tthis.elements.title[0].id = this._id + '-title';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { obj[o] = prev; }\n\t\t},\n\t\t'^prerender': function(obj, o, v) {\n\t\t\tv && !this.rendered && this.render(this.options.show.ready);\n\t\t},\n\n\t\t// Content checks\n\t\t'^content.text$': function(obj, o, v) {\n\t\t\tthis._updateContent(v);\n\t\t},\n\t\t'^content.attr$': function(obj, o, v, prev) {\n\t\t\tif(this.options.content.text === this.target.attr(prev)) {\n\t\t\t\tthis._updateContent( this.target.attr(v) );\n\t\t\t}\n\t\t},\n\t\t'^content.title$': function(obj, o, v) {\n\t\t\t// Remove title if content is null\n\t\t\tif(!v) { return this._removeTitle(); }\n\n\t\t\t// If title isn't already created, create it now and update\n\t\t\tv && !this.elements.title && this._createTitle();\n\t\t\tthis._updateTitle(v);\n\t\t},\n\t\t'^content.button$': function(obj, o, v) {\n\t\t\tthis._updateButton(v);\n\t\t},\n\t\t'^content.title.(text|button)$': function(obj, o, v) {\n\t\t\tthis.set('content.'+o, v); // Backwards title.text/button compat\n\t\t}, \n\n\t\t// Position checks\n\t\t'^position.(my|at)$': function(obj, o, v){\n\t\t\t'string' === typeof v && (obj[o] = new CORNER(v, o === 'at'));\n\t\t},\n\t\t'^position.container$': function(obj, o, v){\n\t\t\tthis.rendered && this.tooltip.appendTo(v);\n\t\t},\n\n\t\t// Show checks\n\t\t'^show.ready$': function(obj, o, v) {\n\t\t\tv && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));\n\t\t},\n\n\t\t// Style checks\n\t\t'^style.classes$': function(obj, o, v, p) {\n\t\t\tthis.rendered && this.tooltip.removeClass(p).addClass(v);\n\t\t},\n\t\t'^style.(width|height)': function(obj, o, v) {\n\t\t\tthis.rendered && this.tooltip.css(o, v);\n\t\t},\n\t\t'^style.widget|content.title': function() {\n\t\t\tthis.rendered && this._setWidget();\n\t\t},\n\t\t'^style.def': function(obj, o, v) {\n\t\t\tthis.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);\n\t\t},\n\n\t\t// Events check\n\t\t'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {\n\t\t\tthis.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);\n\t\t},\n\n\t\t// Properties which require event reassignment\n\t\t'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {\n\t\t\tif(!this.rendered) { return; }\n\n\t\t\t// Set tracking flag\n\t\t\tvar posOptions = this.options.position;\n\t\t\tthis.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);\n\n\t\t\t// Reassign events\n\t\t\tthis._unassignEvents();\n\t\t\tthis._assignEvents();\n\t\t}\n\t}\n};\n\n// Dot notation converter\nfunction convertNotation(options, notation) {\n\tvar i = 0, obj, option = options,\n\n\t// Split notation into array\n\tlevels = notation.split('.');\n\n\t// Loop through\n\twhile( option = option[ levels[i++] ] ) {\n\t\tif(i < levels.length) { obj = option; }\n\t}\n\n\treturn [obj || options, levels.pop()];\n}\n\nPROTOTYPE.get = function(notation) {\n\tif(this.destroyed) { return this; }\n\n\tvar o = convertNotation(this.options, notation.toLowerCase()),\n\t\tresult = o[0][ o[1] ];\n\n\treturn result.precedance ? result.string() : result;\n};\n\nfunction setCallback(notation, args) {\n\tvar category, rule, match;\n\n\tfor(category in this.checks) {\n\t\tfor(rule in this.checks[category]) {\n\t\t\tif(match = (new RegExp(rule, 'i')).exec(notation)) {\n\t\t\t\targs.push(match);\n\n\t\t\t\tif(category === 'builtin' || this.plugins[category]) {\n\t\t\t\t\tthis.checks[category][rule].apply(\n\t\t\t\t\t\tthis.plugins[category] || this, args\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar rmove = /^position\\.(my|at|adjust|target|container|viewport)|style|content|show\\.ready/i,\n\trrender = /^prerender|show\\.ready/i;\n\nPROTOTYPE.set = function(option, value) {\n\tif(this.destroyed) { return this; }\n\n\tvar rendered = this.rendered,\n\t\treposition = FALSE,\n\t\toptions = this.options,\n\t\tchecks = this.checks,\n\t\tname;\n\n\t// Convert singular option/value pair into object form\n\tif('string' === typeof option) {\n\t\tname = option; option = {}; option[name] = value;\n\t}\n\telse { option = $.extend({}, option); }\n\n\t// Set all of the defined options to their new values\n\t$.each(option, function(notation, value) {\n\t\tif(rendered && rrender.test(notation)) {\n\t\t\tdelete option[notation]; return;\n\t\t}\n\n\t\t// Set new obj value\n\t\tvar obj = convertNotation(options, notation.toLowerCase()), previous;\n\t\tprevious = obj[0][ obj[1] ];\n\t\tobj[0][ obj[1] ] = value && value.nodeType ? $(value) : value;\n\n\t\t// Also check if we need to reposition\n\t\treposition = rmove.test(notation) || reposition;\n\n\t\t// Set the new params for the callback\n\t\toption[notation] = [obj[0], obj[1], value, previous];\n\t});\n\n\t// Re-sanitize options\n\tsanitizeOptions(options);\n\n\t/*\n\t * Execute any valid callbacks for the set options\n\t * Also set positioning flag so we don't get loads of redundant repositioning calls.\n\t */\n\tthis.positioning = TRUE;\n\t$.each(option, $.proxy(setCallback, this));\n\tthis.positioning = FALSE;\n\n\t// Update position if needed\n\tif(this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {\n\t\tthis.reposition( options.position.target === 'mouse' ? NULL : this.cache.event );\n\t}\n\n\treturn this;\n};\n\n;PROTOTYPE._update = function(content, element, reposition) {\n\tvar self = this,\n\t\tcache = this.cache;\n\n\t// Make sure tooltip is rendered and content is defined. If not return\n\tif(!this.rendered || !content) { return FALSE; }\n\n\t// Use function to parse content\n\tif($.isFunction(content)) {\n\t\tcontent = content.call(this.elements.target, cache.event, this) || '';\n\t}\n\n\t// Handle deferred content\n\tif($.isFunction(content.then)) {\n\t\tcache.waiting = TRUE;\n\t\treturn content.then(function(c) {\n\t\t\tcache.waiting = FALSE;\n\t\t\treturn self._update(c, element);\n\t\t}, NULL, function(e) {\n\t\t\treturn self._update(e, element);\n\t\t});\n\t}\n\n\t// If content is null... return false\n\tif(content === FALSE || (!content && content !== '')) { return FALSE; }\n\n\t// Append new content if its a DOM array and show it if hidden\n\tif(content.jquery && content.length > 0) {\n\t\telement.empty().append(\n\t\t\tcontent.css({ display: 'block', visibility: 'visible' })\n\t\t);\n\t}\n\n\t// Content is a regular string, insert the new content\n\telse { element.html(content); }\n\n\t// Wait for content to be loaded, and reposition\n\treturn this._waitForContent(element).then(function(images) {\n\t\tif(images.images && images.images.length && self.rendered && self.tooltip[0].offsetWidth > 0) {\n\t\t\tself.reposition(cache.event, !images.length);\n\t\t}\n\t});\n};\n\nPROTOTYPE._waitForContent = function(element) {\n\tvar cache = this.cache;\n\t\n\t// Set flag\n\tcache.waiting = TRUE;\n\n\t// If imagesLoaded is included, ensure images have loaded and return promise\n\treturn ( $.fn.imagesLoaded ? element.imagesLoaded() : $.Deferred().resolve([]) )\n\t\t.done(function() { cache.waiting = FALSE; })\n\t\t.promise();\n};\n\nPROTOTYPE._updateContent = function(content, reposition) {\n\tthis._update(content, this.elements.content, reposition);\n};\n\nPROTOTYPE._updateTitle = function(content, reposition) {\n\tif(this._update(content, this.elements.title, reposition) === FALSE) {\n\t\tthis._removeTitle(FALSE);\n\t}\n};\n\nPROTOTYPE._createTitle = function()\n{\n\tvar elements = this.elements,\n\t\tid = this._id+'-title';\n\n\t// Destroy previous title element, if present\n\tif(elements.titlebar) { this._removeTitle(); }\n\n\t// Create title bar and title elements\n\telements.titlebar = $('<div />', {\n\t\t'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')\n\t})\n\t.append(\n\t\telements.title = $('<div />', {\n\t\t\t'id': id,\n\t\t\t'class': NAMESPACE + '-title',\n\t\t\t'aria-atomic': TRUE\n\t\t})\n\t)\n\t.insertBefore(elements.content)\n\n\t// Button-specific events\n\t.delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {\n\t\t$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');\n\t})\n\t.delegate('.qtip-close', 'mouseover mouseout', function(event){\n\t\t$(this).toggleClass('ui-state-hover', event.type === 'mouseover');\n\t});\n\n\t// Create button if enabled\n\tif(this.options.content.button) { this._createButton(); }\n};\n\nPROTOTYPE._removeTitle = function(reposition)\n{\n\tvar elements = this.elements;\n\n\tif(elements.title) {\n\t\telements.titlebar.remove();\n\t\telements.titlebar = elements.title = elements.button = NULL;\n\n\t\t// Reposition if enabled\n\t\tif(reposition !== FALSE) { this.reposition(); }\n\t}\n};\n\n;PROTOTYPE.reposition = function(event, effect) {\n\tif(!this.rendered || this.positioning || this.destroyed) { return this; }\n\n\t// Set positioning flag\n\tthis.positioning = TRUE;\n\n\tvar cache = this.cache,\n\t\ttooltip = this.tooltip,\n\t\tposOptions = this.options.position,\n\t\ttarget = posOptions.target,\n\t\tmy = posOptions.my,\n\t\tat = posOptions.at,\n\t\tviewport = posOptions.viewport,\n\t\tcontainer = posOptions.container,\n\t\tadjust = posOptions.adjust,\n\t\tmethod = adjust.method.split(' '),\n\t\ttooltipWidth = tooltip.outerWidth(FALSE),\n\t\ttooltipHeight = tooltip.outerHeight(FALSE),\n\t\ttargetWidth = 0,\n\t\ttargetHeight = 0,\n\t\ttype = tooltip.css('position'),\n\t\tposition = { left: 0, top: 0 },\n\t\tvisible = tooltip[0].offsetWidth > 0,\n\t\tisScroll = event && event.type === 'scroll',\n\t\twin = $(window),\n\t\tdoc = container[0].ownerDocument,\n\t\tmouse = this.mouse,\n\t\tpluginCalculations, offset;\n\n\t// Check if absolute position was passed\n\tif($.isArray(target) && target.length === 2) {\n\t\t// Force left top and set position\n\t\tat = { x: LEFT, y: TOP };\n\t\tposition = { left: target[0], top: target[1] };\n\t}\n\n\t// Check if mouse was the target\n\telse if(target === 'mouse') {\n\t\t// Force left top to allow flipping\n\t\tat = { x: LEFT, y: TOP };\n\n\t\t// Use the cached mouse coordinates if available, or passed event has no coordinates\n\t\tif(mouse && mouse.pageX && (adjust.mouse || !event || !event.pageX) ) {\n\t\t\tevent = mouse;\n\t\t}\n\t\t\n\t\t// If the passed event has no coordinates (such as a scroll event)\n\t\telse if(!event || !event.pageX) {\n\t\t\t// Use the mouse origin that caused the show event, if distance hiding is enabled\n\t\t\tif((!adjust.mouse || this.options.show.distance) && cache.origin && cache.origin.pageX) {\n\t\t\t\tevent =  cache.origin;\n\t\t\t}\n\n\t\t\t// Use cached event for resize/scroll events\n\t\t\telse if(!event || (event && (event.type === 'resize' || event.type === 'scroll'))) {\n\t\t\t\tevent = cache.event;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate body and container offset and take them into account below\n\t\tif(type !== 'static') { position = container.offset(); }\n\t\tif(doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {\n\t\t\toffset = $(document.body).offset();\n\t\t}\n\n\t\t// Use event coordinates for position\n\t\tposition = {\n\t\t\tleft: event.pageX - position.left + (offset && offset.left || 0),\n\t\t\ttop: event.pageY - position.top + (offset && offset.top || 0)\n\t\t};\n\n\t\t// Scroll events are a pain, some browsers\n\t\tif(adjust.mouse && isScroll && mouse) {\n\t\t\tposition.left -= (mouse.scrollX || 0) - win.scrollLeft();\n\t\t\tposition.top -= (mouse.scrollY || 0) - win.scrollTop();\n\t\t}\n\t}\n\n\t// Target wasn't mouse or absolute...\n\telse {\n\t\t// Check if event targetting is being used\n\t\tif(target === 'event') {\n\t\t\tif(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {\n\t\t\t\tcache.target = $(event.target);\n\t\t\t}\n\t\t\telse if(!event.target) {\n\t\t\t\tcache.target = this.elements.target;\n\t\t\t}\n\t\t}\n\t\telse if(target !== 'event'){\n\t\t\tcache.target = $(target.jquery ? target : this.elements.target);\n\t\t}\n\t\ttarget = cache.target;\n\n\t\t// Parse the target into a jQuery object and make sure there's an element present\n\t\ttarget = $(target).eq(0);\n\t\tif(target.length === 0) { return this; }\n\n\t\t// Check if window or document is the target\n\t\telse if(target[0] === document || target[0] === window) {\n\t\t\ttargetWidth = BROWSER.iOS ? window.innerWidth : target.width();\n\t\t\ttargetHeight = BROWSER.iOS ? window.innerHeight : target.height();\n\n\t\t\tif(target[0] === window) {\n\t\t\t\tposition = {\n\t\t\t\t\ttop: (viewport || target).scrollTop(),\n\t\t\t\t\tleft: (viewport || target).scrollLeft()\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Check if the target is an <AREA> element\n\t\telse if(PLUGINS.imagemap && target.is('area')) {\n\t\t\tpluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);\n\t\t}\n\n\t\t// Check if the target is an SVG element\n\t\telse if(PLUGINS.svg && target && target[0].ownerSVGElement) {\n\t\t\tpluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);\n\t\t}\n\n\t\t// Otherwise use regular jQuery methods\n\t\telse {\n\t\t\ttargetWidth = target.outerWidth(FALSE);\n\t\t\ttargetHeight = target.outerHeight(FALSE);\n\t\t\tposition = target.offset();\n\t\t}\n\n\t\t// Parse returned plugin values into proper variables\n\t\tif(pluginCalculations) {\n\t\t\ttargetWidth = pluginCalculations.width;\n\t\t\ttargetHeight = pluginCalculations.height;\n\t\t\toffset = pluginCalculations.offset;\n\t\t\tposition = pluginCalculations.position;\n\t\t}\n\n\t\t// Adjust position to take into account offset parents\n\t\tposition = this.reposition.offset(target, position, container);\n\n\t\t// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)\n\t\tif((BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1) || \n\t\t\t(BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33) || \n\t\t\t(!BROWSER.iOS && type === 'fixed')\n\t\t){\n\t\t\tposition.left -= win.scrollLeft();\n\t\t\tposition.top -= win.scrollTop();\n\t\t}\n\n\t\t// Adjust position relative to target\n\t\tif(!pluginCalculations || (pluginCalculations && pluginCalculations.adjustable !== FALSE)) {\n\t\t\tposition.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;\n\t\t\tposition.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;\n\t\t}\n\t}\n\n\t// Adjust position relative to tooltip\n\tposition.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);\n\tposition.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);\n\n\t// Use viewport adjustment plugin if enabled\n\tif(PLUGINS.viewport) {\n\t\tposition.adjusted = PLUGINS.viewport(\n\t\t\tthis, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight\n\t\t);\n\n\t\t// Apply offsets supplied by positioning plugin (if used)\n\t\tif(offset && position.adjusted.left) { position.left += offset.left; }\n\t\tif(offset && position.adjusted.top) {  position.top += offset.top; }\n\t}\n\n\t// Viewport adjustment is disabled, set values to zero\n\telse { position.adjusted = { left: 0, top: 0 }; }\n\n\t// tooltipmove event\n\tif(!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }\n\tdelete position.adjusted;\n\n\t// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly\n\tif(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {\n\t\ttooltip.css(position);\n\t}\n\n\t// Use custom function if provided\n\telse if($.isFunction(posOptions.effect)) {\n\t\tposOptions.effect.call(tooltip, this, $.extend({}, position));\n\t\ttooltip.queue(function(next) {\n\t\t\t// Reset attributes to avoid cross-browser rendering bugs\n\t\t\t$(this).css({ opacity: '', height: '' });\n\t\t\tif(BROWSER.ie) { this.style.removeAttribute('filter'); }\n\n\t\t\tnext();\n\t\t});\n\t}\n\n\t// Set positioning flag\n\tthis.positioning = FALSE;\n\n\treturn this;\n};\n\n// Custom (more correct for qTip!) offset calculator\nPROTOTYPE.reposition.offset = function(elem, pos, container) {\n\tif(!container[0]) { return pos; }\n\n\tvar ownerDocument = $(elem[0].ownerDocument),\n\t\tquirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',\n\t\tparent = container[0],\n\t\tscrolled, position, parentOffset, overflow;\n\n\tfunction scroll(e, i) {\n\t\tpos.left += i * e.scrollLeft();\n\t\tpos.top += i * e.scrollTop();\n\t}\n\n\t// Compensate for non-static containers offset\n\tdo {\n\t\tif((position = $.css(parent, 'position')) !== 'static') {\n\t\t\tif(position === 'fixed') {\n\t\t\t\tparentOffset = parent.getBoundingClientRect();\n\t\t\t\tscroll(ownerDocument, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparentOffset = $(parent).position();\n\t\t\t\tparentOffset.left += (parseFloat($.css(parent, 'borderLeftWidth')) || 0);\n\t\t\t\tparentOffset.top += (parseFloat($.css(parent, 'borderTopWidth')) || 0);\n\t\t\t}\n\n\t\t\tpos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);\n\t\t\tpos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);\n\n\t\t\t// If this is the first parent element with an overflow of \"scroll\" or \"auto\", store it\n\t\t\tif(!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }\n\t\t}\n\t}\n\twhile((parent = parent.offsetParent));\n\n\t// Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)\n\tif(scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {\n\t\tscroll(scrolled, 1);\n\t}\n\n\treturn pos;\n};\n\n// Corner class\nvar C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {\n\tcorner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();\n\tthis.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();\n\tthis.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();\n\tthis.forceY = !!forceY;\n\n\tvar f = corner.charAt(0);\n\tthis.precedance = (f === 't' || f === 'b' ? Y : X);\n}).prototype;\n\nC.invert = function(z, center) {\n\tthis[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];\t\n};\n\nC.string = function() {\n\tvar x = this.x, y = this.y;\n\treturn x === y ? x : this.precedance === Y || (this.forceY && y !== 'center') ? y+' '+x : x+' '+y;\n};\n\nC.abbrev = function() {\n\tvar result = this.string().split(' ');\n\treturn result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');\n};\n\nC.clone = function() {\n\treturn new CORNER( this.string(), this.forceY );\n};;\nPROTOTYPE.toggle = function(state, event) {\n\tvar cache = this.cache,\n\t\toptions = this.options,\n\t\ttooltip = this.tooltip;\n\n\t// Try to prevent flickering when tooltip overlaps show element\n\tif(event) {\n\t\tif((/over|enter/).test(event.type) && (/out|leave/).test(cache.event.type) &&\n\t\t\toptions.show.target.add(event.target).length === options.show.target.length &&\n\t\t\ttooltip.has(event.relatedTarget).length) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Cache event\n\t\tcache.event = cloneEvent(event);\n\t}\n\t\t\n\t// If we're currently waiting and we've just hidden... stop it\n\tthis.waiting && !state && (this.hiddenDuringWait = TRUE);\n\n\t// Render the tooltip if showing and it isn't already\n\tif(!this.rendered) { return state ? this.render(1) : this; }\n\telse if(this.destroyed || this.disabled) { return this; }\n\n\tvar type = state ? 'show' : 'hide',\n\t\topts = this.options[type],\n\t\totherOpts = this.options[ !state ? 'show' : 'hide' ],\n\t\tposOptions = this.options.position,\n\t\tcontentOptions = this.options.content,\n\t\twidth = this.tooltip.css('width'),\n\t\tvisible = this.tooltip.is(':visible'),\n\t\tanimate = state || opts.target.length === 1,\n\t\tsameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,\n\t\tidenticalState, allow, showEvent, delay, after;\n\n\t// Detect state if valid one isn't provided\n\tif((typeof state).search('boolean|number')) { state = !visible; }\n\n\t// Check if the tooltip is in an identical state to the new would-be state\n\tidenticalState = !tooltip.is(':animated') && visible === state && sameTarget;\n\n\t// Fire tooltip(show/hide) event and check if destroyed\n\tallow = !identicalState ? !!this._trigger(type, [90]) : NULL;\n\n\t// Check to make sure the tooltip wasn't destroyed in the callback\n\tif(this.destroyed) { return this; }\n\n\t// If the user didn't stop the method prematurely and we're showing the tooltip, focus it\n\tif(allow !== FALSE && state) { this.focus(event); }\n\n\t// If the state hasn't changed or the user stopped it, return early\n\tif(!allow || identicalState) { return this; }\n\n\t// Set ARIA hidden attribute\n\t$.attr(tooltip[0], 'aria-hidden', !!!state);\n\n\t// Execute state specific properties\n\tif(state) {\n\t\t// Store show origin coordinates\n\t\tcache.origin = cloneEvent(this.mouse);\n\n\t\t// Update tooltip content & title if it's a dynamic function\n\t\tif($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }\n\t\tif($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }\n\n\t\t// Cache mousemove events for positioning purposes (if not already tracking)\n\t\tif(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {\n\t\t\t$(document).bind('mousemove.'+NAMESPACE, this._storeMouse);\n\t\t\ttrackingBound = TRUE;\n\t\t}\n\n\t\t// Update the tooltip position (set width first to prevent viewport/max-width issues)\n\t\tif(!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }\n\t\tthis.reposition(event, arguments[2]);\n\t\tif(!width) { tooltip.css('width', ''); }\n\n\t\t// Hide other tooltips if tooltip is solo\n\t\tif(!!opts.solo) {\n\t\t\t(typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))\n\t\t\t\t.not(tooltip).not(opts.target).qtip('hide', $.Event('tooltipsolo'));\n\t\t}\n\t}\n\telse {\n\t\t// Clear show timer if we're hiding\n\t\tclearTimeout(this.timers.show);\n\n\t\t// Remove cached origin on hide\n\t\tdelete cache.origin;\n\n\t\t// Remove mouse tracking event if not needed (all tracking qTips are hidden)\n\t\tif(trackingBound && !$(SELECTOR+'[tracking=\"true\"]:visible', opts.solo).not(tooltip).length) {\n\t\t\t$(document).unbind('mousemove.'+NAMESPACE);\n\t\t\ttrackingBound = FALSE;\n\t\t}\n\n\t\t// Blur the tooltip\n\t\tthis.blur(event);\n\t}\n\n\t// Define post-animation, state specific properties\n\tafter = $.proxy(function() {\n\t\tif(state) {\n\t\t\t// Prevent antialias from disappearing in IE by removing filter\n\t\t\tif(BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }\n\n\t\t\t// Remove overflow setting to prevent tip bugs\n\t\t\ttooltip.css('overflow', '');\n\n\t\t\t// Autofocus elements if enabled\n\t\t\tif('string' === typeof opts.autofocus) {\n\t\t\t\t$(this.options.show.autofocus, tooltip).focus();\n\t\t\t}\n\n\t\t\t// If set, hide tooltip when inactive for delay period\n\t\t\tthis.options.show.target.trigger('qtip-'+this.id+'-inactive');\n\t\t}\n\t\telse {\n\t\t\t// Reset CSS states\n\t\t\ttooltip.css({\n\t\t\t\tdisplay: '',\n\t\t\t\tvisibility: '',\n\t\t\t\topacity: '',\n\t\t\t\tleft: '',\n\t\t\t\ttop: ''\n\t\t\t});\n\t\t}\n\n\t\t// tooltipvisible/tooltiphidden events\n\t\tthis._trigger(state ? 'visible' : 'hidden');\n\t}, this);\n\n\t// If no effect type is supplied, use a simple toggle\n\tif(opts.effect === FALSE || animate === FALSE) {\n\t\ttooltip[ type ]();\n\t\tafter();\n\t}\n\n\t// Use custom function if provided\n\telse if($.isFunction(opts.effect)) {\n\t\ttooltip.stop(1, 1);\n\t\topts.effect.call(tooltip, this);\n\t\ttooltip.queue('fx', function(n) {\n\t\t\tafter(); n();\n\t\t});\n\t}\n\n\t// Use basic fade function by default\n\telse { tooltip.fadeTo(90, state ? 1 : 0, after); }\n\n\t// If inactive hide method is set, active it\n\tif(state) { opts.target.trigger('qtip-'+this.id+'-inactive'); }\n\n\treturn this;\n};\n\nPROTOTYPE.show = function(event) { return this.toggle(TRUE, event); };\n\nPROTOTYPE.hide = function(event) { return this.toggle(FALSE, event); };\n\n;PROTOTYPE.focus = function(event) {\n\tif(!this.rendered || this.destroyed) { return this; }\n\n\tvar qtips = $(SELECTOR),\n\t\ttooltip = this.tooltip,\n\t\tcurIndex = parseInt(tooltip[0].style.zIndex, 10),\n\t\tnewIndex = QTIP.zindex + qtips.length,\n\t\tfocusedElem;\n\n\t// Only update the z-index if it has changed and tooltip is not already focused\n\tif(!tooltip.hasClass(CLASS_FOCUS)) {\n\t\t// tooltipfocus event\n\t\tif(this._trigger('focus', [newIndex], event)) {\n\t\t\t// Only update z-index's if they've changed\n\t\t\tif(curIndex !== newIndex) {\n\t\t\t\t// Reduce our z-index's and keep them properly ordered\n\t\t\t\tqtips.each(function() {\n\t\t\t\t\tif(this.style.zIndex > curIndex) {\n\t\t\t\t\t\tthis.style.zIndex = this.style.zIndex - 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Fire blur event for focused tooltip\n\t\t\t\tqtips.filter('.' + CLASS_FOCUS).qtip('blur', event);\n\t\t\t}\n\n\t\t\t// Set the new z-index\n\t\t\ttooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\n\t\t}\n\t}\n\n\treturn this;\n};\n\nPROTOTYPE.blur = function(event) {\n\tif(!this.rendered || this.destroyed) { return this; }\n\n\t// Set focused status to FALSE\n\tthis.tooltip.removeClass(CLASS_FOCUS);\n\n\t// tooltipblur event\n\tthis._trigger('blur', [ this.tooltip.css('zIndex') ], event);\n\n\treturn this;\n};\n\n;PROTOTYPE.disable = function(state) {\n\tif(this.destroyed) { return this; }\n\n\t// If 'toggle' is passed, toggle the current state\n\tif(state === 'toggle') {\n\t\tstate = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);\n\t}\n\n\t// Disable if no state passed\n\telse if('boolean' !== typeof state) {\n\t\tstate = TRUE;\n\t}\n\n\tif(this.rendered) {\n\t\tthis.tooltip.toggleClass(CLASS_DISABLED, state)\n\t\t\t.attr('aria-disabled', state);\n\t}\n\n\tthis.disabled = !!state;\n\n\treturn this;\n};\n\nPROTOTYPE.enable = function() { return this.disable(FALSE); };\n\n;PROTOTYPE._createButton = function()\n{\n\tvar self = this,\n\t\telements = this.elements,\n\t\ttooltip = elements.tooltip,\n\t\tbutton = this.options.content.button,\n\t\tisString = typeof button === 'string',\n\t\tclose = isString ? button : 'Close tooltip';\n\n\tif(elements.button) { elements.button.remove(); }\n\n\t// Use custom button if one was supplied by user, else use default\n\tif(button.jquery) {\n\t\telements.button = button;\n\t}\n\telse {\n\t\telements.button = $('<a />', {\n\t\t\t'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE+'-icon'),\n\t\t\t'title': close,\n\t\t\t'aria-label': close\n\t\t})\n\t\t.prepend(\n\t\t\t$('<span />', {\n\t\t\t\t'class': 'ui-icon ui-icon-close',\n\t\t\t\t'html': '&times;'\n\t\t\t})\n\t\t);\n\t}\n\n\t// Create button and setup attributes\n\telements.button.appendTo(elements.titlebar || tooltip)\n\t\t.attr('role', 'button')\n\t\t.click(function(event) {\n\t\t\tif(!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }\n\t\t\treturn FALSE;\n\t\t});\n};\n\nPROTOTYPE._updateButton = function(button)\n{\n\t// Make sure tooltip is rendered and if not, return\n\tif(!this.rendered) { return FALSE; }\n\n\tvar elem = this.elements.button;\n\tif(button) { this._createButton(); }\n\telse { elem.remove(); }\n};\n\n;// Widget class creator\nfunction createWidgetClass(cls) {\n\treturn WIDGET.concat('').join(cls ? '-'+cls+' ' : ' ');\n}\n\n// Widget class setter method\nPROTOTYPE._setWidget = function()\n{\n\tvar on = this.options.style.widget,\n\t\telements = this.elements,\n\t\ttooltip = elements.tooltip,\n\t\tdisabled = tooltip.hasClass(CLASS_DISABLED);\n\n\ttooltip.removeClass(CLASS_DISABLED);\n\tCLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';\n\ttooltip.toggleClass(CLASS_DISABLED, disabled);\n\n\ttooltip.toggleClass('ui-helper-reset '+createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);\n\t\n\tif(elements.content) {\n\t\telements.content.toggleClass( createWidgetClass('content'), on);\n\t}\n\tif(elements.titlebar) {\n\t\telements.titlebar.toggleClass( createWidgetClass('header'), on);\n\t}\n\tif(elements.button) {\n\t\telements.button.toggleClass(NAMESPACE+'-icon', !on);\n\t}\n};;function cloneEvent(event) {\n\treturn event && {\n\t\ttype: event.type,\n\t\tpageX: event.pageX,\n\t\tpageY: event.pageY,\n\t\ttarget: event.target,\n\t\trelatedTarget: event.relatedTarget,\n\t\tscrollX: event.scrollX || window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft,\n\t\tscrollY: event.scrollY || window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop\n\t} || {};\n}\n\nfunction delay(callback, duration) {\n\t// If tooltip has displayed, start hide timer\n\tif(duration > 0) {\n\t\treturn setTimeout(\n\t\t\t$.proxy(callback, this), duration\n\t\t);\n\t}\n\telse{ callback.call(this); }\n}\n\nfunction showMethod(event) {\n\tif(this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }\n\n\t// Clear hide timers\n\tclearTimeout(this.timers.show);\n\tclearTimeout(this.timers.hide);\n\n\t// Start show timer\n\tthis.timers.show = delay.call(this,\n\t\tfunction() { this.toggle(TRUE, event); },\n\t\tthis.options.show.delay\n\t);\n}\n\nfunction hideMethod(event) {\n\tif(this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }\n\n\t// Check if new target was actually the tooltip element\n\tvar relatedTarget = $(event.relatedTarget),\n\t\tontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],\n\t\tontoTarget = relatedTarget[0] === this.options.show.target[0];\n\n\t// Clear timers and stop animation queue\n\tclearTimeout(this.timers.show);\n\tclearTimeout(this.timers.hide);\n\n\t// Prevent hiding if tooltip is fixed and event target is the tooltip.\n\t// Or if mouse positioning is enabled and cursor momentarily overlaps\n\tif(this !== relatedTarget[0] && \n\t\t(this.options.position.target === 'mouse' && ontoTooltip) || \n\t\t(this.options.hide.fixed && (\n\t\t\t(/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))\n\t\t))\n\t{\n\t\ttry {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopImmediatePropagation();\n\t\t} catch(e) {}\n\n\t\treturn;\n\t}\n\n\t// If tooltip has displayed, start hide timer\n\tthis.timers.hide = delay.call(this,\n\t\tfunction() { this.toggle(FALSE, event); },\n\t\tthis.options.hide.delay,\n\t\tthis\n\t);\n}\n\nfunction inactiveMethod(event) {\n\tif(this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return FALSE; }\n\n\t// Clear timer\n\tclearTimeout(this.timers.inactive);\n\n\tthis.timers.inactive = delay.call(this,\n\t\tfunction(){ this.hide(event); },\n\t\tthis.options.hide.inactive\n\t);\n}\n\nfunction repositionMethod(event) {\n\tif(this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }\n}\n\n// Store mouse coordinates\nPROTOTYPE._storeMouse = function(event) {\n\t(this.mouse = cloneEvent(event)).type = 'mousemove';\n};\n\n// Bind events\nPROTOTYPE._bind = function(targets, events, method, suffix, context) {\n\tvar ns = '.' + this._id + (suffix ? '-'+suffix : '');\n\tevents.length && $(targets).bind(\n\t\t(events.split ? events : events.join(ns + ' ')) + ns,\n\t\t$.proxy(method, context || this)\n\t);\n};\nPROTOTYPE._unbind = function(targets, suffix) {\n\t$(targets).unbind('.' + this._id + (suffix ? '-'+suffix : ''));\n};\n\n// Apply common event handlers using delegate (avoids excessive .bind calls!)\nvar ns = '.'+NAMESPACE;\nfunction delegate(selector, events, method) {\t\n\t$(document.body).delegate(selector,\n\t\t(events.split ? events : events.join(ns + ' ')) + ns,\n\t\tfunction() {\n\t\t\tvar api = QTIP.api[ $.attr(this, ATTR_ID) ];\n\t\t\tapi && !api.disabled && method.apply(api, arguments);\n\t\t}\n\t);\n}\n\n$(function() {\n\tdelegate(SELECTOR, ['mouseenter', 'mouseleave'], function(event) {\n\t\tvar state = event.type === 'mouseenter',\n\t\t\ttooltip = $(event.currentTarget),\n\t\t\ttarget = $(event.relatedTarget || event.target),\n\t\t\toptions = this.options;\n\n\t\t// On mouseenter...\n\t\tif(state) {\n\t\t\t// Focus the tooltip on mouseenter (z-index stacking)\n\t\t\tthis.focus(event);\n\n\t\t\t// Clear hide timer on tooltip hover to prevent it from closing\n\t\t\ttooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);\n\t\t}\n\n\t\t// On mouseleave...\n\t\telse {\n\t\t\t// Hide when we leave the tooltip and not onto the show target (if a hide event is set)\n\t\t\tif(options.position.target === 'mouse' && options.hide.event && \n\t\t\t\toptions.show.target && !target.closest(options.show.target[0]).length) {\n\t\t\t\tthis.hide(event);\n\t\t\t}\n\t\t}\n\n\t\t// Add hover class\n\t\ttooltip.toggleClass(CLASS_HOVER, state);\n\t});\n\n\t// Define events which reset the 'inactive' event handler\n\tdelegate('['+ATTR_ID+']', INACTIVE_EVENTS, inactiveMethod);\n});\n\n// Event trigger\nPROTOTYPE._trigger = function(type, args, event) {\n\tvar callback = $.Event('tooltip'+type);\n\tcallback.originalEvent = (event && $.extend({}, event)) || this.cache.event || NULL;\n\n\tthis.triggering = type;\n\tthis.tooltip.trigger(callback, [this].concat(args || []));\n\tthis.triggering = FALSE;\n\n\treturn !callback.isDefaultPrevented();\n};\n\nPROTOTYPE._bindEvents = function(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod) {\n\t// If hide and show targets are the same...\n\tif(hideTarget.add(showTarget).length === hideTarget.length) {\n\t\tvar toggleEvents = [];\n\n\t\t// Filter identical show/hide events\n\t\thideEvents = $.map(hideEvents, function(type) {\n\t\t\tvar showIndex = $.inArray(type, showEvents);\n\n\t\t\t// Both events are identical, remove from both hide and show events\n\t\t\t// and append to toggleEvents\n\t\t\tif(showIndex > -1) {\n\t\t\t\ttoggleEvents.push( showEvents.splice( showIndex, 1 )[0] );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn type;\n\t\t});\n\n\t\t// Toggle events are special case of identical show/hide events, which happen in sequence\n\t\ttoggleEvents.length && this._bind(showTarget, toggleEvents, function(event) {\n\t\t\tvar state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;\n\t\t\t(state ? hideMethod : showMethod).call(this, event);\n\t\t});\n\t}\n\n\t// Apply show/hide/toggle events\n\tthis._bind(showTarget, showEvents, showMethod);\n\tthis._bind(hideTarget, hideEvents, hideMethod);\n};\n\nPROTOTYPE._assignInitialEvents = function(event) {\n\tvar options = this.options,\n\t\tshowTarget = options.show.target,\n\t\thideTarget = options.hide.target,\n\t\tshowEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n\t\thideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];\n\n\t/*\n\t * Make sure hoverIntent functions properly by using mouseleave as a hide event if\n\t * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n\t */\n\tif(/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {\n\t\thideEvents.push('mouseleave');\n\t}\n\n\t/*\n\t * Also make sure initial mouse targetting works correctly by caching mousemove coords\n\t * on show targets before the tooltip has rendered. Also set onTarget when triggered to\n\t * keep mouse tracking working.\n\t */\n\tthis._bind(showTarget, 'mousemove', function(event) {\n\t\tthis._storeMouse(event);\n\t\tthis.cache.onTarget = TRUE;\n\t});\n\n\t// Define hoverIntent function\n\tfunction hoverIntent(event) {\n\t\t// Only continue if tooltip isn't disabled\n\t\tif(this.disabled || this.destroyed) { return FALSE; }\n\n\t\t// Cache the event data\n\t\tthis.cache.event = cloneEvent(event);\n\t\tthis.cache.target = event ? $(event.target) : [undefined];\n\n\t\t// Start the event sequence\n\t\tclearTimeout(this.timers.show);\n\t\tthis.timers.show = delay.call(this,\n\t\t\tfunction() { this.render(typeof event === 'object' || options.show.ready); },\n\t\t\toptions.show.delay\n\t\t);\n\t}\n\n\t// Filter and bind events\n\tthis._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {\n\t\tclearTimeout(this.timers.show);\n\t});\n\n\t// Prerendering is enabled, create tooltip now\n\tif(options.show.ready || options.prerender) { hoverIntent.call(this, event); }\n};\n\n// Event assignment method\nPROTOTYPE._assignEvents = function() {\n\tvar self = this,\n\t\toptions = this.options,\n\t\tposOptions = options.position,\n\n\t\ttooltip = this.tooltip,\n\t\tshowTarget = options.show.target,\n\t\thideTarget = options.hide.target,\n\t\tcontainerTarget = posOptions.container,\n\t\tviewportTarget = posOptions.viewport,\n\t\tdocumentTarget = $(document),\n\t\tbodyTarget = $(document.body),\n\t\twindowTarget = $(window),\n\n\t\tshowEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n\t\thideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];\n\n\n\t// Assign passed event callbacks\n\t$.each(options.events, function(name, callback) {\n\t\tself._bind(tooltip, name === 'toggle' ? ['tooltipshow','tooltiphide'] : ['tooltip'+name], callback, null, tooltip);\n\t});\n\n\t// Hide tooltips when leaving current window/frame (but not select/option elements)\n\tif(/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {\n\t\tthis._bind(documentTarget, ['mouseout', 'blur'], function(event) {\n\t\t\tif(!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {\n\t\t\t\tthis.hide(event);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Enable hide.fixed by adding appropriate class\n\tif(options.hide.fixed) {\n\t\thideTarget = hideTarget.add( tooltip.addClass(CLASS_FIXED) );\n\t}\n\n\t/*\n\t * Make sure hoverIntent functions properly by using mouseleave to clear show timer if\n\t * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n\t */\n\telse if(/mouse(over|enter)/i.test(options.show.event)) {\n\t\tthis._bind(hideTarget, 'mouseleave', function() {\n\t\t\tclearTimeout(this.timers.show);\n\t\t});\n\t}\n\n\t// Hide tooltip on document mousedown if unfocus events are enabled\n\tif(('' + options.hide.event).indexOf('unfocus') > -1) {\n\t\tthis._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function(event) {\n\t\t\tvar elem = $(event.target),\n\t\t\t\tenabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,\n\t\t\t\tisAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;\n\n\t\t\tif(elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&\n\t\t\t\t!this.target.has(elem[0]).length && enabled\n\t\t\t) {\n\t\t\t\tthis.hide(event);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Check if the tooltip hides when inactive\n\tif('number' === typeof options.hide.inactive) {\n\t\t// Bind inactive method to show target(s) as a custom event\n\t\tthis._bind(showTarget, 'qtip-'+this.id+'-inactive', inactiveMethod);\n\n\t\t// Define events which reset the 'inactive' event handler\n\t\tthis._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod, '-inactive');\n\t}\n\n\t// Filter and bind events\n\tthis._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);\n\n\t// Mouse movement bindings\n\tthis._bind(showTarget.add(tooltip), 'mousemove', function(event) {\n\t\t// Check if the tooltip hides when mouse is moved a certain distance\n\t\tif('number' === typeof options.hide.distance) {\n\t\t\tvar origin = this.cache.origin || {},\n\t\t\t\tlimit = this.options.hide.distance,\n\t\t\t\tabs = Math.abs;\n\n\t\t\t// Check if the movement has gone beyond the limit, and hide it if so\n\t\t\tif(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {\n\t\t\t\tthis.hide(event);\n\t\t\t}\n\t\t}\n\n\t\t// Cache mousemove coords on show targets\n\t\tthis._storeMouse(event);\n\t});\n\n\t// Mouse positioning events\n\tif(posOptions.target === 'mouse') {\n\t\t// If mouse adjustment is on...\n\t\tif(posOptions.adjust.mouse) {\n\t\t\t// Apply a mouseleave event so we don't get problems with overlapping\n\t\t\tif(options.hide.event) {\n\t\t\t\t// Track if we're on the target or not\n\t\t\t\tthis._bind(showTarget, ['mouseenter', 'mouseleave'], function(event) {\n\t\t\t\t\tthis.cache.onTarget = event.type === 'mouseenter';\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Update tooltip position on mousemove\n\t\t\tthis._bind(documentTarget, 'mousemove', function(event) {\n\t\t\t\t// Update the tooltip position only if the tooltip is visible and adjustment is enabled\n\t\t\t\tif(this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {\n\t\t\t\t\tthis.reposition(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t// Adjust positions of the tooltip on window resize if enabled\n\tif(posOptions.adjust.resize || viewportTarget.length) {\n\t\tthis._bind( $.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod );\n\t}\n\n\t// Adjust tooltip position on scroll of the window or viewport element if present\n\tif(posOptions.adjust.scroll) {\n\t\tthis._bind( windowTarget.add(posOptions.container), 'scroll', repositionMethod );\n\t}\n};\n\n// Un-assignment method\nPROTOTYPE._unassignEvents = function() {\n\tvar targets = [\n\t\tthis.options.show.target[0],\n\t\tthis.options.hide.target[0],\n\t\tthis.rendered && this.tooltip[0],\n\t\tthis.options.position.container[0],\n\t\tthis.options.position.viewport[0],\n\t\tthis.options.position.container.closest('html')[0], // unfocus\n\t\twindow,\n\t\tdocument\n\t];\n\n\tthis._unbind($([]).pushStack( $.grep(targets, function(i) {\n\t\treturn typeof i === 'object';\n\t})));\n};\n\n;// Initialization method\nfunction init(elem, id, opts) {\n\tvar obj, posOptions, attr, config, title,\n\n\t// Setup element references\n\tdocBody = $(document.body),\n\n\t// Use document body instead of document element if needed\n\tnewTarget = elem[0] === document ? docBody : elem,\n\n\t// Grab metadata from element if plugin is present\n\tmetadata = (elem.metadata) ? elem.metadata(opts.metadata) : NULL,\n\n\t// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise\n\tmetadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,\n\n\t// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,\n\thtml5 = elem.data(opts.metadata.name || 'qtipopts');\n\n\t// If we don't get an object returned attempt to parse it manualyl without parseJSON\n\ttry { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; } catch(e) {}\n\n\t// Merge in and sanitize metadata\n\tconfig = $.extend(TRUE, {}, QTIP.defaults, opts,\n\t\ttypeof html5 === 'object' ? sanitizeOptions(html5) : NULL,\n\t\tsanitizeOptions(metadata5 || metadata));\n\n\t// Re-grab our positioning options now we've merged our metadata and set id to passed value\n\tposOptions = config.position;\n\tconfig.id = id;\n\n\t// Setup missing content if none is detected\n\tif('boolean' === typeof config.content.text) {\n\t\tattr = elem.attr(config.content.attr);\n\n\t\t// Grab from supplied attribute if available\n\t\tif(config.content.attr !== FALSE && attr) { config.content.text = attr; }\n\n\t\t// No valid content was found, abort render\n\t\telse { return FALSE; }\n\t}\n\n\t// Setup target options\n\tif(!posOptions.container.length) { posOptions.container = docBody; }\n\tif(posOptions.target === FALSE) { posOptions.target = newTarget; }\n\tif(config.show.target === FALSE) { config.show.target = newTarget; }\n\tif(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }\n\tif(config.hide.target === FALSE) { config.hide.target = newTarget; }\n\tif(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }\n\n\t// Ensure we only use a single container\n\tposOptions.container = posOptions.container.eq(0);\n\n\t// Convert position corner values into x and y strings\n\tposOptions.at = new CORNER(posOptions.at, TRUE);\n\tposOptions.my = new CORNER(posOptions.my);\n\n\t// Destroy previous tooltip if overwrite is enabled, or skip element if not\n\tif(elem.data(NAMESPACE)) {\n\t\tif(config.overwrite) {\n\t\t\telem.qtip('destroy', true);\n\t\t}\n\t\telse if(config.overwrite === FALSE) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t// Add has-qtip attribute\n\telem.attr(ATTR_HAS, id);\n\n\t// Remove title attribute and store it if present\n\tif(config.suppress && (title = elem.attr('title'))) {\n\t\t// Final attr call fixes event delegatiom and IE default tooltip showing problem\n\t\telem.removeAttr('title').attr(oldtitle, title).attr('title', '');\n\t}\n\n\t// Initialize the tooltip and add API reference\n\tobj = new QTip(elem, config, id, !!attr);\n\telem.data(NAMESPACE, obj);\n\n\t// Catch remove/removeqtip events on target element to destroy redundant tooltip\n\telem.one('remove.qtip-'+id+' removeqtip.qtip-'+id, function() { \n\t\tvar api; if((api = $(this).data(NAMESPACE))) { api.destroy(true); }\n\t});\n\n\treturn obj;\n}\n\n// jQuery $.fn extension method\nQTIP = $.fn.qtip = function(options, notation, newValue)\n{\n\tvar command = ('' + options).toLowerCase(), // Parse command\n\t\treturned = NULL,\n\t\targs = $.makeArray(arguments).slice(1),\n\t\tevent = args[args.length - 1],\n\t\topts = this[0] ? $.data(this[0], NAMESPACE) : NULL;\n\n\t// Check for API request\n\tif((!arguments.length && opts) || command === 'api') {\n\t\treturn opts;\n\t}\n\n\t// Execute API command if present\n\telse if('string' === typeof options) {\n\t\tthis.each(function() {\n\t\t\tvar api = $.data(this, NAMESPACE);\n\t\t\tif(!api) { return TRUE; }\n\n\t\t\t// Cache the event if possible\n\t\t\tif(event && event.timeStamp) { api.cache.event = event; }\n\n\t\t\t// Check for specific API commands\n\t\t\tif(notation && (command === 'option' || command === 'options')) {\n\t\t\t\tif(newValue !== undefined || $.isPlainObject(notation)) {\n\t\t\t\t\tapi.set(notation, newValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturned = api.get(notation);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Execute API command\n\t\t\telse if(api[command]) {\n\t\t\t\tapi[command].apply(api, args);\n\t\t\t}\n\t\t});\n\n\t\treturn returned !== NULL ? returned : this;\n\t}\n\n\t// No API commands. validate provided options and setup qTips\n\telse if('object' === typeof options || !arguments.length) {\n\t\t// Sanitize options first\n\t\topts = sanitizeOptions($.extend(TRUE, {}, options));\n\n\t\treturn this.each(function(i) {\n\t\t\tvar api, id;\n\n\t\t\t// Find next available ID, or use custom ID if provided\n\t\t\tid = $.isArray(opts.id) ? opts.id[i] : opts.id;\n\t\t\tid = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;\n\n\t\t\t// Initialize the qTip and re-grab newly sanitized options\n\t\t\tapi = init($(this), id, opts);\n\t\t\tif(api === FALSE) { return TRUE; }\n\t\t\telse { QTIP.api[id] = api; }\n\n\t\t\t// Initialize plugins\n\t\t\t$.each(PLUGINS, function() {\n\t\t\t\tif(this.initialize === 'initialize') { this(api); }\n\t\t\t});\n\n\t\t\t// Assign initial pre-render events\n\t\t\tapi._assignInitialEvents(event);\n\t\t});\n\t}\n};\n\n// Expose class\n$.qtip = QTip;\n\n// Populated in render method\nQTIP.api = {};\n;$.each({\n\t/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */\n\tattr: function(attr, val) {\n\t\tif(this.length) {\n\t\t\tvar self = this[0],\n\t\t\t\ttitle = 'title',\n\t\t\t\tapi = $.data(self, 'qtip');\n\n\t\t\tif(attr === title && api && 'object' === typeof api && api.options.suppress) {\n\t\t\t\tif(arguments.length < 2) {\n\t\t\t\t\treturn $.attr(self, oldtitle);\n\t\t\t\t}\n\n\t\t\t\t// If qTip is rendered and title was originally used as content, update it\n\t\t\t\tif(api && api.options.content.attr === title && api.cache.attr) {\n\t\t\t\t\tapi.set('content.text', val);\n\t\t\t\t}\n\n\t\t\t\t// Use the regular attr method to set, then cache the result\n\t\t\t\treturn this.attr(oldtitle, val);\n\t\t\t}\n\t\t}\n\n\t\treturn $.fn['attr'+replaceSuffix].apply(this, arguments);\n\t},\n\n\t/* Allow clone to correctly retrieve cached title attributes */\n\tclone: function(keepData) {\n\t\tvar titles = $([]), title = 'title',\n\n\t\t// Clone our element using the real clone method\n\t\telems = $.fn['clone'+replaceSuffix].apply(this, arguments);\n\n\t\t// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false\n\t\tif(!keepData) {\n\t\t\telems.filter('['+oldtitle+']').attr('title', function() {\n\t\t\t\treturn $.attr(this, oldtitle);\n\t\t\t})\n\t\t\t.removeAttr(oldtitle);\n\t\t}\n\n\t\treturn elems;\n\t}\n}, function(name, func) {\n\tif(!func || $.fn[name+replaceSuffix]) { return TRUE; }\n\n\tvar old = $.fn[name+replaceSuffix] = $.fn[name];\n\t$.fn[name] = function() {\n\t\treturn func.apply(this, arguments) || old.apply(this, arguments);\n\t};\n});\n\n/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).\n * This snippet is taken directly from jQuery UI source code found here:\n *     http://code.jquery.com/ui/jquery-ui-git.js\n */\nif(!$.ui) {\n\t$['cleanData'+replaceSuffix] = $.cleanData;\n\t$.cleanData = function( elems ) {\n\t\tfor(var i = 0, elem; (elem = $( elems[i] )).length; i++) {\n\t\t\tif(elem.attr(ATTR_HAS)) {\n\t\t\t\ttry { elem.triggerHandler('removeqtip'); } \n\t\t\t\tcatch( e ) {}\n\t\t\t}\n\t\t}\n\t\t$['cleanData'+replaceSuffix].apply(this, arguments);\n\t};\n}\n\n;// qTip version\nQTIP.version = '@@VERSION';\n\n// Base ID for all qTips\nQTIP.nextid = 0;\n\n// Inactive events array\nQTIP.inactiveEvents = INACTIVE_EVENTS;\n\n// Base z-index for all qTips\nQTIP.zindex = 15000;\n\n// Define configuration defaults\nQTIP.defaults = {\n\tprerender: FALSE,\n\tid: FALSE,\n\toverwrite: TRUE,\n\tsuppress: TRUE,\n\tcontent: {\n\t\ttext: TRUE,\n\t\tattr: 'title',\n\t\ttitle: FALSE,\n\t\tbutton: FALSE\n\t},\n\tposition: {\n\t\tmy: 'top left',\n\t\tat: 'bottom right',\n\t\ttarget: FALSE,\n\t\tcontainer: FALSE,\n\t\tviewport: FALSE,\n\t\tadjust: {\n\t\t\tx: 0, y: 0,\n\t\t\tmouse: TRUE,\n\t\t\tscroll: TRUE,\n\t\t\tresize: TRUE,\n\t\t\tmethod: 'flipinvert flipinvert'\n\t\t},\n\t\teffect: function(api, pos, viewport) {\n\t\t\t$(this).animate(pos, {\n\t\t\t\tduration: 200,\n\t\t\t\tqueue: FALSE\n\t\t\t});\n\t\t}\n\t},\n\tshow: {\n\t\ttarget: FALSE,\n\t\tevent: 'mouseenter',\n\t\teffect: TRUE,\n\t\tdelay: 90,\n\t\tsolo: FALSE,\n\t\tready: FALSE,\n\t\tautofocus: FALSE\n\t},\n\thide: {\n\t\ttarget: FALSE,\n\t\tevent: 'mouseleave',\n\t\teffect: TRUE,\n\t\tdelay: 0,\n\t\tfixed: FALSE,\n\t\tinactive: FALSE,\n\t\tleave: 'window',\n\t\tdistance: FALSE\n\t},\n\tstyle: {\n\t\tclasses: '',\n\t\twidget: FALSE,\n\t\twidth: FALSE,\n\t\theight: FALSE,\n\t\tdef: TRUE\n\t},\n\tevents: {\n\t\trender: NULL,\n\t\tmove: NULL,\n\t\tshow: NULL,\n\t\thide: NULL,\n\t\ttoggle: NULL,\n\t\tvisible: NULL,\n\t\thidden: NULL,\n\t\tfocus: NULL,\n\t\tblur: NULL\n\t}\n};\n\n;var TIP, \n\n// .bind()/.on() namespace\nTIPNS = '.qtip-tip',\n\n// Common CSS strings\nMARGIN = 'margin',\nBORDER = 'border',\nCOLOR = 'color',\nBG_COLOR = 'background-color',\nTRANSPARENT = 'transparent',\nIMPORTANT = ' !important',\n\n// Check if the browser supports <canvas/> elements\nHASCANVAS = !!document.createElement('canvas').getContext,\n\n// Invalid colour values used in parseColours()\nINVALID = /rgba?\\(0, 0, 0(, 0)?\\)|transparent|#123456/i;\n\n// Camel-case method, taken from jQuery source\n// http://code.jquery.com/jquery-1.8.0.js\nfunction camel(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\n\n/*\n * Modified from Modernizr's testPropsAll()\n * http://modernizr.com/downloads/modernizr-latest.js\n */\nvar cssProps = {}, cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\nfunction vendorCss(elem, prop) {\n\tvar ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\n\t\tprops = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),\n\t\tcur, val, i = 0;\n\n\t// If the property has already been mapped...\n\tif(cssProps[prop]) { return elem.css(cssProps[prop]); }\n\n\twhile((cur = props[i++])) {\n\t\tif((val = elem.css(cur)) !== undefined) {\n\t\t\treturn cssProps[prop] = cur, val;\n\t\t}\n\t}\n}\n\n// Parse a given elements CSS property into an int\nfunction intCss(elem, prop) {\n\treturn Math.ceil(parseFloat(vendorCss(elem, prop)));\n}\n\n\n// VML creation (for IE only)\nif(!HASCANVAS) {\n\tvar createVML = function(tag, props, style) {\n\t\treturn '<qtipvml:'+tag+' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"qtip-vml\" '+(props||'')+\n\t\t\t' style=\"behavior: url(#default#VML); '+(style||'')+ '\" />';\n\t};\n}\n\n// Canvas only definitions\nelse {\n\tvar PIXEL_RATIO = window.devicePixelRatio || 1,\n\t\tBACKING_STORE_RATIO = (function() {\n\t\t\tvar context = document.createElement('canvas').getContext('2d');\n\t\t\treturn context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || \n\t\t\t\t\tcontext.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;\n\t\t}()),\n\t\tSCALE = PIXEL_RATIO / BACKING_STORE_RATIO;\n}\n\n\nfunction Tip(qtip, options) {\n\tthis._ns = 'tip';\n\tthis.options = options;\n\tthis.offset = options.offset;\n\tthis.size = [ options.width, options.height ];\n\n\t// Initialize\n\tthis.init( (this.qtip = qtip) );\n}\n\n$.extend(Tip.prototype, {\n\tinit: function(qtip) {\n\t\tvar context, tip;\n\n\t\t// Create tip element and prepend to the tooltip\n\t\ttip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE+'-tip' }).prependTo(qtip.tooltip);\n\n\t\t// Create tip drawing element(s)\n\t\tif(HASCANVAS) {\n\t\t\t// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!\n\t\t\tcontext = $('<canvas />').appendTo(this.element)[0].getContext('2d');\n\n\t\t\t// Setup constant parameters\n\t\t\tcontext.lineJoin = 'miter';\n\t\t\tcontext.miterLimit = 100000;\n\t\t\tcontext.save();\n\t\t}\n\t\telse {\n\t\t\tcontext = createVML('shape', 'coordorigin=\"0,0\"', 'position:absolute;');\n\t\t\tthis.element.html(context + context);\n\n\t\t\t// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML\n\t\t\tqtip._bind( $('*', tip).add(tip), ['click', 'mousedown'], function(event) { event.stopPropagation(); }, this._ns);\n\t\t}\n\n\t\t// Bind update events\n\t\tqtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);\n\n\t\t// Create it\n\t\tthis.create();\n\t},\n\n\t_swapDimensions: function() {\n\t\tthis.size[0] = this.options.height;\n\t\tthis.size[1] = this.options.width;\n\t},\n\t_resetDimensions: function() {\n\t\tthis.size[0] = this.options.width;\n\t\tthis.size[1] = this.options.height;\n\t},\n\n\t_useTitle: function(corner) {\n\t\tvar titlebar = this.qtip.elements.titlebar;\n\t\treturn titlebar && (\n\t\t\tcorner.y === TOP || (corner.y === CENTER && this.element.position().top + (this.size[1] / 2) + this.options.offset < titlebar.outerHeight(TRUE))\n\t\t);\n\t},\n\n\t_parseCorner: function(corner) {\n\t\tvar my = this.qtip.options.position.my;\n\n\t\t// Detect corner and mimic properties\n\t\tif(corner === FALSE || my === FALSE) {\n\t\t\tcorner = FALSE;\n\t\t}\n\t\telse if(corner === TRUE) {\n\t\t\tcorner = new CORNER( my.string() );\n\t\t}\n\t\telse if(!corner.string) {\n\t\t\tcorner = new CORNER(corner);\n\t\t\tcorner.fixed = TRUE;\n\t\t}\n\n\t\treturn corner;\n\t},\n\n\t_parseWidth: function(corner, side, use) {\n\t\tvar elements = this.qtip.elements,\n\t\t\tprop = BORDER + camel(side) + 'Width';\n\n\t\treturn (use ? intCss(use, prop) : (\n\t\t\tintCss(elements.content, prop) ||\n\t\t\tintCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||\n\t\t\tintCss(elements.tooltip, prop)\n\t\t)) || 0;\n\t},\n\n\t_parseRadius: function(corner) {\n\t\tvar elements = this.qtip.elements,\n\t\t\tprop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';\n\n\t\treturn BROWSER.ie < 9 ? 0 :\n\t\t\tintCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || \n\t\t\tintCss(elements.tooltip, prop) || 0;\n\t},\n\n\t_invalidColour: function(elem, prop, compare) {\n\t\tvar val = elem.css(prop);\n\t\treturn !val || (compare && val === elem.css(compare)) || INVALID.test(val) ? FALSE : val;\n\t},\n\n\t_parseColours: function(corner) {\n\t\tvar elements = this.qtip.elements,\n\t\t\ttip = this.element.css('cssText', ''),\n\t\t\tborderSide = BORDER + camel(corner[ corner.precedance ]) + camel(COLOR),\n\t\t\tcolorElem = this._useTitle(corner) && elements.titlebar || elements.content,\n\t\t\tcss = this._invalidColour, color = [];\n\n\t\t// Attempt to detect the background colour from various elements, left-to-right precedance\n\t\tcolor[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) || \n\t\t\tcss(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);\n\n\t\t// Attempt to detect the correct border side colour from various elements, left-to-right precedance\n\t\tcolor[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) || \n\t\t\tcss(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);\n\n\t\t// Reset background and border colours\n\t\t$('*', tip).add(tip).css('cssText', BG_COLOR+':'+TRANSPARENT+IMPORTANT+';'+BORDER+':0'+IMPORTANT+';');\n\n\t\treturn color;\n\t},\n\n\t_calculateSize: function(corner) {\n\t\tvar y = corner.precedance === Y,\n\t\t\twidth = this.options['width'],\n\t\t\theight = this.options['height'],\n\t\t\tisCenter = corner.abbrev() === 'c',\n\t\t\tbase = (y ? width: height) * (isCenter ? 0.5 : 1),\n\t\t\tpow = Math.pow,\n\t\t\tround = Math.round,\n\t\t\tbigHyp, ratio, result,\n\n\t\tsmallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),\n\t\thyp = [ (this.border / base) * smallHyp, (this.border / height) * smallHyp ];\n\n\t\thyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(this.border, 2) );\n\t\thyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(this.border, 2) );\n\n\t\tbigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);\n\t\tratio = bigHyp / smallHyp;\n\n\t\tresult = [ round(ratio * width), round(ratio * height) ];\n\t\treturn y ? result : result.reverse();\n\t},\n\n\t// Tip coordinates calculator\n\t_calculateTip: function(corner, size, scale) {\n\t\tscale = scale || 1;\n\t\tsize = size || this.size;\n\n\t\tvar width = size[0] * scale,\n\t\t\theight = size[1] * scale,\n\t\t\twidth2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),\n\n\t\t// Define tip coordinates in terms of height and width values\n\t\ttips = {\n\t\t\tbr:\t[0,0,\t\twidth,height,\twidth,0],\n\t\t\tbl:\t[0,0,\t\twidth,0,\t\t0,height],\n\t\t\ttr:\t[0,height,\twidth,0,\t\twidth,height],\n\t\t\ttl:\t[0,0,\t\t0,height,\t\twidth,height],\n\t\t\ttc:\t[0,height,\twidth2,0,\t\twidth,height],\n\t\t\tbc:\t[0,0,\t\twidth,0,\t\twidth2,height],\n\t\t\trc:\t[0,0,\t\twidth,height2,\t0,height],\n\t\t\tlc:\t[width,0,\twidth,height,\t0,height2]\n\t\t};\n\n\t\t// Set common side shapes\n\t\ttips.lt = tips.br; tips.rt = tips.bl;\n\t\ttips.lb = tips.tr; tips.rb = tips.tl;\n\n\t\treturn tips[ corner.abbrev() ];\n\t},\n\n\t// Tip coordinates drawer (canvas)\n\t_drawCoords: function(context, coords) {\n\t\tcontext.beginPath();\n\t\tcontext.moveTo(coords[0], coords[1]);\n\t\tcontext.lineTo(coords[2], coords[3]);\n\t\tcontext.lineTo(coords[4], coords[5]);\n\t\tcontext.closePath();\n\t},\n\n\tcreate: function() {\n\t\t// Determine tip corner\n\t\tvar c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);\n\t\t\n\t\t// If we have a tip corner...\n\t\tif( (this.enabled = !!this.corner && this.corner.abbrev() !== 'c') ) {\n\t\t\t// Cache it\n\t\t\tthis.qtip.cache.corner = c.clone();\n\n\t\t\t// Create it\n\t\t\tthis.update();\n\t\t}\n\n\t\t// Toggle tip element\n\t\tthis.element.toggle(this.enabled);\n\n\t\treturn this.corner;\n\t},\n\n\tupdate: function(corner, position) {\n\t\tif(!this.enabled) { return this; }\n\n\t\tvar elements = this.qtip.elements,\n\t\t\ttip = this.element,\n\t\t\tinner = tip.children(),\n\t\t\toptions = this.options,\n\t\t\tcurSize = this.size,\n\t\t\tmimic = options.mimic,\n\t\t\tround = Math.round,\n\t\t\tcolor, precedance, context,\n\t\t\tcoords, bigCoords, translate, newSize, border, BACKING_STORE_RATIO;\n\n\t\t// Re-determine tip if not already set\n\t\tif(!corner) { corner = this.qtip.cache.corner || this.corner; }\n\n\t\t// Use corner property if we detect an invalid mimic value\n\t\tif(mimic === FALSE) { mimic = corner; }\n\n\t\t// Otherwise inherit mimic properties from the corner object as necessary\n\t\telse {\n\t\t\tmimic = new CORNER(mimic);\n\t\t\tmimic.precedance = corner.precedance;\n\n\t\t\tif(mimic.x === 'inherit') { mimic.x = corner.x; }\n\t\t\telse if(mimic.y === 'inherit') { mimic.y = corner.y; }\n\t\t\telse if(mimic.x === mimic.y) {\n\t\t\t\tmimic[ corner.precedance ] = corner[ corner.precedance ];\n\t\t\t}\n\t\t}\n\t\tprecedance = mimic.precedance;\n\n\t\t// Ensure the tip width.height are relative to the tip position\n\t\tif(corner.precedance === X) { this._swapDimensions(); }\n\t\telse { this._resetDimensions(); }\n\n\t\t// Update our colours\n\t\tcolor = this.color = this._parseColours(corner);\n\n\t\t// Detect border width, taking into account colours\n\t\tif(color[1] !== TRANSPARENT) {\n\t\t\t// Grab border width\n\t\t\tborder = this.border = this._parseWidth(corner, corner[corner.precedance]);\n\n\t\t\t// If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)\n\t\t\tif(options.border && border < 1 && !INVALID.test(color[1])) { color[0] = color[1]; }\n\n\t\t\t// Set border width (use detected border width if options.border is true)\n\t\t\tthis.border = border = options.border !== TRUE ? options.border : border;\n\t\t}\n\n\t\t// Border colour was invalid, set border to zero\n\t\telse { this.border = border = 0; }\n\n\t\t// Determine tip size\n\t\tnewSize = this.size = this._calculateSize(corner);\n\t\ttip.css({\n\t\t\twidth: newSize[0],\n\t\t\theight: newSize[1],\n\t\t\tlineHeight: newSize[1]+'px'\n\t\t});\n\n\t\t// Calculate tip translation\n\t\tif(corner.precedance === Y) {\n\t\t\ttranslate = [\n\t\t\t\tround(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2),\n\t\t\t\tround(mimic.y === TOP ? newSize[1] - curSize[1] : 0)\n\t\t\t];\n\t\t}\n\t\telse {\n\t\t\ttranslate = [\n\t\t\t\tround(mimic.x === LEFT ? newSize[0] - curSize[0] : 0),\n\t\t\t\tround(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)\n\t\t\t];\n\t\t}\n\n\t\t// Canvas drawing implementation\n\t\tif(HASCANVAS) {\n\t\t\t// Grab canvas context and clear/save it\n\t\t\tcontext = inner[0].getContext('2d');\n\t\t\tcontext.restore(); context.save();\n\t\t\tcontext.clearRect(0,0,6000,6000);\n\t\t\t\n\t\t\t// Calculate coordinates\n\t\t\tcoords = this._calculateTip(mimic, curSize, SCALE);\n\t\t\tbigCoords = this._calculateTip(mimic, this.size, SCALE);\n\n\t\t\t// Set the canvas size using calculated size\n\t\t\tinner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);\n\t\t\tinner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);\n\n\t\t\t// Draw the outer-stroke tip\n\t\t\tthis._drawCoords(context, bigCoords);\n\t\t\tcontext.fillStyle = color[1];\n\t\t\tcontext.fill();\n\n\t\t\t// Draw the actual tip\n\t\t\tcontext.translate(translate[0] * SCALE, translate[1] * SCALE);\n\t\t\tthis._drawCoords(context, coords);\n\t\t\tcontext.fillStyle = color[0];\n\t\t\tcontext.fill();\n\t\t}\n\n\t\t// VML (IE Proprietary implementation)\n\t\telse {\n\t\t\t// Calculate coordinates\n\t\t\tcoords = this._calculateTip(mimic);\n\n\t\t\t// Setup coordinates string\n\t\t\tcoords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] +\n\t\t\t\t',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';\n\n\t\t\t// Setup VML-specific offset for pixel-perfection\n\t\t\ttranslate[2] = border && /^(r|b)/i.test(corner.string()) ?\n\t\t\t\tBROWSER.ie === 8 ? 2 : 1 : 0;\n\n\t\t\t// Set initial CSS\n\t\t\tinner.css({\n\t\t\t\tcoordsize: (newSize[0]+border) + ' ' + (newSize[1]+border),\n\t\t\t\tantialias: ''+(mimic.string().indexOf(CENTER) > -1),\n\t\t\t\tleft: translate[0] - (translate[2] * Number(precedance === X)),\n\t\t\t\ttop: translate[1] - (translate[2] * Number(precedance === Y)),\n\t\t\t\twidth: newSize[0] + border,\n\t\t\t\theight: newSize[1] + border\n\t\t\t})\n\t\t\t.each(function(i) {\n\t\t\t\tvar $this = $(this);\n\n\t\t\t\t// Set shape specific attributes\n\t\t\t\t$this[ $this.prop ? 'prop' : 'attr' ]({\n\t\t\t\t\tcoordsize: (newSize[0]+border) + ' ' + (newSize[1]+border),\n\t\t\t\t\tpath: coords,\n\t\t\t\t\tfillcolor: color[0],\n\t\t\t\t\tfilled: !!i,\n\t\t\t\t\tstroked: !i\n\t\t\t\t})\n\t\t\t\t.toggle(!!(border || i));\n\n\t\t\t\t// Check if border is enabled and add stroke element\n\t\t\t\t!i && $this.html( createVML(\n\t\t\t\t\t'stroke', 'weight=\"'+(border*2)+'px\" color=\"'+color[1]+'\" miterlimit=\"1000\" joinstyle=\"miter\"'\n\t\t\t\t) );\n\t\t\t});\n\t\t}\n\n\t\t// Opera bug #357 - Incorrect tip position\n\t\t// https://github.com/Craga89/qTip2/issues/367\n\t\twindow.opera && setTimeout(function() {\n\t\t\telements.tip.css({\n\t\t\t\tdisplay: 'inline-block',\n\t\t\t\tvisibility: 'visible'\n\t\t\t});\n\t\t}, 1);\n\n\t\t// Position if needed\n\t\tif(position !== FALSE) { this.calculate(corner, newSize); }\n\t},\n\n\tcalculate: function(corner, size) {\n\t\tif(!this.enabled) { return FALSE; }\n\n\t\tvar self = this,\n\t\t\telements = this.qtip.elements,\n\t\t\ttip = this.element,\n\t\t\tuserOffset = this.options.offset,\n\t\t\tisWidget = elements.tooltip.hasClass('ui-widget'),\n\t\t\tposition = {  },\n\t\t\tprecedance, corners;\n\n\t\t// Inherit corner if not provided\n\t\tcorner = corner || this.corner;\n\t\tprecedance = corner.precedance;\n\n\t\t// Determine which tip dimension to use for adjustment\n\t\tsize = size || this._calculateSize(corner);\n\n\t\t// Setup corners and offset array\n\t\tcorners = [ corner.x, corner.y ];\n\t\tif(precedance === X) { corners.reverse(); }\n\n\t\t// Calculate tip position\n\t\t$.each(corners, function(i, side) {\n\t\t\tvar b, bc, br;\n\n\t\t\tif(side === CENTER) {\n\t\t\t\tb = precedance === Y ? LEFT : TOP;\n\t\t\t\tposition[ b ] = '50%';\n\t\t\t\tposition[MARGIN+'-' + b] = -Math.round(size[ precedance === Y ? 0 : 1 ] / 2) + userOffset;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = self._parseWidth(corner, side, elements.tooltip);\n\t\t\t\tbc = self._parseWidth(corner, side, elements.content);\n\t\t\t\tbr = self._parseRadius(corner);\n\n\t\t\t\tposition[ side ] = Math.max(-self.border, i ? bc : (userOffset + (br > b ? br : -b)));\n\t\t\t}\n\t\t});\n\n\t\t// Adjust for tip size\n\t\tposition[ corner[precedance] ] -= size[ precedance === X ? 0 : 1 ];\n\n\t\t// Set and return new position\n\t\ttip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);\n\t\treturn position;\n\t},\n\n\treposition: function(event, api, pos, viewport) {\n\t\tif(!this.enabled) { return; }\n\n\t\tvar cache = api.cache,\n\t\t\tnewCorner = this.corner.clone(),\n\t\t\tadjust = pos.adjusted,\n\t\t\tmethod = api.options.position.adjust.method.split(' '),\n\t\t\thorizontal = method[0],\n\t\t\tvertical = method[1] || method[0],\n\t\t\tshift = { left: FALSE, top: FALSE, x: 0, y: 0 },\n\t\t\toffset, css = {}, props;\n\n\t\tfunction shiftflip(direction, precedance, popposite, side, opposite) {\n\t\t\t// Horizontal - Shift or flip method\n\t\t\tif(direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {\n\t\t\t\tnewCorner.precedance = newCorner.precedance === X ? Y : X;\n\t\t\t}\n\t\t\telse if(direction !== SHIFT && adjust[side]){\n\t\t\t\tnewCorner[precedance] = newCorner[precedance] === CENTER ? \n\t\t\t\t\t(adjust[side] > 0 ? side : opposite) : (newCorner[precedance] === side ? opposite : side);\n\t\t\t}\n\t\t}\n\n\t\tfunction shiftonly(xy, side, opposite) {\n\t\t\tif(newCorner[xy] === CENTER) {\n\t\t\t\tcss[MARGIN+'-'+side] = shift[xy] = offset[MARGIN+'-'+side] - adjust[side];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprops = offset[opposite] !== undefined ?\n\t\t\t\t\t[ adjust[side], -offset[side] ] : [ -adjust[side], offset[side] ];\n\n\t\t\t\tif( (shift[xy] = Math.max(props[0], props[1])) > props[0] ) {\n\t\t\t\t\tpos[side] -= adjust[side];\n\t\t\t\t\tshift[side] = FALSE;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcss[ offset[opposite] !== undefined ? opposite : side ] = shift[xy];\n\t\t\t}\n\t\t}\n\n\t\t// If our tip position isn't fixed e.g. doesn't adjust with viewport...\n\t\tif(this.corner.fixed !== TRUE) {\n\t\t\t// Perform shift/flip adjustments\n\t\t\tshiftflip(horizontal, X, Y, LEFT, RIGHT);\n\t\t\tshiftflip(vertical, Y, X, TOP, BOTTOM);\n\n\t\t\t// Update and redraw the tip if needed (check cached details of last drawn tip)\n\t\t\tif(newCorner.string() !== cache.corner.string() && (cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left)) {\n\t\t\t\tthis.update(newCorner, FALSE);\n\t\t\t}\n\t\t}\n\n\t\t// Setup tip offset properties\n\t\toffset = this.calculate(newCorner);\n\n\t\t// Readjust offset object to make it left/top\n\t\tif(offset.right !== undefined) { offset.left = -offset.right; }\n\t\tif(offset.bottom !== undefined) { offset.top = -offset.bottom; }\n\t\toffset.user = this.offset;\n\n\t\t// Perform shift adjustments\n\t\tif(shift.left = (horizontal === SHIFT && !!adjust.left)) { shiftonly(X, LEFT, RIGHT); }\n\t\tif(shift.top = (vertical === SHIFT && !!adjust.top)) { shiftonly(Y, TOP, BOTTOM); }\n\n\t\t/*\n\t\t* If the tip is adjusted in both dimensions, or in a\n\t\t* direction that would cause it to be anywhere but the\n\t\t* outer border, hide it!\n\t\t*/\n\t\tthis.element.css(css).toggle(\n\t\t\t!((shift.x && shift.y) || (newCorner.x === CENTER && shift.y) || (newCorner.y === CENTER && shift.x))\n\t\t);\n\n\t\t// Adjust position to accomodate tip dimensions\n\t\tpos.left -= offset.left.charAt ? offset.user : \n\t\t\thorizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;\n\t\tpos.top -= offset.top.charAt ? offset.user : \n\t\t\tvertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;\n\n\t\t// Cache details\n\t\tcache.cornerLeft = adjust.left; cache.cornerTop = adjust.top;\n\t\tcache.corner = newCorner.clone();\n\t},\n\n\tdestroy: function() {\n\t\t// Unbind events\n\t\tthis.qtip._unbind(this.qtip.tooltip, this._ns);\n\n\t\t// Remove the tip element(s)\n\t\tif(this.qtip.elements.tip) {\n\t\t\tthis.qtip.elements.tip.find('*')\n\t\t\t\t.remove().end().remove();\n\t\t}\n\t}\n});\n\nTIP = PLUGINS.tip = function(api) {\n\treturn new Tip(api, api.options.style.tip);\n};\n\n// Initialize tip on render\nTIP.initialize = 'render';\n\n// Setup plugin sanitization options\nTIP.sanitize = function(options) {\n\tif(options.style && 'tip' in options.style) {\n\t\tvar opts = options.style.tip;\n\t\tif(typeof opts !== 'object') { opts = options.style.tip = { corner: opts }; }\n\t\tif(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }\n\t}\n};\n\n// Add new option checks for the plugin\nCHECKS.tip = {\n\t'^position.my|style.tip.(corner|mimic|border)$': function() {\n\t\t// Make sure a tip can be drawn\n\t\tthis.create();\n\t\t\n\t\t// Reposition the tooltip\n\t\tthis.qtip.reposition();\n\t},\n\t'^style.tip.(height|width)$': function(obj) {\n\t\t// Re-set dimensions and redraw the tip\n\t\tthis.size = [ obj.width, obj.height ];\n\t\tthis.update();\n\n\t\t// Reposition the tooltip\n\t\tthis.qtip.reposition();\n\t},\n\t'^content.title|style.(classes|widget)$': function() {\n\t\tthis.update();\n\t}\n};\n\n// Extend original qTip defaults\n$.extend(TRUE, QTIP.defaults, {\n\tstyle: {\n\t\ttip: {\n\t\t\tcorner: TRUE,\n\t\t\tmimic: FALSE,\n\t\t\twidth: 6,\n\t\t\theight: 6,\n\t\t\tborder: TRUE,\n\t\t\toffset: 0\n\t\t}\n\t}\n});\n\n;var MODAL, OVERLAY,\n\tMODALCLASS = 'qtip-modal',\n\tMODALSELECTOR = '.'+MODALCLASS;\n\nOVERLAY = function()\n{\n\tvar self = this,\n\t\tfocusableElems = {},\n\t\tcurrent, onLast,\n\t\tprevState, elem;\n\n\t// Modified code from jQuery UI 1.10.0 source\n\t// http://code.jquery.com/ui/1.10.0/jquery-ui.js\n\tfunction focusable(element) {\n\t\t// Use the defined focusable checker when possible\n\t\tif($.expr[':'].focusable) { return $.expr[':'].focusable; }\n\n\t\tvar isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),\n\t\t\tnodeName = element.nodeName && element.nodeName.toLowerCase(),\n\t\t\tmap, mapName, img;\n\n\t\tif('area' === nodeName) {\n\t\t\tmap = element.parentNode;\n\t\t\tmapName = map.name;\n\t\t\tif(!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\timg = $('img[usemap=#' + mapName + ']')[0];\n\t\t\treturn !!img && img.is(':visible');\n\t\t}\n\t\treturn (/input|select|textarea|button|object/.test( nodeName ) ?\n\t\t\t\t!element.disabled :\n\t\t\t\t'a' === nodeName ? \n\t\t\t\t\telement.href || isTabIndexNotNaN : \n\t\t\t\t\tisTabIndexNotNaN\n\t\t\t);\n\t}\n\n\t// Focus inputs using cached focusable elements (see update())\n\tfunction focusInputs(blurElems) {\n\t\t// Blurring body element in IE causes window.open windows to unfocus!\n\t\tif(focusableElems.length < 1 && blurElems.length) { blurElems.not('body').blur(); }\n\n\t\t// Focus the inputs\n\t\telse { focusableElems.first().focus(); }\n\t}\n\n\t// Steal focus from elements outside tooltip\n\tfunction stealFocus(event) {\n\t\tif(!elem.is(':visible')) { return; }\n\n\t\tvar target = $(event.target),\n\t\t\ttooltip = current.tooltip,\n\t\t\tcontainer = target.closest(SELECTOR),\n\t\t\ttargetOnTop;\n\n\t\t// Determine if input container target is above this\n\t\ttargetOnTop = container.length < 1 ? FALSE :\n\t\t\t(parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10));\n\n\t\t// If we're showing a modal, but focus has landed on an input below\n\t\t// this modal, divert focus to the first visible input in this modal\n\t\t// or if we can't find one... the tooltip itself\n\t\tif(!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {\n\t\t\tfocusInputs(target);\n\t\t}\n\n\t\t// Detect when we leave the last focusable element...\n\t\tonLast = event.target === focusableElems[focusableElems.length - 1];\n\t}\n\n\t$.extend(self, {\n\t\tinit: function() {\n\t\t\t// Create document overlay\n\t\t\telem = self.elem = $('<div />', {\n\t\t\t\tid: 'qtip-overlay',\n\t\t\t\thtml: '<div></div>',\n\t\t\t\tmousedown: function() { return FALSE; }\n\t\t\t})\n\t\t\t.hide();\n\n\t\t\t// Make sure we can't focus anything outside the tooltip\n\t\t\t$(document.body).bind('focusin'+MODALSELECTOR, stealFocus);\n\n\t\t\t// Apply keyboard \"Escape key\" close handler\n\t\t\t$(document).bind('keydown'+MODALSELECTOR, function(event) {\n\t\t\t\tif(current && current.options.show.modal.escape && event.keyCode === 27) {\n\t\t\t\t\tcurrent.hide(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply click handler for blur option\n\t\t\telem.bind('click'+MODALSELECTOR, function(event) {\n\t\t\t\tif(current && current.options.show.modal.blur) {\n\t\t\t\t\tcurrent.hide(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn self;\n\t\t},\n\n\t\tupdate: function(api) {\n\t\t\t// Update current API reference\n\t\t\tcurrent = api;\n\n\t\t\t// Update focusable elements if enabled\n\t\t\tif(api.options.show.modal.stealfocus !== FALSE) {\n\t\t\t\tfocusableElems = api.tooltip.find('*').filter(function() {\n\t\t\t\t\treturn focusable(this);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse { focusableElems = []; }\n\t\t},\n\n\t\ttoggle: function(api, state, duration) {\n\t\t\tvar docBody = $(document.body),\n\t\t\t\ttooltip = api.tooltip,\n\t\t\t\toptions = api.options.show.modal,\n\t\t\t\teffect = options.effect,\n\t\t\t\ttype = state ? 'show': 'hide',\n\t\t\t\tvisible = elem.is(':visible'),\n\t\t\t\tvisibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip),\n\t\t\t\tzindex;\n\n\t\t\t// Set active tooltip API reference\n\t\t\tself.update(api);\n\n\t\t\t// If the modal can steal the focus...\n\t\t\t// Blur the current item and focus anything in the modal we an\n\t\t\tif(state && options.stealfocus !== FALSE) {\n\t\t\t\tfocusInputs( $(':focus') );\n\t\t\t}\n\n\t\t\t// Toggle backdrop cursor style on show\n\t\t\telem.toggleClass('blurs', options.blur);\n\n\t\t\t// Append to body on show\n\t\t\tif(state) {\n\t\t\t\telem.appendTo(document.body);\n\t\t\t}\n\n\t\t\t// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible\n\t\t\tif((elem.is(':animated') && visible === state && prevState !== FALSE) || (!state && visibleModals.length)) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\t// Stop all animations\n\t\t\telem.stop(TRUE, FALSE);\n\n\t\t\t// Use custom function if provided\n\t\t\tif($.isFunction(effect)) {\n\t\t\t\teffect.call(elem, state);\n\t\t\t}\n\n\t\t\t// If no effect type is supplied, use a simple toggle\n\t\t\telse if(effect === FALSE) {\n\t\t\t\telem[ type ]();\n\t\t\t}\n\n\t\t\t// Use basic fade function\n\t\t\telse {\n\t\t\t\telem.fadeTo( parseInt(duration, 10) || 90, state ? 1 : 0, function() {\n\t\t\t\t\tif(!state) { elem.hide(); }\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Reset position and detach from body on hide\n\t\t\tif(!state) {\n\t\t\t\telem.queue(function(next) {\n\t\t\t\t\telem.css({ left: '', top: '' });\n\t\t\t\t\tif(!$(MODALSELECTOR).length) { elem.detach(); }\n\t\t\t\t\tnext();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Cache the state\n\t\t\tprevState = state;\n\n\t\t\t// If the tooltip is destroyed, set reference to null\n\t\t\tif(current.destroyed) { current = NULL; }\n\n\t\t\treturn self;\n\t\t}\n\t});\t\n\n\tself.init();\n};\nOVERLAY = new OVERLAY();\n\nfunction Modal(api, options) {\n\tthis.options = options;\n\tthis._ns = '-modal';\n\n\tthis.init( (this.qtip = api) );\n}\n\n$.extend(Modal.prototype, {\n\tinit: function(qtip) {\n\t\tvar tooltip = qtip.tooltip;\n\n\t\t// If modal is disabled... return\n\t\tif(!this.options.on) { return this; }\n\n\t\t// Set overlay reference\n\t\tqtip.elements.overlay = OVERLAY.elem;\n\n\t\t// Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index\n\t\ttooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length);\n\t\t\n\t\t// Apply our show/hide/focus modal events\n\t\tqtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function(event, api, duration) {\n\t\t\tvar oEvent = event.originalEvent;\n\n\t\t\t// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop\n\t\t\tif(event.target === tooltip[0]) {\n\t\t\t\tif(oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {\n\t\t\t\t\ttry { event.preventDefault(); } catch(e) {}\n\t\t\t\t}\n\t\t\t\telse if(!oEvent || (oEvent && oEvent.type !== 'tooltipsolo')) {\n\t\t\t\t\tthis.toggle(event, event.type === 'tooltipshow', duration);\n\t\t\t\t}\n\t\t\t}\n\t\t}, this._ns, this);\n\n\t\t// Adjust modal z-index on tooltip focus\n\t\tqtip._bind(tooltip, 'tooltipfocus', function(event, api) {\n\t\t\t// If focus was cancelled before it reached us, don't do anything\n\t\t\tif(event.isDefaultPrevented() || event.target !== tooltip[0]) { return; }\n\n\t\t\tvar qtips = $(MODALSELECTOR),\n\n\t\t\t// Keep the modal's lower than other, regular qtips\n\t\t\tnewIndex = QTIP.modal_zindex + qtips.length,\n\t\t\tcurIndex = parseInt(tooltip[0].style.zIndex, 10);\n\n\t\t\t// Set overlay z-index\n\t\t\tOVERLAY.elem[0].style.zIndex = newIndex - 1;\n\n\t\t\t// Reduce modal z-index's and keep them properly ordered\n\t\t\tqtips.each(function() {\n\t\t\t\tif(this.style.zIndex > curIndex) {\n\t\t\t\t\tthis.style.zIndex -= 1;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Fire blur event for focused tooltip\n\t\t\tqtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent);\n\n\t\t\t// Set the new z-index\n\t\t\ttooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\n\n\t\t\t// Set current\n\t\t\tOVERLAY.update(api);\n\n\t\t\t// Prevent default handling\n\t\t\ttry { event.preventDefault(); } catch(e) {}\n\t\t}, this._ns, this);\n\n\t\t// Focus any other visible modals when this one hides\n\t\tqtip._bind(tooltip, 'tooltiphide', function(event) {\n\t\t\tif(event.target === tooltip[0]) {\n\t\t\t\t$(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);\n\t\t\t}\n\t\t}, this._ns, this);\n\t},\n\n\ttoggle: function(event, state, duration) {\n\t\t// Make sure default event hasn't been prevented\n\t\tif(event && event.isDefaultPrevented()) { return this; }\n\n\t\t// Toggle it\n\t\tOVERLAY.toggle(this.qtip, !!state, duration);\n\t},\n\n\tdestroy: function() {\n\t\t// Remove modal class\n\t\tthis.qtip.tooltip.removeClass(MODALCLASS);\n\n\t\t// Remove bound events\n\t\tthis.qtip._unbind(this.qtip.tooltip, this._ns);\n\n\t\t// Delete element reference\n\t\tOVERLAY.toggle(this.qtip, FALSE);\n\t\tdelete this.qtip.elements.overlay;\n\t}\n});\n\n\nMODAL = PLUGINS.modal = function(api) {\n\treturn new Modal(api, api.options.show.modal);\n};\n\n// Setup sanitiztion rules\nMODAL.sanitize = function(opts) {\n\tif(opts.show) { \n\t\tif(typeof opts.show.modal !== 'object') { opts.show.modal = { on: !!opts.show.modal }; }\n\t\telse if(typeof opts.show.modal.on === 'undefined') { opts.show.modal.on = TRUE; }\n\t}\n};\n\n// Base z-index for all modal tooltips (use qTip core z-index as a base)\nQTIP.modal_zindex = QTIP.zindex - 200;\n\n// Plugin needs to be initialized on render\nMODAL.initialize = 'render';\n\n// Setup option set checks\nCHECKS.modal = {\n\t'^show.modal.(on|blur)$': function() {\n\t\t// Initialise\n\t\tthis.destroy();\n\t\tthis.init();\n\t\t\n\t\t// Show the modal if not visible already and tooltip is visible\n\t\tthis.qtip.elems.overlay.toggle(\n\t\t\tthis.qtip.tooltip[0].offsetWidth > 0\n\t\t);\n\t}\n};\n\n// Extend original api defaults\n$.extend(TRUE, QTIP.defaults, {\n\tshow: {\n\t\tmodal: {\n\t\t\ton: FALSE,\n\t\t\teffect: TRUE,\n\t\t\tblur: TRUE,\n\t\t\tstealfocus: TRUE,\n\t\t\tescape: TRUE\n\t\t}\n\t}\n});\n;PLUGINS.viewport = function(api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight)\n{\n\tvar target = posOptions.target,\n\t\ttooltip = api.elements.tooltip,\n\t\tmy = posOptions.my,\n\t\tat = posOptions.at,\n\t\tadjust = posOptions.adjust,\n\t\tmethod = adjust.method.split(' '),\n\t\tmethodX = method[0],\n\t\tmethodY = method[1] || method[0],\n\t\tviewport = posOptions.viewport,\n\t\tcontainer = posOptions.container,\n\t\tcache = api.cache,\n\t\tadjusted = { left: 0, top: 0 },\n\t\tfixed, newMy, newClass, containerOffset, containerStatic,\n\t\tviewportWidth, viewportHeight, viewportScroll, viewportOffset;\n\n\t// If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return\n\tif(!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {\n\t\treturn adjusted;\n\t}\n\n\t// Cach container details\n\tcontainerOffset = container.offset() || adjusted;\n\tcontainerStatic = container.css('position') === 'static';\n\n\t// Cache our viewport details\n\tfixed = tooltip.css('position') === 'fixed';\n\tviewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);\n\tviewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);\n\tviewportScroll = { left: fixed ? 0 : viewport.scrollLeft(), top: fixed ? 0 : viewport.scrollTop() };\n\tviewportOffset = viewport.offset() || adjusted;\n\n\t// Generic calculation method\n\tfunction calculate(side, otherSide, type, adjust, side1, side2, lengthName, targetLength, elemLength) {\n\t\tvar initialPos = position[side1],\n\t\t\tmySide = my[side],\n\t\t\tatSide = at[side],\n\t\t\tisShift = type === SHIFT,\n\t\t\tmyLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,\n\t\t\tatLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,\n\t\t\tsideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),\n\t\t\toverflow1 = sideOffset - initialPos,\n\t\t\toverflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,\n\t\t\toffset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);\n\n\t\t// shift\n\t\tif(isShift) {\n\t\t\toffset = (mySide === side1 ? 1 : -1) * myLength;\n\n\t\t\t// Adjust position but keep it within viewport dimensions\n\t\t\tposition[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;\n\t\t\tposition[side1] = Math.max(\n\t\t\t\t-containerOffset[side1] + viewportOffset[side1],\n\t\t\t\tinitialPos - offset,\n\t\t\t\tMath.min(\n\t\t\t\t\tMath.max(\n\t\t\t\t\t\t-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight),\n\t\t\t\t\t\tinitialPos + offset\n\t\t\t\t\t),\n\t\t\t\t\tposition[side1],\n\n\t\t\t\t\t// Make sure we don't adjust complete off the element when using 'center'\n\t\t\t\t\tmySide === 'center' ? initialPos - myLength : 1E9\n\t\t\t\t)\n\t\t\t);\n\n\t\t}\n\n\t\t// flip/flipinvert\n\t\telse {\n\t\t\t// Update adjustment amount depending on if using flipinvert or flip\n\t\t\tadjust *= (type === FLIPINVERT ? 2 : 0);\n\n\t\t\t// Check for overflow on the left/top\n\t\t\tif(overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {\n\t\t\t\tposition[side1] -= offset + adjust;\n\t\t\t\tnewMy.invert(side, side1);\n\t\t\t}\n\n\t\t\t// Check for overflow on the bottom/right\n\t\t\telse if(overflow2 > 0 && (mySide !== side2 || overflow1 > 0)  ) {\n\t\t\t\tposition[side1] -= (mySide === CENTER ? -offset : offset) + adjust;\n\t\t\t\tnewMy.invert(side, side2);\n\t\t\t}\n\n\t\t\t// Make sure we haven't made things worse with the adjustment and reset if so\n\t\t\tif(position[side1] < viewportScroll && -position[side1] > overflow2) {\n\t\t\t\tposition[side1] = initialPos; newMy = my.clone();\n\t\t\t}\n\t\t}\n\n\t\treturn position[side1] - initialPos;\n\t}\n\n\t// Set newMy if using flip or flipinvert methods\n\tif(methodX !== 'shift' || methodY !== 'shift') { newMy = my.clone(); }\n\n\t// Adjust position based onviewport and adjustment options\n\tadjusted = {\n\t\tleft: methodX !== 'none' ? calculate( X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth ) : 0,\n\t\ttop: methodY !== 'none' ? calculate( Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight ) : 0\n\t};\n\n\t// Set tooltip position class if it's changed\n\tif(newMy && cache.lastClass !== (newClass = NAMESPACE + '-pos-' + newMy.abbrev())) {\n\t\ttooltip.removeClass(api.cache.lastClass).addClass( (api.cache.lastClass = newClass) );\n\t}\n\n\treturn adjusted;\n};\n;PLUGINS.polys = {\n\t// POLY area coordinate calculator\n\t//\tSpecial thanks to Ed Cradock for helping out with this.\n\t//\tUses a binary search algorithm to find suitable coordinates.\n\tpolygon: function(baseCoords, corner) {\n\t\tvar result = {\n\t\t\twidth: 0, height: 0,\n\t\t\tposition: {\n\t\t\t\ttop: 1e10, right: 0,\n\t\t\t\tbottom: 0, left: 1e10\n\t\t\t},\n\t\t\tadjustable: FALSE\n\t\t},\n\t\ti = 0, next,\n\t\tcoords = [],\n\t\tcompareX = 1, compareY = 1,\n\t\trealX = 0, realY = 0,\n\t\tnewWidth, newHeight;\n\n\t\t// First pass, sanitize coords and determine outer edges\n\t\ti = baseCoords.length; while(i--) {\n\t\t\tnext = [ parseInt(baseCoords[--i], 10), parseInt(baseCoords[i+1], 10) ];\n\n\t\t\tif(next[0] > result.position.right){ result.position.right = next[0]; }\n\t\t\tif(next[0] < result.position.left){ result.position.left = next[0]; }\n\t\t\tif(next[1] > result.position.bottom){ result.position.bottom = next[1]; }\n\t\t\tif(next[1] < result.position.top){ result.position.top = next[1]; }\n\n\t\t\tcoords.push(next);\n\t\t}\n\n\t\t// Calculate height and width from outer edges\n\t\tnewWidth = result.width = Math.abs(result.position.right - result.position.left);\n\t\tnewHeight = result.height = Math.abs(result.position.bottom - result.position.top);\n\n\t\t// If it's the center corner...\n\t\tif(corner.abbrev() === 'c') {\n\t\t\tresult.position = {\n\t\t\t\tleft: result.position.left + (result.width / 2),\n\t\t\t\ttop: result.position.top + (result.height / 2)\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\t// Second pass, use a binary search algorithm to locate most suitable coordinate\n\t\t\twhile(newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0)\n\t\t\t{\n\t\t\t\tnewWidth = Math.floor(newWidth / 2);\n\t\t\t\tnewHeight = Math.floor(newHeight / 2);\n\n\t\t\t\tif(corner.x === LEFT){ compareX = newWidth; }\n\t\t\t\telse if(corner.x === RIGHT){ compareX = result.width - newWidth; }\n\t\t\t\telse{ compareX += Math.floor(newWidth / 2); }\n\n\t\t\t\tif(corner.y === TOP){ compareY = newHeight; }\n\t\t\t\telse if(corner.y === BOTTOM){ compareY = result.height - newHeight; }\n\t\t\t\telse{ compareY += Math.floor(newHeight / 2); }\n\n\t\t\t\ti = coords.length; while(i--)\n\t\t\t\t{\n\t\t\t\t\tif(coords.length < 2){ break; }\n\n\t\t\t\t\trealX = coords[i][0] - result.position.left;\n\t\t\t\t\trealY = coords[i][1] - result.position.top;\n\n\t\t\t\t\tif((corner.x === LEFT && realX >= compareX) ||\n\t\t\t\t\t(corner.x === RIGHT && realX <= compareX) ||\n\t\t\t\t\t(corner.x === CENTER && (realX < compareX || realX > (result.width - compareX))) ||\n\t\t\t\t\t(corner.y === TOP && realY >= compareY) ||\n\t\t\t\t\t(corner.y === BOTTOM && realY <= compareY) ||\n\t\t\t\t\t(corner.y === CENTER && (realY < compareY || realY > (result.height - compareY)))) {\n\t\t\t\t\t\tcoords.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.position = { left: coords[0][0], top: coords[0][1] };\n\t\t}\n\n\t\treturn result;\n\t},\n\n\trect: function(ax, ay, bx, by) {\n\t\treturn {\n\t\t\twidth: Math.abs(bx - ax),\n\t\t\theight: Math.abs(by - ay),\n\t\t\tposition: {\n\t\t\t\tleft: Math.min(ax, bx),\n\t\t\t\ttop: Math.min(ay, by)\n\t\t\t}\n\t\t};\n\t},\n\n\t_angles: {\n\t\ttc: 3 / 2, tr: 7 / 4, tl: 5 / 4, \n\t\tbc: 1 / 2, br: 1 / 4, bl: 3 / 4, \n\t\trc: 2, lc: 1, c: 0\n\t},\n\tellipse: function(cx, cy, rx, ry, corner) {\n\t\tvar c = PLUGINS.polys._angles[ corner.abbrev() ],\n\t\t\trxc = c === 0 ? 0 : rx * Math.cos( c * Math.PI ),\n\t\t\trys = ry * Math.sin( c * Math.PI );\n\n\t\treturn {\n\t\t\twidth: (rx * 2) - Math.abs(rxc),\n\t\t\theight: (ry * 2) - Math.abs(rys),\n\t\t\tposition: {\n\t\t\t\tleft: cx + rxc,\n\t\t\t\ttop: cy + rys\n\t\t\t},\n\t\t\tadjustable: FALSE\n\t\t};\n\t},\n\tcircle: function(cx, cy, r, corner) {\n\t\treturn PLUGINS.polys.ellipse(cx, cy, r, r, corner);\n\t}\n};;PLUGINS.svg = function(api, svg, corner)\n{\n\tvar doc = $(document),\n\t\telem = svg[0],\n\t\troot = $(elem.ownerSVGElement),\n\t\txScale = 1, yScale = 1,\n\t\tcomplex = true,\n\t\trootWidth, rootHeight,\n\t\tmtx, transformed, viewBox,\n\t\tlen, next, i, points,\n\t\tresult, position, dimensions;\n\n\t// Ascend the parentNode chain until we find an element with getBBox()\n\twhile(!elem.getBBox) { elem = elem.parentNode; }\n\tif(!elem.getBBox || !elem.parentNode) { return FALSE; }\n\n\t// Determine dimensions where possible\n\trootWidth = root.attr('width') || root.width() || parseInt(root.css('width'), 10);\n\trootHeight = root.attr('height') || root.height() || parseInt(root.css('height'), 10);\n\n\t// Add stroke characteristics to scaling\n\tvar strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2;\n\tif(strokeWidth2) {\n\t\txScale += strokeWidth2 / rootWidth;\n\t\tyScale += strokeWidth2 / rootHeight;\n\t}\n\n\t// Determine which shape calculation to use\n\tswitch(elem.nodeName) {\n\t\tcase 'ellipse':\n\t\tcase 'circle':\n\t\t\tresult = PLUGINS.polys.ellipse(\n\t\t\t\telem.cx.baseVal.value,\n\t\t\t\telem.cy.baseVal.value,\n\t\t\t\t(elem.rx || elem.r).baseVal.value + strokeWidth2,\n\t\t\t\t(elem.ry || elem.r).baseVal.value + strokeWidth2,\n\t\t\t\tcorner\n\t\t\t);\n\t\tbreak;\n\n\t\tcase 'line':\n\t\tcase 'polygon':\n\t\tcase 'polyline':\n\t\t\t// Determine points object (line has none, so mimic using array)\n\t\t\tpoints = elem.points || [ \n\t\t\t\t{ x: elem.x1.baseVal.value, y: elem.y1.baseVal.value },\n\t\t\t\t{ x: elem.x2.baseVal.value, y: elem.y2.baseVal.value }\n\t\t\t];\n\n\t\t\tfor(result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {\n\t\t\t\tnext = points.getItem ? points.getItem(i) : points[i];\n\t\t\t\tresult.push.apply(result, [next.x, next.y]);\n\t\t\t}\n\n\t\t\tresult = PLUGINS.polys.polygon(result, corner);\n\t\tbreak;\n\n\t\t// Unknown shape or rectangle? Use bounding box\n\t\tdefault:\n\t\t\tresult = elem.getBoundingClientRect();\n\t\t\tresult = {\n\t\t\t\twidth: result.width, height: result.height,\n\t\t\t\tposition: {\n\t\t\t\t\tleft: result.left,\n\t\t\t\t\ttop: result.top\n\t\t\t\t}\n\t\t\t};\n\t\t\tcomplex = false;\n\t\tbreak;\n\t}\n\n\t// Shortcut assignments\n\tposition = result.position;\n\troot = root[0];\n\n\t// If the shape was complex (i.e. not using bounding box calculations)\n\tif(complex) {\n\t\t// Convert position into a pixel value\n\t\tif(root.createSVGPoint) {\n\t\t\tmtx = elem.getScreenCTM();\n\t\t\tpoints = root.createSVGPoint();\n\n\t\t\tpoints.x = position.left;\n\t\t\tpoints.y = position.top;\n\t\t\ttransformed = points.matrixTransform( mtx );\n\t\t\tposition.left = transformed.x;\n\t\t\tposition.top = transformed.y;\n\t\t}\n\n\t\t// Calculate viewBox characteristics\n\t\tif(root.viewBox && (viewBox = root.viewBox.baseVal) && viewBox.width && viewBox.height) {\n\t\t\txScale *= rootWidth / viewBox.width;\n\t\t\tyScale *= rootHeight / viewBox.height;\n\t\t}\n\t}\n\n\t// Adjust by scroll offset\n\tposition.left += doc.scrollLeft();\n\tposition.top += doc.scrollTop();\n\n\treturn result;\n};;PLUGINS.imagemap = function(api, area, corner, adjustMethod)\n{\n\tif(!area.jquery) { area = $(area); }\n\n\tvar shape = area.attr('shape').toLowerCase().replace('poly', 'polygon'),\n\t\timage = $('img[usemap=\"#'+area.parent('map').attr('name')+'\"]'),\n\t\tcoordsString = $.trim(area.attr('coords')),\n\t\tcoordsArray = coordsString.replace(/,$/, '').split(','),\n\t\timageOffset, coords, i, next, result, len;\n\n\t// If we can't find the image using the map...\n\tif(!image.length) { return FALSE; }\n\n\t// Pass coordinates string if polygon\n\tif(shape === 'polygon') {\n\t\tresult = PLUGINS.polys.polygon(coordsArray, corner);\n\t}\n\n\t// Otherwise parse the coordinates and pass them as arguments\n\telse if(PLUGINS.polys[shape]) {\n\t\tfor(i = -1, len = coordsArray.length, coords = []; ++i < len;) {\n\t\t\tcoords.push( parseInt(coordsArray[i], 10) );\n\t\t}\n\n\t\tresult = PLUGINS.polys[shape].apply(\n\t\t\tthis, coords.concat(corner)\n\t\t);\n\t}\n\n\t// If no shapre calculation method was found, return false\n\telse { return FALSE; }\n\n\t// Make sure we account for padding and borders on the image\n\timageOffset = image.offset();\n\timageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);\n\timageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);\n\n\t// Add image position to offset coordinates\n\tresult.position.left += imageOffset.left;\n\tresult.position.top += imageOffset.top;\n\n\treturn result;\n};;var IE6,\n\n/* \n * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)\n * Special thanks to Brandon Aaron\n */\nBGIFRAME = '<iframe class=\"qtip-bgiframe\" frameborder=\"0\" tabindex=\"-1\" src=\"javascript:\\'\\';\" ' +\n\t' style=\"display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' +\n\t\t'-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\"></iframe>';\n\nfunction Ie6(api, qtip) {\n\tthis._ns = 'ie6';\n\tthis.init( (this.qtip = api) );\n}\n\n$.extend(Ie6.prototype, {\n\t_scroll : function() {\n\t\tvar overlay = this.qtip.elements.overlay;\n\t\toverlay && (overlay[0].style.top = $(window).scrollTop() + 'px');\n\t},\n\n\tinit: function(qtip) {\n\t\tvar tooltip = qtip.tooltip,\n\t\t\tscroll;\n\n\t\t// Create the BGIFrame element if needed\n\t\tif($('select, object').length < 1) {\n\t\t\tthis.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);\n\n\t\t\t// Update BGIFrame on tooltip move\n\t\t\tqtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);\n\t\t}\n\n\t\t// redraw() container for width/height calculations\n\t\tthis.redrawContainer = $('<div/>', { id: NAMESPACE+'-rcontainer' })\n\t\t\t.appendTo(document.body);\n\n\t\t// Fixup modal plugin if present too\n\t\tif( qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix') ) {\n\t\t\tqtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);\n\t\t\tqtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);\n\t\t}\n\n\t\t// Set dimensions\n\t\tthis.redraw();\n\t},\n\n\tadjustBGIFrame: function() {\n\t\tvar tooltip = this.qtip.tooltip,\n\t\t\tdimensions = {\n\t\t\t\theight: tooltip.outerHeight(FALSE),\n\t\t\t\twidth: tooltip.outerWidth(FALSE)\n\t\t\t},\n\t\t\tplugin = this.qtip.plugins.tip,\n\t\t\ttip = this.qtip.elements.tip,\n\t\t\ttipAdjust, offset;\n\n\t\t// Adjust border offset\n\t\toffset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;\n\t\toffset = { left: -offset, top: -offset };\n\n\t\t// Adjust for tips plugin\n\t\tif(plugin && tip) {\n\t\t\ttipAdjust = (plugin.corner.precedance === 'x') ? [WIDTH, LEFT] : [HEIGHT, TOP];\n\t\t\toffset[ tipAdjust[1] ] -= tip[ tipAdjust[0] ]();\n\t\t}\n\n\t\t// Update bgiframe\n\t\tthis.bgiframe.css(offset).css(dimensions);\n\t},\n\n\t// Max/min width simulator function\n\tredraw: function() {\n\t\tif(this.qtip.rendered < 1 || this.drawing) { return this; }\n\n\t\tvar tooltip = this.qtip.tooltip,\n\t\t\tstyle = this.qtip.options.style,\n\t\t\tcontainer = this.qtip.options.position.container,\n\t\t\tperc, width, max, min;\n\n\t\t// Set drawing flag\n\t\tthis.qtip.drawing = 1;\n\n\t\t// If tooltip has a set height/width, just set it... like a boss!\n\t\tif(style.height) { tooltip.css(HEIGHT, style.height); }\n\t\tif(style.width) { tooltip.css(WIDTH, style.width); }\n\n\t\t// Simulate max/min width if not set width present...\n\t\telse {\n\t\t\t// Reset width and add fluid class\n\t\t\ttooltip.css(WIDTH, '').appendTo(this.redrawContainer);\n\n\t\t\t// Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)\n\t\t\twidth = tooltip.width();\n\t\t\tif(width % 2 < 1) { width += 1; }\n\n\t\t\t// Grab our max/min properties\n\t\t\tmax = tooltip.css('maxWidth') || '';\n\t\t\tmin = tooltip.css('minWidth') || '';\n\n\t\t\t// Parse into proper pixel values\n\t\t\tperc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;\n\t\tmax = ((max.indexOf('%') > -1 ? perc : 1) * parseInt(max, 10)) || width;\n\t\t\tmin = ((min.indexOf('%') > -1 ? perc : 1) * parseInt(min, 10)) || 0;\n\n\t\t\t// Determine new dimension size based on max/min/current values\n\t\t\twidth = max + min ? Math.min(Math.max(width, min), max) : width;\n\n\t\t\t// Set the newly calculated width and remvoe fluid class\n\t\t\ttooltip.css(WIDTH, Math.round(width)).appendTo(container);\n\t\t}\n\n\t\t// Set drawing flag\n\t\tthis.drawing = 0;\n\n\t\treturn this;\n\t},\n\n\tdestroy: function() {\n\t\t// Remove iframe\n\t\tthis.bgiframe && this.bgiframe.remove();\n\n\t\t// Remove bound events\n\t\tthis.qtip._unbind([window, this.qtip.tooltip], this._ns);\n\t}\n});\n\nIE6 = PLUGINS.ie6 = function(api) {\n\t// Proceed only if the browser is IE6\n\treturn BROWSER.ie === 6 ? new Ie6(api) : FALSE;\n};\n\nIE6.initialize = 'render';\n\nCHECKS.ie6 = {\n\t'^content|style$': function() { \n\t\tthis.redraw();\n\t}\n};;}));\n}( window, document ));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy9qcXVlcnktcXRpcC9qcXVlcnkucXRpcC5qcz9lMTIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxhQUFhLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzQkFBc0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9COztBQUV6QztBQUNBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLG9CQUFvQjs7QUFFM0I7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixjQUFjOztBQUVyQztBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFxQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsU0FBUyxlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQseUJBQXlCLGNBQWMsSUFBSTtBQUMzQzs7QUFFQTtBQUNBLGtDQUFrQyxvQkFBb0IsSUFBSTtBQUMxRDs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWU7QUFDeEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkJBQTZCO0FBQzdCLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixhQUFhOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixhQUFhOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBLE9BQU8scUJBQXFCLFVBQVU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxjQUFjOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSx3REFBd0QsY0FBYzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBOztBQUVBO0FBQ0EsT0FBTyx1QkFBdUI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCLEVBQUU7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBOztBQUVBLENBQUM7QUFDRCwyREFBMkQsYUFBYTs7QUFFeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFLHVDQUF1Qyw2QkFBNkI7QUFDcEU7O0FBRUE7QUFDQSxPQUFPLHNCQUFzQixtQkFBbUI7O0FBRWhEO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQyxtQkFBbUIsc0NBQXNDOztBQUV6RDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixZQUFZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1HQUFtRyxzQkFBc0I7QUFDekg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0QsMkNBQTJDLGFBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGtCQUFrQjs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGFBQWE7O0FBRWxDO0FBQ0EsK0JBQStCLG1CQUFtQjs7QUFFbEQ7QUFDQSwrQkFBK0IsYUFBYTs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxpREFBaUQ7QUFDMUYsMENBQTBDLGdEQUFnRDs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsaURBQWlEO0FBQy9EO0FBQ0EsY0FBYywwQkFBMEI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0Qzs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxPQUFPLDBDQUEwQzs7QUFFakQ7QUFDQSxZQUFZLGtEQUFrRDs7QUFFOUQ7QUFDQTs7QUFFQSxrQ0FBa0MsaUNBQWlDOztBQUVuRSxrQ0FBa0Msa0NBQWtDOztBQUVwRSxDQUFDO0FBQ0QsdUNBQXVDLGFBQWE7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsYUFBYTs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELHFCQUFxQixhQUFhOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQiw0QkFBNEI7O0FBRTNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMEJBQTBCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYzs7QUFFbkM7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxPQUFPLGVBQWU7QUFDdEI7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQjs7QUFFQTtBQUNBLDRDQUE0QyxjQUFjOztBQUUxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMEJBQTBCLEVBQUU7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLGNBQWM7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQixFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFLGNBQWM7O0FBRXpGO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCx3QkFBd0I7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYzs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQThELEVBQUU7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxnRUFBZ0UsRUFBRTs7QUFFeEU7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLDRCQUE0Qjs7QUFFekU7QUFDQSxRQUFRLGNBQWM7QUFDdEI7O0FBRUE7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FLGtDQUFrQywrQkFBK0I7QUFDakUsbUNBQW1DLGdDQUFnQztBQUNuRSxnQ0FBZ0MseURBQXlEO0FBQ3pGLG1DQUFtQyxnQ0FBZ0M7QUFDbkUsd0NBQXdDLGlEQUFpRDs7QUFFekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRTtBQUNBLFVBQVUsc0NBQXNDLG1CQUFtQjtBQUNuRSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTs7QUFFMUI7QUFDQSxpQ0FBaUMseUJBQXlCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQyxTQUFTLG9CQUFvQjs7QUFFN0I7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JELElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCx3Q0FBd0MsYUFBYTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBLFNBQVMsbUNBQW1DLEU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBK0M7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlDQUFpQzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCw0QkFBNEI7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBLDhFQUE4RSx5QkFBeUIsRUFBRTtBQUN6Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsMEJBQTBCOztBQUVyRztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjs7QUFFcEI7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0EscUJBQXFCLGFBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0RBQWdEOztBQUUvRDtBQUNBLHVCQUF1QixnQkFBZ0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQsbUNBQW1DLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCxRQUFRLHlCQUF5Qjs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRSxxQkFBcUI7O0FBRXJGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsMEJBQTBCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRCxFQUFFOztBQUVGO0FBQ0EscUJBQXFCLGNBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdURBQXVEO0FBQ2xFO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLHFCQUFxQixRQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRCxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0QsbUNBQW1DLDZCQUE2QjtBQUNoRTs7QUFFQTtBQUNBLDREQUE0RCwyQkFBMkI7QUFDdkYsd0RBQXdELDJCQUEyQjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2QkFBNkIsZ0JBQWdCO0FBQzdFLHFEQUFxRCxvQkFBb0I7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4Qjs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw4QkFBOEI7O0FBRW5GO0FBQ0EsUUFBUSxnQ0FBZ0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFROztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QyxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnQkFBZ0I7O0FBRTFDO0FBQ0E7QUFDQSxFQUFFLEU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixhQUFhOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7O0FBRTFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSx3QkFBd0IsRUFBRTtBQUNsQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7O0FBRXhEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQjtBQUNBLDJDQUEyQyxvQkFBb0IseUJBQXlCO0FBQ3hGLHNEQUFzRCwyQkFBMkI7QUFDakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELG9CQUFvQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBLHVDQUF1QyxpQ0FBaUM7QUFDeEUsc0NBQXNDLGdDQUFnQztBQUN0RSx3Q0FBd0Msa0NBQWtDO0FBQzFFLHFDQUFxQywrQkFBK0I7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixxQkFBcUI7QUFDL0MsZ0NBQWdDLG9DQUFvQztBQUNwRSxTQUFTLHNDQUFzQzs7QUFFL0MseUJBQXlCLHNCQUFzQjtBQUMvQyxpQ0FBaUMsc0NBQXNDO0FBQ3ZFLFNBQVMsdUNBQXVDOztBQUVoRCxzQkFBc0I7QUFDdEI7QUFDQSwyQkFBMkIsT0FBTzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DLHdDQUF3QyxjQUFjOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxREFBcUQ7QUFDMUQsS0FBSztBQUNMOztBQUVBLHdFQUF3RSxXQUFXO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQkFBbUIsZ0JBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxjQUFjOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGLHdCQUF3QixtQkFBbUIsWUFBWSx5QkFBeUI7QUFDaEYsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsOEJBQThCO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsOENBQThDLGFBQWE7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZELG1CQUFtQixpQ0FBaUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUMiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogcVRpcDIgLSBQcmV0dHkgcG93ZXJmdWwgdG9vbHRpcHMgLSBAQHZWRVJTSU9OXG4gKiBodHRwOi8vcXRpcDIuY29tXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IENyYWlnIE1pY2hhZWwgVGhvbXBzb25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQsIEdQTCBsaWNlbnNlc1xuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IEZyaSBKdWwgMjUgMjAxNCAwMToxMiBFRFQtMDQwMFxuQEBCVUlMRFBST1BTICovXG4vKmdsb2JhbCB3aW5kb3c6IGZhbHNlLCBqUXVlcnk6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSwgZGVmaW5lOiBmYWxzZSAqL1xuXG4vKiBDYWNoZSB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKi9cbihmdW5jdGlvbiggd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXG4vLyBVc2VzIEFNRCBvciBicm93c2VyIGdsb2JhbHMgdG8gY3JlYXRlIGEgalF1ZXJ5IHBsdWdpbi5cbihmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIGlmKGpRdWVyeSAmJiAhalF1ZXJ5LmZuLnF0aXApIHtcblx0XHRmYWN0b3J5KGpRdWVyeSk7XG5cdH1cbn1cbihmdW5jdGlvbigkKSB7XG5cdFwidXNlIHN0cmljdFwiOyAvLyBFbmFibGUgRUNNQVNjcmlwdCBcInN0cmljdFwiIG9wZXJhdGlvbiBmb3IgdGhpcyBmdW5jdGlvbi4gU2VlIG1vcmU6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9lY21hc2NyaXB0LTUtc3RyaWN0LW1vZGUtanNvbi1hbmQtbW9yZS9cblxuOy8vIE11bmdlIHRoZSBwcmltaXRpdmVzIC0gUGF1bCBJcmlzaCB0aXBcbnZhciBUUlVFID0gdHJ1ZSxcbkZBTFNFID0gZmFsc2UsXG5OVUxMID0gbnVsbCxcblxuLy8gQ29tbW9uIHZhcmlhYmxlc1xuWCA9ICd4JywgWSA9ICd5JyxcbldJRFRIID0gJ3dpZHRoJyxcbkhFSUdIVCA9ICdoZWlnaHQnLFxuXG4vLyBQb3NpdGlvbmluZyBzaWRlc1xuVE9QID0gJ3RvcCcsXG5MRUZUID0gJ2xlZnQnLFxuQk9UVE9NID0gJ2JvdHRvbScsXG5SSUdIVCA9ICdyaWdodCcsXG5DRU5URVIgPSAnY2VudGVyJyxcblxuLy8gUG9zaXRpb24gYWRqdXN0bWVudCB0eXBlc1xuRkxJUCA9ICdmbGlwJyxcbkZMSVBJTlZFUlQgPSAnZmxpcGludmVydCcsXG5TSElGVCA9ICdzaGlmdCcsXG5cbi8vIFNob3J0Y3V0IHZhcnNcblFUSVAsIFBST1RPVFlQRSwgQ09STkVSLCBDSEVDS1MsXG5QTFVHSU5TID0ge30sXG5OQU1FU1BBQ0UgPSAncXRpcCcsXG5BVFRSX0hBUyA9ICdkYXRhLWhhc3F0aXAnLFxuQVRUUl9JRCA9ICdkYXRhLXF0aXAtaWQnLFxuV0lER0VUID0gWyd1aS13aWRnZXQnLCAndWktdG9vbHRpcCddLFxuU0VMRUNUT1IgPSAnLicrTkFNRVNQQUNFLFxuSU5BQ1RJVkVfRVZFTlRTID0gJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZWxlYXZlIG1vdXNlZW50ZXInLnNwbGl0KCcgJyksXG5cbkNMQVNTX0ZJWEVEID0gTkFNRVNQQUNFKyctZml4ZWQnLFxuQ0xBU1NfREVGQVVMVCA9IE5BTUVTUEFDRSArICctZGVmYXVsdCcsXG5DTEFTU19GT0NVUyA9IE5BTUVTUEFDRSArICctZm9jdXMnLFxuQ0xBU1NfSE9WRVIgPSBOQU1FU1BBQ0UgKyAnLWhvdmVyJyxcbkNMQVNTX0RJU0FCTEVEID0gTkFNRVNQQUNFKyctZGlzYWJsZWQnLFxuXG5yZXBsYWNlU3VmZml4ID0gJ19yZXBsYWNlZEJ5cVRpcCcsXG5vbGR0aXRsZSA9ICdvbGR0aXRsZScsXG50cmFja2luZ0JvdW5kLFxuXG4vLyBCcm93c2VyIGRldGVjdGlvblxuQlJPV1NFUiA9IHtcblx0Lypcblx0ICogSUUgdmVyc2lvbiBkZXRlY3Rpb25cblx0ICpcblx0ICogQWRhcHRlZCBmcm9tOiBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvYXR0YWNrLW9mLXRoZS1pZS1jb25kaXRpb25hbC1jb21tZW50XG5cdCAqIENyZWRpdCB0byBKYW1lcyBQYWRvbHNleSBmb3IgdGhlIG9yaWdpbmFsIGltcGxlbW50YXRpb24hXG5cdCAqL1xuXHRpZTogKGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHYgPSAzLCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR3aGlsZSAoKGRpdi5pbm5lckhUTUwgPSAnPCEtLVtpZiBndCBJRSAnKygrK3YpKyddPjxpPjwvaT48IVtlbmRpZl0tLT4nKSkge1xuXHRcdFx0aWYoIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpWzBdKSB7IGJyZWFrOyB9XG5cdFx0fVxuXHRcdHJldHVybiB2ID4gNCA/IHYgOiBOYU47XG5cdH0oKSksXG4gXG5cdC8qXG5cdCAqIGlPUyB2ZXJzaW9uIGRldGVjdGlvblxuXHQgKi9cblx0aU9TOiBwYXJzZUZsb2F0KCBcblx0XHQoJycgKyAoL0NQVS4qT1MgKFswLTlfXXsxLDV9KXwoQ1BVIGxpa2UpLipBcHBsZVdlYktpdC4qTW9iaWxlL2kuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwnJ10pWzFdKVxuXHRcdC5yZXBsYWNlKCd1bmRlZmluZWQnLCAnM18yJykucmVwbGFjZSgnXycsICcuJykucmVwbGFjZSgnXycsICcnKVxuXHQpIHx8IEZBTFNFXG59O1xuXG47ZnVuY3Rpb24gUVRpcCh0YXJnZXQsIG9wdGlvbnMsIGlkLCBhdHRyKSB7XG5cdC8vIEVsZW1lbnRzIGFuZCBJRFxuXHR0aGlzLmlkID0gaWQ7XG5cdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHR0aGlzLnRvb2x0aXAgPSBOVUxMO1xuXHR0aGlzLmVsZW1lbnRzID0geyB0YXJnZXQ6IHRhcmdldCB9O1xuXG5cdC8vIEludGVybmFsIGNvbnN0cnVjdHNcblx0dGhpcy5faWQgPSBOQU1FU1BBQ0UgKyAnLScgKyBpZDtcblx0dGhpcy50aW1lcnMgPSB7IGltZzoge30gfTtcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0dGhpcy5wbHVnaW5zID0ge307XG5cblx0Ly8gQ2FjaGUgb2JqZWN0XG5cdHRoaXMuY2FjaGUgPSB7XG5cdFx0ZXZlbnQ6IHt9LFxuXHRcdHRhcmdldDogJCgpLFxuXHRcdGRpc2FibGVkOiBGQUxTRSxcblx0XHRhdHRyOiBhdHRyLFxuXHRcdG9uVG9vbHRpcDogRkFMU0UsXG5cdFx0bGFzdENsYXNzOiAnJ1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgaW5pdGlhbCBmbGFnc1xuXHR0aGlzLnJlbmRlcmVkID0gdGhpcy5kZXN0cm95ZWQgPSB0aGlzLmRpc2FibGVkID0gdGhpcy53YWl0aW5nID0gXG5cdFx0dGhpcy5oaWRkZW5EdXJpbmdXYWl0ID0gdGhpcy5wb3NpdGlvbmluZyA9IHRoaXMudHJpZ2dlcmluZyA9IEZBTFNFO1xufVxuUFJPVE9UWVBFID0gUVRpcC5wcm90b3R5cGU7XG5cblBST1RPVFlQRS5fd2hlbiA9IGZ1bmN0aW9uKGRlZmVycmVkcykge1xuXHRyZXR1cm4gJC53aGVuLmFwcGx5KCQsIGRlZmVycmVkcyk7XG59O1xuXG5QUk9UT1RZUEUucmVuZGVyID0gZnVuY3Rpb24oc2hvdykge1xuXHRpZih0aGlzLnJlbmRlcmVkIHx8IHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9IC8vIElmIHRvb2x0aXAgaGFzIGFscmVhZHkgYmVlbiByZW5kZXJlZCwgZXhpdFxuXG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdGNhY2hlID0gdGhpcy5jYWNoZSxcblx0XHRlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXG5cdFx0dGV4dCA9IG9wdGlvbnMuY29udGVudC50ZXh0LFxuXHRcdHRpdGxlID0gb3B0aW9ucy5jb250ZW50LnRpdGxlLFxuXHRcdGJ1dHRvbiA9IG9wdGlvbnMuY29udGVudC5idXR0b24sXG5cdFx0cG9zT3B0aW9ucyA9IG9wdGlvbnMucG9zaXRpb24sXG5cdFx0bmFtZXNwYWNlID0gJy4nK3RoaXMuX2lkKycgJyxcblx0XHRkZWZlcnJlZHMgPSBbXSxcblx0XHR0b29sdGlwO1xuXG5cdC8vIEFkZCBBUklBIGF0dHJpYnV0ZXMgdG8gdGFyZ2V0XG5cdCQuYXR0cih0aGlzLnRhcmdldFswXSwgJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl9pZCk7XG5cblx0Ly8gQ3JlYXRlIHRvb2x0aXAgZWxlbWVudFxuXHR0aGlzLnRvb2x0aXAgPSBlbGVtZW50cy50b29sdGlwID0gdG9vbHRpcCA9ICQoJzxkaXYvPicsIHtcblx0XHQnaWQnOiB0aGlzLl9pZCxcblx0XHQnY2xhc3MnOiBbIE5BTUVTUEFDRSwgQ0xBU1NfREVGQVVMVCwgb3B0aW9ucy5zdHlsZS5jbGFzc2VzLCBOQU1FU1BBQ0UgKyAnLXBvcy0nICsgb3B0aW9ucy5wb3NpdGlvbi5teS5hYmJyZXYoKSBdLmpvaW4oJyAnKSxcblx0XHQnd2lkdGgnOiBvcHRpb25zLnN0eWxlLndpZHRoIHx8ICcnLFxuXHRcdCdoZWlnaHQnOiBvcHRpb25zLnN0eWxlLmhlaWdodCB8fCAnJyxcblx0XHQndHJhY2tpbmcnOiBwb3NPcHRpb25zLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBwb3NPcHRpb25zLmFkanVzdC5tb3VzZSxcblxuXHRcdC8qIEFSSUEgc3BlY2lmaWMgYXR0cmlidXRlcyAqL1xuXHRcdCdyb2xlJzogJ2FsZXJ0Jyxcblx0XHQnYXJpYS1saXZlJzogJ3BvbGl0ZScsXG5cdFx0J2FyaWEtYXRvbWljJzogRkFMU0UsXG5cdFx0J2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLl9pZCArICctY29udGVudCcsXG5cdFx0J2FyaWEtaGlkZGVuJzogVFJVRVxuXHR9KVxuXHQudG9nZ2xlQ2xhc3MoQ0xBU1NfRElTQUJMRUQsIHRoaXMuZGlzYWJsZWQpXG5cdC5hdHRyKEFUVFJfSUQsIHRoaXMuaWQpXG5cdC5kYXRhKE5BTUVTUEFDRSwgdGhpcylcblx0LmFwcGVuZFRvKHBvc09wdGlvbnMuY29udGFpbmVyKVxuXHQuYXBwZW5kKFxuXHRcdC8vIENyZWF0ZSBjb250ZW50IGVsZW1lbnRcblx0XHRlbGVtZW50cy5jb250ZW50ID0gJCgnPGRpdiAvPicsIHtcblx0XHRcdCdjbGFzcyc6IE5BTUVTUEFDRSArICctY29udGVudCcsXG5cdFx0XHQnaWQnOiB0aGlzLl9pZCArICctY29udGVudCcsXG5cdFx0XHQnYXJpYS1hdG9taWMnOiBUUlVFXG5cdFx0fSlcblx0KTtcblxuXHQvLyBTZXQgcmVuZGVyZWQgZmxhZyBhbmQgcHJldmVudCByZWR1bmRhbnQgcmVwb3NpdGlvbiBjYWxscyBmb3Igbm93XG5cdHRoaXMucmVuZGVyZWQgPSAtMTtcblx0dGhpcy5wb3NpdGlvbmluZyA9IFRSVUU7XG5cblx0Ly8gQ3JlYXRlIHRpdGxlLi4uXG5cdGlmKHRpdGxlKSB7XG5cdFx0dGhpcy5fY3JlYXRlVGl0bGUoKTtcblxuXHRcdC8vIFVwZGF0ZSB0aXRsZSBvbmx5IGlmIGl0cyBub3QgYSBjYWxsYmFjayAoY2FsbGVkIGluIHRvZ2dsZSBpZiBzbylcblx0XHRpZighJC5pc0Z1bmN0aW9uKHRpdGxlKSkge1xuXHRcdFx0ZGVmZXJyZWRzLnB1c2goIHRoaXMuX3VwZGF0ZVRpdGxlKHRpdGxlLCBGQUxTRSkgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDcmVhdGUgYnV0dG9uXG5cdGlmKGJ1dHRvbikgeyB0aGlzLl9jcmVhdGVCdXR0b24oKTsgfVxuXG5cdC8vIFNldCBwcm9wZXIgcmVuZGVyZWQgZmxhZyBhbmQgdXBkYXRlIGNvbnRlbnQgaWYgbm90IGEgY2FsbGJhY2sgZnVuY3Rpb24gKGNhbGxlZCBpbiB0b2dnbGUpXG5cdGlmKCEkLmlzRnVuY3Rpb24odGV4dCkpIHtcblx0XHRkZWZlcnJlZHMucHVzaCggdGhpcy5fdXBkYXRlQ29udGVudCh0ZXh0LCBGQUxTRSkgKTtcblx0fVxuXHR0aGlzLnJlbmRlcmVkID0gVFJVRTtcblxuXHQvLyBTZXR1cCB3aWRnZXQgY2xhc3Nlc1xuXHR0aGlzLl9zZXRXaWRnZXQoKTtcblxuXHQvLyBJbml0aWFsaXplICdyZW5kZXInIHBsdWdpbnNcblx0JC5lYWNoKFBMVUdJTlMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgaW5zdGFuY2U7XG5cdFx0aWYodGhpcy5pbml0aWFsaXplID09PSAncmVuZGVyJyAmJiAoaW5zdGFuY2UgPSB0aGlzKHNlbGYpKSkge1xuXHRcdFx0c2VsZi5wbHVnaW5zW25hbWVdID0gaW5zdGFuY2U7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBVbmFzc2lnbiBpbml0aWFsIGV2ZW50cyBhbmQgYXNzaWduIHByb3BlciBldmVudHNcblx0dGhpcy5fdW5hc3NpZ25FdmVudHMoKTtcblx0dGhpcy5fYXNzaWduRXZlbnRzKCk7XG5cblx0Ly8gV2hlbiBkZWZlcnJlZHMgaGF2ZSBjb21wbGV0ZWRcblx0dGhpcy5fd2hlbihkZWZlcnJlZHMpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0Ly8gdG9vbHRpcHJlbmRlciBldmVudFxuXHRcdHNlbGYuX3RyaWdnZXIoJ3JlbmRlcicpO1xuXG5cdFx0Ly8gUmVzZXQgZmxhZ3Ncblx0XHRzZWxmLnBvc2l0aW9uaW5nID0gRkFMU0U7XG5cblx0XHQvLyBTaG93IHRvb2x0aXAgaWYgbm90IGhpZGRlbiBkdXJpbmcgd2FpdCBwZXJpb2Rcblx0XHRpZighc2VsZi5oaWRkZW5EdXJpbmdXYWl0ICYmIChvcHRpb25zLnNob3cucmVhZHkgfHwgc2hvdykpIHtcblx0XHRcdHNlbGYudG9nZ2xlKFRSVUUsIGNhY2hlLmV2ZW50LCBGQUxTRSk7XG5cdFx0fVxuXHRcdHNlbGYuaGlkZGVuRHVyaW5nV2FpdCA9IEZBTFNFO1xuXHR9KTtcblxuXHQvLyBFeHBvc2UgQVBJXG5cdFFUSVAuYXBpW3RoaXMuaWRdID0gdGhpcztcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblBST1RPVFlQRS5kZXN0cm95ID0gZnVuY3Rpb24oaW1tZWRpYXRlKSB7XG5cdC8vIFNldCBmbGFnIHRoZSBzaWduaWZ5IGRlc3Ryb3kgaXMgdGFraW5nIHBsYWNlIHRvIHBsdWdpbnNcblx0Ly8gYW5kIGVuc3VyZSBpdCBvbmx5IGdldHMgZGVzdHJveWVkIG9uY2UhXG5cdGlmKHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzLnRhcmdldDsgfVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdFx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5kZXN0cm95ZWQgPSBUUlVFO1xuXHRcdFxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCxcblx0XHRcdHRpdGxlID0gdGFyZ2V0LmF0dHIob2xkdGl0bGUpO1xuXG5cdFx0Ly8gRGVzdHJveSB0b29sdGlwIGlmIHJlbmRlcmVkXG5cdFx0aWYodGhpcy5yZW5kZXJlZCkge1xuXHRcdFx0dGhpcy50b29sdGlwLnN0b3AoMSwwKS5maW5kKCcqJykucmVtb3ZlKCkuZW5kKCkucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVzdHJveSBhbGwgcGx1Z2luc1xuXHRcdCQuZWFjaCh0aGlzLnBsdWdpbnMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXMuZGVzdHJveSAmJiB0aGlzLmRlc3Ryb3koKTtcblx0XHR9KTtcblxuXHRcdC8vIENsZWFyIHRpbWVycyBhbmQgcmVtb3ZlIGJvdW5kIGV2ZW50c1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaGlkZSk7XG5cdFx0dGhpcy5fdW5hc3NpZ25FdmVudHMoKTtcblxuXHRcdC8vIFJlbW92ZSBhcGkgb2JqZWN0IGFuZCBBUklBIGF0dHJpYnV0ZXNcblx0XHR0YXJnZXQucmVtb3ZlRGF0YShOQU1FU1BBQ0UpXG5cdFx0XHQucmVtb3ZlQXR0cihBVFRSX0lEKVxuXHRcdFx0LnJlbW92ZUF0dHIoQVRUUl9IQVMpXG5cdFx0XHQucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpO1xuXG5cdFx0Ly8gUmVzZXQgb2xkIHRpdGxlIGF0dHJpYnV0ZSBpZiByZW1vdmVkXG5cdFx0aWYodGhpcy5vcHRpb25zLnN1cHByZXNzICYmIHRpdGxlKSB7XG5cdFx0XHR0YXJnZXQuYXR0cigndGl0bGUnLCB0aXRsZSkucmVtb3ZlQXR0cihvbGR0aXRsZSk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHFUaXAgZXZlbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEFQSVxuXHRcdHRoaXMuX3VuYmluZCh0YXJnZXQpO1xuXG5cdFx0Ly8gUmVtb3ZlIElEIGZyb20gdXNlZCBpZCBvYmplY3RzLCBhbmQgZGVsZXRlIG9iamVjdCByZWZlcmVuY2VzXG5cdFx0Ly8gZm9yIGJldHRlciBnYXJiYWdlIGNvbGxlY3Rpb24gYW5kIGxlYWsgcHJvdGVjdGlvblxuXHRcdHRoaXMub3B0aW9ucyA9IHRoaXMuZWxlbWVudHMgPSB0aGlzLmNhY2hlID0gdGhpcy50aW1lcnMgPSBcblx0XHRcdHRoaXMucGx1Z2lucyA9IHRoaXMubW91c2UgPSBOVUxMO1xuXG5cdFx0Ly8gRGVsZXRlIGVwb3hzZWQgQVBJIG9iamVjdFxuXHRcdGRlbGV0ZSBRVElQLmFwaVt0aGlzLmlkXTtcblx0fVxuXG5cdC8vIElmIGFuIGltbWVkaWF0ZSBkZXN0b3J5IGlzIG5lZWRlZFxuXHRpZigoaW1tZWRpYXRlICE9PSBUUlVFIHx8IHRoaXMudHJpZ2dlcmluZyA9PT0gJ2hpZGUnKSAmJiB0aGlzLnJlbmRlcmVkKSB7XG5cdFx0dGhpcy50b29sdGlwLm9uZSgndG9vbHRpcGhpZGRlbicsICQucHJveHkocHJvY2VzcywgdGhpcykpO1xuXHRcdCF0aGlzLnRyaWdnZXJpbmcgJiYgdGhpcy5oaWRlKCk7XG5cdH1cblxuXHQvLyBJZiB3ZSdyZSBub3QgaW4gdGhlIHByb2Nlc3Mgb2YgaGlkaW5nLi4uIHByb2Nlc3Ncblx0ZWxzZSB7IHByb2Nlc3MuY2FsbCh0aGlzKTsgfVxuXG5cdHJldHVybiB0aGlzLnRhcmdldDtcbn07XG5cbjtmdW5jdGlvbiBpbnZhbGlkT3B0KGEpIHtcblx0cmV0dXJuIGEgPT09IE5VTEwgfHwgJC50eXBlKGEpICE9PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaW52YWxpZENvbnRlbnQoYykge1xuXHRyZXR1cm4gISggJC5pc0Z1bmN0aW9uKGMpIHx8IChjICYmIGMuYXR0cikgfHwgYy5sZW5ndGggfHwgKCQudHlwZShjKSA9PT0gJ29iamVjdCcgJiYgKGMuanF1ZXJ5IHx8IGMudGhlbikgKSk7XG59XG5cbi8vIE9wdGlvbiBvYmplY3Qgc2FuaXRpemVyXG5mdW5jdGlvbiBzYW5pdGl6ZU9wdGlvbnMob3B0cykge1xuXHR2YXIgY29udGVudCwgdGV4dCwgYWpheCwgb25jZTtcblxuXHRpZihpbnZhbGlkT3B0KG9wdHMpKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdGlmKGludmFsaWRPcHQob3B0cy5tZXRhZGF0YSkpIHtcblx0XHRvcHRzLm1ldGFkYXRhID0geyB0eXBlOiBvcHRzLm1ldGFkYXRhIH07XG5cdH1cblxuXHRpZignY29udGVudCcgaW4gb3B0cykge1xuXHRcdGNvbnRlbnQgPSBvcHRzLmNvbnRlbnQ7XG5cblx0XHRpZihpbnZhbGlkT3B0KGNvbnRlbnQpIHx8IGNvbnRlbnQuanF1ZXJ5IHx8IGNvbnRlbnQuZG9uZSkge1xuXHRcdFx0Y29udGVudCA9IG9wdHMuY29udGVudCA9IHtcblx0XHRcdFx0dGV4dDogKHRleHQgPSBpbnZhbGlkQ29udGVudChjb250ZW50KSA/IEZBTFNFIDogY29udGVudClcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgeyB0ZXh0ID0gY29udGVudC50ZXh0OyB9XG5cblx0XHQvLyBERVBSRUNBVEVEIC0gT2xkIGNvbnRlbnQuYWpheCBwbHVnaW4gZnVuY3Rpb25hbGl0eVxuXHRcdC8vIENvbnZlcnRzIGl0IGludG8gdGhlIHByb3BlciBEZWZlcnJlZCBzeW50YXhcblx0XHRpZignYWpheCcgaW4gY29udGVudCkge1xuXHRcdFx0YWpheCA9IGNvbnRlbnQuYWpheDtcblx0XHRcdG9uY2UgPSBhamF4ICYmIGFqYXgub25jZSAhPT0gRkFMU0U7XG5cdFx0XHRkZWxldGUgY29udGVudC5hamF4O1xuXG5cdFx0XHRjb250ZW50LnRleHQgPSBmdW5jdGlvbihldmVudCwgYXBpKSB7XG5cdFx0XHRcdHZhciBsb2FkaW5nID0gdGV4dCB8fCAkKHRoaXMpLmF0dHIoYXBpLm9wdGlvbnMuY29udGVudC5hdHRyKSB8fCAnTG9hZGluZy4uLicsXG5cblx0XHRcdFx0ZGVmZXJyZWQgPSAkLmFqYXgoXG5cdFx0XHRcdFx0JC5leHRlbmQoe30sIGFqYXgsIHsgY29udGV4dDogYXBpIH0pXG5cdFx0XHRcdClcblx0XHRcdFx0LnRoZW4oYWpheC5zdWNjZXNzLCBOVUxMLCBhamF4LmVycm9yKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0XHRcdFx0aWYoY29udGVudCAmJiBvbmNlKSB7IGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIGNvbnRlbnQpOyB9XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uKHhociwgc3RhdHVzLCBlcnJvcikge1xuXHRcdFx0XHRcdGlmKGFwaS5kZXN0cm95ZWQgfHwgeGhyLnN0YXR1cyA9PT0gMCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRhcGkuc2V0KCdjb250ZW50LnRleHQnLCBzdGF0dXMgKyAnOiAnICsgZXJyb3IpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gIW9uY2UgPyAoYXBpLnNldCgnY29udGVudC50ZXh0JywgbG9hZGluZyksIGRlZmVycmVkKSA6IGxvYWRpbmc7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmKCd0aXRsZScgaW4gY29udGVudCkge1xuXHRcdFx0aWYoIWludmFsaWRPcHQoY29udGVudC50aXRsZSkpIHtcblx0XHRcdFx0Y29udGVudC5idXR0b24gPSBjb250ZW50LnRpdGxlLmJ1dHRvbjtcblx0XHRcdFx0Y29udGVudC50aXRsZSA9IGNvbnRlbnQudGl0bGUudGV4dDtcblx0XHRcdH1cblxuXHRcdFx0aWYoaW52YWxpZENvbnRlbnQoY29udGVudC50aXRsZSB8fCBGQUxTRSkpIHtcblx0XHRcdFx0Y29udGVudC50aXRsZSA9IEZBTFNFO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmKCdwb3NpdGlvbicgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMucG9zaXRpb24pKSB7XG5cdFx0b3B0cy5wb3NpdGlvbiA9IHsgbXk6IG9wdHMucG9zaXRpb24sIGF0OiBvcHRzLnBvc2l0aW9uIH07XG5cdH1cblxuXHRpZignc2hvdycgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMuc2hvdykpIHtcblx0XHRvcHRzLnNob3cgPSBvcHRzLnNob3cuanF1ZXJ5ID8geyB0YXJnZXQ6IG9wdHMuc2hvdyB9IDogXG5cdFx0XHRvcHRzLnNob3cgPT09IFRSVUUgPyB7IHJlYWR5OiBUUlVFIH0gOiB7IGV2ZW50OiBvcHRzLnNob3cgfTtcblx0fVxuXG5cdGlmKCdoaWRlJyBpbiBvcHRzICYmIGludmFsaWRPcHQob3B0cy5oaWRlKSkge1xuXHRcdG9wdHMuaGlkZSA9IG9wdHMuaGlkZS5qcXVlcnkgPyB7IHRhcmdldDogb3B0cy5oaWRlIH0gOiB7IGV2ZW50OiBvcHRzLmhpZGUgfTtcblx0fVxuXG5cdGlmKCdzdHlsZScgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMuc3R5bGUpKSB7XG5cdFx0b3B0cy5zdHlsZSA9IHsgY2xhc3Nlczogb3B0cy5zdHlsZSB9O1xuXHR9XG5cblx0Ly8gU2FuaXRpemUgcGx1Z2luIG9wdGlvbnNcblx0JC5lYWNoKFBMVUdJTlMsIGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2FuaXRpemUgJiYgdGhpcy5zYW5pdGl6ZShvcHRzKTtcblx0fSk7XG5cblx0cmV0dXJuIG9wdHM7XG59XG5cbi8vIFNldHVwIGJ1aWx0aW4gLnNldCgpIG9wdGlvbiBjaGVja3NcbkNIRUNLUyA9IFBST1RPVFlQRS5jaGVja3MgPSB7XG5cdGJ1aWx0aW46IHtcblx0XHQvLyBDb3JlIGNoZWNrc1xuXHRcdCdeaWQkJzogZnVuY3Rpb24ob2JqLCBvLCB2LCBwcmV2KSB7XG5cdFx0XHR2YXIgaWQgPSB2ID09PSBUUlVFID8gUVRJUC5uZXh0aWQgOiB2LFxuXHRcdFx0XHRuZXdfaWQgPSBOQU1FU1BBQ0UgKyAnLScgKyBpZDtcblxuXHRcdFx0aWYoaWQgIT09IEZBTFNFICYmIGlkLmxlbmd0aCA+IDAgJiYgISQoJyMnK25ld19pZCkubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2lkID0gbmV3X2lkO1xuXG5cdFx0XHRcdGlmKHRoaXMucmVuZGVyZWQpIHtcblx0XHRcdFx0XHR0aGlzLnRvb2x0aXBbMF0uaWQgPSB0aGlzLl9pZDtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzLmNvbnRlbnRbMF0uaWQgPSB0aGlzLl9pZCArICctY29udGVudCc7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50cy50aXRsZVswXS5pZCA9IHRoaXMuX2lkICsgJy10aXRsZSc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgeyBvYmpbb10gPSBwcmV2OyB9XG5cdFx0fSxcblx0XHQnXnByZXJlbmRlcic6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0diAmJiAhdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnJlbmRlcih0aGlzLm9wdGlvbnMuc2hvdy5yZWFkeSk7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnQgY2hlY2tzXG5cdFx0J15jb250ZW50LnRleHQkJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR0aGlzLl91cGRhdGVDb250ZW50KHYpO1xuXHRcdH0sXG5cdFx0J15jb250ZW50LmF0dHIkJzogZnVuY3Rpb24ob2JqLCBvLCB2LCBwcmV2KSB7XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuY29udGVudC50ZXh0ID09PSB0aGlzLnRhcmdldC5hdHRyKHByZXYpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoIHRoaXMudGFyZ2V0LmF0dHIodikgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCdeY29udGVudC50aXRsZSQnOiBmdW5jdGlvbihvYmosIG8sIHYpIHtcblx0XHRcdC8vIFJlbW92ZSB0aXRsZSBpZiBjb250ZW50IGlzIG51bGxcblx0XHRcdGlmKCF2KSB7IHJldHVybiB0aGlzLl9yZW1vdmVUaXRsZSgpOyB9XG5cblx0XHRcdC8vIElmIHRpdGxlIGlzbid0IGFscmVhZHkgY3JlYXRlZCwgY3JlYXRlIGl0IG5vdyBhbmQgdXBkYXRlXG5cdFx0XHR2ICYmICF0aGlzLmVsZW1lbnRzLnRpdGxlICYmIHRoaXMuX2NyZWF0ZVRpdGxlKCk7XG5cdFx0XHR0aGlzLl91cGRhdGVUaXRsZSh2KTtcblx0XHR9LFxuXHRcdCdeY29udGVudC5idXR0b24kJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR0aGlzLl91cGRhdGVCdXR0b24odik7XG5cdFx0fSxcblx0XHQnXmNvbnRlbnQudGl0bGUuKHRleHR8YnV0dG9uKSQnOiBmdW5jdGlvbihvYmosIG8sIHYpIHtcblx0XHRcdHRoaXMuc2V0KCdjb250ZW50Licrbywgdik7IC8vIEJhY2t3YXJkcyB0aXRsZS50ZXh0L2J1dHRvbiBjb21wYXRcblx0XHR9LCBcblxuXHRcdC8vIFBvc2l0aW9uIGNoZWNrc1xuXHRcdCdecG9zaXRpb24uKG15fGF0KSQnOiBmdW5jdGlvbihvYmosIG8sIHYpe1xuXHRcdFx0J3N0cmluZycgPT09IHR5cGVvZiB2ICYmIChvYmpbb10gPSBuZXcgQ09STkVSKHYsIG8gPT09ICdhdCcpKTtcblx0XHR9LFxuXHRcdCdecG9zaXRpb24uY29udGFpbmVyJCc6IGZ1bmN0aW9uKG9iaiwgbywgdil7XG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC5hcHBlbmRUbyh2KTtcblx0XHR9LFxuXG5cdFx0Ly8gU2hvdyBjaGVja3Ncblx0XHQnXnNob3cucmVhZHkkJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR2ICYmICghdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnJlbmRlcihUUlVFKSB8fCB0aGlzLnRvZ2dsZShUUlVFKSk7XG5cdFx0fSxcblxuXHRcdC8vIFN0eWxlIGNoZWNrc1xuXHRcdCdec3R5bGUuY2xhc3NlcyQnOiBmdW5jdGlvbihvYmosIG8sIHYsIHApIHtcblx0XHRcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwLnJlbW92ZUNsYXNzKHApLmFkZENsYXNzKHYpO1xuXHRcdH0sXG5cdFx0J15zdHlsZS4od2lkdGh8aGVpZ2h0KSc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXAuY3NzKG8sIHYpO1xuXHRcdH0sXG5cdFx0J15zdHlsZS53aWRnZXR8Y29udGVudC50aXRsZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLl9zZXRXaWRnZXQoKTtcblx0XHR9LFxuXHRcdCdec3R5bGUuZGVmJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC50b2dnbGVDbGFzcyhDTEFTU19ERUZBVUxULCAhIXYpO1xuXHRcdH0sXG5cblx0XHQvLyBFdmVudHMgY2hlY2tcblx0XHQnXmV2ZW50cy4ocmVuZGVyfHNob3d8bW92ZXxoaWRlfGZvY3VzfGJsdXIpJCc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXBbKCQuaXNGdW5jdGlvbih2KSA/ICcnIDogJ3VuJykgKyAnYmluZCddKCd0b29sdGlwJytvLCB2KTtcblx0XHR9LFxuXG5cdFx0Ly8gUHJvcGVydGllcyB3aGljaCByZXF1aXJlIGV2ZW50IHJlYXNzaWdubWVudFxuXHRcdCdeKHNob3d8aGlkZXxwb3NpdGlvbikuKGV2ZW50fHRhcmdldHxmaXhlZHxpbmFjdGl2ZXxsZWF2ZXxkaXN0YW5jZXx2aWV3cG9ydHxhZGp1c3QpJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZighdGhpcy5yZW5kZXJlZCkgeyByZXR1cm47IH1cblxuXHRcdFx0Ly8gU2V0IHRyYWNraW5nIGZsYWdcblx0XHRcdHZhciBwb3NPcHRpb25zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0dGhpcy50b29sdGlwLmF0dHIoJ3RyYWNraW5nJywgcG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScgJiYgcG9zT3B0aW9ucy5hZGp1c3QubW91c2UpO1xuXG5cdFx0XHQvLyBSZWFzc2lnbiBldmVudHNcblx0XHRcdHRoaXMuX3VuYXNzaWduRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9hc3NpZ25FdmVudHMoKTtcblx0XHR9XG5cdH1cbn07XG5cbi8vIERvdCBub3RhdGlvbiBjb252ZXJ0ZXJcbmZ1bmN0aW9uIGNvbnZlcnROb3RhdGlvbihvcHRpb25zLCBub3RhdGlvbikge1xuXHR2YXIgaSA9IDAsIG9iaiwgb3B0aW9uID0gb3B0aW9ucyxcblxuXHQvLyBTcGxpdCBub3RhdGlvbiBpbnRvIGFycmF5XG5cdGxldmVscyA9IG5vdGF0aW9uLnNwbGl0KCcuJyk7XG5cblx0Ly8gTG9vcCB0aHJvdWdoXG5cdHdoaWxlKCBvcHRpb24gPSBvcHRpb25bIGxldmVsc1tpKytdIF0gKSB7XG5cdFx0aWYoaSA8IGxldmVscy5sZW5ndGgpIHsgb2JqID0gb3B0aW9uOyB9XG5cdH1cblxuXHRyZXR1cm4gW29iaiB8fCBvcHRpb25zLCBsZXZlbHMucG9wKCldO1xufVxuXG5QUk9UT1RZUEUuZ2V0ID0gZnVuY3Rpb24obm90YXRpb24pIHtcblx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHR2YXIgbyA9IGNvbnZlcnROb3RhdGlvbih0aGlzLm9wdGlvbnMsIG5vdGF0aW9uLnRvTG93ZXJDYXNlKCkpLFxuXHRcdHJlc3VsdCA9IG9bMF1bIG9bMV0gXTtcblxuXHRyZXR1cm4gcmVzdWx0LnByZWNlZGFuY2UgPyByZXN1bHQuc3RyaW5nKCkgOiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBzZXRDYWxsYmFjayhub3RhdGlvbiwgYXJncykge1xuXHR2YXIgY2F0ZWdvcnksIHJ1bGUsIG1hdGNoO1xuXG5cdGZvcihjYXRlZ29yeSBpbiB0aGlzLmNoZWNrcykge1xuXHRcdGZvcihydWxlIGluIHRoaXMuY2hlY2tzW2NhdGVnb3J5XSkge1xuXHRcdFx0aWYobWF0Y2ggPSAobmV3IFJlZ0V4cChydWxlLCAnaScpKS5leGVjKG5vdGF0aW9uKSkge1xuXHRcdFx0XHRhcmdzLnB1c2gobWF0Y2gpO1xuXG5cdFx0XHRcdGlmKGNhdGVnb3J5ID09PSAnYnVpbHRpbicgfHwgdGhpcy5wbHVnaW5zW2NhdGVnb3J5XSkge1xuXHRcdFx0XHRcdHRoaXMuY2hlY2tzW2NhdGVnb3J5XVtydWxlXS5hcHBseShcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luc1tjYXRlZ29yeV0gfHwgdGhpcywgYXJnc1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxudmFyIHJtb3ZlID0gL15wb3NpdGlvblxcLihteXxhdHxhZGp1c3R8dGFyZ2V0fGNvbnRhaW5lcnx2aWV3cG9ydCl8c3R5bGV8Y29udGVudHxzaG93XFwucmVhZHkvaSxcblx0cnJlbmRlciA9IC9ecHJlcmVuZGVyfHNob3dcXC5yZWFkeS9pO1xuXG5QUk9UT1RZUEUuc2V0ID0gZnVuY3Rpb24ob3B0aW9uLCB2YWx1ZSkge1xuXHRpZih0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdHZhciByZW5kZXJlZCA9IHRoaXMucmVuZGVyZWQsXG5cdFx0cmVwb3NpdGlvbiA9IEZBTFNFLFxuXHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0Y2hlY2tzID0gdGhpcy5jaGVja3MsXG5cdFx0bmFtZTtcblxuXHQvLyBDb252ZXJ0IHNpbmd1bGFyIG9wdGlvbi92YWx1ZSBwYWlyIGludG8gb2JqZWN0IGZvcm1cblx0aWYoJ3N0cmluZycgPT09IHR5cGVvZiBvcHRpb24pIHtcblx0XHRuYW1lID0gb3B0aW9uOyBvcHRpb24gPSB7fTsgb3B0aW9uW25hbWVdID0gdmFsdWU7XG5cdH1cblx0ZWxzZSB7IG9wdGlvbiA9ICQuZXh0ZW5kKHt9LCBvcHRpb24pOyB9XG5cblx0Ly8gU2V0IGFsbCBvZiB0aGUgZGVmaW5lZCBvcHRpb25zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0JC5lYWNoKG9wdGlvbiwgZnVuY3Rpb24obm90YXRpb24sIHZhbHVlKSB7XG5cdFx0aWYocmVuZGVyZWQgJiYgcnJlbmRlci50ZXN0KG5vdGF0aW9uKSkge1xuXHRcdFx0ZGVsZXRlIG9wdGlvbltub3RhdGlvbl07IHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTZXQgbmV3IG9iaiB2YWx1ZVxuXHRcdHZhciBvYmogPSBjb252ZXJ0Tm90YXRpb24ob3B0aW9ucywgbm90YXRpb24udG9Mb3dlckNhc2UoKSksIHByZXZpb3VzO1xuXHRcdHByZXZpb3VzID0gb2JqWzBdWyBvYmpbMV0gXTtcblx0XHRvYmpbMF1bIG9ialsxXSBdID0gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPyAkKHZhbHVlKSA6IHZhbHVlO1xuXG5cdFx0Ly8gQWxzbyBjaGVjayBpZiB3ZSBuZWVkIHRvIHJlcG9zaXRpb25cblx0XHRyZXBvc2l0aW9uID0gcm1vdmUudGVzdChub3RhdGlvbikgfHwgcmVwb3NpdGlvbjtcblxuXHRcdC8vIFNldCB0aGUgbmV3IHBhcmFtcyBmb3IgdGhlIGNhbGxiYWNrXG5cdFx0b3B0aW9uW25vdGF0aW9uXSA9IFtvYmpbMF0sIG9ialsxXSwgdmFsdWUsIHByZXZpb3VzXTtcblx0fSk7XG5cblx0Ly8gUmUtc2FuaXRpemUgb3B0aW9uc1xuXHRzYW5pdGl6ZU9wdGlvbnMob3B0aW9ucyk7XG5cblx0Lypcblx0ICogRXhlY3V0ZSBhbnkgdmFsaWQgY2FsbGJhY2tzIGZvciB0aGUgc2V0IG9wdGlvbnNcblx0ICogQWxzbyBzZXQgcG9zaXRpb25pbmcgZmxhZyBzbyB3ZSBkb24ndCBnZXQgbG9hZHMgb2YgcmVkdW5kYW50IHJlcG9zaXRpb25pbmcgY2FsbHMuXG5cdCAqL1xuXHR0aGlzLnBvc2l0aW9uaW5nID0gVFJVRTtcblx0JC5lYWNoKG9wdGlvbiwgJC5wcm94eShzZXRDYWxsYmFjaywgdGhpcykpO1xuXHR0aGlzLnBvc2l0aW9uaW5nID0gRkFMU0U7XG5cblx0Ly8gVXBkYXRlIHBvc2l0aW9uIGlmIG5lZWRlZFxuXHRpZih0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAgJiYgcmVwb3NpdGlvbikge1xuXHRcdHRoaXMucmVwb3NpdGlvbiggb3B0aW9ucy5wb3NpdGlvbi50YXJnZXQgPT09ICdtb3VzZScgPyBOVUxMIDogdGhpcy5jYWNoZS5ldmVudCApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG47UFJPVE9UWVBFLl91cGRhdGUgPSBmdW5jdGlvbihjb250ZW50LCBlbGVtZW50LCByZXBvc2l0aW9uKSB7XG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0Ly8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgcmVuZGVyZWQgYW5kIGNvbnRlbnQgaXMgZGVmaW5lZC4gSWYgbm90IHJldHVyblxuXHRpZighdGhpcy5yZW5kZXJlZCB8fCAhY29udGVudCkgeyByZXR1cm4gRkFMU0U7IH1cblxuXHQvLyBVc2UgZnVuY3Rpb24gdG8gcGFyc2UgY29udGVudFxuXHRpZigkLmlzRnVuY3Rpb24oY29udGVudCkpIHtcblx0XHRjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuZWxlbWVudHMudGFyZ2V0LCBjYWNoZS5ldmVudCwgdGhpcykgfHwgJyc7XG5cdH1cblxuXHQvLyBIYW5kbGUgZGVmZXJyZWQgY29udGVudFxuXHRpZigkLmlzRnVuY3Rpb24oY29udGVudC50aGVuKSkge1xuXHRcdGNhY2hlLndhaXRpbmcgPSBUUlVFO1xuXHRcdHJldHVybiBjb250ZW50LnRoZW4oZnVuY3Rpb24oYykge1xuXHRcdFx0Y2FjaGUud2FpdGluZyA9IEZBTFNFO1xuXHRcdFx0cmV0dXJuIHNlbGYuX3VwZGF0ZShjLCBlbGVtZW50KTtcblx0XHR9LCBOVUxMLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdXBkYXRlKGUsIGVsZW1lbnQpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gSWYgY29udGVudCBpcyBudWxsLi4uIHJldHVybiBmYWxzZVxuXHRpZihjb250ZW50ID09PSBGQUxTRSB8fCAoIWNvbnRlbnQgJiYgY29udGVudCAhPT0gJycpKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIEFwcGVuZCBuZXcgY29udGVudCBpZiBpdHMgYSBET00gYXJyYXkgYW5kIHNob3cgaXQgaWYgaGlkZGVuXG5cdGlmKGNvbnRlbnQuanF1ZXJ5ICYmIGNvbnRlbnQubGVuZ3RoID4gMCkge1xuXHRcdGVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoXG5cdFx0XHRjb250ZW50LmNzcyh7IGRpc3BsYXk6ICdibG9jaycsIHZpc2liaWxpdHk6ICd2aXNpYmxlJyB9KVxuXHRcdCk7XG5cdH1cblxuXHQvLyBDb250ZW50IGlzIGEgcmVndWxhciBzdHJpbmcsIGluc2VydCB0aGUgbmV3IGNvbnRlbnRcblx0ZWxzZSB7IGVsZW1lbnQuaHRtbChjb250ZW50KTsgfVxuXG5cdC8vIFdhaXQgZm9yIGNvbnRlbnQgdG8gYmUgbG9hZGVkLCBhbmQgcmVwb3NpdGlvblxuXHRyZXR1cm4gdGhpcy5fd2FpdEZvckNvbnRlbnQoZWxlbWVudCkudGhlbihmdW5jdGlvbihpbWFnZXMpIHtcblx0XHRpZihpbWFnZXMuaW1hZ2VzICYmIGltYWdlcy5pbWFnZXMubGVuZ3RoICYmIHNlbGYucmVuZGVyZWQgJiYgc2VsZi50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCkge1xuXHRcdFx0c2VsZi5yZXBvc2l0aW9uKGNhY2hlLmV2ZW50LCAhaW1hZ2VzLmxlbmd0aCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cblBST1RPVFlQRS5fd2FpdEZvckNvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cdHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFxuXHQvLyBTZXQgZmxhZ1xuXHRjYWNoZS53YWl0aW5nID0gVFJVRTtcblxuXHQvLyBJZiBpbWFnZXNMb2FkZWQgaXMgaW5jbHVkZWQsIGVuc3VyZSBpbWFnZXMgaGF2ZSBsb2FkZWQgYW5kIHJldHVybiBwcm9taXNlXG5cdHJldHVybiAoICQuZm4uaW1hZ2VzTG9hZGVkID8gZWxlbWVudC5pbWFnZXNMb2FkZWQoKSA6ICQuRGVmZXJyZWQoKS5yZXNvbHZlKFtdKSApXG5cdFx0LmRvbmUoZnVuY3Rpb24oKSB7IGNhY2hlLndhaXRpbmcgPSBGQUxTRTsgfSlcblx0XHQucHJvbWlzZSgpO1xufTtcblxuUFJPVE9UWVBFLl91cGRhdGVDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCwgcmVwb3NpdGlvbikge1xuXHR0aGlzLl91cGRhdGUoY29udGVudCwgdGhpcy5lbGVtZW50cy5jb250ZW50LCByZXBvc2l0aW9uKTtcbn07XG5cblBST1RPVFlQRS5fdXBkYXRlVGl0bGUgPSBmdW5jdGlvbihjb250ZW50LCByZXBvc2l0aW9uKSB7XG5cdGlmKHRoaXMuX3VwZGF0ZShjb250ZW50LCB0aGlzLmVsZW1lbnRzLnRpdGxlLCByZXBvc2l0aW9uKSA9PT0gRkFMU0UpIHtcblx0XHR0aGlzLl9yZW1vdmVUaXRsZShGQUxTRSk7XG5cdH1cbn07XG5cblBST1RPVFlQRS5fY3JlYXRlVGl0bGUgPSBmdW5jdGlvbigpXG57XG5cdHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXG5cdFx0aWQgPSB0aGlzLl9pZCsnLXRpdGxlJztcblxuXHQvLyBEZXN0cm95IHByZXZpb3VzIHRpdGxlIGVsZW1lbnQsIGlmIHByZXNlbnRcblx0aWYoZWxlbWVudHMudGl0bGViYXIpIHsgdGhpcy5fcmVtb3ZlVGl0bGUoKTsgfVxuXG5cdC8vIENyZWF0ZSB0aXRsZSBiYXIgYW5kIHRpdGxlIGVsZW1lbnRzXG5cdGVsZW1lbnRzLnRpdGxlYmFyID0gJCgnPGRpdiAvPicsIHtcblx0XHQnY2xhc3MnOiBOQU1FU1BBQ0UgKyAnLXRpdGxlYmFyICcgKyAodGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCA/IGNyZWF0ZVdpZGdldENsYXNzKCdoZWFkZXInKSA6ICcnKVxuXHR9KVxuXHQuYXBwZW5kKFxuXHRcdGVsZW1lbnRzLnRpdGxlID0gJCgnPGRpdiAvPicsIHtcblx0XHRcdCdpZCc6IGlkLFxuXHRcdFx0J2NsYXNzJzogTkFNRVNQQUNFICsgJy10aXRsZScsXG5cdFx0XHQnYXJpYS1hdG9taWMnOiBUUlVFXG5cdFx0fSlcblx0KVxuXHQuaW5zZXJ0QmVmb3JlKGVsZW1lbnRzLmNvbnRlbnQpXG5cblx0Ly8gQnV0dG9uLXNwZWNpZmljIGV2ZW50c1xuXHQuZGVsZWdhdGUoJy5xdGlwLWNsb3NlJywgJ21vdXNlZG93biBrZXlkb3duIG1vdXNldXAga2V5dXAgbW91c2VvdXQnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdCQodGhpcykudG9nZ2xlQ2xhc3MoJ3VpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1mb2N1cycsIGV2ZW50LnR5cGUuc3Vic3RyKC00KSA9PT0gJ2Rvd24nKTtcblx0fSlcblx0LmRlbGVnYXRlKCcucXRpcC1jbG9zZScsICdtb3VzZW92ZXIgbW91c2VvdXQnLCBmdW5jdGlvbihldmVudCl7XG5cdFx0JCh0aGlzKS50b2dnbGVDbGFzcygndWktc3RhdGUtaG92ZXInLCBldmVudC50eXBlID09PSAnbW91c2VvdmVyJyk7XG5cdH0pO1xuXG5cdC8vIENyZWF0ZSBidXR0b24gaWYgZW5hYmxlZFxuXHRpZih0aGlzLm9wdGlvbnMuY29udGVudC5idXR0b24pIHsgdGhpcy5fY3JlYXRlQnV0dG9uKCk7IH1cbn07XG5cblBST1RPVFlQRS5fcmVtb3ZlVGl0bGUgPSBmdW5jdGlvbihyZXBvc2l0aW9uKVxue1xuXHR2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdGlmKGVsZW1lbnRzLnRpdGxlKSB7XG5cdFx0ZWxlbWVudHMudGl0bGViYXIucmVtb3ZlKCk7XG5cdFx0ZWxlbWVudHMudGl0bGViYXIgPSBlbGVtZW50cy50aXRsZSA9IGVsZW1lbnRzLmJ1dHRvbiA9IE5VTEw7XG5cblx0XHQvLyBSZXBvc2l0aW9uIGlmIGVuYWJsZWRcblx0XHRpZihyZXBvc2l0aW9uICE9PSBGQUxTRSkgeyB0aGlzLnJlcG9zaXRpb24oKTsgfVxuXHR9XG59O1xuXG47UFJPVE9UWVBFLnJlcG9zaXRpb24gPSBmdW5jdGlvbihldmVudCwgZWZmZWN0KSB7XG5cdGlmKCF0aGlzLnJlbmRlcmVkIHx8IHRoaXMucG9zaXRpb25pbmcgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHQvLyBTZXQgcG9zaXRpb25pbmcgZmxhZ1xuXHR0aGlzLnBvc2l0aW9uaW5nID0gVFJVRTtcblxuXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuXHRcdHRvb2x0aXAgPSB0aGlzLnRvb2x0aXAsXG5cdFx0cG9zT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcblx0XHR0YXJnZXQgPSBwb3NPcHRpb25zLnRhcmdldCxcblx0XHRteSA9IHBvc09wdGlvbnMubXksXG5cdFx0YXQgPSBwb3NPcHRpb25zLmF0LFxuXHRcdHZpZXdwb3J0ID0gcG9zT3B0aW9ucy52aWV3cG9ydCxcblx0XHRjb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcblx0XHRhZGp1c3QgPSBwb3NPcHRpb25zLmFkanVzdCxcblx0XHRtZXRob2QgPSBhZGp1c3QubWV0aG9kLnNwbGl0KCcgJyksXG5cdFx0dG9vbHRpcFdpZHRoID0gdG9vbHRpcC5vdXRlcldpZHRoKEZBTFNFKSxcblx0XHR0b29sdGlwSGVpZ2h0ID0gdG9vbHRpcC5vdXRlckhlaWdodChGQUxTRSksXG5cdFx0dGFyZ2V0V2lkdGggPSAwLFxuXHRcdHRhcmdldEhlaWdodCA9IDAsXG5cdFx0dHlwZSA9IHRvb2x0aXAuY3NzKCdwb3NpdGlvbicpLFxuXHRcdHBvc2l0aW9uID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHR2aXNpYmxlID0gdG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAsXG5cdFx0aXNTY3JvbGwgPSBldmVudCAmJiBldmVudC50eXBlID09PSAnc2Nyb2xsJyxcblx0XHR3aW4gPSAkKHdpbmRvdyksXG5cdFx0ZG9jID0gY29udGFpbmVyWzBdLm93bmVyRG9jdW1lbnQsXG5cdFx0bW91c2UgPSB0aGlzLm1vdXNlLFxuXHRcdHBsdWdpbkNhbGN1bGF0aW9ucywgb2Zmc2V0O1xuXG5cdC8vIENoZWNrIGlmIGFic29sdXRlIHBvc2l0aW9uIHdhcyBwYXNzZWRcblx0aWYoJC5pc0FycmF5KHRhcmdldCkgJiYgdGFyZ2V0Lmxlbmd0aCA9PT0gMikge1xuXHRcdC8vIEZvcmNlIGxlZnQgdG9wIGFuZCBzZXQgcG9zaXRpb25cblx0XHRhdCA9IHsgeDogTEVGVCwgeTogVE9QIH07XG5cdFx0cG9zaXRpb24gPSB7IGxlZnQ6IHRhcmdldFswXSwgdG9wOiB0YXJnZXRbMV0gfTtcblx0fVxuXG5cdC8vIENoZWNrIGlmIG1vdXNlIHdhcyB0aGUgdGFyZ2V0XG5cdGVsc2UgaWYodGFyZ2V0ID09PSAnbW91c2UnKSB7XG5cdFx0Ly8gRm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRhdCA9IHsgeDogTEVGVCwgeTogVE9QIH07XG5cblx0XHQvLyBVc2UgdGhlIGNhY2hlZCBtb3VzZSBjb29yZGluYXRlcyBpZiBhdmFpbGFibGUsIG9yIHBhc3NlZCBldmVudCBoYXMgbm8gY29vcmRpbmF0ZXNcblx0XHRpZihtb3VzZSAmJiBtb3VzZS5wYWdlWCAmJiAoYWRqdXN0Lm1vdXNlIHx8ICFldmVudCB8fCAhZXZlbnQucGFnZVgpICkge1xuXHRcdFx0ZXZlbnQgPSBtb3VzZTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gSWYgdGhlIHBhc3NlZCBldmVudCBoYXMgbm8gY29vcmRpbmF0ZXMgKHN1Y2ggYXMgYSBzY3JvbGwgZXZlbnQpXG5cdFx0ZWxzZSBpZighZXZlbnQgfHwgIWV2ZW50LnBhZ2VYKSB7XG5cdFx0XHQvLyBVc2UgdGhlIG1vdXNlIG9yaWdpbiB0aGF0IGNhdXNlZCB0aGUgc2hvdyBldmVudCwgaWYgZGlzdGFuY2UgaGlkaW5nIGlzIGVuYWJsZWRcblx0XHRcdGlmKCghYWRqdXN0Lm1vdXNlIHx8IHRoaXMub3B0aW9ucy5zaG93LmRpc3RhbmNlKSAmJiBjYWNoZS5vcmlnaW4gJiYgY2FjaGUub3JpZ2luLnBhZ2VYKSB7XG5cdFx0XHRcdGV2ZW50ID0gIGNhY2hlLm9yaWdpbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGNhY2hlZCBldmVudCBmb3IgcmVzaXplL3Njcm9sbCBldmVudHNcblx0XHRcdGVsc2UgaWYoIWV2ZW50IHx8IChldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ3Jlc2l6ZScgfHwgZXZlbnQudHlwZSA9PT0gJ3Njcm9sbCcpKSkge1xuXHRcdFx0XHRldmVudCA9IGNhY2hlLmV2ZW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBib2R5IGFuZCBjb250YWluZXIgb2Zmc2V0IGFuZCB0YWtlIHRoZW0gaW50byBhY2NvdW50IGJlbG93XG5cdFx0aWYodHlwZSAhPT0gJ3N0YXRpYycpIHsgcG9zaXRpb24gPSBjb250YWluZXIub2Zmc2V0KCk7IH1cblx0XHRpZihkb2MuYm9keS5vZmZzZXRXaWR0aCAhPT0gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpKSB7XG5cdFx0XHRvZmZzZXQgPSAkKGRvY3VtZW50LmJvZHkpLm9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBldmVudCBjb29yZGluYXRlcyBmb3IgcG9zaXRpb25cblx0XHRwb3NpdGlvbiA9IHtcblx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gcG9zaXRpb24ubGVmdCArIChvZmZzZXQgJiYgb2Zmc2V0LmxlZnQgfHwgMCksXG5cdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gcG9zaXRpb24udG9wICsgKG9mZnNldCAmJiBvZmZzZXQudG9wIHx8IDApXG5cdFx0fTtcblxuXHRcdC8vIFNjcm9sbCBldmVudHMgYXJlIGEgcGFpbiwgc29tZSBicm93c2Vyc1xuXHRcdGlmKGFkanVzdC5tb3VzZSAmJiBpc1Njcm9sbCAmJiBtb3VzZSkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSAobW91c2Uuc2Nyb2xsWCB8fCAwKSAtIHdpbi5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gKG1vdXNlLnNjcm9sbFkgfHwgMCkgLSB3aW4uc2Nyb2xsVG9wKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGFyZ2V0IHdhc24ndCBtb3VzZSBvciBhYnNvbHV0ZS4uLlxuXHRlbHNlIHtcblx0XHQvLyBDaGVjayBpZiBldmVudCB0YXJnZXR0aW5nIGlzIGJlaW5nIHVzZWRcblx0XHRpZih0YXJnZXQgPT09ICdldmVudCcpIHtcblx0XHRcdGlmKGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50eXBlICE9PSAnc2Nyb2xsJyAmJiBldmVudC50eXBlICE9PSAncmVzaXplJykge1xuXHRcdFx0XHRjYWNoZS50YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCFldmVudC50YXJnZXQpIHtcblx0XHRcdFx0Y2FjaGUudGFyZ2V0ID0gdGhpcy5lbGVtZW50cy50YXJnZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYodGFyZ2V0ICE9PSAnZXZlbnQnKXtcblx0XHRcdGNhY2hlLnRhcmdldCA9ICQodGFyZ2V0LmpxdWVyeSA/IHRhcmdldCA6IHRoaXMuZWxlbWVudHMudGFyZ2V0KTtcblx0XHR9XG5cdFx0dGFyZ2V0ID0gY2FjaGUudGFyZ2V0O1xuXG5cdFx0Ly8gUGFyc2UgdGhlIHRhcmdldCBpbnRvIGEgalF1ZXJ5IG9iamVjdCBhbmQgbWFrZSBzdXJlIHRoZXJlJ3MgYW4gZWxlbWVudCBwcmVzZW50XG5cdFx0dGFyZ2V0ID0gJCh0YXJnZXQpLmVxKDApO1xuXHRcdGlmKHRhcmdldC5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdC8vIENoZWNrIGlmIHdpbmRvdyBvciBkb2N1bWVudCBpcyB0aGUgdGFyZ2V0XG5cdFx0ZWxzZSBpZih0YXJnZXRbMF0gPT09IGRvY3VtZW50IHx8IHRhcmdldFswXSA9PT0gd2luZG93KSB7XG5cdFx0XHR0YXJnZXRXaWR0aCA9IEJST1dTRVIuaU9TID8gd2luZG93LmlubmVyV2lkdGggOiB0YXJnZXQud2lkdGgoKTtcblx0XHRcdHRhcmdldEhlaWdodCA9IEJST1dTRVIuaU9TID8gd2luZG93LmlubmVySGVpZ2h0IDogdGFyZ2V0LmhlaWdodCgpO1xuXG5cdFx0XHRpZih0YXJnZXRbMF0gPT09IHdpbmRvdykge1xuXHRcdFx0XHRwb3NpdGlvbiA9IHtcblx0XHRcdFx0XHR0b3A6ICh2aWV3cG9ydCB8fCB0YXJnZXQpLnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRcdGxlZnQ6ICh2aWV3cG9ydCB8fCB0YXJnZXQpLnNjcm9sbExlZnQoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gPEFSRUE+IGVsZW1lbnRcblx0XHRlbHNlIGlmKFBMVUdJTlMuaW1hZ2VtYXAgJiYgdGFyZ2V0LmlzKCdhcmVhJykpIHtcblx0XHRcdHBsdWdpbkNhbGN1bGF0aW9ucyA9IFBMVUdJTlMuaW1hZ2VtYXAodGhpcywgdGFyZ2V0LCBhdCwgUExVR0lOUy52aWV3cG9ydCA/IG1ldGhvZCA6IEZBTFNFKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIFNWRyBlbGVtZW50XG5cdFx0ZWxzZSBpZihQTFVHSU5TLnN2ZyAmJiB0YXJnZXQgJiYgdGFyZ2V0WzBdLm93bmVyU1ZHRWxlbWVudCkge1xuXHRcdFx0cGx1Z2luQ2FsY3VsYXRpb25zID0gUExVR0lOUy5zdmcodGhpcywgdGFyZ2V0LCBhdCwgUExVR0lOUy52aWV3cG9ydCA/IG1ldGhvZCA6IEZBTFNFKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UgdXNlIHJlZ3VsYXIgalF1ZXJ5IG1ldGhvZHNcblx0XHRlbHNlIHtcblx0XHRcdHRhcmdldFdpZHRoID0gdGFyZ2V0Lm91dGVyV2lkdGgoRkFMU0UpO1xuXHRcdFx0dGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0Lm91dGVySGVpZ2h0KEZBTFNFKTtcblx0XHRcdHBvc2l0aW9uID0gdGFyZ2V0Lm9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vIFBhcnNlIHJldHVybmVkIHBsdWdpbiB2YWx1ZXMgaW50byBwcm9wZXIgdmFyaWFibGVzXG5cdFx0aWYocGx1Z2luQ2FsY3VsYXRpb25zKSB7XG5cdFx0XHR0YXJnZXRXaWR0aCA9IHBsdWdpbkNhbGN1bGF0aW9ucy53aWR0aDtcblx0XHRcdHRhcmdldEhlaWdodCA9IHBsdWdpbkNhbGN1bGF0aW9ucy5oZWlnaHQ7XG5cdFx0XHRvZmZzZXQgPSBwbHVnaW5DYWxjdWxhdGlvbnMub2Zmc2V0O1xuXHRcdFx0cG9zaXRpb24gPSBwbHVnaW5DYWxjdWxhdGlvbnMucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0Ly8gQWRqdXN0IHBvc2l0aW9uIHRvIHRha2UgaW50byBhY2NvdW50IG9mZnNldCBwYXJlbnRzXG5cdFx0cG9zaXRpb24gPSB0aGlzLnJlcG9zaXRpb24ub2Zmc2V0KHRhcmdldCwgcG9zaXRpb24sIGNvbnRhaW5lcik7XG5cblx0XHQvLyBBZGp1c3QgZm9yIHBvc2l0aW9uLmZpeGVkIHRvb2x0aXBzIChhbmQgYWxzbyBpT1Mgc2Nyb2xsIGJ1ZyBpbiB2My4yLTQuMCAmIHY0LjMtNC4zLjIpXG5cdFx0aWYoKEJST1dTRVIuaU9TID4gMy4xICYmIEJST1dTRVIuaU9TIDwgNC4xKSB8fCBcblx0XHRcdChCUk9XU0VSLmlPUyA+PSA0LjMgJiYgQlJPV1NFUi5pT1MgPCA0LjMzKSB8fCBcblx0XHRcdCghQlJPV1NFUi5pT1MgJiYgdHlwZSA9PT0gJ2ZpeGVkJylcblx0XHQpe1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSB3aW4uc2Nyb2xsTGVmdCgpO1xuXHRcdFx0cG9zaXRpb24udG9wIC09IHdpbi5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHQvLyBBZGp1c3QgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGFyZ2V0XG5cdFx0aWYoIXBsdWdpbkNhbGN1bGF0aW9ucyB8fCAocGx1Z2luQ2FsY3VsYXRpb25zICYmIHBsdWdpbkNhbGN1bGF0aW9ucy5hZGp1c3RhYmxlICE9PSBGQUxTRSkpIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gYXQueCA9PT0gUklHSFQgPyB0YXJnZXRXaWR0aCA6IGF0LnggPT09IENFTlRFUiA/IHRhcmdldFdpZHRoIC8gMiA6IDA7XG5cdFx0XHRwb3NpdGlvbi50b3AgKz0gYXQueSA9PT0gQk9UVE9NID8gdGFyZ2V0SGVpZ2h0IDogYXQueSA9PT0gQ0VOVEVSID8gdGFyZ2V0SGVpZ2h0IC8gMiA6IDA7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRqdXN0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRvb2x0aXBcblx0cG9zaXRpb24ubGVmdCArPSBhZGp1c3QueCArIChteS54ID09PSBSSUdIVCA/IC10b29sdGlwV2lkdGggOiBteS54ID09PSBDRU5URVIgPyAtdG9vbHRpcFdpZHRoIC8gMiA6IDApO1xuXHRwb3NpdGlvbi50b3AgKz0gYWRqdXN0LnkgKyAobXkueSA9PT0gQk9UVE9NID8gLXRvb2x0aXBIZWlnaHQgOiBteS55ID09PSBDRU5URVIgPyAtdG9vbHRpcEhlaWdodCAvIDIgOiAwKTtcblxuXHQvLyBVc2Ugdmlld3BvcnQgYWRqdXN0bWVudCBwbHVnaW4gaWYgZW5hYmxlZFxuXHRpZihQTFVHSU5TLnZpZXdwb3J0KSB7XG5cdFx0cG9zaXRpb24uYWRqdXN0ZWQgPSBQTFVHSU5TLnZpZXdwb3J0KFxuXHRcdFx0dGhpcywgcG9zaXRpb24sIHBvc09wdGlvbnMsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRvb2x0aXBXaWR0aCwgdG9vbHRpcEhlaWdodFxuXHRcdCk7XG5cblx0XHQvLyBBcHBseSBvZmZzZXRzIHN1cHBsaWVkIGJ5IHBvc2l0aW9uaW5nIHBsdWdpbiAoaWYgdXNlZClcblx0XHRpZihvZmZzZXQgJiYgcG9zaXRpb24uYWRqdXN0ZWQubGVmdCkgeyBwb3NpdGlvbi5sZWZ0ICs9IG9mZnNldC5sZWZ0OyB9XG5cdFx0aWYob2Zmc2V0ICYmIHBvc2l0aW9uLmFkanVzdGVkLnRvcCkgeyAgcG9zaXRpb24udG9wICs9IG9mZnNldC50b3A7IH1cblx0fVxuXG5cdC8vIFZpZXdwb3J0IGFkanVzdG1lbnQgaXMgZGlzYWJsZWQsIHNldCB2YWx1ZXMgdG8gemVyb1xuXHRlbHNlIHsgcG9zaXRpb24uYWRqdXN0ZWQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9OyB9XG5cblx0Ly8gdG9vbHRpcG1vdmUgZXZlbnRcblx0aWYoIXRoaXMuX3RyaWdnZXIoJ21vdmUnLCBbcG9zaXRpb24sIHZpZXdwb3J0LmVsZW0gfHwgdmlld3BvcnRdLCBldmVudCkpIHsgcmV0dXJuIHRoaXM7IH1cblx0ZGVsZXRlIHBvc2l0aW9uLmFkanVzdGVkO1xuXG5cdC8vIElmIGVmZmVjdCBpcyBkaXNhYmxlZCwgdGFyZ2V0IGl0IG1vdXNlLCBubyBhbmltYXRpb24gaXMgZGVmaW5lZCBvciBwb3NpdGlvbmluZyBnaXZlcyBOYU4gb3V0LCBzZXQgQ1NTIGRpcmVjdGx5XG5cdGlmKGVmZmVjdCA9PT0gRkFMU0UgfHwgIXZpc2libGUgfHwgaXNOYU4ocG9zaXRpb24ubGVmdCkgfHwgaXNOYU4ocG9zaXRpb24udG9wKSB8fCB0YXJnZXQgPT09ICdtb3VzZScgfHwgISQuaXNGdW5jdGlvbihwb3NPcHRpb25zLmVmZmVjdCkpIHtcblx0XHR0b29sdGlwLmNzcyhwb3NpdGlvbik7XG5cdH1cblxuXHQvLyBVc2UgY3VzdG9tIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXG5cdGVsc2UgaWYoJC5pc0Z1bmN0aW9uKHBvc09wdGlvbnMuZWZmZWN0KSkge1xuXHRcdHBvc09wdGlvbnMuZWZmZWN0LmNhbGwodG9vbHRpcCwgdGhpcywgJC5leHRlbmQoe30sIHBvc2l0aW9uKSk7XG5cdFx0dG9vbHRpcC5xdWV1ZShmdW5jdGlvbihuZXh0KSB7XG5cdFx0XHQvLyBSZXNldCBhdHRyaWJ1dGVzIHRvIGF2b2lkIGNyb3NzLWJyb3dzZXIgcmVuZGVyaW5nIGJ1Z3Ncblx0XHRcdCQodGhpcykuY3NzKHsgb3BhY2l0eTogJycsIGhlaWdodDogJycgfSk7XG5cdFx0XHRpZihCUk9XU0VSLmllKSB7IHRoaXMuc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdmaWx0ZXInKTsgfVxuXG5cdFx0XHRuZXh0KCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBTZXQgcG9zaXRpb25pbmcgZmxhZ1xuXHR0aGlzLnBvc2l0aW9uaW5nID0gRkFMU0U7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vLyBDdXN0b20gKG1vcmUgY29ycmVjdCBmb3IgcVRpcCEpIG9mZnNldCBjYWxjdWxhdG9yXG5QUk9UT1RZUEUucmVwb3NpdGlvbi5vZmZzZXQgPSBmdW5jdGlvbihlbGVtLCBwb3MsIGNvbnRhaW5lcikge1xuXHRpZighY29udGFpbmVyWzBdKSB7IHJldHVybiBwb3M7IH1cblxuXHR2YXIgb3duZXJEb2N1bWVudCA9ICQoZWxlbVswXS5vd25lckRvY3VtZW50KSxcblx0XHRxdWlya3MgPSAhIUJST1dTRVIuaWUgJiYgZG9jdW1lbnQuY29tcGF0TW9kZSAhPT0gJ0NTUzFDb21wYXQnLFxuXHRcdHBhcmVudCA9IGNvbnRhaW5lclswXSxcblx0XHRzY3JvbGxlZCwgcG9zaXRpb24sIHBhcmVudE9mZnNldCwgb3ZlcmZsb3c7XG5cblx0ZnVuY3Rpb24gc2Nyb2xsKGUsIGkpIHtcblx0XHRwb3MubGVmdCArPSBpICogZS5zY3JvbGxMZWZ0KCk7XG5cdFx0cG9zLnRvcCArPSBpICogZS5zY3JvbGxUb3AoKTtcblx0fVxuXG5cdC8vIENvbXBlbnNhdGUgZm9yIG5vbi1zdGF0aWMgY29udGFpbmVycyBvZmZzZXRcblx0ZG8ge1xuXHRcdGlmKChwb3NpdGlvbiA9ICQuY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJykpICE9PSAnc3RhdGljJykge1xuXHRcdFx0aWYocG9zaXRpb24gPT09ICdmaXhlZCcpIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRzY3JvbGwob3duZXJEb2N1bWVudCwgLTEpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9ICQocGFyZW50KS5wb3NpdGlvbigpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSAocGFyc2VGbG9hdCgkLmNzcyhwYXJlbnQsICdib3JkZXJMZWZ0V2lkdGgnKSkgfHwgMCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0gKHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnYm9yZGVyVG9wV2lkdGgnKSkgfHwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdHBvcy5sZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0ICsgKHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnbWFyZ2luTGVmdCcpKSB8fCAwKTtcblx0XHRcdHBvcy50b3AgLT0gcGFyZW50T2Zmc2V0LnRvcCArIChwYXJzZUZsb2F0KCQuY3NzKHBhcmVudCwgJ21hcmdpblRvcCcpKSB8fCAwKTtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgcGFyZW50IGVsZW1lbnQgd2l0aCBhbiBvdmVyZmxvdyBvZiBcInNjcm9sbFwiIG9yIFwiYXV0b1wiLCBzdG9yZSBpdFxuXHRcdFx0aWYoIXNjcm9sbGVkICYmIChvdmVyZmxvdyA9ICQuY3NzKHBhcmVudCwgJ292ZXJmbG93JykpICE9PSAnaGlkZGVuJyAmJiBvdmVyZmxvdyAhPT0gJ3Zpc2libGUnKSB7IHNjcm9sbGVkID0gJChwYXJlbnQpOyB9XG5cdFx0fVxuXHR9XG5cdHdoaWxlKChwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50KSk7XG5cblx0Ly8gQ29tcGVuc2F0ZSBmb3IgY29udGFpbmVycyBzY3JvbGwgaWYgaXQgYWxzbyBoYXMgYW4gb2Zmc2V0UGFyZW50IChvciBpbiBJRSBxdWlya3MgbW9kZSlcblx0aWYoc2Nyb2xsZWQgJiYgKHNjcm9sbGVkWzBdICE9PSBvd25lckRvY3VtZW50WzBdIHx8IHF1aXJrcykpIHtcblx0XHRzY3JvbGwoc2Nyb2xsZWQsIDEpO1xuXHR9XG5cblx0cmV0dXJuIHBvcztcbn07XG5cbi8vIENvcm5lciBjbGFzc1xudmFyIEMgPSAoQ09STkVSID0gUFJPVE9UWVBFLnJlcG9zaXRpb24uQ29ybmVyID0gZnVuY3Rpb24oY29ybmVyLCBmb3JjZVkpIHtcblx0Y29ybmVyID0gKCcnICsgY29ybmVyKS5yZXBsYWNlKC8oW0EtWl0pLywgJyAkMScpLnJlcGxhY2UoL21pZGRsZS9naSwgQ0VOVEVSKS50b0xvd2VyQ2FzZSgpO1xuXHR0aGlzLnggPSAoY29ybmVyLm1hdGNoKC9sZWZ0fHJpZ2h0L2kpIHx8IGNvcm5lci5tYXRjaCgvY2VudGVyLykgfHwgWydpbmhlcml0J10pWzBdLnRvTG93ZXJDYXNlKCk7XG5cdHRoaXMueSA9IChjb3JuZXIubWF0Y2goL3RvcHxib3R0b218Y2VudGVyL2kpIHx8IFsnaW5oZXJpdCddKVswXS50b0xvd2VyQ2FzZSgpO1xuXHR0aGlzLmZvcmNlWSA9ICEhZm9yY2VZO1xuXG5cdHZhciBmID0gY29ybmVyLmNoYXJBdCgwKTtcblx0dGhpcy5wcmVjZWRhbmNlID0gKGYgPT09ICd0JyB8fCBmID09PSAnYicgPyBZIDogWCk7XG59KS5wcm90b3R5cGU7XG5cbkMuaW52ZXJ0ID0gZnVuY3Rpb24oeiwgY2VudGVyKSB7XG5cdHRoaXNbel0gPSB0aGlzW3pdID09PSBMRUZUID8gUklHSFQgOiB0aGlzW3pdID09PSBSSUdIVCA/IExFRlQgOiBjZW50ZXIgfHwgdGhpc1t6XTtcdFxufTtcblxuQy5zdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdHJldHVybiB4ID09PSB5ID8geCA6IHRoaXMucHJlY2VkYW5jZSA9PT0gWSB8fCAodGhpcy5mb3JjZVkgJiYgeSAhPT0gJ2NlbnRlcicpID8geSsnICcreCA6IHgrJyAnK3k7XG59O1xuXG5DLmFiYnJldiA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcmVzdWx0ID0gdGhpcy5zdHJpbmcoKS5zcGxpdCgnICcpO1xuXHRyZXR1cm4gcmVzdWx0WzBdLmNoYXJBdCgwKSArIChyZXN1bHRbMV0gJiYgcmVzdWx0WzFdLmNoYXJBdCgwKSB8fCAnJyk7XG59O1xuXG5DLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBuZXcgQ09STkVSKCB0aGlzLnN0cmluZygpLCB0aGlzLmZvcmNlWSApO1xufTs7XG5QUk9UT1RZUEUudG9nZ2xlID0gZnVuY3Rpb24oc3RhdGUsIGV2ZW50KSB7XG5cdHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG5cdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHR0b29sdGlwID0gdGhpcy50b29sdGlwO1xuXG5cdC8vIFRyeSB0byBwcmV2ZW50IGZsaWNrZXJpbmcgd2hlbiB0b29sdGlwIG92ZXJsYXBzIHNob3cgZWxlbWVudFxuXHRpZihldmVudCkge1xuXHRcdGlmKCgvb3ZlcnxlbnRlci8pLnRlc3QoZXZlbnQudHlwZSkgJiYgKC9vdXR8bGVhdmUvKS50ZXN0KGNhY2hlLmV2ZW50LnR5cGUpICYmXG5cdFx0XHRvcHRpb25zLnNob3cudGFyZ2V0LmFkZChldmVudC50YXJnZXQpLmxlbmd0aCA9PT0gb3B0aW9ucy5zaG93LnRhcmdldC5sZW5ndGggJiZcblx0XHRcdHRvb2x0aXAuaGFzKGV2ZW50LnJlbGF0ZWRUYXJnZXQpLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgZXZlbnRcblx0XHRjYWNoZS5ldmVudCA9IGNsb25lRXZlbnQoZXZlbnQpO1xuXHR9XG5cdFx0XG5cdC8vIElmIHdlJ3JlIGN1cnJlbnRseSB3YWl0aW5nIGFuZCB3ZSd2ZSBqdXN0IGhpZGRlbi4uLiBzdG9wIGl0XG5cdHRoaXMud2FpdGluZyAmJiAhc3RhdGUgJiYgKHRoaXMuaGlkZGVuRHVyaW5nV2FpdCA9IFRSVUUpO1xuXG5cdC8vIFJlbmRlciB0aGUgdG9vbHRpcCBpZiBzaG93aW5nIGFuZCBpdCBpc24ndCBhbHJlYWR5XG5cdGlmKCF0aGlzLnJlbmRlcmVkKSB7IHJldHVybiBzdGF0ZSA/IHRoaXMucmVuZGVyKDEpIDogdGhpczsgfVxuXHRlbHNlIGlmKHRoaXMuZGVzdHJveWVkIHx8IHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHR2YXIgdHlwZSA9IHN0YXRlID8gJ3Nob3cnIDogJ2hpZGUnLFxuXHRcdG9wdHMgPSB0aGlzLm9wdGlvbnNbdHlwZV0sXG5cdFx0b3RoZXJPcHRzID0gdGhpcy5vcHRpb25zWyAhc3RhdGUgPyAnc2hvdycgOiAnaGlkZScgXSxcblx0XHRwb3NPcHRpb25zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxuXHRcdGNvbnRlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNvbnRlbnQsXG5cdFx0d2lkdGggPSB0aGlzLnRvb2x0aXAuY3NzKCd3aWR0aCcpLFxuXHRcdHZpc2libGUgPSB0aGlzLnRvb2x0aXAuaXMoJzp2aXNpYmxlJyksXG5cdFx0YW5pbWF0ZSA9IHN0YXRlIHx8IG9wdHMudGFyZ2V0Lmxlbmd0aCA9PT0gMSxcblx0XHRzYW1lVGFyZ2V0ID0gIWV2ZW50IHx8IG9wdHMudGFyZ2V0Lmxlbmd0aCA8IDIgfHwgY2FjaGUudGFyZ2V0WzBdID09PSBldmVudC50YXJnZXQsXG5cdFx0aWRlbnRpY2FsU3RhdGUsIGFsbG93LCBzaG93RXZlbnQsIGRlbGF5LCBhZnRlcjtcblxuXHQvLyBEZXRlY3Qgc3RhdGUgaWYgdmFsaWQgb25lIGlzbid0IHByb3ZpZGVkXG5cdGlmKCh0eXBlb2Ygc3RhdGUpLnNlYXJjaCgnYm9vbGVhbnxudW1iZXInKSkgeyBzdGF0ZSA9ICF2aXNpYmxlOyB9XG5cblx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaXMgaW4gYW4gaWRlbnRpY2FsIHN0YXRlIHRvIHRoZSBuZXcgd291bGQtYmUgc3RhdGVcblx0aWRlbnRpY2FsU3RhdGUgPSAhdG9vbHRpcC5pcygnOmFuaW1hdGVkJykgJiYgdmlzaWJsZSA9PT0gc3RhdGUgJiYgc2FtZVRhcmdldDtcblxuXHQvLyBGaXJlIHRvb2x0aXAoc2hvdy9oaWRlKSBldmVudCBhbmQgY2hlY2sgaWYgZGVzdHJveWVkXG5cdGFsbG93ID0gIWlkZW50aWNhbFN0YXRlID8gISF0aGlzLl90cmlnZ2VyKHR5cGUsIFs5MF0pIDogTlVMTDtcblxuXHQvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhlIHRvb2x0aXAgd2Fzbid0IGRlc3Ryb3llZCBpbiB0aGUgY2FsbGJhY2tcblx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHQvLyBJZiB0aGUgdXNlciBkaWRuJ3Qgc3RvcCB0aGUgbWV0aG9kIHByZW1hdHVyZWx5IGFuZCB3ZSdyZSBzaG93aW5nIHRoZSB0b29sdGlwLCBmb2N1cyBpdFxuXHRpZihhbGxvdyAhPT0gRkFMU0UgJiYgc3RhdGUpIHsgdGhpcy5mb2N1cyhldmVudCk7IH1cblxuXHQvLyBJZiB0aGUgc3RhdGUgaGFzbid0IGNoYW5nZWQgb3IgdGhlIHVzZXIgc3RvcHBlZCBpdCwgcmV0dXJuIGVhcmx5XG5cdGlmKCFhbGxvdyB8fCBpZGVudGljYWxTdGF0ZSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdC8vIFNldCBBUklBIGhpZGRlbiBhdHRyaWJ1dGVcblx0JC5hdHRyKHRvb2x0aXBbMF0sICdhcmlhLWhpZGRlbicsICEhIXN0YXRlKTtcblxuXHQvLyBFeGVjdXRlIHN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXNcblx0aWYoc3RhdGUpIHtcblx0XHQvLyBTdG9yZSBzaG93IG9yaWdpbiBjb29yZGluYXRlc1xuXHRcdGNhY2hlLm9yaWdpbiA9IGNsb25lRXZlbnQodGhpcy5tb3VzZSk7XG5cblx0XHQvLyBVcGRhdGUgdG9vbHRpcCBjb250ZW50ICYgdGl0bGUgaWYgaXQncyBhIGR5bmFtaWMgZnVuY3Rpb25cblx0XHRpZigkLmlzRnVuY3Rpb24oY29udGVudE9wdGlvbnMudGV4dCkpIHsgdGhpcy5fdXBkYXRlQ29udGVudChjb250ZW50T3B0aW9ucy50ZXh0LCBGQUxTRSk7IH1cblx0XHRpZigkLmlzRnVuY3Rpb24oY29udGVudE9wdGlvbnMudGl0bGUpKSB7IHRoaXMuX3VwZGF0ZVRpdGxlKGNvbnRlbnRPcHRpb25zLnRpdGxlLCBGQUxTRSk7IH1cblxuXHRcdC8vIENhY2hlIG1vdXNlbW92ZSBldmVudHMgZm9yIHBvc2l0aW9uaW5nIHB1cnBvc2VzIChpZiBub3QgYWxyZWFkeSB0cmFja2luZylcblx0XHRpZighdHJhY2tpbmdCb3VuZCAmJiBwb3NPcHRpb25zLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBwb3NPcHRpb25zLmFkanVzdC5tb3VzZSkge1xuXHRcdFx0JChkb2N1bWVudCkuYmluZCgnbW91c2Vtb3ZlLicrTkFNRVNQQUNFLCB0aGlzLl9zdG9yZU1vdXNlKTtcblx0XHRcdHRyYWNraW5nQm91bmQgPSBUUlVFO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSB0aGUgdG9vbHRpcCBwb3NpdGlvbiAoc2V0IHdpZHRoIGZpcnN0IHRvIHByZXZlbnQgdmlld3BvcnQvbWF4LXdpZHRoIGlzc3Vlcylcblx0XHRpZighd2lkdGgpIHsgdG9vbHRpcC5jc3MoJ3dpZHRoJywgdG9vbHRpcC5vdXRlcldpZHRoKEZBTFNFKSk7IH1cblx0XHR0aGlzLnJlcG9zaXRpb24oZXZlbnQsIGFyZ3VtZW50c1syXSk7XG5cdFx0aWYoIXdpZHRoKSB7IHRvb2x0aXAuY3NzKCd3aWR0aCcsICcnKTsgfVxuXG5cdFx0Ly8gSGlkZSBvdGhlciB0b29sdGlwcyBpZiB0b29sdGlwIGlzIHNvbG9cblx0XHRpZighIW9wdHMuc29sbykge1xuXHRcdFx0KHR5cGVvZiBvcHRzLnNvbG8gPT09ICdzdHJpbmcnID8gJChvcHRzLnNvbG8pIDogJChTRUxFQ1RPUiwgb3B0cy5zb2xvKSlcblx0XHRcdFx0Lm5vdCh0b29sdGlwKS5ub3Qob3B0cy50YXJnZXQpLnF0aXAoJ2hpZGUnLCAkLkV2ZW50KCd0b29sdGlwc29sbycpKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQ2xlYXIgc2hvdyB0aW1lciBpZiB3ZSdyZSBoaWRpbmdcblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cblx0XHQvLyBSZW1vdmUgY2FjaGVkIG9yaWdpbiBvbiBoaWRlXG5cdFx0ZGVsZXRlIGNhY2hlLm9yaWdpbjtcblxuXHRcdC8vIFJlbW92ZSBtb3VzZSB0cmFja2luZyBldmVudCBpZiBub3QgbmVlZGVkIChhbGwgdHJhY2tpbmcgcVRpcHMgYXJlIGhpZGRlbilcblx0XHRpZih0cmFja2luZ0JvdW5kICYmICEkKFNFTEVDVE9SKydbdHJhY2tpbmc9XCJ0cnVlXCJdOnZpc2libGUnLCBvcHRzLnNvbG8pLm5vdCh0b29sdGlwKS5sZW5ndGgpIHtcblx0XHRcdCQoZG9jdW1lbnQpLnVuYmluZCgnbW91c2Vtb3ZlLicrTkFNRVNQQUNFKTtcblx0XHRcdHRyYWNraW5nQm91bmQgPSBGQUxTRTtcblx0XHR9XG5cblx0XHQvLyBCbHVyIHRoZSB0b29sdGlwXG5cdFx0dGhpcy5ibHVyKGV2ZW50KTtcblx0fVxuXG5cdC8vIERlZmluZSBwb3N0LWFuaW1hdGlvbiwgc3RhdGUgc3BlY2lmaWMgcHJvcGVydGllc1xuXHRhZnRlciA9ICQucHJveHkoZnVuY3Rpb24oKSB7XG5cdFx0aWYoc3RhdGUpIHtcblx0XHRcdC8vIFByZXZlbnQgYW50aWFsaWFzIGZyb20gZGlzYXBwZWFyaW5nIGluIElFIGJ5IHJlbW92aW5nIGZpbHRlclxuXHRcdFx0aWYoQlJPV1NFUi5pZSkgeyB0b29sdGlwWzBdLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7IH1cblxuXHRcdFx0Ly8gUmVtb3ZlIG92ZXJmbG93IHNldHRpbmcgdG8gcHJldmVudCB0aXAgYnVnc1xuXHRcdFx0dG9vbHRpcC5jc3MoJ292ZXJmbG93JywgJycpO1xuXG5cdFx0XHQvLyBBdXRvZm9jdXMgZWxlbWVudHMgaWYgZW5hYmxlZFxuXHRcdFx0aWYoJ3N0cmluZycgPT09IHR5cGVvZiBvcHRzLmF1dG9mb2N1cykge1xuXHRcdFx0XHQkKHRoaXMub3B0aW9ucy5zaG93LmF1dG9mb2N1cywgdG9vbHRpcCkuZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgc2V0LCBoaWRlIHRvb2x0aXAgd2hlbiBpbmFjdGl2ZSBmb3IgZGVsYXkgcGVyaW9kXG5cdFx0XHR0aGlzLm9wdGlvbnMuc2hvdy50YXJnZXQudHJpZ2dlcigncXRpcC0nK3RoaXMuaWQrJy1pbmFjdGl2ZScpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFJlc2V0IENTUyBzdGF0ZXNcblx0XHRcdHRvb2x0aXAuY3NzKHtcblx0XHRcdFx0ZGlzcGxheTogJycsXG5cdFx0XHRcdHZpc2liaWxpdHk6ICcnLFxuXHRcdFx0XHRvcGFjaXR5OiAnJyxcblx0XHRcdFx0bGVmdDogJycsXG5cdFx0XHRcdHRvcDogJydcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHRvb2x0aXB2aXNpYmxlL3Rvb2x0aXBoaWRkZW4gZXZlbnRzXG5cdFx0dGhpcy5fdHJpZ2dlcihzdGF0ZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKTtcblx0fSwgdGhpcyk7XG5cblx0Ly8gSWYgbm8gZWZmZWN0IHR5cGUgaXMgc3VwcGxpZWQsIHVzZSBhIHNpbXBsZSB0b2dnbGVcblx0aWYob3B0cy5lZmZlY3QgPT09IEZBTFNFIHx8IGFuaW1hdGUgPT09IEZBTFNFKSB7XG5cdFx0dG9vbHRpcFsgdHlwZSBdKCk7XG5cdFx0YWZ0ZXIoKTtcblx0fVxuXG5cdC8vIFVzZSBjdXN0b20gZnVuY3Rpb24gaWYgcHJvdmlkZWRcblx0ZWxzZSBpZigkLmlzRnVuY3Rpb24ob3B0cy5lZmZlY3QpKSB7XG5cdFx0dG9vbHRpcC5zdG9wKDEsIDEpO1xuXHRcdG9wdHMuZWZmZWN0LmNhbGwodG9vbHRpcCwgdGhpcyk7XG5cdFx0dG9vbHRpcC5xdWV1ZSgnZngnLCBmdW5jdGlvbihuKSB7XG5cdFx0XHRhZnRlcigpOyBuKCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBVc2UgYmFzaWMgZmFkZSBmdW5jdGlvbiBieSBkZWZhdWx0XG5cdGVsc2UgeyB0b29sdGlwLmZhZGVUbyg5MCwgc3RhdGUgPyAxIDogMCwgYWZ0ZXIpOyB9XG5cblx0Ly8gSWYgaW5hY3RpdmUgaGlkZSBtZXRob2QgaXMgc2V0LCBhY3RpdmUgaXRcblx0aWYoc3RhdGUpIHsgb3B0cy50YXJnZXQudHJpZ2dlcigncXRpcC0nK3RoaXMuaWQrJy1pbmFjdGl2ZScpOyB9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5QUk9UT1RZUEUuc2hvdyA9IGZ1bmN0aW9uKGV2ZW50KSB7IHJldHVybiB0aGlzLnRvZ2dsZShUUlVFLCBldmVudCk7IH07XG5cblBST1RPVFlQRS5oaWRlID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuIHRoaXMudG9nZ2xlKEZBTFNFLCBldmVudCk7IH07XG5cbjtQUk9UT1RZUEUuZm9jdXMgPSBmdW5jdGlvbihldmVudCkge1xuXHRpZighdGhpcy5yZW5kZXJlZCB8fCB0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdHZhciBxdGlwcyA9ICQoU0VMRUNUT1IpLFxuXHRcdHRvb2x0aXAgPSB0aGlzLnRvb2x0aXAsXG5cdFx0Y3VySW5kZXggPSBwYXJzZUludCh0b29sdGlwWzBdLnN0eWxlLnpJbmRleCwgMTApLFxuXHRcdG5ld0luZGV4ID0gUVRJUC56aW5kZXggKyBxdGlwcy5sZW5ndGgsXG5cdFx0Zm9jdXNlZEVsZW07XG5cblx0Ly8gT25seSB1cGRhdGUgdGhlIHotaW5kZXggaWYgaXQgaGFzIGNoYW5nZWQgYW5kIHRvb2x0aXAgaXMgbm90IGFscmVhZHkgZm9jdXNlZFxuXHRpZighdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19GT0NVUykpIHtcblx0XHQvLyB0b29sdGlwZm9jdXMgZXZlbnRcblx0XHRpZih0aGlzLl90cmlnZ2VyKCdmb2N1cycsIFtuZXdJbmRleF0sIGV2ZW50KSkge1xuXHRcdFx0Ly8gT25seSB1cGRhdGUgei1pbmRleCdzIGlmIHRoZXkndmUgY2hhbmdlZFxuXHRcdFx0aWYoY3VySW5kZXggIT09IG5ld0luZGV4KSB7XG5cdFx0XHRcdC8vIFJlZHVjZSBvdXIgei1pbmRleCdzIGFuZCBrZWVwIHRoZW0gcHJvcGVybHkgb3JkZXJlZFxuXHRcdFx0XHRxdGlwcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmKHRoaXMuc3R5bGUuekluZGV4ID4gY3VySW5kZXgpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuekluZGV4ID0gdGhpcy5zdHlsZS56SW5kZXggLSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gRmlyZSBibHVyIGV2ZW50IGZvciBmb2N1c2VkIHRvb2x0aXBcblx0XHRcdFx0cXRpcHMuZmlsdGVyKCcuJyArIENMQVNTX0ZPQ1VTKS5xdGlwKCdibHVyJywgZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIG5ldyB6LWluZGV4XG5cdFx0XHR0b29sdGlwLmFkZENsYXNzKENMQVNTX0ZPQ1VTKVswXS5zdHlsZS56SW5kZXggPSBuZXdJbmRleDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblBST1RPVFlQRS5ibHVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0aWYoIXRoaXMucmVuZGVyZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHQvLyBTZXQgZm9jdXNlZCBzdGF0dXMgdG8gRkFMU0Vcblx0dGhpcy50b29sdGlwLnJlbW92ZUNsYXNzKENMQVNTX0ZPQ1VTKTtcblxuXHQvLyB0b29sdGlwYmx1ciBldmVudFxuXHR0aGlzLl90cmlnZ2VyKCdibHVyJywgWyB0aGlzLnRvb2x0aXAuY3NzKCd6SW5kZXgnKSBdLCBldmVudCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG47UFJPVE9UWVBFLmRpc2FibGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRpZih0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdC8vIElmICd0b2dnbGUnIGlzIHBhc3NlZCwgdG9nZ2xlIHRoZSBjdXJyZW50IHN0YXRlXG5cdGlmKHN0YXRlID09PSAndG9nZ2xlJykge1xuXHRcdHN0YXRlID0gISh0aGlzLnJlbmRlcmVkID8gdGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSA6IHRoaXMuZGlzYWJsZWQpO1xuXHR9XG5cblx0Ly8gRGlzYWJsZSBpZiBubyBzdGF0ZSBwYXNzZWRcblx0ZWxzZSBpZignYm9vbGVhbicgIT09IHR5cGVvZiBzdGF0ZSkge1xuXHRcdHN0YXRlID0gVFJVRTtcblx0fVxuXG5cdGlmKHRoaXMucmVuZGVyZWQpIHtcblx0XHR0aGlzLnRvb2x0aXAudG9nZ2xlQ2xhc3MoQ0xBU1NfRElTQUJMRUQsIHN0YXRlKVxuXHRcdFx0LmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBzdGF0ZSk7XG5cdH1cblxuXHR0aGlzLmRpc2FibGVkID0gISFzdGF0ZTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblBST1RPVFlQRS5lbmFibGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZShGQUxTRSk7IH07XG5cbjtQUk9UT1RZUEUuX2NyZWF0ZUJ1dHRvbiA9IGZ1bmN0aW9uKClcbntcblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcblx0XHR0b29sdGlwID0gZWxlbWVudHMudG9vbHRpcCxcblx0XHRidXR0b24gPSB0aGlzLm9wdGlvbnMuY29udGVudC5idXR0b24sXG5cdFx0aXNTdHJpbmcgPSB0eXBlb2YgYnV0dG9uID09PSAnc3RyaW5nJyxcblx0XHRjbG9zZSA9IGlzU3RyaW5nID8gYnV0dG9uIDogJ0Nsb3NlIHRvb2x0aXAnO1xuXG5cdGlmKGVsZW1lbnRzLmJ1dHRvbikgeyBlbGVtZW50cy5idXR0b24ucmVtb3ZlKCk7IH1cblxuXHQvLyBVc2UgY3VzdG9tIGJ1dHRvbiBpZiBvbmUgd2FzIHN1cHBsaWVkIGJ5IHVzZXIsIGVsc2UgdXNlIGRlZmF1bHRcblx0aWYoYnV0dG9uLmpxdWVyeSkge1xuXHRcdGVsZW1lbnRzLmJ1dHRvbiA9IGJ1dHRvbjtcblx0fVxuXHRlbHNlIHtcblx0XHRlbGVtZW50cy5idXR0b24gPSAkKCc8YSAvPicsIHtcblx0XHRcdCdjbGFzcyc6ICdxdGlwLWNsb3NlICcgKyAodGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCA/ICcnIDogTkFNRVNQQUNFKyctaWNvbicpLFxuXHRcdFx0J3RpdGxlJzogY2xvc2UsXG5cdFx0XHQnYXJpYS1sYWJlbCc6IGNsb3NlXG5cdFx0fSlcblx0XHQucHJlcGVuZChcblx0XHRcdCQoJzxzcGFuIC8+Jywge1xuXHRcdFx0XHQnY2xhc3MnOiAndWktaWNvbiB1aS1pY29uLWNsb3NlJyxcblx0XHRcdFx0J2h0bWwnOiAnJnRpbWVzOydcblx0XHRcdH0pXG5cdFx0KTtcblx0fVxuXG5cdC8vIENyZWF0ZSBidXR0b24gYW5kIHNldHVwIGF0dHJpYnV0ZXNcblx0ZWxlbWVudHMuYnV0dG9uLmFwcGVuZFRvKGVsZW1lbnRzLnRpdGxlYmFyIHx8IHRvb2x0aXApXG5cdFx0LmF0dHIoJ3JvbGUnLCAnYnV0dG9uJylcblx0XHQuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmKCF0b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSkgeyBzZWxmLmhpZGUoZXZlbnQpOyB9XG5cdFx0XHRyZXR1cm4gRkFMU0U7XG5cdFx0fSk7XG59O1xuXG5QUk9UT1RZUEUuX3VwZGF0ZUJ1dHRvbiA9IGZ1bmN0aW9uKGJ1dHRvbilcbntcblx0Ly8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgcmVuZGVyZWQgYW5kIGlmIG5vdCwgcmV0dXJuXG5cdGlmKCF0aGlzLnJlbmRlcmVkKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdHZhciBlbGVtID0gdGhpcy5lbGVtZW50cy5idXR0b247XG5cdGlmKGJ1dHRvbikgeyB0aGlzLl9jcmVhdGVCdXR0b24oKTsgfVxuXHRlbHNlIHsgZWxlbS5yZW1vdmUoKTsgfVxufTtcblxuOy8vIFdpZGdldCBjbGFzcyBjcmVhdG9yXG5mdW5jdGlvbiBjcmVhdGVXaWRnZXRDbGFzcyhjbHMpIHtcblx0cmV0dXJuIFdJREdFVC5jb25jYXQoJycpLmpvaW4oY2xzID8gJy0nK2NscysnICcgOiAnICcpO1xufVxuXG4vLyBXaWRnZXQgY2xhc3Mgc2V0dGVyIG1ldGhvZFxuUFJPVE9UWVBFLl9zZXRXaWRnZXQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBvbiA9IHRoaXMub3B0aW9ucy5zdHlsZS53aWRnZXQsXG5cdFx0ZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxuXHRcdHRvb2x0aXAgPSBlbGVtZW50cy50b29sdGlwLFxuXHRcdGRpc2FibGVkID0gdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCk7XG5cblx0dG9vbHRpcC5yZW1vdmVDbGFzcyhDTEFTU19ESVNBQkxFRCk7XG5cdENMQVNTX0RJU0FCTEVEID0gb24gPyAndWktc3RhdGUtZGlzYWJsZWQnIDogJ3F0aXAtZGlzYWJsZWQnO1xuXHR0b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0RJU0FCTEVELCBkaXNhYmxlZCk7XG5cblx0dG9vbHRpcC50b2dnbGVDbGFzcygndWktaGVscGVyLXJlc2V0ICcrY3JlYXRlV2lkZ2V0Q2xhc3MoKSwgb24pLnRvZ2dsZUNsYXNzKENMQVNTX0RFRkFVTFQsIHRoaXMub3B0aW9ucy5zdHlsZS5kZWYgJiYgIW9uKTtcblx0XG5cdGlmKGVsZW1lbnRzLmNvbnRlbnQpIHtcblx0XHRlbGVtZW50cy5jb250ZW50LnRvZ2dsZUNsYXNzKCBjcmVhdGVXaWRnZXRDbGFzcygnY29udGVudCcpLCBvbik7XG5cdH1cblx0aWYoZWxlbWVudHMudGl0bGViYXIpIHtcblx0XHRlbGVtZW50cy50aXRsZWJhci50b2dnbGVDbGFzcyggY3JlYXRlV2lkZ2V0Q2xhc3MoJ2hlYWRlcicpLCBvbik7XG5cdH1cblx0aWYoZWxlbWVudHMuYnV0dG9uKSB7XG5cdFx0ZWxlbWVudHMuYnV0dG9uLnRvZ2dsZUNsYXNzKE5BTUVTUEFDRSsnLWljb24nLCAhb24pO1xuXHR9XG59OztmdW5jdGlvbiBjbG9uZUV2ZW50KGV2ZW50KSB7XG5cdHJldHVybiBldmVudCAmJiB7XG5cdFx0dHlwZTogZXZlbnQudHlwZSxcblx0XHRwYWdlWDogZXZlbnQucGFnZVgsXG5cdFx0cGFnZVk6IGV2ZW50LnBhZ2VZLFxuXHRcdHRhcmdldDogZXZlbnQudGFyZ2V0LFxuXHRcdHJlbGF0ZWRUYXJnZXQ6IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0c2Nyb2xsWDogZXZlbnQuc2Nyb2xsWCB8fCB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuXHRcdHNjcm9sbFk6IGV2ZW50LnNjcm9sbFkgfHwgd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3Bcblx0fSB8fCB7fTtcbn1cblxuZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIGR1cmF0aW9uKSB7XG5cdC8vIElmIHRvb2x0aXAgaGFzIGRpc3BsYXllZCwgc3RhcnQgaGlkZSB0aW1lclxuXHRpZihkdXJhdGlvbiA+IDApIHtcblx0XHRyZXR1cm4gc2V0VGltZW91dChcblx0XHRcdCQucHJveHkoY2FsbGJhY2ssIHRoaXMpLCBkdXJhdGlvblxuXHRcdCk7XG5cdH1cblx0ZWxzZXsgY2FsbGJhY2suY2FsbCh0aGlzKTsgfVxufVxuXG5mdW5jdGlvbiBzaG93TWV0aG9kKGV2ZW50KSB7XG5cdGlmKHRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkpIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0Ly8gQ2xlYXIgaGlkZSB0aW1lcnNcblx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xuXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaGlkZSk7XG5cblx0Ly8gU3RhcnQgc2hvdyB0aW1lclxuXHR0aGlzLnRpbWVycy5zaG93ID0gZGVsYXkuY2FsbCh0aGlzLFxuXHRcdGZ1bmN0aW9uKCkgeyB0aGlzLnRvZ2dsZShUUlVFLCBldmVudCk7IH0sXG5cdFx0dGhpcy5vcHRpb25zLnNob3cuZGVsYXlcblx0KTtcbn1cblxuZnVuY3Rpb24gaGlkZU1ldGhvZChldmVudCkge1xuXHRpZih0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIENoZWNrIGlmIG5ldyB0YXJnZXQgd2FzIGFjdHVhbGx5IHRoZSB0b29sdGlwIGVsZW1lbnRcblx0dmFyIHJlbGF0ZWRUYXJnZXQgPSAkKGV2ZW50LnJlbGF0ZWRUYXJnZXQpLFxuXHRcdG9udG9Ub29sdGlwID0gcmVsYXRlZFRhcmdldC5jbG9zZXN0KFNFTEVDVE9SKVswXSA9PT0gdGhpcy50b29sdGlwWzBdLFxuXHRcdG9udG9UYXJnZXQgPSByZWxhdGVkVGFyZ2V0WzBdID09PSB0aGlzLm9wdGlvbnMuc2hvdy50YXJnZXRbMF07XG5cblx0Ly8gQ2xlYXIgdGltZXJzIGFuZCBzdG9wIGFuaW1hdGlvbiBxdWV1ZVxuXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5oaWRlKTtcblxuXHQvLyBQcmV2ZW50IGhpZGluZyBpZiB0b29sdGlwIGlzIGZpeGVkIGFuZCBldmVudCB0YXJnZXQgaXMgdGhlIHRvb2x0aXAuXG5cdC8vIE9yIGlmIG1vdXNlIHBvc2l0aW9uaW5nIGlzIGVuYWJsZWQgYW5kIGN1cnNvciBtb21lbnRhcmlseSBvdmVybGFwc1xuXHRpZih0aGlzICE9PSByZWxhdGVkVGFyZ2V0WzBdICYmIFxuXHRcdCh0aGlzLm9wdGlvbnMucG9zaXRpb24udGFyZ2V0ID09PSAnbW91c2UnICYmIG9udG9Ub29sdGlwKSB8fCBcblx0XHQodGhpcy5vcHRpb25zLmhpZGUuZml4ZWQgJiYgKFxuXHRcdFx0KC9tb3VzZShvdXR8bGVhdmV8bW92ZSkvKS50ZXN0KGV2ZW50LnR5cGUpICYmIChvbnRvVG9vbHRpcCB8fCBvbnRvVGFyZ2V0KSlcblx0XHQpKVxuXHR7XG5cdFx0dHJ5IHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9IGNhdGNoKGUpIHt9XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBJZiB0b29sdGlwIGhhcyBkaXNwbGF5ZWQsIHN0YXJ0IGhpZGUgdGltZXJcblx0dGhpcy50aW1lcnMuaGlkZSA9IGRlbGF5LmNhbGwodGhpcyxcblx0XHRmdW5jdGlvbigpIHsgdGhpcy50b2dnbGUoRkFMU0UsIGV2ZW50KTsgfSxcblx0XHR0aGlzLm9wdGlvbnMuaGlkZS5kZWxheSxcblx0XHR0aGlzXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGluYWN0aXZlTWV0aG9kKGV2ZW50KSB7XG5cdGlmKHRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgfHwgIXRoaXMub3B0aW9ucy5oaWRlLmluYWN0aXZlKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIENsZWFyIHRpbWVyXG5cdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5pbmFjdGl2ZSk7XG5cblx0dGhpcy50aW1lcnMuaW5hY3RpdmUgPSBkZWxheS5jYWxsKHRoaXMsXG5cdFx0ZnVuY3Rpb24oKXsgdGhpcy5oaWRlKGV2ZW50KTsgfSxcblx0XHR0aGlzLm9wdGlvbnMuaGlkZS5pbmFjdGl2ZVxuXHQpO1xufVxuXG5mdW5jdGlvbiByZXBvc2l0aW9uTWV0aG9kKGV2ZW50KSB7XG5cdGlmKHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCkgeyB0aGlzLnJlcG9zaXRpb24oZXZlbnQpOyB9XG59XG5cbi8vIFN0b3JlIG1vdXNlIGNvb3JkaW5hdGVzXG5QUk9UT1RZUEUuX3N0b3JlTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXHQodGhpcy5tb3VzZSA9IGNsb25lRXZlbnQoZXZlbnQpKS50eXBlID0gJ21vdXNlbW92ZSc7XG59O1xuXG4vLyBCaW5kIGV2ZW50c1xuUFJPVE9UWVBFLl9iaW5kID0gZnVuY3Rpb24odGFyZ2V0cywgZXZlbnRzLCBtZXRob2QsIHN1ZmZpeCwgY29udGV4dCkge1xuXHR2YXIgbnMgPSAnLicgKyB0aGlzLl9pZCArIChzdWZmaXggPyAnLScrc3VmZml4IDogJycpO1xuXHRldmVudHMubGVuZ3RoICYmICQodGFyZ2V0cykuYmluZChcblx0XHQoZXZlbnRzLnNwbGl0ID8gZXZlbnRzIDogZXZlbnRzLmpvaW4obnMgKyAnICcpKSArIG5zLFxuXHRcdCQucHJveHkobWV0aG9kLCBjb250ZXh0IHx8IHRoaXMpXG5cdCk7XG59O1xuUFJPVE9UWVBFLl91bmJpbmQgPSBmdW5jdGlvbih0YXJnZXRzLCBzdWZmaXgpIHtcblx0JCh0YXJnZXRzKS51bmJpbmQoJy4nICsgdGhpcy5faWQgKyAoc3VmZml4ID8gJy0nK3N1ZmZpeCA6ICcnKSk7XG59O1xuXG4vLyBBcHBseSBjb21tb24gZXZlbnQgaGFuZGxlcnMgdXNpbmcgZGVsZWdhdGUgKGF2b2lkcyBleGNlc3NpdmUgLmJpbmQgY2FsbHMhKVxudmFyIG5zID0gJy4nK05BTUVTUEFDRTtcbmZ1bmN0aW9uIGRlbGVnYXRlKHNlbGVjdG9yLCBldmVudHMsIG1ldGhvZCkge1x0XG5cdCQoZG9jdW1lbnQuYm9keSkuZGVsZWdhdGUoc2VsZWN0b3IsXG5cdFx0KGV2ZW50cy5zcGxpdCA/IGV2ZW50cyA6IGV2ZW50cy5qb2luKG5zICsgJyAnKSkgKyBucyxcblx0XHRmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcGkgPSBRVElQLmFwaVsgJC5hdHRyKHRoaXMsIEFUVFJfSUQpIF07XG5cdFx0XHRhcGkgJiYgIWFwaS5kaXNhYmxlZCAmJiBtZXRob2QuYXBwbHkoYXBpLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0KTtcbn1cblxuJChmdW5jdGlvbigpIHtcblx0ZGVsZWdhdGUoU0VMRUNUT1IsIFsnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ10sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHN0YXRlID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlZW50ZXInLFxuXHRcdFx0dG9vbHRpcCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCksXG5cdFx0XHR0YXJnZXQgPSAkKGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0KSxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBPbiBtb3VzZWVudGVyLi4uXG5cdFx0aWYoc3RhdGUpIHtcblx0XHRcdC8vIEZvY3VzIHRoZSB0b29sdGlwIG9uIG1vdXNlZW50ZXIgKHotaW5kZXggc3RhY2tpbmcpXG5cdFx0XHR0aGlzLmZvY3VzKGV2ZW50KTtcblxuXHRcdFx0Ly8gQ2xlYXIgaGlkZSB0aW1lciBvbiB0b29sdGlwIGhvdmVyIHRvIHByZXZlbnQgaXQgZnJvbSBjbG9zaW5nXG5cdFx0XHR0b29sdGlwLmhhc0NsYXNzKENMQVNTX0ZJWEVEKSAmJiAhdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmhpZGUpO1xuXHRcdH1cblxuXHRcdC8vIE9uIG1vdXNlbGVhdmUuLi5cblx0XHRlbHNlIHtcblx0XHRcdC8vIEhpZGUgd2hlbiB3ZSBsZWF2ZSB0aGUgdG9vbHRpcCBhbmQgbm90IG9udG8gdGhlIHNob3cgdGFyZ2V0IChpZiBhIGhpZGUgZXZlbnQgaXMgc2V0KVxuXHRcdFx0aWYob3B0aW9ucy5wb3NpdGlvbi50YXJnZXQgPT09ICdtb3VzZScgJiYgb3B0aW9ucy5oaWRlLmV2ZW50ICYmIFxuXHRcdFx0XHRvcHRpb25zLnNob3cudGFyZ2V0ICYmICF0YXJnZXQuY2xvc2VzdChvcHRpb25zLnNob3cudGFyZ2V0WzBdKS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5oaWRlKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgaG92ZXIgY2xhc3Ncblx0XHR0b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0hPVkVSLCBzdGF0ZSk7XG5cdH0pO1xuXG5cdC8vIERlZmluZSBldmVudHMgd2hpY2ggcmVzZXQgdGhlICdpbmFjdGl2ZScgZXZlbnQgaGFuZGxlclxuXHRkZWxlZ2F0ZSgnWycrQVRUUl9JRCsnXScsIElOQUNUSVZFX0VWRU5UUywgaW5hY3RpdmVNZXRob2QpO1xufSk7XG5cbi8vIEV2ZW50IHRyaWdnZXJcblBST1RPVFlQRS5fdHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUsIGFyZ3MsIGV2ZW50KSB7XG5cdHZhciBjYWxsYmFjayA9ICQuRXZlbnQoJ3Rvb2x0aXAnK3R5cGUpO1xuXHRjYWxsYmFjay5vcmlnaW5hbEV2ZW50ID0gKGV2ZW50ICYmICQuZXh0ZW5kKHt9LCBldmVudCkpIHx8IHRoaXMuY2FjaGUuZXZlbnQgfHwgTlVMTDtcblxuXHR0aGlzLnRyaWdnZXJpbmcgPSB0eXBlO1xuXHR0aGlzLnRvb2x0aXAudHJpZ2dlcihjYWxsYmFjaywgW3RoaXNdLmNvbmNhdChhcmdzIHx8IFtdKSk7XG5cdHRoaXMudHJpZ2dlcmluZyA9IEZBTFNFO1xuXG5cdHJldHVybiAhY2FsbGJhY2suaXNEZWZhdWx0UHJldmVudGVkKCk7XG59O1xuXG5QUk9UT1RZUEUuX2JpbmRFdmVudHMgPSBmdW5jdGlvbihzaG93RXZlbnRzLCBoaWRlRXZlbnRzLCBzaG93VGFyZ2V0LCBoaWRlVGFyZ2V0LCBzaG93TWV0aG9kLCBoaWRlTWV0aG9kKSB7XG5cdC8vIElmIGhpZGUgYW5kIHNob3cgdGFyZ2V0cyBhcmUgdGhlIHNhbWUuLi5cblx0aWYoaGlkZVRhcmdldC5hZGQoc2hvd1RhcmdldCkubGVuZ3RoID09PSBoaWRlVGFyZ2V0Lmxlbmd0aCkge1xuXHRcdHZhciB0b2dnbGVFdmVudHMgPSBbXTtcblxuXHRcdC8vIEZpbHRlciBpZGVudGljYWwgc2hvdy9oaWRlIGV2ZW50c1xuXHRcdGhpZGVFdmVudHMgPSAkLm1hcChoaWRlRXZlbnRzLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgc2hvd0luZGV4ID0gJC5pbkFycmF5KHR5cGUsIHNob3dFdmVudHMpO1xuXG5cdFx0XHQvLyBCb3RoIGV2ZW50cyBhcmUgaWRlbnRpY2FsLCByZW1vdmUgZnJvbSBib3RoIGhpZGUgYW5kIHNob3cgZXZlbnRzXG5cdFx0XHQvLyBhbmQgYXBwZW5kIHRvIHRvZ2dsZUV2ZW50c1xuXHRcdFx0aWYoc2hvd0luZGV4ID4gLTEpIHtcblx0XHRcdFx0dG9nZ2xlRXZlbnRzLnB1c2goIHNob3dFdmVudHMuc3BsaWNlKCBzaG93SW5kZXgsIDEgKVswXSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0eXBlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVG9nZ2xlIGV2ZW50cyBhcmUgc3BlY2lhbCBjYXNlIG9mIGlkZW50aWNhbCBzaG93L2hpZGUgZXZlbnRzLCB3aGljaCBoYXBwZW4gaW4gc2VxdWVuY2Vcblx0XHR0b2dnbGVFdmVudHMubGVuZ3RoICYmIHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgdG9nZ2xlRXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIHN0YXRlID0gdGhpcy5yZW5kZXJlZCA/IHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAgOiBmYWxzZTtcblx0XHRcdChzdGF0ZSA/IGhpZGVNZXRob2QgOiBzaG93TWV0aG9kKS5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEFwcGx5IHNob3cvaGlkZS90b2dnbGUgZXZlbnRzXG5cdHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgc2hvd0V2ZW50cywgc2hvd01ldGhvZCk7XG5cdHRoaXMuX2JpbmQoaGlkZVRhcmdldCwgaGlkZUV2ZW50cywgaGlkZU1ldGhvZCk7XG59O1xuXG5QUk9UT1RZUEUuX2Fzc2lnbkluaXRpYWxFdmVudHMgPSBmdW5jdGlvbihldmVudCkge1xuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRzaG93VGFyZ2V0ID0gb3B0aW9ucy5zaG93LnRhcmdldCxcblx0XHRoaWRlVGFyZ2V0ID0gb3B0aW9ucy5oaWRlLnRhcmdldCxcblx0XHRzaG93RXZlbnRzID0gb3B0aW9ucy5zaG93LmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5zaG93LmV2ZW50KS5zcGxpdCgnICcpIDogW10sXG5cdFx0aGlkZUV2ZW50cyA9IG9wdGlvbnMuaGlkZS5ldmVudCA/ICQudHJpbSgnJyArIG9wdGlvbnMuaGlkZS5ldmVudCkuc3BsaXQoJyAnKSA6IFtdO1xuXG5cdC8qXG5cdCAqIE1ha2Ugc3VyZSBob3ZlckludGVudCBmdW5jdGlvbnMgcHJvcGVybHkgYnkgdXNpbmcgbW91c2VsZWF2ZSBhcyBhIGhpZGUgZXZlbnQgaWZcblx0ICogbW91c2VlbnRlci9tb3VzZW91dCBpcyB1c2VkIGZvciBzaG93LmV2ZW50LCBldmVuIGlmIGl0IGlzbid0IGluIHRoZSB1c2VycyBvcHRpb25zLlxuXHQgKi9cblx0aWYoL21vdXNlKG92ZXJ8ZW50ZXIpL2kudGVzdChvcHRpb25zLnNob3cuZXZlbnQpICYmICEvbW91c2Uob3V0fGxlYXZlKS9pLnRlc3Qob3B0aW9ucy5oaWRlLmV2ZW50KSkge1xuXHRcdGhpZGVFdmVudHMucHVzaCgnbW91c2VsZWF2ZScpO1xuXHR9XG5cblx0Lypcblx0ICogQWxzbyBtYWtlIHN1cmUgaW5pdGlhbCBtb3VzZSB0YXJnZXR0aW5nIHdvcmtzIGNvcnJlY3RseSBieSBjYWNoaW5nIG1vdXNlbW92ZSBjb29yZHNcblx0ICogb24gc2hvdyB0YXJnZXRzIGJlZm9yZSB0aGUgdG9vbHRpcCBoYXMgcmVuZGVyZWQuIEFsc28gc2V0IG9uVGFyZ2V0IHdoZW4gdHJpZ2dlcmVkIHRvXG5cdCAqIGtlZXAgbW91c2UgdHJhY2tpbmcgd29ya2luZy5cblx0ICovXG5cdHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dGhpcy5fc3RvcmVNb3VzZShldmVudCk7XG5cdFx0dGhpcy5jYWNoZS5vblRhcmdldCA9IFRSVUU7XG5cdH0pO1xuXG5cdC8vIERlZmluZSBob3ZlckludGVudCBmdW5jdGlvblxuXHRmdW5jdGlvbiBob3ZlckludGVudChldmVudCkge1xuXHRcdC8vIE9ubHkgY29udGludWUgaWYgdG9vbHRpcCBpc24ndCBkaXNhYmxlZFxuXHRcdGlmKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0XHQvLyBDYWNoZSB0aGUgZXZlbnQgZGF0YVxuXHRcdHRoaXMuY2FjaGUuZXZlbnQgPSBjbG9uZUV2ZW50KGV2ZW50KTtcblx0XHR0aGlzLmNhY2hlLnRhcmdldCA9IGV2ZW50ID8gJChldmVudC50YXJnZXQpIDogW3VuZGVmaW5lZF07XG5cblx0XHQvLyBTdGFydCB0aGUgZXZlbnQgc2VxdWVuY2Vcblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cdFx0dGhpcy50aW1lcnMuc2hvdyA9IGRlbGF5LmNhbGwodGhpcyxcblx0XHRcdGZ1bmN0aW9uKCkgeyB0aGlzLnJlbmRlcih0eXBlb2YgZXZlbnQgPT09ICdvYmplY3QnIHx8IG9wdGlvbnMuc2hvdy5yZWFkeSk7IH0sXG5cdFx0XHRvcHRpb25zLnNob3cuZGVsYXlcblx0XHQpO1xuXHR9XG5cblx0Ly8gRmlsdGVyIGFuZCBiaW5kIGV2ZW50c1xuXHR0aGlzLl9iaW5kRXZlbnRzKHNob3dFdmVudHMsIGhpZGVFdmVudHMsIHNob3dUYXJnZXQsIGhpZGVUYXJnZXQsIGhvdmVySW50ZW50LCBmdW5jdGlvbigpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cdH0pO1xuXG5cdC8vIFByZXJlbmRlcmluZyBpcyBlbmFibGVkLCBjcmVhdGUgdG9vbHRpcCBub3dcblx0aWYob3B0aW9ucy5zaG93LnJlYWR5IHx8IG9wdGlvbnMucHJlcmVuZGVyKSB7IGhvdmVySW50ZW50LmNhbGwodGhpcywgZXZlbnQpOyB9XG59O1xuXG4vLyBFdmVudCBhc3NpZ25tZW50IG1ldGhvZFxuUFJPVE9UWVBFLl9hc3NpZ25FdmVudHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0cG9zT3B0aW9ucyA9IG9wdGlvbnMucG9zaXRpb24sXG5cblx0XHR0b29sdGlwID0gdGhpcy50b29sdGlwLFxuXHRcdHNob3dUYXJnZXQgPSBvcHRpb25zLnNob3cudGFyZ2V0LFxuXHRcdGhpZGVUYXJnZXQgPSBvcHRpb25zLmhpZGUudGFyZ2V0LFxuXHRcdGNvbnRhaW5lclRhcmdldCA9IHBvc09wdGlvbnMuY29udGFpbmVyLFxuXHRcdHZpZXdwb3J0VGFyZ2V0ID0gcG9zT3B0aW9ucy52aWV3cG9ydCxcblx0XHRkb2N1bWVudFRhcmdldCA9ICQoZG9jdW1lbnQpLFxuXHRcdGJvZHlUYXJnZXQgPSAkKGRvY3VtZW50LmJvZHkpLFxuXHRcdHdpbmRvd1RhcmdldCA9ICQod2luZG93KSxcblxuXHRcdHNob3dFdmVudHMgPSBvcHRpb25zLnNob3cuZXZlbnQgPyAkLnRyaW0oJycgKyBvcHRpb25zLnNob3cuZXZlbnQpLnNwbGl0KCcgJykgOiBbXSxcblx0XHRoaWRlRXZlbnRzID0gb3B0aW9ucy5oaWRlLmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5oaWRlLmV2ZW50KS5zcGxpdCgnICcpIDogW107XG5cblxuXHQvLyBBc3NpZ24gcGFzc2VkIGV2ZW50IGNhbGxiYWNrc1xuXHQkLmVhY2gob3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0c2VsZi5fYmluZCh0b29sdGlwLCBuYW1lID09PSAndG9nZ2xlJyA/IFsndG9vbHRpcHNob3cnLCd0b29sdGlwaGlkZSddIDogWyd0b29sdGlwJytuYW1lXSwgY2FsbGJhY2ssIG51bGwsIHRvb2x0aXApO1xuXHR9KTtcblxuXHQvLyBIaWRlIHRvb2x0aXBzIHdoZW4gbGVhdmluZyBjdXJyZW50IHdpbmRvdy9mcmFtZSAoYnV0IG5vdCBzZWxlY3Qvb3B0aW9uIGVsZW1lbnRzKVxuXHRpZigvbW91c2Uob3V0fGxlYXZlKS9pLnRlc3Qob3B0aW9ucy5oaWRlLmV2ZW50KSAmJiBvcHRpb25zLmhpZGUubGVhdmUgPT09ICd3aW5kb3cnKSB7XG5cdFx0dGhpcy5fYmluZChkb2N1bWVudFRhcmdldCwgWydtb3VzZW91dCcsICdibHVyJ10sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZighL3NlbGVjdHxvcHRpb24vLnRlc3QoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lKSAmJiAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuXHRcdFx0XHR0aGlzLmhpZGUoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gRW5hYmxlIGhpZGUuZml4ZWQgYnkgYWRkaW5nIGFwcHJvcHJpYXRlIGNsYXNzXG5cdGlmKG9wdGlvbnMuaGlkZS5maXhlZCkge1xuXHRcdGhpZGVUYXJnZXQgPSBoaWRlVGFyZ2V0LmFkZCggdG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GSVhFRCkgKTtcblx0fVxuXG5cdC8qXG5cdCAqIE1ha2Ugc3VyZSBob3ZlckludGVudCBmdW5jdGlvbnMgcHJvcGVybHkgYnkgdXNpbmcgbW91c2VsZWF2ZSB0byBjbGVhciBzaG93IHRpbWVyIGlmXG5cdCAqIG1vdXNlZW50ZXIvbW91c2VvdXQgaXMgdXNlZCBmb3Igc2hvdy5ldmVudCwgZXZlbiBpZiBpdCBpc24ndCBpbiB0aGUgdXNlcnMgb3B0aW9ucy5cblx0ICovXG5cdGVsc2UgaWYoL21vdXNlKG92ZXJ8ZW50ZXIpL2kudGVzdChvcHRpb25zLnNob3cuZXZlbnQpKSB7XG5cdFx0dGhpcy5fYmluZChoaWRlVGFyZ2V0LCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gSGlkZSB0b29sdGlwIG9uIGRvY3VtZW50IG1vdXNlZG93biBpZiB1bmZvY3VzIGV2ZW50cyBhcmUgZW5hYmxlZFxuXHRpZigoJycgKyBvcHRpb25zLmhpZGUuZXZlbnQpLmluZGV4T2YoJ3VuZm9jdXMnKSA+IC0xKSB7XG5cdFx0dGhpcy5fYmluZChjb250YWluZXJUYXJnZXQuY2xvc2VzdCgnaHRtbCcpLCBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoZXZlbnQudGFyZ2V0KSxcblx0XHRcdFx0ZW5hYmxlZCA9IHRoaXMucmVuZGVyZWQgJiYgIXRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgJiYgdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCxcblx0XHRcdFx0aXNBbmNlc3RvciA9IGVsZW0ucGFyZW50cyhTRUxFQ1RPUikuZmlsdGVyKHRoaXMudG9vbHRpcFswXSkubGVuZ3RoID4gMDtcblxuXHRcdFx0aWYoZWxlbVswXSAhPT0gdGhpcy50YXJnZXRbMF0gJiYgZWxlbVswXSAhPT0gdGhpcy50b29sdGlwWzBdICYmICFpc0FuY2VzdG9yICYmXG5cdFx0XHRcdCF0aGlzLnRhcmdldC5oYXMoZWxlbVswXSkubGVuZ3RoICYmIGVuYWJsZWRcblx0XHRcdCkge1xuXHRcdFx0XHR0aGlzLmhpZGUoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaGlkZXMgd2hlbiBpbmFjdGl2ZVxuXHRpZignbnVtYmVyJyA9PT0gdHlwZW9mIG9wdGlvbnMuaGlkZS5pbmFjdGl2ZSkge1xuXHRcdC8vIEJpbmQgaW5hY3RpdmUgbWV0aG9kIHRvIHNob3cgdGFyZ2V0KHMpIGFzIGEgY3VzdG9tIGV2ZW50XG5cdFx0dGhpcy5fYmluZChzaG93VGFyZ2V0LCAncXRpcC0nK3RoaXMuaWQrJy1pbmFjdGl2ZScsIGluYWN0aXZlTWV0aG9kKTtcblxuXHRcdC8vIERlZmluZSBldmVudHMgd2hpY2ggcmVzZXQgdGhlICdpbmFjdGl2ZScgZXZlbnQgaGFuZGxlclxuXHRcdHRoaXMuX2JpbmQoaGlkZVRhcmdldC5hZGQodG9vbHRpcCksIFFUSVAuaW5hY3RpdmVFdmVudHMsIGluYWN0aXZlTWV0aG9kLCAnLWluYWN0aXZlJyk7XG5cdH1cblxuXHQvLyBGaWx0ZXIgYW5kIGJpbmQgZXZlbnRzXG5cdHRoaXMuX2JpbmRFdmVudHMoc2hvd0V2ZW50cywgaGlkZUV2ZW50cywgc2hvd1RhcmdldCwgaGlkZVRhcmdldCwgc2hvd01ldGhvZCwgaGlkZU1ldGhvZCk7XG5cblx0Ly8gTW91c2UgbW92ZW1lbnQgYmluZGluZ3Ncblx0dGhpcy5fYmluZChzaG93VGFyZ2V0LmFkZCh0b29sdGlwKSwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaGlkZXMgd2hlbiBtb3VzZSBpcyBtb3ZlZCBhIGNlcnRhaW4gZGlzdGFuY2Vcblx0XHRpZignbnVtYmVyJyA9PT0gdHlwZW9mIG9wdGlvbnMuaGlkZS5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIG9yaWdpbiA9IHRoaXMuY2FjaGUub3JpZ2luIHx8IHt9LFxuXHRcdFx0XHRsaW1pdCA9IHRoaXMub3B0aW9ucy5oaWRlLmRpc3RhbmNlLFxuXHRcdFx0XHRhYnMgPSBNYXRoLmFicztcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG1vdmVtZW50IGhhcyBnb25lIGJleW9uZCB0aGUgbGltaXQsIGFuZCBoaWRlIGl0IGlmIHNvXG5cdFx0XHRpZihhYnMoZXZlbnQucGFnZVggLSBvcmlnaW4ucGFnZVgpID49IGxpbWl0IHx8IGFicyhldmVudC5wYWdlWSAtIG9yaWdpbi5wYWdlWSkgPj0gbGltaXQpIHtcblx0XHRcdFx0dGhpcy5oaWRlKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSBtb3VzZW1vdmUgY29vcmRzIG9uIHNob3cgdGFyZ2V0c1xuXHRcdHRoaXMuX3N0b3JlTW91c2UoZXZlbnQpO1xuXHR9KTtcblxuXHQvLyBNb3VzZSBwb3NpdGlvbmluZyBldmVudHNcblx0aWYocG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScpIHtcblx0XHQvLyBJZiBtb3VzZSBhZGp1c3RtZW50IGlzIG9uLi4uXG5cdFx0aWYocG9zT3B0aW9ucy5hZGp1c3QubW91c2UpIHtcblx0XHRcdC8vIEFwcGx5IGEgbW91c2VsZWF2ZSBldmVudCBzbyB3ZSBkb24ndCBnZXQgcHJvYmxlbXMgd2l0aCBvdmVybGFwcGluZ1xuXHRcdFx0aWYob3B0aW9ucy5oaWRlLmV2ZW50KSB7XG5cdFx0XHRcdC8vIFRyYWNrIGlmIHdlJ3JlIG9uIHRoZSB0YXJnZXQgb3Igbm90XG5cdFx0XHRcdHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgWydtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnXSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHR0aGlzLmNhY2hlLm9uVGFyZ2V0ID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlZW50ZXInO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHRvb2x0aXAgcG9zaXRpb24gb24gbW91c2Vtb3ZlXG5cdFx0XHR0aGlzLl9iaW5kKGRvY3VtZW50VGFyZ2V0LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSB0b29sdGlwIHBvc2l0aW9uIG9ubHkgaWYgdGhlIHRvb2x0aXAgaXMgdmlzaWJsZSBhbmQgYWRqdXN0bWVudCBpcyBlbmFibGVkXG5cdFx0XHRcdGlmKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5jYWNoZS5vblRhcmdldCAmJiAhdGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSAmJiB0aGlzLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy5yZXBvc2l0aW9uKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRqdXN0IHBvc2l0aW9ucyBvZiB0aGUgdG9vbHRpcCBvbiB3aW5kb3cgcmVzaXplIGlmIGVuYWJsZWRcblx0aWYocG9zT3B0aW9ucy5hZGp1c3QucmVzaXplIHx8IHZpZXdwb3J0VGFyZ2V0Lmxlbmd0aCkge1xuXHRcdHRoaXMuX2JpbmQoICQuZXZlbnQuc3BlY2lhbC5yZXNpemUgPyB2aWV3cG9ydFRhcmdldCA6IHdpbmRvd1RhcmdldCwgJ3Jlc2l6ZScsIHJlcG9zaXRpb25NZXRob2QgKTtcblx0fVxuXG5cdC8vIEFkanVzdCB0b29sdGlwIHBvc2l0aW9uIG9uIHNjcm9sbCBvZiB0aGUgd2luZG93IG9yIHZpZXdwb3J0IGVsZW1lbnQgaWYgcHJlc2VudFxuXHRpZihwb3NPcHRpb25zLmFkanVzdC5zY3JvbGwpIHtcblx0XHR0aGlzLl9iaW5kKCB3aW5kb3dUYXJnZXQuYWRkKHBvc09wdGlvbnMuY29udGFpbmVyKSwgJ3Njcm9sbCcsIHJlcG9zaXRpb25NZXRob2QgKTtcblx0fVxufTtcblxuLy8gVW4tYXNzaWdubWVudCBtZXRob2RcblBST1RPVFlQRS5fdW5hc3NpZ25FdmVudHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRhcmdldHMgPSBbXG5cdFx0dGhpcy5vcHRpb25zLnNob3cudGFyZ2V0WzBdLFxuXHRcdHRoaXMub3B0aW9ucy5oaWRlLnRhcmdldFswXSxcblx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFswXSxcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24uY29udGFpbmVyWzBdLFxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbi52aWV3cG9ydFswXSxcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24uY29udGFpbmVyLmNsb3Nlc3QoJ2h0bWwnKVswXSwgLy8gdW5mb2N1c1xuXHRcdHdpbmRvdyxcblx0XHRkb2N1bWVudFxuXHRdO1xuXG5cdHRoaXMuX3VuYmluZCgkKFtdKS5wdXNoU3RhY2soICQuZ3JlcCh0YXJnZXRzLCBmdW5jdGlvbihpKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBpID09PSAnb2JqZWN0Jztcblx0fSkpKTtcbn07XG5cbjsvLyBJbml0aWFsaXphdGlvbiBtZXRob2RcbmZ1bmN0aW9uIGluaXQoZWxlbSwgaWQsIG9wdHMpIHtcblx0dmFyIG9iaiwgcG9zT3B0aW9ucywgYXR0ciwgY29uZmlnLCB0aXRsZSxcblxuXHQvLyBTZXR1cCBlbGVtZW50IHJlZmVyZW5jZXNcblx0ZG9jQm9keSA9ICQoZG9jdW1lbnQuYm9keSksXG5cblx0Ly8gVXNlIGRvY3VtZW50IGJvZHkgaW5zdGVhZCBvZiBkb2N1bWVudCBlbGVtZW50IGlmIG5lZWRlZFxuXHRuZXdUYXJnZXQgPSBlbGVtWzBdID09PSBkb2N1bWVudCA/IGRvY0JvZHkgOiBlbGVtLFxuXG5cdC8vIEdyYWIgbWV0YWRhdGEgZnJvbSBlbGVtZW50IGlmIHBsdWdpbiBpcyBwcmVzZW50XG5cdG1ldGFkYXRhID0gKGVsZW0ubWV0YWRhdGEpID8gZWxlbS5tZXRhZGF0YShvcHRzLm1ldGFkYXRhKSA6IE5VTEwsXG5cblx0Ly8gSWYgbWV0YWRhdGEgdHlwZSBpZiBIVE1MNSwgZ3JhYiAnbmFtZScgZnJvbSB0aGUgb2JqZWN0IGluc3RlYWQsIG9yIHVzZSB0aGUgcmVndWxhciBkYXRhIG9iamVjdCBvdGhlcndpc2Vcblx0bWV0YWRhdGE1ID0gb3B0cy5tZXRhZGF0YS50eXBlID09PSAnaHRtbDUnICYmIG1ldGFkYXRhID8gbWV0YWRhdGFbb3B0cy5tZXRhZGF0YS5uYW1lXSA6IE5VTEwsXG5cblx0Ly8gR3JhYiBkYXRhIGZyb20gbWV0YWRhdGEubmFtZSAob3IgZGF0YS1xdGlwb3B0cyBhcyBmYWxsYmFjaykgdXNpbmcgLmRhdGEoKSBtZXRob2QsXG5cdGh0bWw1ID0gZWxlbS5kYXRhKG9wdHMubWV0YWRhdGEubmFtZSB8fCAncXRpcG9wdHMnKTtcblxuXHQvLyBJZiB3ZSBkb24ndCBnZXQgYW4gb2JqZWN0IHJldHVybmVkIGF0dGVtcHQgdG8gcGFyc2UgaXQgbWFudWFseWwgd2l0aG91dCBwYXJzZUpTT05cblx0dHJ5IHsgaHRtbDUgPSB0eXBlb2YgaHRtbDUgPT09ICdzdHJpbmcnID8gJC5wYXJzZUpTT04oaHRtbDUpIDogaHRtbDU7IH0gY2F0Y2goZSkge31cblxuXHQvLyBNZXJnZSBpbiBhbmQgc2FuaXRpemUgbWV0YWRhdGFcblx0Y29uZmlnID0gJC5leHRlbmQoVFJVRSwge30sIFFUSVAuZGVmYXVsdHMsIG9wdHMsXG5cdFx0dHlwZW9mIGh0bWw1ID09PSAnb2JqZWN0JyA/IHNhbml0aXplT3B0aW9ucyhodG1sNSkgOiBOVUxMLFxuXHRcdHNhbml0aXplT3B0aW9ucyhtZXRhZGF0YTUgfHwgbWV0YWRhdGEpKTtcblxuXHQvLyBSZS1ncmFiIG91ciBwb3NpdGlvbmluZyBvcHRpb25zIG5vdyB3ZSd2ZSBtZXJnZWQgb3VyIG1ldGFkYXRhIGFuZCBzZXQgaWQgdG8gcGFzc2VkIHZhbHVlXG5cdHBvc09wdGlvbnMgPSBjb25maWcucG9zaXRpb247XG5cdGNvbmZpZy5pZCA9IGlkO1xuXG5cdC8vIFNldHVwIG1pc3NpbmcgY29udGVudCBpZiBub25lIGlzIGRldGVjdGVkXG5cdGlmKCdib29sZWFuJyA9PT0gdHlwZW9mIGNvbmZpZy5jb250ZW50LnRleHQpIHtcblx0XHRhdHRyID0gZWxlbS5hdHRyKGNvbmZpZy5jb250ZW50LmF0dHIpO1xuXG5cdFx0Ly8gR3JhYiBmcm9tIHN1cHBsaWVkIGF0dHJpYnV0ZSBpZiBhdmFpbGFibGVcblx0XHRpZihjb25maWcuY29udGVudC5hdHRyICE9PSBGQUxTRSAmJiBhdHRyKSB7IGNvbmZpZy5jb250ZW50LnRleHQgPSBhdHRyOyB9XG5cblx0XHQvLyBObyB2YWxpZCBjb250ZW50IHdhcyBmb3VuZCwgYWJvcnQgcmVuZGVyXG5cdFx0ZWxzZSB7IHJldHVybiBGQUxTRTsgfVxuXHR9XG5cblx0Ly8gU2V0dXAgdGFyZ2V0IG9wdGlvbnNcblx0aWYoIXBvc09wdGlvbnMuY29udGFpbmVyLmxlbmd0aCkgeyBwb3NPcHRpb25zLmNvbnRhaW5lciA9IGRvY0JvZHk7IH1cblx0aWYocG9zT3B0aW9ucy50YXJnZXQgPT09IEZBTFNFKSB7IHBvc09wdGlvbnMudGFyZ2V0ID0gbmV3VGFyZ2V0OyB9XG5cdGlmKGNvbmZpZy5zaG93LnRhcmdldCA9PT0gRkFMU0UpIHsgY29uZmlnLnNob3cudGFyZ2V0ID0gbmV3VGFyZ2V0OyB9XG5cdGlmKGNvbmZpZy5zaG93LnNvbG8gPT09IFRSVUUpIHsgY29uZmlnLnNob3cuc29sbyA9IHBvc09wdGlvbnMuY29udGFpbmVyLmNsb3Nlc3QoJ2JvZHknKTsgfVxuXHRpZihjb25maWcuaGlkZS50YXJnZXQgPT09IEZBTFNFKSB7IGNvbmZpZy5oaWRlLnRhcmdldCA9IG5ld1RhcmdldDsgfVxuXHRpZihjb25maWcucG9zaXRpb24udmlld3BvcnQgPT09IFRSVUUpIHsgY29uZmlnLnBvc2l0aW9uLnZpZXdwb3J0ID0gcG9zT3B0aW9ucy5jb250YWluZXI7IH1cblxuXHQvLyBFbnN1cmUgd2Ugb25seSB1c2UgYSBzaW5nbGUgY29udGFpbmVyXG5cdHBvc09wdGlvbnMuY29udGFpbmVyID0gcG9zT3B0aW9ucy5jb250YWluZXIuZXEoMCk7XG5cblx0Ly8gQ29udmVydCBwb3NpdGlvbiBjb3JuZXIgdmFsdWVzIGludG8geCBhbmQgeSBzdHJpbmdzXG5cdHBvc09wdGlvbnMuYXQgPSBuZXcgQ09STkVSKHBvc09wdGlvbnMuYXQsIFRSVUUpO1xuXHRwb3NPcHRpb25zLm15ID0gbmV3IENPUk5FUihwb3NPcHRpb25zLm15KTtcblxuXHQvLyBEZXN0cm95IHByZXZpb3VzIHRvb2x0aXAgaWYgb3ZlcndyaXRlIGlzIGVuYWJsZWQsIG9yIHNraXAgZWxlbWVudCBpZiBub3Rcblx0aWYoZWxlbS5kYXRhKE5BTUVTUEFDRSkpIHtcblx0XHRpZihjb25maWcub3ZlcndyaXRlKSB7XG5cdFx0XHRlbGVtLnF0aXAoJ2Rlc3Ryb3knLCB0cnVlKTtcblx0XHR9XG5cdFx0ZWxzZSBpZihjb25maWcub3ZlcndyaXRlID09PSBGQUxTRSkge1xuXHRcdFx0cmV0dXJuIEZBTFNFO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkZCBoYXMtcXRpcCBhdHRyaWJ1dGVcblx0ZWxlbS5hdHRyKEFUVFJfSEFTLCBpZCk7XG5cblx0Ly8gUmVtb3ZlIHRpdGxlIGF0dHJpYnV0ZSBhbmQgc3RvcmUgaXQgaWYgcHJlc2VudFxuXHRpZihjb25maWcuc3VwcHJlc3MgJiYgKHRpdGxlID0gZWxlbS5hdHRyKCd0aXRsZScpKSkge1xuXHRcdC8vIEZpbmFsIGF0dHIgY2FsbCBmaXhlcyBldmVudCBkZWxlZ2F0aW9tIGFuZCBJRSBkZWZhdWx0IHRvb2x0aXAgc2hvd2luZyBwcm9ibGVtXG5cdFx0ZWxlbS5yZW1vdmVBdHRyKCd0aXRsZScpLmF0dHIob2xkdGl0bGUsIHRpdGxlKS5hdHRyKCd0aXRsZScsICcnKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpemUgdGhlIHRvb2x0aXAgYW5kIGFkZCBBUEkgcmVmZXJlbmNlXG5cdG9iaiA9IG5ldyBRVGlwKGVsZW0sIGNvbmZpZywgaWQsICEhYXR0cik7XG5cdGVsZW0uZGF0YShOQU1FU1BBQ0UsIG9iaik7XG5cblx0Ly8gQ2F0Y2ggcmVtb3ZlL3JlbW92ZXF0aXAgZXZlbnRzIG9uIHRhcmdldCBlbGVtZW50IHRvIGRlc3Ryb3kgcmVkdW5kYW50IHRvb2x0aXBcblx0ZWxlbS5vbmUoJ3JlbW92ZS5xdGlwLScraWQrJyByZW1vdmVxdGlwLnF0aXAtJytpZCwgZnVuY3Rpb24oKSB7IFxuXHRcdHZhciBhcGk7IGlmKChhcGkgPSAkKHRoaXMpLmRhdGEoTkFNRVNQQUNFKSkpIHsgYXBpLmRlc3Ryb3kodHJ1ZSk7IH1cblx0fSk7XG5cblx0cmV0dXJuIG9iajtcbn1cblxuLy8galF1ZXJ5ICQuZm4gZXh0ZW5zaW9uIG1ldGhvZFxuUVRJUCA9ICQuZm4ucXRpcCA9IGZ1bmN0aW9uKG9wdGlvbnMsIG5vdGF0aW9uLCBuZXdWYWx1ZSlcbntcblx0dmFyIGNvbW1hbmQgPSAoJycgKyBvcHRpb25zKS50b0xvd2VyQ2FzZSgpLCAvLyBQYXJzZSBjb21tYW5kXG5cdFx0cmV0dXJuZWQgPSBOVUxMLFxuXHRcdGFyZ3MgPSAkLm1ha2VBcnJheShhcmd1bWVudHMpLnNsaWNlKDEpLFxuXHRcdGV2ZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdLFxuXHRcdG9wdHMgPSB0aGlzWzBdID8gJC5kYXRhKHRoaXNbMF0sIE5BTUVTUEFDRSkgOiBOVUxMO1xuXG5cdC8vIENoZWNrIGZvciBBUEkgcmVxdWVzdFxuXHRpZigoIWFyZ3VtZW50cy5sZW5ndGggJiYgb3B0cykgfHwgY29tbWFuZCA9PT0gJ2FwaScpIHtcblx0XHRyZXR1cm4gb3B0cztcblx0fVxuXG5cdC8vIEV4ZWN1dGUgQVBJIGNvbW1hbmQgaWYgcHJlc2VudFxuXHRlbHNlIGlmKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0aW9ucykge1xuXHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcGkgPSAkLmRhdGEodGhpcywgTkFNRVNQQUNFKTtcblx0XHRcdGlmKCFhcGkpIHsgcmV0dXJuIFRSVUU7IH1cblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIGV2ZW50IGlmIHBvc3NpYmxlXG5cdFx0XHRpZihldmVudCAmJiBldmVudC50aW1lU3RhbXApIHsgYXBpLmNhY2hlLmV2ZW50ID0gZXZlbnQ7IH1cblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHNwZWNpZmljIEFQSSBjb21tYW5kc1xuXHRcdFx0aWYobm90YXRpb24gJiYgKGNvbW1hbmQgPT09ICdvcHRpb24nIHx8IGNvbW1hbmQgPT09ICdvcHRpb25zJykpIHtcblx0XHRcdFx0aWYobmV3VmFsdWUgIT09IHVuZGVmaW5lZCB8fCAkLmlzUGxhaW5PYmplY3Qobm90YXRpb24pKSB7XG5cdFx0XHRcdFx0YXBpLnNldChub3RhdGlvbiwgbmV3VmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybmVkID0gYXBpLmdldChub3RhdGlvbik7XG5cdFx0XHRcdFx0cmV0dXJuIEZBTFNFO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEV4ZWN1dGUgQVBJIGNvbW1hbmRcblx0XHRcdGVsc2UgaWYoYXBpW2NvbW1hbmRdKSB7XG5cdFx0XHRcdGFwaVtjb21tYW5kXS5hcHBseShhcGksIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJldHVybmVkICE9PSBOVUxMID8gcmV0dXJuZWQgOiB0aGlzO1xuXHR9XG5cblx0Ly8gTm8gQVBJIGNvbW1hbmRzLiB2YWxpZGF0ZSBwcm92aWRlZCBvcHRpb25zIGFuZCBzZXR1cCBxVGlwc1xuXHRlbHNlIGlmKCdvYmplY3QnID09PSB0eXBlb2Ygb3B0aW9ucyB8fCAhYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdC8vIFNhbml0aXplIG9wdGlvbnMgZmlyc3Rcblx0XHRvcHRzID0gc2FuaXRpemVPcHRpb25zKCQuZXh0ZW5kKFRSVUUsIHt9LCBvcHRpb25zKSk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdHZhciBhcGksIGlkO1xuXG5cdFx0XHQvLyBGaW5kIG5leHQgYXZhaWxhYmxlIElELCBvciB1c2UgY3VzdG9tIElEIGlmIHByb3ZpZGVkXG5cdFx0XHRpZCA9ICQuaXNBcnJheShvcHRzLmlkKSA/IG9wdHMuaWRbaV0gOiBvcHRzLmlkO1xuXHRcdFx0aWQgPSAhaWQgfHwgaWQgPT09IEZBTFNFIHx8IGlkLmxlbmd0aCA8IDEgfHwgUVRJUC5hcGlbaWRdID8gUVRJUC5uZXh0aWQrKyA6IGlkO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHRoZSBxVGlwIGFuZCByZS1ncmFiIG5ld2x5IHNhbml0aXplZCBvcHRpb25zXG5cdFx0XHRhcGkgPSBpbml0KCQodGhpcyksIGlkLCBvcHRzKTtcblx0XHRcdGlmKGFwaSA9PT0gRkFMU0UpIHsgcmV0dXJuIFRSVUU7IH1cblx0XHRcdGVsc2UgeyBRVElQLmFwaVtpZF0gPSBhcGk7IH1cblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBwbHVnaW5zXG5cdFx0XHQkLmVhY2goUExVR0lOUywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHRoaXMuaW5pdGlhbGl6ZSA9PT0gJ2luaXRpYWxpemUnKSB7IHRoaXMoYXBpKTsgfVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFzc2lnbiBpbml0aWFsIHByZS1yZW5kZXIgZXZlbnRzXG5cdFx0XHRhcGkuX2Fzc2lnbkluaXRpYWxFdmVudHMoZXZlbnQpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG4vLyBFeHBvc2UgY2xhc3NcbiQucXRpcCA9IFFUaXA7XG5cbi8vIFBvcHVsYXRlZCBpbiByZW5kZXIgbWV0aG9kXG5RVElQLmFwaSA9IHt9O1xuOyQuZWFjaCh7XG5cdC8qIEFsbG93IG90aGVyIHBsdWdpbnMgdG8gc3VjY2Vzc2Z1bGx5IHJldHJpZXZlIHRoZSB0aXRsZSBvZiBhbiBlbGVtZW50IHdpdGggYSBxVGlwIGFwcGxpZWQgKi9cblx0YXR0cjogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG5cdFx0aWYodGhpcy5sZW5ndGgpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpc1swXSxcblx0XHRcdFx0dGl0bGUgPSAndGl0bGUnLFxuXHRcdFx0XHRhcGkgPSAkLmRhdGEoc2VsZiwgJ3F0aXAnKTtcblxuXHRcdFx0aWYoYXR0ciA9PT0gdGl0bGUgJiYgYXBpICYmICdvYmplY3QnID09PSB0eXBlb2YgYXBpICYmIGFwaS5vcHRpb25zLnN1cHByZXNzKSB7XG5cdFx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuYXR0cihzZWxmLCBvbGR0aXRsZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBxVGlwIGlzIHJlbmRlcmVkIGFuZCB0aXRsZSB3YXMgb3JpZ2luYWxseSB1c2VkIGFzIGNvbnRlbnQsIHVwZGF0ZSBpdFxuXHRcdFx0XHRpZihhcGkgJiYgYXBpLm9wdGlvbnMuY29udGVudC5hdHRyID09PSB0aXRsZSAmJiBhcGkuY2FjaGUuYXR0cikge1xuXHRcdFx0XHRcdGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIHZhbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVc2UgdGhlIHJlZ3VsYXIgYXR0ciBtZXRob2QgdG8gc2V0LCB0aGVuIGNhY2hlIHRoZSByZXN1bHRcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXR0cihvbGR0aXRsZSwgdmFsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJC5mblsnYXR0cicrcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvKiBBbGxvdyBjbG9uZSB0byBjb3JyZWN0bHkgcmV0cmlldmUgY2FjaGVkIHRpdGxlIGF0dHJpYnV0ZXMgKi9cblx0Y2xvbmU6IGZ1bmN0aW9uKGtlZXBEYXRhKSB7XG5cdFx0dmFyIHRpdGxlcyA9ICQoW10pLCB0aXRsZSA9ICd0aXRsZScsXG5cblx0XHQvLyBDbG9uZSBvdXIgZWxlbWVudCB1c2luZyB0aGUgcmVhbCBjbG9uZSBtZXRob2Rcblx0XHRlbGVtcyA9ICQuZm5bJ2Nsb25lJytyZXBsYWNlU3VmZml4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0Ly8gR3JhYiBhbGwgZWxlbWVudHMgd2l0aCBhbiBvbGR0aXRsZSBzZXQsIGFuZCBjaGFuZ2UgaXQgdG8gcmVndWxhciB0aXRsZSBhdHRyaWJ1dGUsIGlmIGtlZXBEYXRhIGlzIGZhbHNlXG5cdFx0aWYoIWtlZXBEYXRhKSB7XG5cdFx0XHRlbGVtcy5maWx0ZXIoJ1snK29sZHRpdGxlKyddJykuYXR0cigndGl0bGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQuYXR0cih0aGlzLCBvbGR0aXRsZSk7XG5cdFx0XHR9KVxuXHRcdFx0LnJlbW92ZUF0dHIob2xkdGl0bGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtcztcblx0fVxufSwgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRpZighZnVuYyB8fCAkLmZuW25hbWUrcmVwbGFjZVN1ZmZpeF0pIHsgcmV0dXJuIFRSVUU7IH1cblxuXHR2YXIgb2xkID0gJC5mbltuYW1lK3JlcGxhY2VTdWZmaXhdID0gJC5mbltuYW1lXTtcblx0JC5mbltuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG59KTtcblxuLyogRmlyZSBvZmYgJ3JlbW92ZXF0aXAnIGhhbmRsZXIgaW4gJC5jbGVhbkRhdGEgaWYgalF1ZXJ5IFVJIG5vdCBwcmVzZW50IChpdCBhbHJlYWR5IGRvZXMgc2ltaWxhcikuXG4gKiBUaGlzIHNuaXBwZXQgaXMgdGFrZW4gZGlyZWN0bHkgZnJvbSBqUXVlcnkgVUkgc291cmNlIGNvZGUgZm91bmQgaGVyZTpcbiAqICAgICBodHRwOi8vY29kZS5qcXVlcnkuY29tL3VpL2pxdWVyeS11aS1naXQuanNcbiAqL1xuaWYoISQudWkpIHtcblx0JFsnY2xlYW5EYXRhJytyZXBsYWNlU3VmZml4XSA9ICQuY2xlYW5EYXRhO1xuXHQkLmNsZWFuRGF0YSA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHRmb3IodmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9ICQoIGVsZW1zW2ldICkpLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZihlbGVtLmF0dHIoQVRUUl9IQVMpKSB7XG5cdFx0XHRcdHRyeSB7IGVsZW0udHJpZ2dlckhhbmRsZXIoJ3JlbW92ZXF0aXAnKTsgfSBcblx0XHRcdFx0Y2F0Y2goIGUgKSB7fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQkWydjbGVhbkRhdGEnK3JlcGxhY2VTdWZmaXhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG59XG5cbjsvLyBxVGlwIHZlcnNpb25cblFUSVAudmVyc2lvbiA9ICdAQFZFUlNJT04nO1xuXG4vLyBCYXNlIElEIGZvciBhbGwgcVRpcHNcblFUSVAubmV4dGlkID0gMDtcblxuLy8gSW5hY3RpdmUgZXZlbnRzIGFycmF5XG5RVElQLmluYWN0aXZlRXZlbnRzID0gSU5BQ1RJVkVfRVZFTlRTO1xuXG4vLyBCYXNlIHotaW5kZXggZm9yIGFsbCBxVGlwc1xuUVRJUC56aW5kZXggPSAxNTAwMDtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYXRpb24gZGVmYXVsdHNcblFUSVAuZGVmYXVsdHMgPSB7XG5cdHByZXJlbmRlcjogRkFMU0UsXG5cdGlkOiBGQUxTRSxcblx0b3ZlcndyaXRlOiBUUlVFLFxuXHRzdXBwcmVzczogVFJVRSxcblx0Y29udGVudDoge1xuXHRcdHRleHQ6IFRSVUUsXG5cdFx0YXR0cjogJ3RpdGxlJyxcblx0XHR0aXRsZTogRkFMU0UsXG5cdFx0YnV0dG9uOiBGQUxTRVxuXHR9LFxuXHRwb3NpdGlvbjoge1xuXHRcdG15OiAndG9wIGxlZnQnLFxuXHRcdGF0OiAnYm90dG9tIHJpZ2h0Jyxcblx0XHR0YXJnZXQ6IEZBTFNFLFxuXHRcdGNvbnRhaW5lcjogRkFMU0UsXG5cdFx0dmlld3BvcnQ6IEZBTFNFLFxuXHRcdGFkanVzdDoge1xuXHRcdFx0eDogMCwgeTogMCxcblx0XHRcdG1vdXNlOiBUUlVFLFxuXHRcdFx0c2Nyb2xsOiBUUlVFLFxuXHRcdFx0cmVzaXplOiBUUlVFLFxuXHRcdFx0bWV0aG9kOiAnZmxpcGludmVydCBmbGlwaW52ZXJ0J1xuXHRcdH0sXG5cdFx0ZWZmZWN0OiBmdW5jdGlvbihhcGksIHBvcywgdmlld3BvcnQpIHtcblx0XHRcdCQodGhpcykuYW5pbWF0ZShwb3MsIHtcblx0XHRcdFx0ZHVyYXRpb246IDIwMCxcblx0XHRcdFx0cXVldWU6IEZBTFNFXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cdHNob3c6IHtcblx0XHR0YXJnZXQ6IEZBTFNFLFxuXHRcdGV2ZW50OiAnbW91c2VlbnRlcicsXG5cdFx0ZWZmZWN0OiBUUlVFLFxuXHRcdGRlbGF5OiA5MCxcblx0XHRzb2xvOiBGQUxTRSxcblx0XHRyZWFkeTogRkFMU0UsXG5cdFx0YXV0b2ZvY3VzOiBGQUxTRVxuXHR9LFxuXHRoaWRlOiB7XG5cdFx0dGFyZ2V0OiBGQUxTRSxcblx0XHRldmVudDogJ21vdXNlbGVhdmUnLFxuXHRcdGVmZmVjdDogVFJVRSxcblx0XHRkZWxheTogMCxcblx0XHRmaXhlZDogRkFMU0UsXG5cdFx0aW5hY3RpdmU6IEZBTFNFLFxuXHRcdGxlYXZlOiAnd2luZG93Jyxcblx0XHRkaXN0YW5jZTogRkFMU0Vcblx0fSxcblx0c3R5bGU6IHtcblx0XHRjbGFzc2VzOiAnJyxcblx0XHR3aWRnZXQ6IEZBTFNFLFxuXHRcdHdpZHRoOiBGQUxTRSxcblx0XHRoZWlnaHQ6IEZBTFNFLFxuXHRcdGRlZjogVFJVRVxuXHR9LFxuXHRldmVudHM6IHtcblx0XHRyZW5kZXI6IE5VTEwsXG5cdFx0bW92ZTogTlVMTCxcblx0XHRzaG93OiBOVUxMLFxuXHRcdGhpZGU6IE5VTEwsXG5cdFx0dG9nZ2xlOiBOVUxMLFxuXHRcdHZpc2libGU6IE5VTEwsXG5cdFx0aGlkZGVuOiBOVUxMLFxuXHRcdGZvY3VzOiBOVUxMLFxuXHRcdGJsdXI6IE5VTExcblx0fVxufTtcblxuO3ZhciBUSVAsIFxuXG4vLyAuYmluZCgpLy5vbigpIG5hbWVzcGFjZVxuVElQTlMgPSAnLnF0aXAtdGlwJyxcblxuLy8gQ29tbW9uIENTUyBzdHJpbmdzXG5NQVJHSU4gPSAnbWFyZ2luJyxcbkJPUkRFUiA9ICdib3JkZXInLFxuQ09MT1IgPSAnY29sb3InLFxuQkdfQ09MT1IgPSAnYmFja2dyb3VuZC1jb2xvcicsXG5UUkFOU1BBUkVOVCA9ICd0cmFuc3BhcmVudCcsXG5JTVBPUlRBTlQgPSAnICFpbXBvcnRhbnQnLFxuXG4vLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyA8Y2FudmFzLz4gZWxlbWVudHNcbkhBU0NBTlZBUyA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcblxuLy8gSW52YWxpZCBjb2xvdXIgdmFsdWVzIHVzZWQgaW4gcGFyc2VDb2xvdXJzKClcbklOVkFMSUQgPSAvcmdiYT9cXCgwLCAwLCAwKCwgMCk/XFwpfHRyYW5zcGFyZW50fCMxMjM0NTYvaTtcblxuLy8gQ2FtZWwtY2FzZSBtZXRob2QsIHRha2VuIGZyb20galF1ZXJ5IHNvdXJjZVxuLy8gaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS9qcXVlcnktMS44LjAuanNcbmZ1bmN0aW9uIGNhbWVsKHMpIHsgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpOyB9XG5cbi8qXG4gKiBNb2RpZmllZCBmcm9tIE1vZGVybml6cidzIHRlc3RQcm9wc0FsbCgpXG4gKiBodHRwOi8vbW9kZXJuaXpyLmNvbS9kb3dubG9hZHMvbW9kZXJuaXpyLWxhdGVzdC5qc1xuICovXG52YXIgY3NzUHJvcHMgPSB7fSwgY3NzUHJlZml4ZXMgPSBbXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIl07XG5mdW5jdGlvbiB2ZW5kb3JDc3MoZWxlbSwgcHJvcCkge1xuXHR2YXIgdWNQcm9wID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSksXG5cdFx0cHJvcHMgPSAocHJvcCArICcgJyArIGNzc1ByZWZpeGVzLmpvaW4odWNQcm9wICsgJyAnKSArIHVjUHJvcCkuc3BsaXQoJyAnKSxcblx0XHRjdXIsIHZhbCwgaSA9IDA7XG5cblx0Ly8gSWYgdGhlIHByb3BlcnR5IGhhcyBhbHJlYWR5IGJlZW4gbWFwcGVkLi4uXG5cdGlmKGNzc1Byb3BzW3Byb3BdKSB7IHJldHVybiBlbGVtLmNzcyhjc3NQcm9wc1twcm9wXSk7IH1cblxuXHR3aGlsZSgoY3VyID0gcHJvcHNbaSsrXSkpIHtcblx0XHRpZigodmFsID0gZWxlbS5jc3MoY3VyKSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGNzc1Byb3BzW3Byb3BdID0gY3VyLCB2YWw7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFBhcnNlIGEgZ2l2ZW4gZWxlbWVudHMgQ1NTIHByb3BlcnR5IGludG8gYW4gaW50XG5mdW5jdGlvbiBpbnRDc3MoZWxlbSwgcHJvcCkge1xuXHRyZXR1cm4gTWF0aC5jZWlsKHBhcnNlRmxvYXQodmVuZG9yQ3NzKGVsZW0sIHByb3ApKSk7XG59XG5cblxuLy8gVk1MIGNyZWF0aW9uIChmb3IgSUUgb25seSlcbmlmKCFIQVNDQU5WQVMpIHtcblx0dmFyIGNyZWF0ZVZNTCA9IGZ1bmN0aW9uKHRhZywgcHJvcHMsIHN0eWxlKSB7XG5cdFx0cmV0dXJuICc8cXRpcHZtbDonK3RhZysnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cInF0aXAtdm1sXCIgJysocHJvcHN8fCcnKStcblx0XHRcdCcgc3R5bGU9XCJiZWhhdmlvcjogdXJsKCNkZWZhdWx0I1ZNTCk7ICcrKHN0eWxlfHwnJykrICdcIiAvPic7XG5cdH07XG59XG5cbi8vIENhbnZhcyBvbmx5IGRlZmluaXRpb25zXG5lbHNlIHtcblx0dmFyIFBJWEVMX1JBVElPID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcblx0XHRCQUNLSU5HX1NUT1JFX1JBVElPID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IFxuXHRcdFx0XHRcdGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblx0XHR9KCkpLFxuXHRcdFNDQUxFID0gUElYRUxfUkFUSU8gLyBCQUNLSU5HX1NUT1JFX1JBVElPO1xufVxuXG5cbmZ1bmN0aW9uIFRpcChxdGlwLCBvcHRpb25zKSB7XG5cdHRoaXMuX25zID0gJ3RpcCc7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG5cdHRoaXMuc2l6ZSA9IFsgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQgXTtcblxuXHQvLyBJbml0aWFsaXplXG5cdHRoaXMuaW5pdCggKHRoaXMucXRpcCA9IHF0aXApICk7XG59XG5cbiQuZXh0ZW5kKFRpcC5wcm90b3R5cGUsIHtcblx0aW5pdDogZnVuY3Rpb24ocXRpcCkge1xuXHRcdHZhciBjb250ZXh0LCB0aXA7XG5cblx0XHQvLyBDcmVhdGUgdGlwIGVsZW1lbnQgYW5kIHByZXBlbmQgdG8gdGhlIHRvb2x0aXBcblx0XHR0aXAgPSB0aGlzLmVsZW1lbnQgPSBxdGlwLmVsZW1lbnRzLnRpcCA9ICQoJzxkaXYgLz4nLCB7ICdjbGFzcyc6IE5BTUVTUEFDRSsnLXRpcCcgfSkucHJlcGVuZFRvKHF0aXAudG9vbHRpcCk7XG5cblx0XHQvLyBDcmVhdGUgdGlwIGRyYXdpbmcgZWxlbWVudChzKVxuXHRcdGlmKEhBU0NBTlZBUykge1xuXHRcdFx0Ly8gc2F2ZSgpIGFzIHNvb24gYXMgd2UgY3JlYXRlIHRoZSBjYW52YXMgZWxlbWVudCBzbyBGRjIgZG9lc24ndCBib3JrIG9uIG91ciBmaXJzdCByZXN0b3JlKCkhXG5cdFx0XHRjb250ZXh0ID0gJCgnPGNhbnZhcyAvPicpLmFwcGVuZFRvKHRoaXMuZWxlbWVudClbMF0uZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdFx0Ly8gU2V0dXAgY29uc3RhbnQgcGFyYW1ldGVyc1xuXHRcdFx0Y29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG5cdFx0XHRjb250ZXh0Lm1pdGVyTGltaXQgPSAxMDAwMDA7XG5cdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gY3JlYXRlVk1MKCdzaGFwZScsICdjb29yZG9yaWdpbj1cIjAsMFwiJywgJ3Bvc2l0aW9uOmFic29sdXRlOycpO1xuXHRcdFx0dGhpcy5lbGVtZW50Lmh0bWwoY29udGV4dCArIGNvbnRleHQpO1xuXG5cdFx0XHQvLyBQcmV2ZW50IG1vdXNpbmcgZG93biBvbiB0aGUgdGlwIHNpbmNlIGl0IGNhdXNlcyBwcm9ibGVtcyB3aXRoIC5saXZlKCkgaGFuZGxpbmcgaW4gSUUgZHVlIHRvIFZNTFxuXHRcdFx0cXRpcC5fYmluZCggJCgnKicsIHRpcCkuYWRkKHRpcCksIFsnY2xpY2snLCAnbW91c2Vkb3duJ10sIGZ1bmN0aW9uKGV2ZW50KSB7IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyB9LCB0aGlzLl9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gQmluZCB1cGRhdGUgZXZlbnRzXG5cdFx0cXRpcC5fYmluZChxdGlwLnRvb2x0aXAsICd0b29sdGlwbW92ZScsIHRoaXMucmVwb3NpdGlvbiwgdGhpcy5fbnMsIHRoaXMpO1xuXG5cdFx0Ly8gQ3JlYXRlIGl0XG5cdFx0dGhpcy5jcmVhdGUoKTtcblx0fSxcblxuXHRfc3dhcERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2l6ZVswXSA9IHRoaXMub3B0aW9ucy5oZWlnaHQ7XG5cdFx0dGhpcy5zaXplWzFdID0gdGhpcy5vcHRpb25zLndpZHRoO1xuXHR9LFxuXHRfcmVzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNpemVbMF0gPSB0aGlzLm9wdGlvbnMud2lkdGg7XG5cdFx0dGhpcy5zaXplWzFdID0gdGhpcy5vcHRpb25zLmhlaWdodDtcblx0fSxcblxuXHRfdXNlVGl0bGU6IGZ1bmN0aW9uKGNvcm5lcikge1xuXHRcdHZhciB0aXRsZWJhciA9IHRoaXMucXRpcC5lbGVtZW50cy50aXRsZWJhcjtcblx0XHRyZXR1cm4gdGl0bGViYXIgJiYgKFxuXHRcdFx0Y29ybmVyLnkgPT09IFRPUCB8fCAoY29ybmVyLnkgPT09IENFTlRFUiAmJiB0aGlzLmVsZW1lbnQucG9zaXRpb24oKS50b3AgKyAodGhpcy5zaXplWzFdIC8gMikgKyB0aGlzLm9wdGlvbnMub2Zmc2V0IDwgdGl0bGViYXIub3V0ZXJIZWlnaHQoVFJVRSkpXG5cdFx0KTtcblx0fSxcblxuXHRfcGFyc2VDb3JuZXI6IGZ1bmN0aW9uKGNvcm5lcikge1xuXHRcdHZhciBteSA9IHRoaXMucXRpcC5vcHRpb25zLnBvc2l0aW9uLm15O1xuXG5cdFx0Ly8gRGV0ZWN0IGNvcm5lciBhbmQgbWltaWMgcHJvcGVydGllc1xuXHRcdGlmKGNvcm5lciA9PT0gRkFMU0UgfHwgbXkgPT09IEZBTFNFKSB7XG5cdFx0XHRjb3JuZXIgPSBGQUxTRTtcblx0XHR9XG5cdFx0ZWxzZSBpZihjb3JuZXIgPT09IFRSVUUpIHtcblx0XHRcdGNvcm5lciA9IG5ldyBDT1JORVIoIG15LnN0cmluZygpICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYoIWNvcm5lci5zdHJpbmcpIHtcblx0XHRcdGNvcm5lciA9IG5ldyBDT1JORVIoY29ybmVyKTtcblx0XHRcdGNvcm5lci5maXhlZCA9IFRSVUU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvcm5lcjtcblx0fSxcblxuXHRfcGFyc2VXaWR0aDogZnVuY3Rpb24oY29ybmVyLCBzaWRlLCB1c2UpIHtcblx0XHR2YXIgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXG5cdFx0XHRwcm9wID0gQk9SREVSICsgY2FtZWwoc2lkZSkgKyAnV2lkdGgnO1xuXG5cdFx0cmV0dXJuICh1c2UgPyBpbnRDc3ModXNlLCBwcm9wKSA6IChcblx0XHRcdGludENzcyhlbGVtZW50cy5jb250ZW50LCBwcm9wKSB8fFxuXHRcdFx0aW50Q3NzKHRoaXMuX3VzZVRpdGxlKGNvcm5lcikgJiYgZWxlbWVudHMudGl0bGViYXIgfHwgZWxlbWVudHMuY29udGVudCwgcHJvcCkgfHxcblx0XHRcdGludENzcyhlbGVtZW50cy50b29sdGlwLCBwcm9wKVxuXHRcdCkpIHx8IDA7XG5cdH0sXG5cblx0X3BhcnNlUmFkaXVzOiBmdW5jdGlvbihjb3JuZXIpIHtcblx0XHR2YXIgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXG5cdFx0XHRwcm9wID0gQk9SREVSICsgY2FtZWwoY29ybmVyLnkpICsgY2FtZWwoY29ybmVyLngpICsgJ1JhZGl1cyc7XG5cblx0XHRyZXR1cm4gQlJPV1NFUi5pZSA8IDkgPyAwIDpcblx0XHRcdGludENzcyh0aGlzLl91c2VUaXRsZShjb3JuZXIpICYmIGVsZW1lbnRzLnRpdGxlYmFyIHx8IGVsZW1lbnRzLmNvbnRlbnQsIHByb3ApIHx8IFxuXHRcdFx0aW50Q3NzKGVsZW1lbnRzLnRvb2x0aXAsIHByb3ApIHx8IDA7XG5cdH0sXG5cblx0X2ludmFsaWRDb2xvdXI6IGZ1bmN0aW9uKGVsZW0sIHByb3AsIGNvbXBhcmUpIHtcblx0XHR2YXIgdmFsID0gZWxlbS5jc3MocHJvcCk7XG5cdFx0cmV0dXJuICF2YWwgfHwgKGNvbXBhcmUgJiYgdmFsID09PSBlbGVtLmNzcyhjb21wYXJlKSkgfHwgSU5WQUxJRC50ZXN0KHZhbCkgPyBGQUxTRSA6IHZhbDtcblx0fSxcblxuXHRfcGFyc2VDb2xvdXJzOiBmdW5jdGlvbihjb3JuZXIpIHtcblx0XHR2YXIgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXG5cdFx0XHR0aXAgPSB0aGlzLmVsZW1lbnQuY3NzKCdjc3NUZXh0JywgJycpLFxuXHRcdFx0Ym9yZGVyU2lkZSA9IEJPUkRFUiArIGNhbWVsKGNvcm5lclsgY29ybmVyLnByZWNlZGFuY2UgXSkgKyBjYW1lbChDT0xPUiksXG5cdFx0XHRjb2xvckVsZW0gPSB0aGlzLl91c2VUaXRsZShjb3JuZXIpICYmIGVsZW1lbnRzLnRpdGxlYmFyIHx8IGVsZW1lbnRzLmNvbnRlbnQsXG5cdFx0XHRjc3MgPSB0aGlzLl9pbnZhbGlkQ29sb3VyLCBjb2xvciA9IFtdO1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBkZXRlY3QgdGhlIGJhY2tncm91bmQgY29sb3VyIGZyb20gdmFyaW91cyBlbGVtZW50cywgbGVmdC10by1yaWdodCBwcmVjZWRhbmNlXG5cdFx0Y29sb3JbMF0gPSBjc3ModGlwLCBCR19DT0xPUikgfHwgY3NzKGNvbG9yRWxlbSwgQkdfQ09MT1IpIHx8IGNzcyhlbGVtZW50cy5jb250ZW50LCBCR19DT0xPUikgfHwgXG5cdFx0XHRjc3MoZWxlbWVudHMudG9vbHRpcCwgQkdfQ09MT1IpIHx8IHRpcC5jc3MoQkdfQ09MT1IpO1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBkZXRlY3QgdGhlIGNvcnJlY3QgYm9yZGVyIHNpZGUgY29sb3VyIGZyb20gdmFyaW91cyBlbGVtZW50cywgbGVmdC10by1yaWdodCBwcmVjZWRhbmNlXG5cdFx0Y29sb3JbMV0gPSBjc3ModGlwLCBib3JkZXJTaWRlLCBDT0xPUikgfHwgY3NzKGNvbG9yRWxlbSwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IFxuXHRcdFx0Y3NzKGVsZW1lbnRzLmNvbnRlbnQsIGJvcmRlclNpZGUsIENPTE9SKSB8fCBjc3MoZWxlbWVudHMudG9vbHRpcCwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IGVsZW1lbnRzLnRvb2x0aXAuY3NzKGJvcmRlclNpZGUpO1xuXG5cdFx0Ly8gUmVzZXQgYmFja2dyb3VuZCBhbmQgYm9yZGVyIGNvbG91cnNcblx0XHQkKCcqJywgdGlwKS5hZGQodGlwKS5jc3MoJ2Nzc1RleHQnLCBCR19DT0xPUisnOicrVFJBTlNQQVJFTlQrSU1QT1JUQU5UKyc7JytCT1JERVIrJzowJytJTVBPUlRBTlQrJzsnKTtcblxuXHRcdHJldHVybiBjb2xvcjtcblx0fSxcblxuXHRfY2FsY3VsYXRlU2l6ZTogZnVuY3Rpb24oY29ybmVyKSB7XG5cdFx0dmFyIHkgPSBjb3JuZXIucHJlY2VkYW5jZSA9PT0gWSxcblx0XHRcdHdpZHRoID0gdGhpcy5vcHRpb25zWyd3aWR0aCddLFxuXHRcdFx0aGVpZ2h0ID0gdGhpcy5vcHRpb25zWydoZWlnaHQnXSxcblx0XHRcdGlzQ2VudGVyID0gY29ybmVyLmFiYnJldigpID09PSAnYycsXG5cdFx0XHRiYXNlID0gKHkgPyB3aWR0aDogaGVpZ2h0KSAqIChpc0NlbnRlciA/IDAuNSA6IDEpLFxuXHRcdFx0cG93ID0gTWF0aC5wb3csXG5cdFx0XHRyb3VuZCA9IE1hdGgucm91bmQsXG5cdFx0XHRiaWdIeXAsIHJhdGlvLCByZXN1bHQsXG5cblx0XHRzbWFsbEh5cCA9IE1hdGguc3FydCggcG93KGJhc2UsIDIpICsgcG93KGhlaWdodCwgMikgKSxcblx0XHRoeXAgPSBbICh0aGlzLmJvcmRlciAvIGJhc2UpICogc21hbGxIeXAsICh0aGlzLmJvcmRlciAvIGhlaWdodCkgKiBzbWFsbEh5cCBdO1xuXG5cdFx0aHlwWzJdID0gTWF0aC5zcXJ0KCBwb3coaHlwWzBdLCAyKSAtIHBvdyh0aGlzLmJvcmRlciwgMikgKTtcblx0XHRoeXBbM10gPSBNYXRoLnNxcnQoIHBvdyhoeXBbMV0sIDIpIC0gcG93KHRoaXMuYm9yZGVyLCAyKSApO1xuXG5cdFx0YmlnSHlwID0gc21hbGxIeXAgKyBoeXBbMl0gKyBoeXBbM10gKyAoaXNDZW50ZXIgPyAwIDogaHlwWzBdKTtcblx0XHRyYXRpbyA9IGJpZ0h5cCAvIHNtYWxsSHlwO1xuXG5cdFx0cmVzdWx0ID0gWyByb3VuZChyYXRpbyAqIHdpZHRoKSwgcm91bmQocmF0aW8gKiBoZWlnaHQpIF07XG5cdFx0cmV0dXJuIHkgPyByZXN1bHQgOiByZXN1bHQucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdC8vIFRpcCBjb29yZGluYXRlcyBjYWxjdWxhdG9yXG5cdF9jYWxjdWxhdGVUaXA6IGZ1bmN0aW9uKGNvcm5lciwgc2l6ZSwgc2NhbGUpIHtcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XG5cdFx0c2l6ZSA9IHNpemUgfHwgdGhpcy5zaXplO1xuXG5cdFx0dmFyIHdpZHRoID0gc2l6ZVswXSAqIHNjYWxlLFxuXHRcdFx0aGVpZ2h0ID0gc2l6ZVsxXSAqIHNjYWxlLFxuXHRcdFx0d2lkdGgyID0gTWF0aC5jZWlsKHdpZHRoIC8gMiksIGhlaWdodDIgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMiksXG5cblx0XHQvLyBEZWZpbmUgdGlwIGNvb3JkaW5hdGVzIGluIHRlcm1zIG9mIGhlaWdodCBhbmQgd2lkdGggdmFsdWVzXG5cdFx0dGlwcyA9IHtcblx0XHRcdGJyOlx0WzAsMCxcdFx0d2lkdGgsaGVpZ2h0LFx0d2lkdGgsMF0sXG5cdFx0XHRibDpcdFswLDAsXHRcdHdpZHRoLDAsXHRcdDAsaGVpZ2h0XSxcblx0XHRcdHRyOlx0WzAsaGVpZ2h0LFx0d2lkdGgsMCxcdFx0d2lkdGgsaGVpZ2h0XSxcblx0XHRcdHRsOlx0WzAsMCxcdFx0MCxoZWlnaHQsXHRcdHdpZHRoLGhlaWdodF0sXG5cdFx0XHR0YzpcdFswLGhlaWdodCxcdHdpZHRoMiwwLFx0XHR3aWR0aCxoZWlnaHRdLFxuXHRcdFx0YmM6XHRbMCwwLFx0XHR3aWR0aCwwLFx0XHR3aWR0aDIsaGVpZ2h0XSxcblx0XHRcdHJjOlx0WzAsMCxcdFx0d2lkdGgsaGVpZ2h0MixcdDAsaGVpZ2h0XSxcblx0XHRcdGxjOlx0W3dpZHRoLDAsXHR3aWR0aCxoZWlnaHQsXHQwLGhlaWdodDJdXG5cdFx0fTtcblxuXHRcdC8vIFNldCBjb21tb24gc2lkZSBzaGFwZXNcblx0XHR0aXBzLmx0ID0gdGlwcy5icjsgdGlwcy5ydCA9IHRpcHMuYmw7XG5cdFx0dGlwcy5sYiA9IHRpcHMudHI7IHRpcHMucmIgPSB0aXBzLnRsO1xuXG5cdFx0cmV0dXJuIHRpcHNbIGNvcm5lci5hYmJyZXYoKSBdO1xuXHR9LFxuXG5cdC8vIFRpcCBjb29yZGluYXRlcyBkcmF3ZXIgKGNhbnZhcylcblx0X2RyYXdDb29yZHM6IGZ1bmN0aW9uKGNvbnRleHQsIGNvb3Jkcykge1xuXHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0Y29udGV4dC5tb3ZlVG8oY29vcmRzWzBdLCBjb29yZHNbMV0pO1xuXHRcdGNvbnRleHQubGluZVRvKGNvb3Jkc1syXSwgY29vcmRzWzNdKTtcblx0XHRjb250ZXh0LmxpbmVUbyhjb29yZHNbNF0sIGNvb3Jkc1s1XSk7XG5cdFx0Y29udGV4dC5jbG9zZVBhdGgoKTtcblx0fSxcblxuXHRjcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIERldGVybWluZSB0aXAgY29ybmVyXG5cdFx0dmFyIGMgPSB0aGlzLmNvcm5lciA9IChIQVNDQU5WQVMgfHwgQlJPV1NFUi5pZSkgJiYgdGhpcy5fcGFyc2VDb3JuZXIodGhpcy5vcHRpb25zLmNvcm5lcik7XG5cdFx0XG5cdFx0Ly8gSWYgd2UgaGF2ZSBhIHRpcCBjb3JuZXIuLi5cblx0XHRpZiggKHRoaXMuZW5hYmxlZCA9ICEhdGhpcy5jb3JuZXIgJiYgdGhpcy5jb3JuZXIuYWJicmV2KCkgIT09ICdjJykgKSB7XG5cdFx0XHQvLyBDYWNoZSBpdFxuXHRcdFx0dGhpcy5xdGlwLmNhY2hlLmNvcm5lciA9IGMuY2xvbmUoKTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGl0XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdC8vIFRvZ2dsZSB0aXAgZWxlbWVudFxuXHRcdHRoaXMuZWxlbWVudC50b2dnbGUodGhpcy5lbmFibGVkKTtcblxuXHRcdHJldHVybiB0aGlzLmNvcm5lcjtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNvcm5lciwgcG9zaXRpb24pIHtcblx0XHRpZighdGhpcy5lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR2YXIgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXG5cdFx0XHR0aXAgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRpbm5lciA9IHRpcC5jaGlsZHJlbigpLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGN1clNpemUgPSB0aGlzLnNpemUsXG5cdFx0XHRtaW1pYyA9IG9wdGlvbnMubWltaWMsXG5cdFx0XHRyb3VuZCA9IE1hdGgucm91bmQsXG5cdFx0XHRjb2xvciwgcHJlY2VkYW5jZSwgY29udGV4dCxcblx0XHRcdGNvb3JkcywgYmlnQ29vcmRzLCB0cmFuc2xhdGUsIG5ld1NpemUsIGJvcmRlciwgQkFDS0lOR19TVE9SRV9SQVRJTztcblxuXHRcdC8vIFJlLWRldGVybWluZSB0aXAgaWYgbm90IGFscmVhZHkgc2V0XG5cdFx0aWYoIWNvcm5lcikgeyBjb3JuZXIgPSB0aGlzLnF0aXAuY2FjaGUuY29ybmVyIHx8IHRoaXMuY29ybmVyOyB9XG5cblx0XHQvLyBVc2UgY29ybmVyIHByb3BlcnR5IGlmIHdlIGRldGVjdCBhbiBpbnZhbGlkIG1pbWljIHZhbHVlXG5cdFx0aWYobWltaWMgPT09IEZBTFNFKSB7IG1pbWljID0gY29ybmVyOyB9XG5cblx0XHQvLyBPdGhlcndpc2UgaW5oZXJpdCBtaW1pYyBwcm9wZXJ0aWVzIGZyb20gdGhlIGNvcm5lciBvYmplY3QgYXMgbmVjZXNzYXJ5XG5cdFx0ZWxzZSB7XG5cdFx0XHRtaW1pYyA9IG5ldyBDT1JORVIobWltaWMpO1xuXHRcdFx0bWltaWMucHJlY2VkYW5jZSA9IGNvcm5lci5wcmVjZWRhbmNlO1xuXG5cdFx0XHRpZihtaW1pYy54ID09PSAnaW5oZXJpdCcpIHsgbWltaWMueCA9IGNvcm5lci54OyB9XG5cdFx0XHRlbHNlIGlmKG1pbWljLnkgPT09ICdpbmhlcml0JykgeyBtaW1pYy55ID0gY29ybmVyLnk7IH1cblx0XHRcdGVsc2UgaWYobWltaWMueCA9PT0gbWltaWMueSkge1xuXHRcdFx0XHRtaW1pY1sgY29ybmVyLnByZWNlZGFuY2UgXSA9IGNvcm5lclsgY29ybmVyLnByZWNlZGFuY2UgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cHJlY2VkYW5jZSA9IG1pbWljLnByZWNlZGFuY2U7XG5cblx0XHQvLyBFbnN1cmUgdGhlIHRpcCB3aWR0aC5oZWlnaHQgYXJlIHJlbGF0aXZlIHRvIHRoZSB0aXAgcG9zaXRpb25cblx0XHRpZihjb3JuZXIucHJlY2VkYW5jZSA9PT0gWCkgeyB0aGlzLl9zd2FwRGltZW5zaW9ucygpOyB9XG5cdFx0ZWxzZSB7IHRoaXMuX3Jlc2V0RGltZW5zaW9ucygpOyB9XG5cblx0XHQvLyBVcGRhdGUgb3VyIGNvbG91cnNcblx0XHRjb2xvciA9IHRoaXMuY29sb3IgPSB0aGlzLl9wYXJzZUNvbG91cnMoY29ybmVyKTtcblxuXHRcdC8vIERldGVjdCBib3JkZXIgd2lkdGgsIHRha2luZyBpbnRvIGFjY291bnQgY29sb3Vyc1xuXHRcdGlmKGNvbG9yWzFdICE9PSBUUkFOU1BBUkVOVCkge1xuXHRcdFx0Ly8gR3JhYiBib3JkZXIgd2lkdGhcblx0XHRcdGJvcmRlciA9IHRoaXMuYm9yZGVyID0gdGhpcy5fcGFyc2VXaWR0aChjb3JuZXIsIGNvcm5lcltjb3JuZXIucHJlY2VkYW5jZV0pO1xuXG5cdFx0XHQvLyBJZiBib3JkZXIgd2lkdGggaXNuJ3QgemVybywgdXNlIGJvcmRlciBjb2xvciBhcyBmaWxsIGlmIGl0J3Mgbm90IGludmFsaWQgKDEuMCBzdHlsZSB0aXBzKVxuXHRcdFx0aWYob3B0aW9ucy5ib3JkZXIgJiYgYm9yZGVyIDwgMSAmJiAhSU5WQUxJRC50ZXN0KGNvbG9yWzFdKSkgeyBjb2xvclswXSA9IGNvbG9yWzFdOyB9XG5cblx0XHRcdC8vIFNldCBib3JkZXIgd2lkdGggKHVzZSBkZXRlY3RlZCBib3JkZXIgd2lkdGggaWYgb3B0aW9ucy5ib3JkZXIgaXMgdHJ1ZSlcblx0XHRcdHRoaXMuYm9yZGVyID0gYm9yZGVyID0gb3B0aW9ucy5ib3JkZXIgIT09IFRSVUUgPyBvcHRpb25zLmJvcmRlciA6IGJvcmRlcjtcblx0XHR9XG5cblx0XHQvLyBCb3JkZXIgY29sb3VyIHdhcyBpbnZhbGlkLCBzZXQgYm9yZGVyIHRvIHplcm9cblx0XHRlbHNlIHsgdGhpcy5ib3JkZXIgPSBib3JkZXIgPSAwOyB9XG5cblx0XHQvLyBEZXRlcm1pbmUgdGlwIHNpemVcblx0XHRuZXdTaXplID0gdGhpcy5zaXplID0gdGhpcy5fY2FsY3VsYXRlU2l6ZShjb3JuZXIpO1xuXHRcdHRpcC5jc3Moe1xuXHRcdFx0d2lkdGg6IG5ld1NpemVbMF0sXG5cdFx0XHRoZWlnaHQ6IG5ld1NpemVbMV0sXG5cdFx0XHRsaW5lSGVpZ2h0OiBuZXdTaXplWzFdKydweCdcblx0XHR9KTtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aXAgdHJhbnNsYXRpb25cblx0XHRpZihjb3JuZXIucHJlY2VkYW5jZSA9PT0gWSkge1xuXHRcdFx0dHJhbnNsYXRlID0gW1xuXHRcdFx0XHRyb3VuZChtaW1pYy54ID09PSBMRUZUID8gYm9yZGVyIDogbWltaWMueCA9PT0gUklHSFQgPyBuZXdTaXplWzBdIC0gY3VyU2l6ZVswXSAtIGJvcmRlciA6IChuZXdTaXplWzBdIC0gY3VyU2l6ZVswXSkgLyAyKSxcblx0XHRcdFx0cm91bmQobWltaWMueSA9PT0gVE9QID8gbmV3U2l6ZVsxXSAtIGN1clNpemVbMV0gOiAwKVxuXHRcdFx0XTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0cmFuc2xhdGUgPSBbXG5cdFx0XHRcdHJvdW5kKG1pbWljLnggPT09IExFRlQgPyBuZXdTaXplWzBdIC0gY3VyU2l6ZVswXSA6IDApLFxuXHRcdFx0XHRyb3VuZChtaW1pYy55ID09PSBUT1AgPyBib3JkZXIgOiBtaW1pYy55ID09PSBCT1RUT00gPyBuZXdTaXplWzFdIC0gY3VyU2l6ZVsxXSAtIGJvcmRlciA6IChuZXdTaXplWzFdIC0gY3VyU2l6ZVsxXSkgLyAyKVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHQvLyBDYW52YXMgZHJhd2luZyBpbXBsZW1lbnRhdGlvblxuXHRcdGlmKEhBU0NBTlZBUykge1xuXHRcdFx0Ly8gR3JhYiBjYW52YXMgY29udGV4dCBhbmQgY2xlYXIvc2F2ZSBpdFxuXHRcdFx0Y29udGV4dCA9IGlubmVyWzBdLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHRjb250ZXh0LnJlc3RvcmUoKTsgY29udGV4dC5zYXZlKCk7XG5cdFx0XHRjb250ZXh0LmNsZWFyUmVjdCgwLDAsNjAwMCw2MDAwKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGNvb3JkaW5hdGVzXG5cdFx0XHRjb29yZHMgPSB0aGlzLl9jYWxjdWxhdGVUaXAobWltaWMsIGN1clNpemUsIFNDQUxFKTtcblx0XHRcdGJpZ0Nvb3JkcyA9IHRoaXMuX2NhbGN1bGF0ZVRpcChtaW1pYywgdGhpcy5zaXplLCBTQ0FMRSk7XG5cblx0XHRcdC8vIFNldCB0aGUgY2FudmFzIHNpemUgdXNpbmcgY2FsY3VsYXRlZCBzaXplXG5cdFx0XHRpbm5lci5hdHRyKFdJRFRILCBuZXdTaXplWzBdICogU0NBTEUpLmF0dHIoSEVJR0hULCBuZXdTaXplWzFdICogU0NBTEUpO1xuXHRcdFx0aW5uZXIuY3NzKFdJRFRILCBuZXdTaXplWzBdKS5jc3MoSEVJR0hULCBuZXdTaXplWzFdKTtcblxuXHRcdFx0Ly8gRHJhdyB0aGUgb3V0ZXItc3Ryb2tlIHRpcFxuXHRcdFx0dGhpcy5fZHJhd0Nvb3Jkcyhjb250ZXh0LCBiaWdDb29yZHMpO1xuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBjb2xvclsxXTtcblx0XHRcdGNvbnRleHQuZmlsbCgpO1xuXG5cdFx0XHQvLyBEcmF3IHRoZSBhY3R1YWwgdGlwXG5cdFx0XHRjb250ZXh0LnRyYW5zbGF0ZSh0cmFuc2xhdGVbMF0gKiBTQ0FMRSwgdHJhbnNsYXRlWzFdICogU0NBTEUpO1xuXHRcdFx0dGhpcy5fZHJhd0Nvb3Jkcyhjb250ZXh0LCBjb29yZHMpO1xuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBjb2xvclswXTtcblx0XHRcdGNvbnRleHQuZmlsbCgpO1xuXHRcdH1cblxuXHRcdC8vIFZNTCAoSUUgUHJvcHJpZXRhcnkgaW1wbGVtZW50YXRpb24pXG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZXNcblx0XHRcdGNvb3JkcyA9IHRoaXMuX2NhbGN1bGF0ZVRpcChtaW1pYyk7XG5cblx0XHRcdC8vIFNldHVwIGNvb3JkaW5hdGVzIHN0cmluZ1xuXHRcdFx0Y29vcmRzID0gJ20nICsgY29vcmRzWzBdICsgJywnICsgY29vcmRzWzFdICsgJyBsJyArIGNvb3Jkc1syXSArXG5cdFx0XHRcdCcsJyArIGNvb3Jkc1szXSArICcgJyArIGNvb3Jkc1s0XSArICcsJyArIGNvb3Jkc1s1XSArICcgeGUnO1xuXG5cdFx0XHQvLyBTZXR1cCBWTUwtc3BlY2lmaWMgb2Zmc2V0IGZvciBwaXhlbC1wZXJmZWN0aW9uXG5cdFx0XHR0cmFuc2xhdGVbMl0gPSBib3JkZXIgJiYgL14ocnxiKS9pLnRlc3QoY29ybmVyLnN0cmluZygpKSA/XG5cdFx0XHRcdEJST1dTRVIuaWUgPT09IDggPyAyIDogMSA6IDA7XG5cblx0XHRcdC8vIFNldCBpbml0aWFsIENTU1xuXHRcdFx0aW5uZXIuY3NzKHtcblx0XHRcdFx0Y29vcmRzaXplOiAobmV3U2l6ZVswXStib3JkZXIpICsgJyAnICsgKG5ld1NpemVbMV0rYm9yZGVyKSxcblx0XHRcdFx0YW50aWFsaWFzOiAnJysobWltaWMuc3RyaW5nKCkuaW5kZXhPZihDRU5URVIpID4gLTEpLFxuXHRcdFx0XHRsZWZ0OiB0cmFuc2xhdGVbMF0gLSAodHJhbnNsYXRlWzJdICogTnVtYmVyKHByZWNlZGFuY2UgPT09IFgpKSxcblx0XHRcdFx0dG9wOiB0cmFuc2xhdGVbMV0gLSAodHJhbnNsYXRlWzJdICogTnVtYmVyKHByZWNlZGFuY2UgPT09IFkpKSxcblx0XHRcdFx0d2lkdGg6IG5ld1NpemVbMF0gKyBib3JkZXIsXG5cdFx0XHRcdGhlaWdodDogbmV3U2l6ZVsxXSArIGJvcmRlclxuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblxuXHRcdFx0XHQvLyBTZXQgc2hhcGUgc3BlY2lmaWMgYXR0cmlidXRlc1xuXHRcdFx0XHQkdGhpc1sgJHRoaXMucHJvcCA/ICdwcm9wJyA6ICdhdHRyJyBdKHtcblx0XHRcdFx0XHRjb29yZHNpemU6IChuZXdTaXplWzBdK2JvcmRlcikgKyAnICcgKyAobmV3U2l6ZVsxXStib3JkZXIpLFxuXHRcdFx0XHRcdHBhdGg6IGNvb3Jkcyxcblx0XHRcdFx0XHRmaWxsY29sb3I6IGNvbG9yWzBdLFxuXHRcdFx0XHRcdGZpbGxlZDogISFpLFxuXHRcdFx0XHRcdHN0cm9rZWQ6ICFpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50b2dnbGUoISEoYm9yZGVyIHx8IGkpKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiBib3JkZXIgaXMgZW5hYmxlZCBhbmQgYWRkIHN0cm9rZSBlbGVtZW50XG5cdFx0XHRcdCFpICYmICR0aGlzLmh0bWwoIGNyZWF0ZVZNTChcblx0XHRcdFx0XHQnc3Ryb2tlJywgJ3dlaWdodD1cIicrKGJvcmRlcioyKSsncHhcIiBjb2xvcj1cIicrY29sb3JbMV0rJ1wiIG1pdGVybGltaXQ9XCIxMDAwXCIgam9pbnN0eWxlPVwibWl0ZXJcIidcblx0XHRcdFx0KSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlcmEgYnVnICMzNTcgLSBJbmNvcnJlY3QgdGlwIHBvc2l0aW9uXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0NyYWdhODkvcVRpcDIvaXNzdWVzLzM2N1xuXHRcdHdpbmRvdy5vcGVyYSAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0ZWxlbWVudHMudGlwLmNzcyh7XG5cdFx0XHRcdGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuXHRcdFx0XHR2aXNpYmlsaXR5OiAndmlzaWJsZSdcblx0XHRcdH0pO1xuXHRcdH0sIDEpO1xuXG5cdFx0Ly8gUG9zaXRpb24gaWYgbmVlZGVkXG5cdFx0aWYocG9zaXRpb24gIT09IEZBTFNFKSB7IHRoaXMuY2FsY3VsYXRlKGNvcm5lciwgbmV3U2l6ZSk7IH1cblx0fSxcblxuXHRjYWxjdWxhdGU6IGZ1bmN0aW9uKGNvcm5lciwgc2l6ZSkge1xuXHRcdGlmKCF0aGlzLmVuYWJsZWQpIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcblx0XHRcdHRpcCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHVzZXJPZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0LFxuXHRcdFx0aXNXaWRnZXQgPSBlbGVtZW50cy50b29sdGlwLmhhc0NsYXNzKCd1aS13aWRnZXQnKSxcblx0XHRcdHBvc2l0aW9uID0geyAgfSxcblx0XHRcdHByZWNlZGFuY2UsIGNvcm5lcnM7XG5cblx0XHQvLyBJbmhlcml0IGNvcm5lciBpZiBub3QgcHJvdmlkZWRcblx0XHRjb3JuZXIgPSBjb3JuZXIgfHwgdGhpcy5jb3JuZXI7XG5cdFx0cHJlY2VkYW5jZSA9IGNvcm5lci5wcmVjZWRhbmNlO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIHdoaWNoIHRpcCBkaW1lbnNpb24gdG8gdXNlIGZvciBhZGp1c3RtZW50XG5cdFx0c2l6ZSA9IHNpemUgfHwgdGhpcy5fY2FsY3VsYXRlU2l6ZShjb3JuZXIpO1xuXG5cdFx0Ly8gU2V0dXAgY29ybmVycyBhbmQgb2Zmc2V0IGFycmF5XG5cdFx0Y29ybmVycyA9IFsgY29ybmVyLngsIGNvcm5lci55IF07XG5cdFx0aWYocHJlY2VkYW5jZSA9PT0gWCkgeyBjb3JuZXJzLnJldmVyc2UoKTsgfVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRpcCBwb3NpdGlvblxuXHRcdCQuZWFjaChjb3JuZXJzLCBmdW5jdGlvbihpLCBzaWRlKSB7XG5cdFx0XHR2YXIgYiwgYmMsIGJyO1xuXG5cdFx0XHRpZihzaWRlID09PSBDRU5URVIpIHtcblx0XHRcdFx0YiA9IHByZWNlZGFuY2UgPT09IFkgPyBMRUZUIDogVE9QO1xuXHRcdFx0XHRwb3NpdGlvblsgYiBdID0gJzUwJSc7XG5cdFx0XHRcdHBvc2l0aW9uW01BUkdJTisnLScgKyBiXSA9IC1NYXRoLnJvdW5kKHNpemVbIHByZWNlZGFuY2UgPT09IFkgPyAwIDogMSBdIC8gMikgKyB1c2VyT2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGIgPSBzZWxmLl9wYXJzZVdpZHRoKGNvcm5lciwgc2lkZSwgZWxlbWVudHMudG9vbHRpcCk7XG5cdFx0XHRcdGJjID0gc2VsZi5fcGFyc2VXaWR0aChjb3JuZXIsIHNpZGUsIGVsZW1lbnRzLmNvbnRlbnQpO1xuXHRcdFx0XHRiciA9IHNlbGYuX3BhcnNlUmFkaXVzKGNvcm5lcik7XG5cblx0XHRcdFx0cG9zaXRpb25bIHNpZGUgXSA9IE1hdGgubWF4KC1zZWxmLmJvcmRlciwgaSA/IGJjIDogKHVzZXJPZmZzZXQgKyAoYnIgPiBiID8gYnIgOiAtYikpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEFkanVzdCBmb3IgdGlwIHNpemVcblx0XHRwb3NpdGlvblsgY29ybmVyW3ByZWNlZGFuY2VdIF0gLT0gc2l6ZVsgcHJlY2VkYW5jZSA9PT0gWCA/IDAgOiAxIF07XG5cblx0XHQvLyBTZXQgYW5kIHJldHVybiBuZXcgcG9zaXRpb25cblx0XHR0aXAuY3NzKHsgbWFyZ2luOiAnJywgdG9wOiAnJywgYm90dG9tOiAnJywgbGVmdDogJycsIHJpZ2h0OiAnJyB9KS5jc3MocG9zaXRpb24pO1xuXHRcdHJldHVybiBwb3NpdGlvbjtcblx0fSxcblxuXHRyZXBvc2l0aW9uOiBmdW5jdGlvbihldmVudCwgYXBpLCBwb3MsIHZpZXdwb3J0KSB7XG5cdFx0aWYoIXRoaXMuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBjYWNoZSA9IGFwaS5jYWNoZSxcblx0XHRcdG5ld0Nvcm5lciA9IHRoaXMuY29ybmVyLmNsb25lKCksXG5cdFx0XHRhZGp1c3QgPSBwb3MuYWRqdXN0ZWQsXG5cdFx0XHRtZXRob2QgPSBhcGkub3B0aW9ucy5wb3NpdGlvbi5hZGp1c3QubWV0aG9kLnNwbGl0KCcgJyksXG5cdFx0XHRob3Jpem9udGFsID0gbWV0aG9kWzBdLFxuXHRcdFx0dmVydGljYWwgPSBtZXRob2RbMV0gfHwgbWV0aG9kWzBdLFxuXHRcdFx0c2hpZnQgPSB7IGxlZnQ6IEZBTFNFLCB0b3A6IEZBTFNFLCB4OiAwLCB5OiAwIH0sXG5cdFx0XHRvZmZzZXQsIGNzcyA9IHt9LCBwcm9wcztcblxuXHRcdGZ1bmN0aW9uIHNoaWZ0ZmxpcChkaXJlY3Rpb24sIHByZWNlZGFuY2UsIHBvcHBvc2l0ZSwgc2lkZSwgb3Bwb3NpdGUpIHtcblx0XHRcdC8vIEhvcml6b250YWwgLSBTaGlmdCBvciBmbGlwIG1ldGhvZFxuXHRcdFx0aWYoZGlyZWN0aW9uID09PSBTSElGVCAmJiBuZXdDb3JuZXIucHJlY2VkYW5jZSA9PT0gcHJlY2VkYW5jZSAmJiBhZGp1c3Rbc2lkZV0gJiYgbmV3Q29ybmVyW3BvcHBvc2l0ZV0gIT09IENFTlRFUikge1xuXHRcdFx0XHRuZXdDb3JuZXIucHJlY2VkYW5jZSA9IG5ld0Nvcm5lci5wcmVjZWRhbmNlID09PSBYID8gWSA6IFg7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGRpcmVjdGlvbiAhPT0gU0hJRlQgJiYgYWRqdXN0W3NpZGVdKXtcblx0XHRcdFx0bmV3Q29ybmVyW3ByZWNlZGFuY2VdID0gbmV3Q29ybmVyW3ByZWNlZGFuY2VdID09PSBDRU5URVIgPyBcblx0XHRcdFx0XHQoYWRqdXN0W3NpZGVdID4gMCA/IHNpZGUgOiBvcHBvc2l0ZSkgOiAobmV3Q29ybmVyW3ByZWNlZGFuY2VdID09PSBzaWRlID8gb3Bwb3NpdGUgOiBzaWRlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaGlmdG9ubHkoeHksIHNpZGUsIG9wcG9zaXRlKSB7XG5cdFx0XHRpZihuZXdDb3JuZXJbeHldID09PSBDRU5URVIpIHtcblx0XHRcdFx0Y3NzW01BUkdJTisnLScrc2lkZV0gPSBzaGlmdFt4eV0gPSBvZmZzZXRbTUFSR0lOKyctJytzaWRlXSAtIGFkanVzdFtzaWRlXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRwcm9wcyA9IG9mZnNldFtvcHBvc2l0ZV0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0WyBhZGp1c3Rbc2lkZV0sIC1vZmZzZXRbc2lkZV0gXSA6IFsgLWFkanVzdFtzaWRlXSwgb2Zmc2V0W3NpZGVdIF07XG5cblx0XHRcdFx0aWYoIChzaGlmdFt4eV0gPSBNYXRoLm1heChwcm9wc1swXSwgcHJvcHNbMV0pKSA+IHByb3BzWzBdICkge1xuXHRcdFx0XHRcdHBvc1tzaWRlXSAtPSBhZGp1c3Rbc2lkZV07XG5cdFx0XHRcdFx0c2hpZnRbc2lkZV0gPSBGQUxTRTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y3NzWyBvZmZzZXRbb3Bwb3NpdGVdICE9PSB1bmRlZmluZWQgPyBvcHBvc2l0ZSA6IHNpZGUgXSA9IHNoaWZ0W3h5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiBvdXIgdGlwIHBvc2l0aW9uIGlzbid0IGZpeGVkIGUuZy4gZG9lc24ndCBhZGp1c3Qgd2l0aCB2aWV3cG9ydC4uLlxuXHRcdGlmKHRoaXMuY29ybmVyLmZpeGVkICE9PSBUUlVFKSB7XG5cdFx0XHQvLyBQZXJmb3JtIHNoaWZ0L2ZsaXAgYWRqdXN0bWVudHNcblx0XHRcdHNoaWZ0ZmxpcChob3Jpem9udGFsLCBYLCBZLCBMRUZULCBSSUdIVCk7XG5cdFx0XHRzaGlmdGZsaXAodmVydGljYWwsIFksIFgsIFRPUCwgQk9UVE9NKTtcblxuXHRcdFx0Ly8gVXBkYXRlIGFuZCByZWRyYXcgdGhlIHRpcCBpZiBuZWVkZWQgKGNoZWNrIGNhY2hlZCBkZXRhaWxzIG9mIGxhc3QgZHJhd24gdGlwKVxuXHRcdFx0aWYobmV3Q29ybmVyLnN0cmluZygpICE9PSBjYWNoZS5jb3JuZXIuc3RyaW5nKCkgJiYgKGNhY2hlLmNvcm5lclRvcCAhPT0gYWRqdXN0LnRvcCB8fCBjYWNoZS5jb3JuZXJMZWZ0ICE9PSBhZGp1c3QubGVmdCkpIHtcblx0XHRcdFx0dGhpcy51cGRhdGUobmV3Q29ybmVyLCBGQUxTRSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgdGlwIG9mZnNldCBwcm9wZXJ0aWVzXG5cdFx0b2Zmc2V0ID0gdGhpcy5jYWxjdWxhdGUobmV3Q29ybmVyKTtcblxuXHRcdC8vIFJlYWRqdXN0IG9mZnNldCBvYmplY3QgdG8gbWFrZSBpdCBsZWZ0L3RvcFxuXHRcdGlmKG9mZnNldC5yaWdodCAhPT0gdW5kZWZpbmVkKSB7IG9mZnNldC5sZWZ0ID0gLW9mZnNldC5yaWdodDsgfVxuXHRcdGlmKG9mZnNldC5ib3R0b20gIT09IHVuZGVmaW5lZCkgeyBvZmZzZXQudG9wID0gLW9mZnNldC5ib3R0b207IH1cblx0XHRvZmZzZXQudXNlciA9IHRoaXMub2Zmc2V0O1xuXG5cdFx0Ly8gUGVyZm9ybSBzaGlmdCBhZGp1c3RtZW50c1xuXHRcdGlmKHNoaWZ0LmxlZnQgPSAoaG9yaXpvbnRhbCA9PT0gU0hJRlQgJiYgISFhZGp1c3QubGVmdCkpIHsgc2hpZnRvbmx5KFgsIExFRlQsIFJJR0hUKTsgfVxuXHRcdGlmKHNoaWZ0LnRvcCA9ICh2ZXJ0aWNhbCA9PT0gU0hJRlQgJiYgISFhZGp1c3QudG9wKSkgeyBzaGlmdG9ubHkoWSwgVE9QLCBCT1RUT00pOyB9XG5cblx0XHQvKlxuXHRcdCogSWYgdGhlIHRpcCBpcyBhZGp1c3RlZCBpbiBib3RoIGRpbWVuc2lvbnMsIG9yIGluIGFcblx0XHQqIGRpcmVjdGlvbiB0aGF0IHdvdWxkIGNhdXNlIGl0IHRvIGJlIGFueXdoZXJlIGJ1dCB0aGVcblx0XHQqIG91dGVyIGJvcmRlciwgaGlkZSBpdCFcblx0XHQqL1xuXHRcdHRoaXMuZWxlbWVudC5jc3MoY3NzKS50b2dnbGUoXG5cdFx0XHQhKChzaGlmdC54ICYmIHNoaWZ0LnkpIHx8IChuZXdDb3JuZXIueCA9PT0gQ0VOVEVSICYmIHNoaWZ0LnkpIHx8IChuZXdDb3JuZXIueSA9PT0gQ0VOVEVSICYmIHNoaWZ0LngpKVxuXHRcdCk7XG5cblx0XHQvLyBBZGp1c3QgcG9zaXRpb24gdG8gYWNjb21vZGF0ZSB0aXAgZGltZW5zaW9uc1xuXHRcdHBvcy5sZWZ0IC09IG9mZnNldC5sZWZ0LmNoYXJBdCA/IG9mZnNldC51c2VyIDogXG5cdFx0XHRob3Jpem9udGFsICE9PSBTSElGVCB8fCBzaGlmdC50b3AgfHwgIXNoaWZ0LmxlZnQgJiYgIXNoaWZ0LnRvcCA/IG9mZnNldC5sZWZ0ICsgdGhpcy5ib3JkZXIgOiAwO1xuXHRcdHBvcy50b3AgLT0gb2Zmc2V0LnRvcC5jaGFyQXQgPyBvZmZzZXQudXNlciA6IFxuXHRcdFx0dmVydGljYWwgIT09IFNISUZUIHx8IHNoaWZ0LmxlZnQgfHwgIXNoaWZ0LmxlZnQgJiYgIXNoaWZ0LnRvcCA/IG9mZnNldC50b3AgKyB0aGlzLmJvcmRlciA6IDA7XG5cblx0XHQvLyBDYWNoZSBkZXRhaWxzXG5cdFx0Y2FjaGUuY29ybmVyTGVmdCA9IGFkanVzdC5sZWZ0OyBjYWNoZS5jb3JuZXJUb3AgPSBhZGp1c3QudG9wO1xuXHRcdGNhY2hlLmNvcm5lciA9IG5ld0Nvcm5lci5jbG9uZSgpO1xuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFVuYmluZCBldmVudHNcblx0XHR0aGlzLnF0aXAuX3VuYmluZCh0aGlzLnF0aXAudG9vbHRpcCwgdGhpcy5fbnMpO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSB0aXAgZWxlbWVudChzKVxuXHRcdGlmKHRoaXMucXRpcC5lbGVtZW50cy50aXApIHtcblx0XHRcdHRoaXMucXRpcC5lbGVtZW50cy50aXAuZmluZCgnKicpXG5cdFx0XHRcdC5yZW1vdmUoKS5lbmQoKS5yZW1vdmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5USVAgPSBQTFVHSU5TLnRpcCA9IGZ1bmN0aW9uKGFwaSkge1xuXHRyZXR1cm4gbmV3IFRpcChhcGksIGFwaS5vcHRpb25zLnN0eWxlLnRpcCk7XG59O1xuXG4vLyBJbml0aWFsaXplIHRpcCBvbiByZW5kZXJcblRJUC5pbml0aWFsaXplID0gJ3JlbmRlcic7XG5cbi8vIFNldHVwIHBsdWdpbiBzYW5pdGl6YXRpb24gb3B0aW9uc1xuVElQLnNhbml0aXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRpZihvcHRpb25zLnN0eWxlICYmICd0aXAnIGluIG9wdGlvbnMuc3R5bGUpIHtcblx0XHR2YXIgb3B0cyA9IG9wdGlvbnMuc3R5bGUudGlwO1xuXHRcdGlmKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JykgeyBvcHRzID0gb3B0aW9ucy5zdHlsZS50aXAgPSB7IGNvcm5lcjogb3B0cyB9OyB9XG5cdFx0aWYoISgvc3RyaW5nfGJvb2xlYW4vaSkudGVzdCh0eXBlb2Ygb3B0cy5jb3JuZXIpKSB7IG9wdHMuY29ybmVyID0gVFJVRTsgfVxuXHR9XG59O1xuXG4vLyBBZGQgbmV3IG9wdGlvbiBjaGVja3MgZm9yIHRoZSBwbHVnaW5cbkNIRUNLUy50aXAgPSB7XG5cdCdecG9zaXRpb24ubXl8c3R5bGUudGlwLihjb3JuZXJ8bWltaWN8Ym9yZGVyKSQnOiBmdW5jdGlvbigpIHtcblx0XHQvLyBNYWtlIHN1cmUgYSB0aXAgY2FuIGJlIGRyYXduXG5cdFx0dGhpcy5jcmVhdGUoKTtcblx0XHRcblx0XHQvLyBSZXBvc2l0aW9uIHRoZSB0b29sdGlwXG5cdFx0dGhpcy5xdGlwLnJlcG9zaXRpb24oKTtcblx0fSxcblx0J15zdHlsZS50aXAuKGhlaWdodHx3aWR0aCkkJzogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Ly8gUmUtc2V0IGRpbWVuc2lvbnMgYW5kIHJlZHJhdyB0aGUgdGlwXG5cdFx0dGhpcy5zaXplID0gWyBvYmoud2lkdGgsIG9iai5oZWlnaHQgXTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0Ly8gUmVwb3NpdGlvbiB0aGUgdG9vbHRpcFxuXHRcdHRoaXMucXRpcC5yZXBvc2l0aW9uKCk7XG5cdH0sXG5cdCdeY29udGVudC50aXRsZXxzdHlsZS4oY2xhc3Nlc3x3aWRnZXQpJCc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH1cbn07XG5cbi8vIEV4dGVuZCBvcmlnaW5hbCBxVGlwIGRlZmF1bHRzXG4kLmV4dGVuZChUUlVFLCBRVElQLmRlZmF1bHRzLCB7XG5cdHN0eWxlOiB7XG5cdFx0dGlwOiB7XG5cdFx0XHRjb3JuZXI6IFRSVUUsXG5cdFx0XHRtaW1pYzogRkFMU0UsXG5cdFx0XHR3aWR0aDogNixcblx0XHRcdGhlaWdodDogNixcblx0XHRcdGJvcmRlcjogVFJVRSxcblx0XHRcdG9mZnNldDogMFxuXHRcdH1cblx0fVxufSk7XG5cbjt2YXIgTU9EQUwsIE9WRVJMQVksXG5cdE1PREFMQ0xBU1MgPSAncXRpcC1tb2RhbCcsXG5cdE1PREFMU0VMRUNUT1IgPSAnLicrTU9EQUxDTEFTUztcblxuT1ZFUkxBWSA9IGZ1bmN0aW9uKClcbntcblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdGZvY3VzYWJsZUVsZW1zID0ge30sXG5cdFx0Y3VycmVudCwgb25MYXN0LFxuXHRcdHByZXZTdGF0ZSwgZWxlbTtcblxuXHQvLyBNb2RpZmllZCBjb2RlIGZyb20galF1ZXJ5IFVJIDEuMTAuMCBzb3VyY2Vcblx0Ly8gaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS91aS8xLjEwLjAvanF1ZXJ5LXVpLmpzXG5cdGZ1bmN0aW9uIGZvY3VzYWJsZShlbGVtZW50KSB7XG5cdFx0Ly8gVXNlIHRoZSBkZWZpbmVkIGZvY3VzYWJsZSBjaGVja2VyIHdoZW4gcG9zc2libGVcblx0XHRpZigkLmV4cHJbJzonXS5mb2N1c2FibGUpIHsgcmV0dXJuICQuZXhwclsnOiddLmZvY3VzYWJsZTsgfVxuXG5cdFx0dmFyIGlzVGFiSW5kZXhOb3ROYU4gPSAhaXNOYU4oJC5hdHRyKGVsZW1lbnQsICd0YWJpbmRleCcpKSxcblx0XHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRtYXAsIG1hcE5hbWUsIGltZztcblxuXHRcdGlmKCdhcmVhJyA9PT0gbm9kZU5hbWUpIHtcblx0XHRcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRcdG1hcE5hbWUgPSBtYXAubmFtZTtcblx0XHRcdGlmKCFlbGVtZW50LmhyZWYgfHwgIW1hcE5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdtYXAnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGltZyA9ICQoJ2ltZ1t1c2VtYXA9IycgKyBtYXBOYW1lICsgJ10nKVswXTtcblx0XHRcdHJldHVybiAhIWltZyAmJiBpbWcuaXMoJzp2aXNpYmxlJyk7XG5cdFx0fVxuXHRcdHJldHVybiAoL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0Ly50ZXN0KCBub2RlTmFtZSApID9cblx0XHRcdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFx0XHQnYScgPT09IG5vZGVOYW1lID8gXG5cdFx0XHRcdFx0ZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOiBcblx0XHRcdFx0XHRpc1RhYkluZGV4Tm90TmFOXG5cdFx0XHQpO1xuXHR9XG5cblx0Ly8gRm9jdXMgaW5wdXRzIHVzaW5nIGNhY2hlZCBmb2N1c2FibGUgZWxlbWVudHMgKHNlZSB1cGRhdGUoKSlcblx0ZnVuY3Rpb24gZm9jdXNJbnB1dHMoYmx1ckVsZW1zKSB7XG5cdFx0Ly8gQmx1cnJpbmcgYm9keSBlbGVtZW50IGluIElFIGNhdXNlcyB3aW5kb3cub3BlbiB3aW5kb3dzIHRvIHVuZm9jdXMhXG5cdFx0aWYoZm9jdXNhYmxlRWxlbXMubGVuZ3RoIDwgMSAmJiBibHVyRWxlbXMubGVuZ3RoKSB7IGJsdXJFbGVtcy5ub3QoJ2JvZHknKS5ibHVyKCk7IH1cblxuXHRcdC8vIEZvY3VzIHRoZSBpbnB1dHNcblx0XHRlbHNlIHsgZm9jdXNhYmxlRWxlbXMuZmlyc3QoKS5mb2N1cygpOyB9XG5cdH1cblxuXHQvLyBTdGVhbCBmb2N1cyBmcm9tIGVsZW1lbnRzIG91dHNpZGUgdG9vbHRpcFxuXHRmdW5jdGlvbiBzdGVhbEZvY3VzKGV2ZW50KSB7XG5cdFx0aWYoIWVsZW0uaXMoJzp2aXNpYmxlJykpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgdGFyZ2V0ID0gJChldmVudC50YXJnZXQpLFxuXHRcdFx0dG9vbHRpcCA9IGN1cnJlbnQudG9vbHRpcCxcblx0XHRcdGNvbnRhaW5lciA9IHRhcmdldC5jbG9zZXN0KFNFTEVDVE9SKSxcblx0XHRcdHRhcmdldE9uVG9wO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIGlucHV0IGNvbnRhaW5lciB0YXJnZXQgaXMgYWJvdmUgdGhpc1xuXHRcdHRhcmdldE9uVG9wID0gY29udGFpbmVyLmxlbmd0aCA8IDEgPyBGQUxTRSA6XG5cdFx0XHQocGFyc2VJbnQoY29udGFpbmVyWzBdLnN0eWxlLnpJbmRleCwgMTApID4gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKSk7XG5cblx0XHQvLyBJZiB3ZSdyZSBzaG93aW5nIGEgbW9kYWwsIGJ1dCBmb2N1cyBoYXMgbGFuZGVkIG9uIGFuIGlucHV0IGJlbG93XG5cdFx0Ly8gdGhpcyBtb2RhbCwgZGl2ZXJ0IGZvY3VzIHRvIHRoZSBmaXJzdCB2aXNpYmxlIGlucHV0IGluIHRoaXMgbW9kYWxcblx0XHQvLyBvciBpZiB3ZSBjYW4ndCBmaW5kIG9uZS4uLiB0aGUgdG9vbHRpcCBpdHNlbGZcblx0XHRpZighdGFyZ2V0T25Ub3AgJiYgdGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1IpWzBdICE9PSB0b29sdGlwWzBdKSB7XG5cdFx0XHRmb2N1c0lucHV0cyh0YXJnZXQpO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCB3aGVuIHdlIGxlYXZlIHRoZSBsYXN0IGZvY3VzYWJsZSBlbGVtZW50Li4uXG5cdFx0b25MYXN0ID0gZXZlbnQudGFyZ2V0ID09PSBmb2N1c2FibGVFbGVtc1tmb2N1c2FibGVFbGVtcy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdCQuZXh0ZW5kKHNlbGYsIHtcblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENyZWF0ZSBkb2N1bWVudCBvdmVybGF5XG5cdFx0XHRlbGVtID0gc2VsZi5lbGVtID0gJCgnPGRpdiAvPicsIHtcblx0XHRcdFx0aWQ6ICdxdGlwLW92ZXJsYXknLFxuXHRcdFx0XHRodG1sOiAnPGRpdj48L2Rpdj4nLFxuXHRcdFx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCkgeyByZXR1cm4gRkFMU0U7IH1cblx0XHRcdH0pXG5cdFx0XHQuaGlkZSgpO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgY2FuJ3QgZm9jdXMgYW55dGhpbmcgb3V0c2lkZSB0aGUgdG9vbHRpcFxuXHRcdFx0JChkb2N1bWVudC5ib2R5KS5iaW5kKCdmb2N1c2luJytNT0RBTFNFTEVDVE9SLCBzdGVhbEZvY3VzKTtcblxuXHRcdFx0Ly8gQXBwbHkga2V5Ym9hcmQgXCJFc2NhcGUga2V5XCIgY2xvc2UgaGFuZGxlclxuXHRcdFx0JChkb2N1bWVudCkuYmluZCgna2V5ZG93bicrTU9EQUxTRUxFQ1RPUiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYoY3VycmVudCAmJiBjdXJyZW50Lm9wdGlvbnMuc2hvdy5tb2RhbC5lc2NhcGUgJiYgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdFx0XHRjdXJyZW50LmhpZGUoZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgY2xpY2sgaGFuZGxlciBmb3IgYmx1ciBvcHRpb25cblx0XHRcdGVsZW0uYmluZCgnY2xpY2snK01PREFMU0VMRUNUT1IsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmKGN1cnJlbnQgJiYgY3VycmVudC5vcHRpb25zLnNob3cubW9kYWwuYmx1cikge1xuXHRcdFx0XHRcdGN1cnJlbnQuaGlkZShldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihhcGkpIHtcblx0XHRcdC8vIFVwZGF0ZSBjdXJyZW50IEFQSSByZWZlcmVuY2Vcblx0XHRcdGN1cnJlbnQgPSBhcGk7XG5cblx0XHRcdC8vIFVwZGF0ZSBmb2N1c2FibGUgZWxlbWVudHMgaWYgZW5hYmxlZFxuXHRcdFx0aWYoYXBpLm9wdGlvbnMuc2hvdy5tb2RhbC5zdGVhbGZvY3VzICE9PSBGQUxTRSkge1xuXHRcdFx0XHRmb2N1c2FibGVFbGVtcyA9IGFwaS50b29sdGlwLmZpbmQoJyonKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZvY3VzYWJsZSh0aGlzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgZm9jdXNhYmxlRWxlbXMgPSBbXTsgfVxuXHRcdH0sXG5cblx0XHR0b2dnbGU6IGZ1bmN0aW9uKGFwaSwgc3RhdGUsIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgZG9jQm9keSA9ICQoZG9jdW1lbnQuYm9keSksXG5cdFx0XHRcdHRvb2x0aXAgPSBhcGkudG9vbHRpcCxcblx0XHRcdFx0b3B0aW9ucyA9IGFwaS5vcHRpb25zLnNob3cubW9kYWwsXG5cdFx0XHRcdGVmZmVjdCA9IG9wdGlvbnMuZWZmZWN0LFxuXHRcdFx0XHR0eXBlID0gc3RhdGUgPyAnc2hvdyc6ICdoaWRlJyxcblx0XHRcdFx0dmlzaWJsZSA9IGVsZW0uaXMoJzp2aXNpYmxlJyksXG5cdFx0XHRcdHZpc2libGVNb2RhbHMgPSAkKE1PREFMU0VMRUNUT1IpLmZpbHRlcignOnZpc2libGU6bm90KDphbmltYXRlZCknKS5ub3QodG9vbHRpcCksXG5cdFx0XHRcdHppbmRleDtcblxuXHRcdFx0Ly8gU2V0IGFjdGl2ZSB0b29sdGlwIEFQSSByZWZlcmVuY2Vcblx0XHRcdHNlbGYudXBkYXRlKGFwaSk7XG5cblx0XHRcdC8vIElmIHRoZSBtb2RhbCBjYW4gc3RlYWwgdGhlIGZvY3VzLi4uXG5cdFx0XHQvLyBCbHVyIHRoZSBjdXJyZW50IGl0ZW0gYW5kIGZvY3VzIGFueXRoaW5nIGluIHRoZSBtb2RhbCB3ZSBhblxuXHRcdFx0aWYoc3RhdGUgJiYgb3B0aW9ucy5zdGVhbGZvY3VzICE9PSBGQUxTRSkge1xuXHRcdFx0XHRmb2N1c0lucHV0cyggJCgnOmZvY3VzJykgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIGJhY2tkcm9wIGN1cnNvciBzdHlsZSBvbiBzaG93XG5cdFx0XHRlbGVtLnRvZ2dsZUNsYXNzKCdibHVycycsIG9wdGlvbnMuYmx1cik7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBib2R5IG9uIHNob3dcblx0XHRcdGlmKHN0YXRlKSB7XG5cdFx0XHRcdGVsZW0uYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXZlbnQgbW9kYWwgZnJvbSBjb25mbGljdGluZyB3aXRoIHNob3cuc29sbywgYW5kIGRvbid0IGhpZGUgYmFja2Ryb3AgaXMgb3RoZXIgbW9kYWxzIGFyZSB2aXNpYmxlXG5cdFx0XHRpZigoZWxlbS5pcygnOmFuaW1hdGVkJykgJiYgdmlzaWJsZSA9PT0gc3RhdGUgJiYgcHJldlN0YXRlICE9PSBGQUxTRSkgfHwgKCFzdGF0ZSAmJiB2aXNpYmxlTW9kYWxzLmxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3AgYWxsIGFuaW1hdGlvbnNcblx0XHRcdGVsZW0uc3RvcChUUlVFLCBGQUxTRSk7XG5cblx0XHRcdC8vIFVzZSBjdXN0b20gZnVuY3Rpb24gaWYgcHJvdmlkZWRcblx0XHRcdGlmKCQuaXNGdW5jdGlvbihlZmZlY3QpKSB7XG5cdFx0XHRcdGVmZmVjdC5jYWxsKGVsZW0sIHN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm8gZWZmZWN0IHR5cGUgaXMgc3VwcGxpZWQsIHVzZSBhIHNpbXBsZSB0b2dnbGVcblx0XHRcdGVsc2UgaWYoZWZmZWN0ID09PSBGQUxTRSkge1xuXHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGJhc2ljIGZhZGUgZnVuY3Rpb25cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlbGVtLmZhZGVUbyggcGFyc2VJbnQoZHVyYXRpb24sIDEwKSB8fCA5MCwgc3RhdGUgPyAxIDogMCwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYoIXN0YXRlKSB7IGVsZW0uaGlkZSgpOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBhbmQgZGV0YWNoIGZyb20gYm9keSBvbiBoaWRlXG5cdFx0XHRpZighc3RhdGUpIHtcblx0XHRcdFx0ZWxlbS5xdWV1ZShmdW5jdGlvbihuZXh0KSB7XG5cdFx0XHRcdFx0ZWxlbS5jc3MoeyBsZWZ0OiAnJywgdG9wOiAnJyB9KTtcblx0XHRcdFx0XHRpZighJChNT0RBTFNFTEVDVE9SKS5sZW5ndGgpIHsgZWxlbS5kZXRhY2goKTsgfVxuXHRcdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhY2hlIHRoZSBzdGF0ZVxuXHRcdFx0cHJldlN0YXRlID0gc3RhdGU7XG5cblx0XHRcdC8vIElmIHRoZSB0b29sdGlwIGlzIGRlc3Ryb3llZCwgc2V0IHJlZmVyZW5jZSB0byBudWxsXG5cdFx0XHRpZihjdXJyZW50LmRlc3Ryb3llZCkgeyBjdXJyZW50ID0gTlVMTDsgfVxuXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9XG5cdH0pO1x0XG5cblx0c2VsZi5pbml0KCk7XG59O1xuT1ZFUkxBWSA9IG5ldyBPVkVSTEFZKCk7XG5cbmZ1bmN0aW9uIE1vZGFsKGFwaSwgb3B0aW9ucykge1xuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHR0aGlzLl9ucyA9ICctbW9kYWwnO1xuXG5cdHRoaXMuaW5pdCggKHRoaXMucXRpcCA9IGFwaSkgKTtcbn1cblxuJC5leHRlbmQoTW9kYWwucHJvdG90eXBlLCB7XG5cdGluaXQ6IGZ1bmN0aW9uKHF0aXApIHtcblx0XHR2YXIgdG9vbHRpcCA9IHF0aXAudG9vbHRpcDtcblxuXHRcdC8vIElmIG1vZGFsIGlzIGRpc2FibGVkLi4uIHJldHVyblxuXHRcdGlmKCF0aGlzLm9wdGlvbnMub24pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdC8vIFNldCBvdmVybGF5IHJlZmVyZW5jZVxuXHRcdHF0aXAuZWxlbWVudHMub3ZlcmxheSA9IE9WRVJMQVkuZWxlbTtcblxuXHRcdC8vIEFkZCB1bmlxdWUgYXR0cmlidXRlIHNvIHdlIGNhbiBncmFiIG1vZGFsIHRvb2x0aXBzIGVhc2lseSB2aWEgYSBTRUxFQ1RPUiwgYW5kIHNldCB6LWluZGV4XG5cdFx0dG9vbHRpcC5hZGRDbGFzcyhNT0RBTENMQVNTKS5jc3MoJ3otaW5kZXgnLCBRVElQLm1vZGFsX3ppbmRleCArICQoTU9EQUxTRUxFQ1RPUikubGVuZ3RoKTtcblx0XHRcblx0XHQvLyBBcHBseSBvdXIgc2hvdy9oaWRlL2ZvY3VzIG1vZGFsIGV2ZW50c1xuXHRcdHF0aXAuX2JpbmQodG9vbHRpcCwgWyd0b29sdGlwc2hvdycsICd0b29sdGlwaGlkZSddLCBmdW5jdGlvbihldmVudCwgYXBpLCBkdXJhdGlvbikge1xuXHRcdFx0dmFyIG9FdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSBtb3VzZW91dCBkb2Vzbid0IHRyaWdnZXIgYSBoaWRlIHdoZW4gc2hvd2luZyB0aGUgbW9kYWwgYW5kIG1vdXNpbmcgb250byBiYWNrZHJvcFxuXHRcdFx0aWYoZXZlbnQudGFyZ2V0ID09PSB0b29sdGlwWzBdKSB7XG5cdFx0XHRcdGlmKG9FdmVudCAmJiBldmVudC50eXBlID09PSAndG9vbHRpcGhpZGUnICYmIC9tb3VzZShsZWF2ZXxlbnRlcikvLnRlc3Qob0V2ZW50LnR5cGUpICYmICQob0V2ZW50LnJlbGF0ZWRUYXJnZXQpLmNsb3Nlc3QoT1ZFUkxBWS5lbGVtWzBdKS5sZW5ndGgpIHtcblx0XHRcdFx0XHR0cnkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9IGNhdGNoKGUpIHt9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZighb0V2ZW50IHx8IChvRXZlbnQgJiYgb0V2ZW50LnR5cGUgIT09ICd0b29sdGlwc29sbycpKSB7XG5cdFx0XHRcdFx0dGhpcy50b2dnbGUoZXZlbnQsIGV2ZW50LnR5cGUgPT09ICd0b29sdGlwc2hvdycsIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sIHRoaXMuX25zLCB0aGlzKTtcblxuXHRcdC8vIEFkanVzdCBtb2RhbCB6LWluZGV4IG9uIHRvb2x0aXAgZm9jdXNcblx0XHRxdGlwLl9iaW5kKHRvb2x0aXAsICd0b29sdGlwZm9jdXMnLCBmdW5jdGlvbihldmVudCwgYXBpKSB7XG5cdFx0XHQvLyBJZiBmb2N1cyB3YXMgY2FuY2VsbGVkIGJlZm9yZSBpdCByZWFjaGVkIHVzLCBkb24ndCBkbyBhbnl0aGluZ1xuXHRcdFx0aWYoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQudGFyZ2V0ICE9PSB0b29sdGlwWzBdKSB7IHJldHVybjsgfVxuXG5cdFx0XHR2YXIgcXRpcHMgPSAkKE1PREFMU0VMRUNUT1IpLFxuXG5cdFx0XHQvLyBLZWVwIHRoZSBtb2RhbCdzIGxvd2VyIHRoYW4gb3RoZXIsIHJlZ3VsYXIgcXRpcHNcblx0XHRcdG5ld0luZGV4ID0gUVRJUC5tb2RhbF96aW5kZXggKyBxdGlwcy5sZW5ndGgsXG5cdFx0XHRjdXJJbmRleCA9IHBhcnNlSW50KHRvb2x0aXBbMF0uc3R5bGUuekluZGV4LCAxMCk7XG5cblx0XHRcdC8vIFNldCBvdmVybGF5IHotaW5kZXhcblx0XHRcdE9WRVJMQVkuZWxlbVswXS5zdHlsZS56SW5kZXggPSBuZXdJbmRleCAtIDE7XG5cblx0XHRcdC8vIFJlZHVjZSBtb2RhbCB6LWluZGV4J3MgYW5kIGtlZXAgdGhlbSBwcm9wZXJseSBvcmRlcmVkXG5cdFx0XHRxdGlwcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZih0aGlzLnN0eWxlLnpJbmRleCA+IGN1ckluZGV4KSB7XG5cdFx0XHRcdFx0dGhpcy5zdHlsZS56SW5kZXggLT0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEZpcmUgYmx1ciBldmVudCBmb3IgZm9jdXNlZCB0b29sdGlwXG5cdFx0XHRxdGlwcy5maWx0ZXIoJy4nICsgQ0xBU1NfRk9DVVMpLnF0aXAoJ2JsdXInLCBldmVudC5vcmlnaW5hbEV2ZW50KTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXcgei1pbmRleFxuXHRcdFx0dG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GT0NVUylbMF0uc3R5bGUuekluZGV4ID0gbmV3SW5kZXg7XG5cblx0XHRcdC8vIFNldCBjdXJyZW50XG5cdFx0XHRPVkVSTEFZLnVwZGF0ZShhcGkpO1xuXG5cdFx0XHQvLyBQcmV2ZW50IGRlZmF1bHQgaGFuZGxpbmdcblx0XHRcdHRyeSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH0gY2F0Y2goZSkge31cblx0XHR9LCB0aGlzLl9ucywgdGhpcyk7XG5cblx0XHQvLyBGb2N1cyBhbnkgb3RoZXIgdmlzaWJsZSBtb2RhbHMgd2hlbiB0aGlzIG9uZSBoaWRlc1xuXHRcdHF0aXAuX2JpbmQodG9vbHRpcCwgJ3Rvb2x0aXBoaWRlJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmKGV2ZW50LnRhcmdldCA9PT0gdG9vbHRpcFswXSkge1xuXHRcdFx0XHQkKE1PREFMU0VMRUNUT1IpLmZpbHRlcignOnZpc2libGUnKS5ub3QodG9vbHRpcCkubGFzdCgpLnF0aXAoJ2ZvY3VzJywgZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMuX25zLCB0aGlzKTtcblx0fSxcblxuXHR0b2dnbGU6IGZ1bmN0aW9uKGV2ZW50LCBzdGF0ZSwgZHVyYXRpb24pIHtcblx0XHQvLyBNYWtlIHN1cmUgZGVmYXVsdCBldmVudCBoYXNuJ3QgYmVlbiBwcmV2ZW50ZWRcblx0XHRpZihldmVudCAmJiBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0Ly8gVG9nZ2xlIGl0XG5cdFx0T1ZFUkxBWS50b2dnbGUodGhpcy5xdGlwLCAhIXN0YXRlLCBkdXJhdGlvbik7XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gUmVtb3ZlIG1vZGFsIGNsYXNzXG5cdFx0dGhpcy5xdGlwLnRvb2x0aXAucmVtb3ZlQ2xhc3MoTU9EQUxDTEFTUyk7XG5cblx0XHQvLyBSZW1vdmUgYm91bmQgZXZlbnRzXG5cdFx0dGhpcy5xdGlwLl91bmJpbmQodGhpcy5xdGlwLnRvb2x0aXAsIHRoaXMuX25zKTtcblxuXHRcdC8vIERlbGV0ZSBlbGVtZW50IHJlZmVyZW5jZVxuXHRcdE9WRVJMQVkudG9nZ2xlKHRoaXMucXRpcCwgRkFMU0UpO1xuXHRcdGRlbGV0ZSB0aGlzLnF0aXAuZWxlbWVudHMub3ZlcmxheTtcblx0fVxufSk7XG5cblxuTU9EQUwgPSBQTFVHSU5TLm1vZGFsID0gZnVuY3Rpb24oYXBpKSB7XG5cdHJldHVybiBuZXcgTW9kYWwoYXBpLCBhcGkub3B0aW9ucy5zaG93Lm1vZGFsKTtcbn07XG5cbi8vIFNldHVwIHNhbml0aXp0aW9uIHJ1bGVzXG5NT0RBTC5zYW5pdGl6ZSA9IGZ1bmN0aW9uKG9wdHMpIHtcblx0aWYob3B0cy5zaG93KSB7IFxuXHRcdGlmKHR5cGVvZiBvcHRzLnNob3cubW9kYWwgIT09ICdvYmplY3QnKSB7IG9wdHMuc2hvdy5tb2RhbCA9IHsgb246ICEhb3B0cy5zaG93Lm1vZGFsIH07IH1cblx0XHRlbHNlIGlmKHR5cGVvZiBvcHRzLnNob3cubW9kYWwub24gPT09ICd1bmRlZmluZWQnKSB7IG9wdHMuc2hvdy5tb2RhbC5vbiA9IFRSVUU7IH1cblx0fVxufTtcblxuLy8gQmFzZSB6LWluZGV4IGZvciBhbGwgbW9kYWwgdG9vbHRpcHMgKHVzZSBxVGlwIGNvcmUgei1pbmRleCBhcyBhIGJhc2UpXG5RVElQLm1vZGFsX3ppbmRleCA9IFFUSVAuemluZGV4IC0gMjAwO1xuXG4vLyBQbHVnaW4gbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQgb24gcmVuZGVyXG5NT0RBTC5pbml0aWFsaXplID0gJ3JlbmRlcic7XG5cbi8vIFNldHVwIG9wdGlvbiBzZXQgY2hlY2tzXG5DSEVDS1MubW9kYWwgPSB7XG5cdCdec2hvdy5tb2RhbC4ob258Ymx1cikkJzogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gSW5pdGlhbGlzZVxuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdHRoaXMuaW5pdCgpO1xuXHRcdFxuXHRcdC8vIFNob3cgdGhlIG1vZGFsIGlmIG5vdCB2aXNpYmxlIGFscmVhZHkgYW5kIHRvb2x0aXAgaXMgdmlzaWJsZVxuXHRcdHRoaXMucXRpcC5lbGVtcy5vdmVybGF5LnRvZ2dsZShcblx0XHRcdHRoaXMucXRpcC50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMFxuXHRcdCk7XG5cdH1cbn07XG5cbi8vIEV4dGVuZCBvcmlnaW5hbCBhcGkgZGVmYXVsdHNcbiQuZXh0ZW5kKFRSVUUsIFFUSVAuZGVmYXVsdHMsIHtcblx0c2hvdzoge1xuXHRcdG1vZGFsOiB7XG5cdFx0XHRvbjogRkFMU0UsXG5cdFx0XHRlZmZlY3Q6IFRSVUUsXG5cdFx0XHRibHVyOiBUUlVFLFxuXHRcdFx0c3RlYWxmb2N1czogVFJVRSxcblx0XHRcdGVzY2FwZTogVFJVRVxuXHRcdH1cblx0fVxufSk7XG47UExVR0lOUy52aWV3cG9ydCA9IGZ1bmN0aW9uKGFwaSwgcG9zaXRpb24sIHBvc09wdGlvbnMsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIGVsZW1XaWR0aCwgZWxlbUhlaWdodClcbntcblx0dmFyIHRhcmdldCA9IHBvc09wdGlvbnMudGFyZ2V0LFxuXHRcdHRvb2x0aXAgPSBhcGkuZWxlbWVudHMudG9vbHRpcCxcblx0XHRteSA9IHBvc09wdGlvbnMubXksXG5cdFx0YXQgPSBwb3NPcHRpb25zLmF0LFxuXHRcdGFkanVzdCA9IHBvc09wdGlvbnMuYWRqdXN0LFxuXHRcdG1ldGhvZCA9IGFkanVzdC5tZXRob2Quc3BsaXQoJyAnKSxcblx0XHRtZXRob2RYID0gbWV0aG9kWzBdLFxuXHRcdG1ldGhvZFkgPSBtZXRob2RbMV0gfHwgbWV0aG9kWzBdLFxuXHRcdHZpZXdwb3J0ID0gcG9zT3B0aW9ucy52aWV3cG9ydCxcblx0XHRjb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcblx0XHRjYWNoZSA9IGFwaS5jYWNoZSxcblx0XHRhZGp1c3RlZCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG5cdFx0Zml4ZWQsIG5ld015LCBuZXdDbGFzcywgY29udGFpbmVyT2Zmc2V0LCBjb250YWluZXJTdGF0aWMsXG5cdFx0dmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIHZpZXdwb3J0U2Nyb2xsLCB2aWV3cG9ydE9mZnNldDtcblxuXHQvLyBJZiB2aWV3cG9ydCBpcyBub3QgYSBqUXVlcnkgZWxlbWVudCwgb3IgaXQncyB0aGUgd2luZG93L2RvY3VtZW50LCBvciBubyBhZGp1c3RtZW50IG1ldGhvZCBpcyB1c2VkLi4uIHJldHVyblxuXHRpZighdmlld3BvcnQuanF1ZXJ5IHx8IHRhcmdldFswXSA9PT0gd2luZG93IHx8IHRhcmdldFswXSA9PT0gZG9jdW1lbnQuYm9keSB8fCBhZGp1c3QubWV0aG9kID09PSAnbm9uZScpIHtcblx0XHRyZXR1cm4gYWRqdXN0ZWQ7XG5cdH1cblxuXHQvLyBDYWNoIGNvbnRhaW5lciBkZXRhaWxzXG5cdGNvbnRhaW5lck9mZnNldCA9IGNvbnRhaW5lci5vZmZzZXQoKSB8fCBhZGp1c3RlZDtcblx0Y29udGFpbmVyU3RhdGljID0gY29udGFpbmVyLmNzcygncG9zaXRpb24nKSA9PT0gJ3N0YXRpYyc7XG5cblx0Ly8gQ2FjaGUgb3VyIHZpZXdwb3J0IGRldGFpbHNcblx0Zml4ZWQgPSB0b29sdGlwLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJztcblx0dmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0WzBdID09PSB3aW5kb3cgPyB2aWV3cG9ydC53aWR0aCgpIDogdmlld3BvcnQub3V0ZXJXaWR0aChGQUxTRSk7XG5cdHZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRbMF0gPT09IHdpbmRvdyA/IHZpZXdwb3J0LmhlaWdodCgpIDogdmlld3BvcnQub3V0ZXJIZWlnaHQoRkFMU0UpO1xuXHR2aWV3cG9ydFNjcm9sbCA9IHsgbGVmdDogZml4ZWQgPyAwIDogdmlld3BvcnQuc2Nyb2xsTGVmdCgpLCB0b3A6IGZpeGVkID8gMCA6IHZpZXdwb3J0LnNjcm9sbFRvcCgpIH07XG5cdHZpZXdwb3J0T2Zmc2V0ID0gdmlld3BvcnQub2Zmc2V0KCkgfHwgYWRqdXN0ZWQ7XG5cblx0Ly8gR2VuZXJpYyBjYWxjdWxhdGlvbiBtZXRob2Rcblx0ZnVuY3Rpb24gY2FsY3VsYXRlKHNpZGUsIG90aGVyU2lkZSwgdHlwZSwgYWRqdXN0LCBzaWRlMSwgc2lkZTIsIGxlbmd0aE5hbWUsIHRhcmdldExlbmd0aCwgZWxlbUxlbmd0aCkge1xuXHRcdHZhciBpbml0aWFsUG9zID0gcG9zaXRpb25bc2lkZTFdLFxuXHRcdFx0bXlTaWRlID0gbXlbc2lkZV0sXG5cdFx0XHRhdFNpZGUgPSBhdFtzaWRlXSxcblx0XHRcdGlzU2hpZnQgPSB0eXBlID09PSBTSElGVCxcblx0XHRcdG15TGVuZ3RoID0gbXlTaWRlID09PSBzaWRlMSA/IGVsZW1MZW5ndGggOiBteVNpZGUgPT09IHNpZGUyID8gLWVsZW1MZW5ndGggOiAtZWxlbUxlbmd0aCAvIDIsXG5cdFx0XHRhdExlbmd0aCA9IGF0U2lkZSA9PT0gc2lkZTEgPyB0YXJnZXRMZW5ndGggOiBhdFNpZGUgPT09IHNpZGUyID8gLXRhcmdldExlbmd0aCA6IC10YXJnZXRMZW5ndGggLyAyLFxuXHRcdFx0c2lkZU9mZnNldCA9IHZpZXdwb3J0U2Nyb2xsW3NpZGUxXSArIHZpZXdwb3J0T2Zmc2V0W3NpZGUxXSAtIChjb250YWluZXJTdGF0aWMgPyAwIDogY29udGFpbmVyT2Zmc2V0W3NpZGUxXSksXG5cdFx0XHRvdmVyZmxvdzEgPSBzaWRlT2Zmc2V0IC0gaW5pdGlhbFBvcyxcblx0XHRcdG92ZXJmbG93MiA9IGluaXRpYWxQb3MgKyBlbGVtTGVuZ3RoIC0gKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSAtIHNpZGVPZmZzZXQsXG5cdFx0XHRvZmZzZXQgPSBteUxlbmd0aCAtIChteS5wcmVjZWRhbmNlID09PSBzaWRlIHx8IG15U2lkZSA9PT0gbXlbb3RoZXJTaWRlXSA/IGF0TGVuZ3RoIDogMCkgLSAoYXRTaWRlID09PSBDRU5URVIgPyB0YXJnZXRMZW5ndGggLyAyIDogMCk7XG5cblx0XHQvLyBzaGlmdFxuXHRcdGlmKGlzU2hpZnQpIHtcblx0XHRcdG9mZnNldCA9IChteVNpZGUgPT09IHNpZGUxID8gMSA6IC0xKSAqIG15TGVuZ3RoO1xuXG5cdFx0XHQvLyBBZGp1c3QgcG9zaXRpb24gYnV0IGtlZXAgaXQgd2l0aGluIHZpZXdwb3J0IGRpbWVuc2lvbnNcblx0XHRcdHBvc2l0aW9uW3NpZGUxXSArPSBvdmVyZmxvdzEgPiAwID8gb3ZlcmZsb3cxIDogb3ZlcmZsb3cyID4gMCA/IC1vdmVyZmxvdzIgOiAwO1xuXHRcdFx0cG9zaXRpb25bc2lkZTFdID0gTWF0aC5tYXgoXG5cdFx0XHRcdC1jb250YWluZXJPZmZzZXRbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdLFxuXHRcdFx0XHRpbml0aWFsUG9zIC0gb2Zmc2V0LFxuXHRcdFx0XHRNYXRoLm1pbihcblx0XHRcdFx0XHRNYXRoLm1heChcblx0XHRcdFx0XHRcdC1jb250YWluZXJPZmZzZXRbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdICsgKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSxcblx0XHRcdFx0XHRcdGluaXRpYWxQb3MgKyBvZmZzZXRcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdHBvc2l0aW9uW3NpZGUxXSxcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhZGp1c3QgY29tcGxldGUgb2ZmIHRoZSBlbGVtZW50IHdoZW4gdXNpbmcgJ2NlbnRlcidcblx0XHRcdFx0XHRteVNpZGUgPT09ICdjZW50ZXInID8gaW5pdGlhbFBvcyAtIG15TGVuZ3RoIDogMUU5XG5cdFx0XHRcdClcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHQvLyBmbGlwL2ZsaXBpbnZlcnRcblx0XHRlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBhZGp1c3RtZW50IGFtb3VudCBkZXBlbmRpbmcgb24gaWYgdXNpbmcgZmxpcGludmVydCBvciBmbGlwXG5cdFx0XHRhZGp1c3QgKj0gKHR5cGUgPT09IEZMSVBJTlZFUlQgPyAyIDogMCk7XG5cblx0XHRcdC8vIENoZWNrIGZvciBvdmVyZmxvdyBvbiB0aGUgbGVmdC90b3Bcblx0XHRcdGlmKG92ZXJmbG93MSA+IDAgJiYgKG15U2lkZSAhPT0gc2lkZTEgfHwgb3ZlcmZsb3cyID4gMCkpIHtcblx0XHRcdFx0cG9zaXRpb25bc2lkZTFdIC09IG9mZnNldCArIGFkanVzdDtcblx0XHRcdFx0bmV3TXkuaW52ZXJ0KHNpZGUsIHNpZGUxKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIG92ZXJmbG93IG9uIHRoZSBib3R0b20vcmlnaHRcblx0XHRcdGVsc2UgaWYob3ZlcmZsb3cyID4gMCAmJiAobXlTaWRlICE9PSBzaWRlMiB8fCBvdmVyZmxvdzEgPiAwKSAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uW3NpZGUxXSAtPSAobXlTaWRlID09PSBDRU5URVIgPyAtb2Zmc2V0IDogb2Zmc2V0KSArIGFkanVzdDtcblx0XHRcdFx0bmV3TXkuaW52ZXJ0KHNpZGUsIHNpZGUyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGhhdmVuJ3QgbWFkZSB0aGluZ3Mgd29yc2Ugd2l0aCB0aGUgYWRqdXN0bWVudCBhbmQgcmVzZXQgaWYgc29cblx0XHRcdGlmKHBvc2l0aW9uW3NpZGUxXSA8IHZpZXdwb3J0U2Nyb2xsICYmIC1wb3NpdGlvbltzaWRlMV0gPiBvdmVyZmxvdzIpIHtcblx0XHRcdFx0cG9zaXRpb25bc2lkZTFdID0gaW5pdGlhbFBvczsgbmV3TXkgPSBteS5jbG9uZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwb3NpdGlvbltzaWRlMV0gLSBpbml0aWFsUG9zO1xuXHR9XG5cblx0Ly8gU2V0IG5ld015IGlmIHVzaW5nIGZsaXAgb3IgZmxpcGludmVydCBtZXRob2RzXG5cdGlmKG1ldGhvZFggIT09ICdzaGlmdCcgfHwgbWV0aG9kWSAhPT0gJ3NoaWZ0JykgeyBuZXdNeSA9IG15LmNsb25lKCk7IH1cblxuXHQvLyBBZGp1c3QgcG9zaXRpb24gYmFzZWQgb252aWV3cG9ydCBhbmQgYWRqdXN0bWVudCBvcHRpb25zXG5cdGFkanVzdGVkID0ge1xuXHRcdGxlZnQ6IG1ldGhvZFggIT09ICdub25lJyA/IGNhbGN1bGF0ZSggWCwgWSwgbWV0aG9kWCwgYWRqdXN0LngsIExFRlQsIFJJR0hULCBXSURUSCwgdGFyZ2V0V2lkdGgsIGVsZW1XaWR0aCApIDogMCxcblx0XHR0b3A6IG1ldGhvZFkgIT09ICdub25lJyA/IGNhbGN1bGF0ZSggWSwgWCwgbWV0aG9kWSwgYWRqdXN0LnksIFRPUCwgQk9UVE9NLCBIRUlHSFQsIHRhcmdldEhlaWdodCwgZWxlbUhlaWdodCApIDogMFxuXHR9O1xuXG5cdC8vIFNldCB0b29sdGlwIHBvc2l0aW9uIGNsYXNzIGlmIGl0J3MgY2hhbmdlZFxuXHRpZihuZXdNeSAmJiBjYWNoZS5sYXN0Q2xhc3MgIT09IChuZXdDbGFzcyA9IE5BTUVTUEFDRSArICctcG9zLScgKyBuZXdNeS5hYmJyZXYoKSkpIHtcblx0XHR0b29sdGlwLnJlbW92ZUNsYXNzKGFwaS5jYWNoZS5sYXN0Q2xhc3MpLmFkZENsYXNzKCAoYXBpLmNhY2hlLmxhc3RDbGFzcyA9IG5ld0NsYXNzKSApO1xuXHR9XG5cblx0cmV0dXJuIGFkanVzdGVkO1xufTtcbjtQTFVHSU5TLnBvbHlzID0ge1xuXHQvLyBQT0xZIGFyZWEgY29vcmRpbmF0ZSBjYWxjdWxhdG9yXG5cdC8vXHRTcGVjaWFsIHRoYW5rcyB0byBFZCBDcmFkb2NrIGZvciBoZWxwaW5nIG91dCB3aXRoIHRoaXMuXG5cdC8vXHRVc2VzIGEgYmluYXJ5IHNlYXJjaCBhbGdvcml0aG0gdG8gZmluZCBzdWl0YWJsZSBjb29yZGluYXRlcy5cblx0cG9seWdvbjogZnVuY3Rpb24oYmFzZUNvb3JkcywgY29ybmVyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHR0b3A6IDFlMTAsIHJpZ2h0OiAwLFxuXHRcdFx0XHRib3R0b206IDAsIGxlZnQ6IDFlMTBcblx0XHRcdH0sXG5cdFx0XHRhZGp1c3RhYmxlOiBGQUxTRVxuXHRcdH0sXG5cdFx0aSA9IDAsIG5leHQsXG5cdFx0Y29vcmRzID0gW10sXG5cdFx0Y29tcGFyZVggPSAxLCBjb21wYXJlWSA9IDEsXG5cdFx0cmVhbFggPSAwLCByZWFsWSA9IDAsXG5cdFx0bmV3V2lkdGgsIG5ld0hlaWdodDtcblxuXHRcdC8vIEZpcnN0IHBhc3MsIHNhbml0aXplIGNvb3JkcyBhbmQgZGV0ZXJtaW5lIG91dGVyIGVkZ2VzXG5cdFx0aSA9IGJhc2VDb29yZHMubGVuZ3RoOyB3aGlsZShpLS0pIHtcblx0XHRcdG5leHQgPSBbIHBhcnNlSW50KGJhc2VDb29yZHNbLS1pXSwgMTApLCBwYXJzZUludChiYXNlQ29vcmRzW2krMV0sIDEwKSBdO1xuXG5cdFx0XHRpZihuZXh0WzBdID4gcmVzdWx0LnBvc2l0aW9uLnJpZ2h0KXsgcmVzdWx0LnBvc2l0aW9uLnJpZ2h0ID0gbmV4dFswXTsgfVxuXHRcdFx0aWYobmV4dFswXSA8IHJlc3VsdC5wb3NpdGlvbi5sZWZ0KXsgcmVzdWx0LnBvc2l0aW9uLmxlZnQgPSBuZXh0WzBdOyB9XG5cdFx0XHRpZihuZXh0WzFdID4gcmVzdWx0LnBvc2l0aW9uLmJvdHRvbSl7IHJlc3VsdC5wb3NpdGlvbi5ib3R0b20gPSBuZXh0WzFdOyB9XG5cdFx0XHRpZihuZXh0WzFdIDwgcmVzdWx0LnBvc2l0aW9uLnRvcCl7IHJlc3VsdC5wb3NpdGlvbi50b3AgPSBuZXh0WzFdOyB9XG5cblx0XHRcdGNvb3Jkcy5wdXNoKG5leHQpO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBoZWlnaHQgYW5kIHdpZHRoIGZyb20gb3V0ZXIgZWRnZXNcblx0XHRuZXdXaWR0aCA9IHJlc3VsdC53aWR0aCA9IE1hdGguYWJzKHJlc3VsdC5wb3NpdGlvbi5yaWdodCAtIHJlc3VsdC5wb3NpdGlvbi5sZWZ0KTtcblx0XHRuZXdIZWlnaHQgPSByZXN1bHQuaGVpZ2h0ID0gTWF0aC5hYnMocmVzdWx0LnBvc2l0aW9uLmJvdHRvbSAtIHJlc3VsdC5wb3NpdGlvbi50b3ApO1xuXG5cdFx0Ly8gSWYgaXQncyB0aGUgY2VudGVyIGNvcm5lci4uLlxuXHRcdGlmKGNvcm5lci5hYmJyZXYoKSA9PT0gJ2MnKSB7XG5cdFx0XHRyZXN1bHQucG9zaXRpb24gPSB7XG5cdFx0XHRcdGxlZnQ6IHJlc3VsdC5wb3NpdGlvbi5sZWZ0ICsgKHJlc3VsdC53aWR0aCAvIDIpLFxuXHRcdFx0XHR0b3A6IHJlc3VsdC5wb3NpdGlvbi50b3AgKyAocmVzdWx0LmhlaWdodCAvIDIpXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFNlY29uZCBwYXNzLCB1c2UgYSBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobSB0byBsb2NhdGUgbW9zdCBzdWl0YWJsZSBjb29yZGluYXRlXG5cdFx0XHR3aGlsZShuZXdXaWR0aCA+IDAgJiYgbmV3SGVpZ2h0ID4gMCAmJiBjb21wYXJlWCA+IDAgJiYgY29tcGFyZVkgPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXdXaWR0aCA9IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKTtcblx0XHRcdFx0bmV3SGVpZ2h0ID0gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRpZihjb3JuZXIueCA9PT0gTEVGVCl7IGNvbXBhcmVYID0gbmV3V2lkdGg7IH1cblx0XHRcdFx0ZWxzZSBpZihjb3JuZXIueCA9PT0gUklHSFQpeyBjb21wYXJlWCA9IHJlc3VsdC53aWR0aCAtIG5ld1dpZHRoOyB9XG5cdFx0XHRcdGVsc2V7IGNvbXBhcmVYICs9IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKTsgfVxuXG5cdFx0XHRcdGlmKGNvcm5lci55ID09PSBUT1ApeyBjb21wYXJlWSA9IG5ld0hlaWdodDsgfVxuXHRcdFx0XHRlbHNlIGlmKGNvcm5lci55ID09PSBCT1RUT00peyBjb21wYXJlWSA9IHJlc3VsdC5oZWlnaHQgLSBuZXdIZWlnaHQ7IH1cblx0XHRcdFx0ZWxzZXsgY29tcGFyZVkgKz0gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKTsgfVxuXG5cdFx0XHRcdGkgPSBjb29yZHMubGVuZ3RoOyB3aGlsZShpLS0pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZihjb29yZHMubGVuZ3RoIDwgMil7IGJyZWFrOyB9XG5cblx0XHRcdFx0XHRyZWFsWCA9IGNvb3Jkc1tpXVswXSAtIHJlc3VsdC5wb3NpdGlvbi5sZWZ0O1xuXHRcdFx0XHRcdHJlYWxZID0gY29vcmRzW2ldWzFdIC0gcmVzdWx0LnBvc2l0aW9uLnRvcDtcblxuXHRcdFx0XHRcdGlmKChjb3JuZXIueCA9PT0gTEVGVCAmJiByZWFsWCA+PSBjb21wYXJlWCkgfHxcblx0XHRcdFx0XHQoY29ybmVyLnggPT09IFJJR0hUICYmIHJlYWxYIDw9IGNvbXBhcmVYKSB8fFxuXHRcdFx0XHRcdChjb3JuZXIueCA9PT0gQ0VOVEVSICYmIChyZWFsWCA8IGNvbXBhcmVYIHx8IHJlYWxYID4gKHJlc3VsdC53aWR0aCAtIGNvbXBhcmVYKSkpIHx8XG5cdFx0XHRcdFx0KGNvcm5lci55ID09PSBUT1AgJiYgcmVhbFkgPj0gY29tcGFyZVkpIHx8XG5cdFx0XHRcdFx0KGNvcm5lci55ID09PSBCT1RUT00gJiYgcmVhbFkgPD0gY29tcGFyZVkpIHx8XG5cdFx0XHRcdFx0KGNvcm5lci55ID09PSBDRU5URVIgJiYgKHJlYWxZIDwgY29tcGFyZVkgfHwgcmVhbFkgPiAocmVzdWx0LmhlaWdodCAtIGNvbXBhcmVZKSkpKSB7XG5cdFx0XHRcdFx0XHRjb29yZHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnBvc2l0aW9uID0geyBsZWZ0OiBjb29yZHNbMF1bMF0sIHRvcDogY29vcmRzWzBdWzFdIH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRyZWN0OiBmdW5jdGlvbihheCwgYXksIGJ4LCBieSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogTWF0aC5hYnMoYnggLSBheCksXG5cdFx0XHRoZWlnaHQ6IE1hdGguYWJzKGJ5IC0gYXkpLFxuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0bGVmdDogTWF0aC5taW4oYXgsIGJ4KSxcblx0XHRcdFx0dG9wOiBNYXRoLm1pbihheSwgYnkpXG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRfYW5nbGVzOiB7XG5cdFx0dGM6IDMgLyAyLCB0cjogNyAvIDQsIHRsOiA1IC8gNCwgXG5cdFx0YmM6IDEgLyAyLCBicjogMSAvIDQsIGJsOiAzIC8gNCwgXG5cdFx0cmM6IDIsIGxjOiAxLCBjOiAwXG5cdH0sXG5cdGVsbGlwc2U6IGZ1bmN0aW9uKGN4LCBjeSwgcngsIHJ5LCBjb3JuZXIpIHtcblx0XHR2YXIgYyA9IFBMVUdJTlMucG9seXMuX2FuZ2xlc1sgY29ybmVyLmFiYnJldigpIF0sXG5cdFx0XHRyeGMgPSBjID09PSAwID8gMCA6IHJ4ICogTWF0aC5jb3MoIGMgKiBNYXRoLlBJICksXG5cdFx0XHRyeXMgPSByeSAqIE1hdGguc2luKCBjICogTWF0aC5QSSApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiAocnggKiAyKSAtIE1hdGguYWJzKHJ4YyksXG5cdFx0XHRoZWlnaHQ6IChyeSAqIDIpIC0gTWF0aC5hYnMocnlzKSxcblx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdGxlZnQ6IGN4ICsgcnhjLFxuXHRcdFx0XHR0b3A6IGN5ICsgcnlzXG5cdFx0XHR9LFxuXHRcdFx0YWRqdXN0YWJsZTogRkFMU0Vcblx0XHR9O1xuXHR9LFxuXHRjaXJjbGU6IGZ1bmN0aW9uKGN4LCBjeSwgciwgY29ybmVyKSB7XG5cdFx0cmV0dXJuIFBMVUdJTlMucG9seXMuZWxsaXBzZShjeCwgY3ksIHIsIHIsIGNvcm5lcik7XG5cdH1cbn07O1BMVUdJTlMuc3ZnID0gZnVuY3Rpb24oYXBpLCBzdmcsIGNvcm5lcilcbntcblx0dmFyIGRvYyA9ICQoZG9jdW1lbnQpLFxuXHRcdGVsZW0gPSBzdmdbMF0sXG5cdFx0cm9vdCA9ICQoZWxlbS5vd25lclNWR0VsZW1lbnQpLFxuXHRcdHhTY2FsZSA9IDEsIHlTY2FsZSA9IDEsXG5cdFx0Y29tcGxleCA9IHRydWUsXG5cdFx0cm9vdFdpZHRoLCByb290SGVpZ2h0LFxuXHRcdG10eCwgdHJhbnNmb3JtZWQsIHZpZXdCb3gsXG5cdFx0bGVuLCBuZXh0LCBpLCBwb2ludHMsXG5cdFx0cmVzdWx0LCBwb3NpdGlvbiwgZGltZW5zaW9ucztcblxuXHQvLyBBc2NlbmQgdGhlIHBhcmVudE5vZGUgY2hhaW4gdW50aWwgd2UgZmluZCBhbiBlbGVtZW50IHdpdGggZ2V0QkJveCgpXG5cdHdoaWxlKCFlbGVtLmdldEJCb3gpIHsgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTsgfVxuXHRpZighZWxlbS5nZXRCQm94IHx8ICFlbGVtLnBhcmVudE5vZGUpIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0Ly8gRGV0ZXJtaW5lIGRpbWVuc2lvbnMgd2hlcmUgcG9zc2libGVcblx0cm9vdFdpZHRoID0gcm9vdC5hdHRyKCd3aWR0aCcpIHx8IHJvb3Qud2lkdGgoKSB8fCBwYXJzZUludChyb290LmNzcygnd2lkdGgnKSwgMTApO1xuXHRyb290SGVpZ2h0ID0gcm9vdC5hdHRyKCdoZWlnaHQnKSB8fCByb290LmhlaWdodCgpIHx8IHBhcnNlSW50KHJvb3QuY3NzKCdoZWlnaHQnKSwgMTApO1xuXG5cdC8vIEFkZCBzdHJva2UgY2hhcmFjdGVyaXN0aWNzIHRvIHNjYWxpbmdcblx0dmFyIHN0cm9rZVdpZHRoMiA9IChwYXJzZUludChzdmcuY3NzKCdzdHJva2Utd2lkdGgnKSwgMTApIHx8IDApIC8gMjtcblx0aWYoc3Ryb2tlV2lkdGgyKSB7XG5cdFx0eFNjYWxlICs9IHN0cm9rZVdpZHRoMiAvIHJvb3RXaWR0aDtcblx0XHR5U2NhbGUgKz0gc3Ryb2tlV2lkdGgyIC8gcm9vdEhlaWdodDtcblx0fVxuXG5cdC8vIERldGVybWluZSB3aGljaCBzaGFwZSBjYWxjdWxhdGlvbiB0byB1c2Vcblx0c3dpdGNoKGVsZW0ubm9kZU5hbWUpIHtcblx0XHRjYXNlICdlbGxpcHNlJzpcblx0XHRjYXNlICdjaXJjbGUnOlxuXHRcdFx0cmVzdWx0ID0gUExVR0lOUy5wb2x5cy5lbGxpcHNlKFxuXHRcdFx0XHRlbGVtLmN4LmJhc2VWYWwudmFsdWUsXG5cdFx0XHRcdGVsZW0uY3kuYmFzZVZhbC52YWx1ZSxcblx0XHRcdFx0KGVsZW0ucnggfHwgZWxlbS5yKS5iYXNlVmFsLnZhbHVlICsgc3Ryb2tlV2lkdGgyLFxuXHRcdFx0XHQoZWxlbS5yeSB8fCBlbGVtLnIpLmJhc2VWYWwudmFsdWUgKyBzdHJva2VXaWR0aDIsXG5cdFx0XHRcdGNvcm5lclxuXHRcdFx0KTtcblx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdGNhc2UgJ3BvbHlnb24nOlxuXHRcdGNhc2UgJ3BvbHlsaW5lJzpcblx0XHRcdC8vIERldGVybWluZSBwb2ludHMgb2JqZWN0IChsaW5lIGhhcyBub25lLCBzbyBtaW1pYyB1c2luZyBhcnJheSlcblx0XHRcdHBvaW50cyA9IGVsZW0ucG9pbnRzIHx8IFsgXG5cdFx0XHRcdHsgeDogZWxlbS54MS5iYXNlVmFsLnZhbHVlLCB5OiBlbGVtLnkxLmJhc2VWYWwudmFsdWUgfSxcblx0XHRcdFx0eyB4OiBlbGVtLngyLmJhc2VWYWwudmFsdWUsIHk6IGVsZW0ueTIuYmFzZVZhbC52YWx1ZSB9XG5cdFx0XHRdO1xuXG5cdFx0XHRmb3IocmVzdWx0ID0gW10sIGkgPSAtMSwgbGVuID0gcG9pbnRzLm51bWJlck9mSXRlbXMgfHwgcG9pbnRzLmxlbmd0aDsgKytpIDwgbGVuOykge1xuXHRcdFx0XHRuZXh0ID0gcG9pbnRzLmdldEl0ZW0gPyBwb2ludHMuZ2V0SXRlbShpKSA6IHBvaW50c1tpXTtcblx0XHRcdFx0cmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBbbmV4dC54LCBuZXh0LnldKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0ID0gUExVR0lOUy5wb2x5cy5wb2x5Z29uKHJlc3VsdCwgY29ybmVyKTtcblx0XHRicmVhaztcblxuXHRcdC8vIFVua25vd24gc2hhcGUgb3IgcmVjdGFuZ2xlPyBVc2UgYm91bmRpbmcgYm94XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJlc3VsdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdHdpZHRoOiByZXN1bHQud2lkdGgsIGhlaWdodDogcmVzdWx0LmhlaWdodCxcblx0XHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0XHRsZWZ0OiByZXN1bHQubGVmdCxcblx0XHRcdFx0XHR0b3A6IHJlc3VsdC50b3Bcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGNvbXBsZXggPSBmYWxzZTtcblx0XHRicmVhaztcblx0fVxuXG5cdC8vIFNob3J0Y3V0IGFzc2lnbm1lbnRzXG5cdHBvc2l0aW9uID0gcmVzdWx0LnBvc2l0aW9uO1xuXHRyb290ID0gcm9vdFswXTtcblxuXHQvLyBJZiB0aGUgc2hhcGUgd2FzIGNvbXBsZXggKGkuZS4gbm90IHVzaW5nIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMpXG5cdGlmKGNvbXBsZXgpIHtcblx0XHQvLyBDb252ZXJ0IHBvc2l0aW9uIGludG8gYSBwaXhlbCB2YWx1ZVxuXHRcdGlmKHJvb3QuY3JlYXRlU1ZHUG9pbnQpIHtcblx0XHRcdG10eCA9IGVsZW0uZ2V0U2NyZWVuQ1RNKCk7XG5cdFx0XHRwb2ludHMgPSByb290LmNyZWF0ZVNWR1BvaW50KCk7XG5cblx0XHRcdHBvaW50cy54ID0gcG9zaXRpb24ubGVmdDtcblx0XHRcdHBvaW50cy55ID0gcG9zaXRpb24udG9wO1xuXHRcdFx0dHJhbnNmb3JtZWQgPSBwb2ludHMubWF0cml4VHJhbnNmb3JtKCBtdHggKTtcblx0XHRcdHBvc2l0aW9uLmxlZnQgPSB0cmFuc2Zvcm1lZC54O1xuXHRcdFx0cG9zaXRpb24udG9wID0gdHJhbnNmb3JtZWQueTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgdmlld0JveCBjaGFyYWN0ZXJpc3RpY3Ncblx0XHRpZihyb290LnZpZXdCb3ggJiYgKHZpZXdCb3ggPSByb290LnZpZXdCb3guYmFzZVZhbCkgJiYgdmlld0JveC53aWR0aCAmJiB2aWV3Qm94LmhlaWdodCkge1xuXHRcdFx0eFNjYWxlICo9IHJvb3RXaWR0aCAvIHZpZXdCb3gud2lkdGg7XG5cdFx0XHR5U2NhbGUgKj0gcm9vdEhlaWdodCAvIHZpZXdCb3guaGVpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkanVzdCBieSBzY3JvbGwgb2Zmc2V0XG5cdHBvc2l0aW9uLmxlZnQgKz0gZG9jLnNjcm9sbExlZnQoKTtcblx0cG9zaXRpb24udG9wICs9IGRvYy5zY3JvbGxUb3AoKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufTs7UExVR0lOUy5pbWFnZW1hcCA9IGZ1bmN0aW9uKGFwaSwgYXJlYSwgY29ybmVyLCBhZGp1c3RNZXRob2QpXG57XG5cdGlmKCFhcmVhLmpxdWVyeSkgeyBhcmVhID0gJChhcmVhKTsgfVxuXG5cdHZhciBzaGFwZSA9IGFyZWEuYXR0cignc2hhcGUnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3BvbHknLCAncG9seWdvbicpLFxuXHRcdGltYWdlID0gJCgnaW1nW3VzZW1hcD1cIiMnK2FyZWEucGFyZW50KCdtYXAnKS5hdHRyKCduYW1lJykrJ1wiXScpLFxuXHRcdGNvb3Jkc1N0cmluZyA9ICQudHJpbShhcmVhLmF0dHIoJ2Nvb3JkcycpKSxcblx0XHRjb29yZHNBcnJheSA9IGNvb3Jkc1N0cmluZy5yZXBsYWNlKC8sJC8sICcnKS5zcGxpdCgnLCcpLFxuXHRcdGltYWdlT2Zmc2V0LCBjb29yZHMsIGksIG5leHQsIHJlc3VsdCwgbGVuO1xuXG5cdC8vIElmIHdlIGNhbid0IGZpbmQgdGhlIGltYWdlIHVzaW5nIHRoZSBtYXAuLi5cblx0aWYoIWltYWdlLmxlbmd0aCkgeyByZXR1cm4gRkFMU0U7IH1cblxuXHQvLyBQYXNzIGNvb3JkaW5hdGVzIHN0cmluZyBpZiBwb2x5Z29uXG5cdGlmKHNoYXBlID09PSAncG9seWdvbicpIHtcblx0XHRyZXN1bHQgPSBQTFVHSU5TLnBvbHlzLnBvbHlnb24oY29vcmRzQXJyYXksIGNvcm5lcik7XG5cdH1cblxuXHQvLyBPdGhlcndpc2UgcGFyc2UgdGhlIGNvb3JkaW5hdGVzIGFuZCBwYXNzIHRoZW0gYXMgYXJndW1lbnRzXG5cdGVsc2UgaWYoUExVR0lOUy5wb2x5c1tzaGFwZV0pIHtcblx0XHRmb3IoaSA9IC0xLCBsZW4gPSBjb29yZHNBcnJheS5sZW5ndGgsIGNvb3JkcyA9IFtdOyArK2kgPCBsZW47KSB7XG5cdFx0XHRjb29yZHMucHVzaCggcGFyc2VJbnQoY29vcmRzQXJyYXlbaV0sIDEwKSApO1xuXHRcdH1cblxuXHRcdHJlc3VsdCA9IFBMVUdJTlMucG9seXNbc2hhcGVdLmFwcGx5KFxuXHRcdFx0dGhpcywgY29vcmRzLmNvbmNhdChjb3JuZXIpXG5cdFx0KTtcblx0fVxuXG5cdC8vIElmIG5vIHNoYXByZSBjYWxjdWxhdGlvbiBtZXRob2Qgd2FzIGZvdW5kLCByZXR1cm4gZmFsc2Vcblx0ZWxzZSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIE1ha2Ugc3VyZSB3ZSBhY2NvdW50IGZvciBwYWRkaW5nIGFuZCBib3JkZXJzIG9uIHRoZSBpbWFnZVxuXHRpbWFnZU9mZnNldCA9IGltYWdlLm9mZnNldCgpO1xuXHRpbWFnZU9mZnNldC5sZWZ0ICs9IE1hdGguY2VpbCgoaW1hZ2Uub3V0ZXJXaWR0aChGQUxTRSkgLSBpbWFnZS53aWR0aCgpKSAvIDIpO1xuXHRpbWFnZU9mZnNldC50b3AgKz0gTWF0aC5jZWlsKChpbWFnZS5vdXRlckhlaWdodChGQUxTRSkgLSBpbWFnZS5oZWlnaHQoKSkgLyAyKTtcblxuXHQvLyBBZGQgaW1hZ2UgcG9zaXRpb24gdG8gb2Zmc2V0IGNvb3JkaW5hdGVzXG5cdHJlc3VsdC5wb3NpdGlvbi5sZWZ0ICs9IGltYWdlT2Zmc2V0LmxlZnQ7XG5cdHJlc3VsdC5wb3NpdGlvbi50b3AgKz0gaW1hZ2VPZmZzZXQudG9wO1xuXG5cdHJldHVybiByZXN1bHQ7XG59Ozt2YXIgSUU2LFxuXG4vKiBcbiAqIEJHSUZyYW1lIGFkYXB0aW9uIChodHRwOi8vcGx1Z2lucy5qcXVlcnkuY29tL3Byb2plY3QvYmdpZnJhbWUpXG4gKiBTcGVjaWFsIHRoYW5rcyB0byBCcmFuZG9uIEFhcm9uXG4gKi9cbkJHSUZSQU1FID0gJzxpZnJhbWUgY2xhc3M9XCJxdGlwLWJnaWZyYW1lXCIgZnJhbWVib3JkZXI9XCIwXCIgdGFiaW5kZXg9XCItMVwiIHNyYz1cImphdmFzY3JpcHQ6XFwnXFwnO1wiICcgK1xuXHQnIHN0eWxlPVwiZGlzcGxheTpibG9jazsgcG9zaXRpb246YWJzb2x1dGU7IHotaW5kZXg6LTE7IGZpbHRlcjphbHBoYShvcGFjaXR5PTApOyAnICtcblx0XHQnLW1zLWZpbHRlcjpcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTApXCI7XCI+PC9pZnJhbWU+JztcblxuZnVuY3Rpb24gSWU2KGFwaSwgcXRpcCkge1xuXHR0aGlzLl9ucyA9ICdpZTYnO1xuXHR0aGlzLmluaXQoICh0aGlzLnF0aXAgPSBhcGkpICk7XG59XG5cbiQuZXh0ZW5kKEllNi5wcm90b3R5cGUsIHtcblx0X3Njcm9sbCA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvdmVybGF5ID0gdGhpcy5xdGlwLmVsZW1lbnRzLm92ZXJsYXk7XG5cdFx0b3ZlcmxheSAmJiAob3ZlcmxheVswXS5zdHlsZS50b3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAncHgnKTtcblx0fSxcblxuXHRpbml0OiBmdW5jdGlvbihxdGlwKSB7XG5cdFx0dmFyIHRvb2x0aXAgPSBxdGlwLnRvb2x0aXAsXG5cdFx0XHRzY3JvbGw7XG5cblx0XHQvLyBDcmVhdGUgdGhlIEJHSUZyYW1lIGVsZW1lbnQgaWYgbmVlZGVkXG5cdFx0aWYoJCgnc2VsZWN0LCBvYmplY3QnKS5sZW5ndGggPCAxKSB7XG5cdFx0XHR0aGlzLmJnaWZyYW1lID0gcXRpcC5lbGVtZW50cy5iZ2lmcmFtZSA9ICQoQkdJRlJBTUUpLmFwcGVuZFRvKHRvb2x0aXApO1xuXG5cdFx0XHQvLyBVcGRhdGUgQkdJRnJhbWUgb24gdG9vbHRpcCBtb3ZlXG5cdFx0XHRxdGlwLl9iaW5kKHRvb2x0aXAsICd0b29sdGlwbW92ZScsIHRoaXMuYWRqdXN0QkdJRnJhbWUsIHRoaXMuX25zLCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyByZWRyYXcoKSBjb250YWluZXIgZm9yIHdpZHRoL2hlaWdodCBjYWxjdWxhdGlvbnNcblx0XHR0aGlzLnJlZHJhd0NvbnRhaW5lciA9ICQoJzxkaXYvPicsIHsgaWQ6IE5BTUVTUEFDRSsnLXJjb250YWluZXInIH0pXG5cdFx0XHQuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG5cblx0XHQvLyBGaXh1cCBtb2RhbCBwbHVnaW4gaWYgcHJlc2VudCB0b29cblx0XHRpZiggcXRpcC5lbGVtZW50cy5vdmVybGF5ICYmIHF0aXAuZWxlbWVudHMub3ZlcmxheS5hZGRDbGFzcygncXRpcG1vZGFsLWllNmZpeCcpICkge1xuXHRcdFx0cXRpcC5fYmluZCh3aW5kb3csIFsnc2Nyb2xsJywgJ3Jlc2l6ZSddLCB0aGlzLl9zY3JvbGwsIHRoaXMuX25zLCB0aGlzKTtcblx0XHRcdHF0aXAuX2JpbmQodG9vbHRpcCwgWyd0b29sdGlwc2hvdyddLCB0aGlzLl9zY3JvbGwsIHRoaXMuX25zLCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgZGltZW5zaW9uc1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0YWRqdXN0QkdJRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0b29sdGlwID0gdGhpcy5xdGlwLnRvb2x0aXAsXG5cdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRoZWlnaHQ6IHRvb2x0aXAub3V0ZXJIZWlnaHQoRkFMU0UpLFxuXHRcdFx0XHR3aWR0aDogdG9vbHRpcC5vdXRlcldpZHRoKEZBTFNFKVxuXHRcdFx0fSxcblx0XHRcdHBsdWdpbiA9IHRoaXMucXRpcC5wbHVnaW5zLnRpcCxcblx0XHRcdHRpcCA9IHRoaXMucXRpcC5lbGVtZW50cy50aXAsXG5cdFx0XHR0aXBBZGp1c3QsIG9mZnNldDtcblxuXHRcdC8vIEFkanVzdCBib3JkZXIgb2Zmc2V0XG5cdFx0b2Zmc2V0ID0gcGFyc2VJbnQodG9vbHRpcC5jc3MoJ2JvcmRlckxlZnRXaWR0aCcpLCAxMCkgfHwgMDtcblx0XHRvZmZzZXQgPSB7IGxlZnQ6IC1vZmZzZXQsIHRvcDogLW9mZnNldCB9O1xuXG5cdFx0Ly8gQWRqdXN0IGZvciB0aXBzIHBsdWdpblxuXHRcdGlmKHBsdWdpbiAmJiB0aXApIHtcblx0XHRcdHRpcEFkanVzdCA9IChwbHVnaW4uY29ybmVyLnByZWNlZGFuY2UgPT09ICd4JykgPyBbV0lEVEgsIExFRlRdIDogW0hFSUdIVCwgVE9QXTtcblx0XHRcdG9mZnNldFsgdGlwQWRqdXN0WzFdIF0gLT0gdGlwWyB0aXBBZGp1c3RbMF0gXSgpO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBiZ2lmcmFtZVxuXHRcdHRoaXMuYmdpZnJhbWUuY3NzKG9mZnNldCkuY3NzKGRpbWVuc2lvbnMpO1xuXHR9LFxuXG5cdC8vIE1heC9taW4gd2lkdGggc2ltdWxhdG9yIGZ1bmN0aW9uXG5cdHJlZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5xdGlwLnJlbmRlcmVkIDwgMSB8fCB0aGlzLmRyYXdpbmcpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHZhciB0b29sdGlwID0gdGhpcy5xdGlwLnRvb2x0aXAsXG5cdFx0XHRzdHlsZSA9IHRoaXMucXRpcC5vcHRpb25zLnN0eWxlLFxuXHRcdFx0Y29udGFpbmVyID0gdGhpcy5xdGlwLm9wdGlvbnMucG9zaXRpb24uY29udGFpbmVyLFxuXHRcdFx0cGVyYywgd2lkdGgsIG1heCwgbWluO1xuXG5cdFx0Ly8gU2V0IGRyYXdpbmcgZmxhZ1xuXHRcdHRoaXMucXRpcC5kcmF3aW5nID0gMTtcblxuXHRcdC8vIElmIHRvb2x0aXAgaGFzIGEgc2V0IGhlaWdodC93aWR0aCwganVzdCBzZXQgaXQuLi4gbGlrZSBhIGJvc3MhXG5cdFx0aWYoc3R5bGUuaGVpZ2h0KSB7IHRvb2x0aXAuY3NzKEhFSUdIVCwgc3R5bGUuaGVpZ2h0KTsgfVxuXHRcdGlmKHN0eWxlLndpZHRoKSB7IHRvb2x0aXAuY3NzKFdJRFRILCBzdHlsZS53aWR0aCk7IH1cblxuXHRcdC8vIFNpbXVsYXRlIG1heC9taW4gd2lkdGggaWYgbm90IHNldCB3aWR0aCBwcmVzZW50Li4uXG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBSZXNldCB3aWR0aCBhbmQgYWRkIGZsdWlkIGNsYXNzXG5cdFx0XHR0b29sdGlwLmNzcyhXSURUSCwgJycpLmFwcGVuZFRvKHRoaXMucmVkcmF3Q29udGFpbmVyKTtcblxuXHRcdFx0Ly8gR3JhYiBvdXIgdG9vbHRpcCB3aWR0aCAoYWRkIDEgaWYgb2RkIHNvIHdlIGRvbid0IGdldCB3cmFwcGluZyBwcm9ibGVtcy4uIGh1enphaCEpXG5cdFx0XHR3aWR0aCA9IHRvb2x0aXAud2lkdGgoKTtcblx0XHRcdGlmKHdpZHRoICUgMiA8IDEpIHsgd2lkdGggKz0gMTsgfVxuXG5cdFx0XHQvLyBHcmFiIG91ciBtYXgvbWluIHByb3BlcnRpZXNcblx0XHRcdG1heCA9IHRvb2x0aXAuY3NzKCdtYXhXaWR0aCcpIHx8ICcnO1xuXHRcdFx0bWluID0gdG9vbHRpcC5jc3MoJ21pbldpZHRoJykgfHwgJyc7XG5cblx0XHRcdC8vIFBhcnNlIGludG8gcHJvcGVyIHBpeGVsIHZhbHVlc1xuXHRcdFx0cGVyYyA9IChtYXggKyBtaW4pLmluZGV4T2YoJyUnKSA+IC0xID8gY29udGFpbmVyLndpZHRoKCkgLyAxMDAgOiAwO1xuXHRcdG1heCA9ICgobWF4LmluZGV4T2YoJyUnKSA+IC0xID8gcGVyYyA6IDEpICogcGFyc2VJbnQobWF4LCAxMCkpIHx8IHdpZHRoO1xuXHRcdFx0bWluID0gKChtaW4uaW5kZXhPZignJScpID4gLTEgPyBwZXJjIDogMSkgKiBwYXJzZUludChtaW4sIDEwKSkgfHwgMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIG5ldyBkaW1lbnNpb24gc2l6ZSBiYXNlZCBvbiBtYXgvbWluL2N1cnJlbnQgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IG1heCArIG1pbiA/IE1hdGgubWluKE1hdGgubWF4KHdpZHRoLCBtaW4pLCBtYXgpIDogd2lkdGg7XG5cblx0XHRcdC8vIFNldCB0aGUgbmV3bHkgY2FsY3VsYXRlZCB3aWR0aCBhbmQgcmVtdm9lIGZsdWlkIGNsYXNzXG5cdFx0XHR0b29sdGlwLmNzcyhXSURUSCwgTWF0aC5yb3VuZCh3aWR0aCkpLmFwcGVuZFRvKGNvbnRhaW5lcik7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGRyYXdpbmcgZmxhZ1xuXHRcdHRoaXMuZHJhd2luZyA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHQvLyBSZW1vdmUgaWZyYW1lXG5cdFx0dGhpcy5iZ2lmcmFtZSAmJiB0aGlzLmJnaWZyYW1lLnJlbW92ZSgpO1xuXG5cdFx0Ly8gUmVtb3ZlIGJvdW5kIGV2ZW50c1xuXHRcdHRoaXMucXRpcC5fdW5iaW5kKFt3aW5kb3csIHRoaXMucXRpcC50b29sdGlwXSwgdGhpcy5fbnMpO1xuXHR9XG59KTtcblxuSUU2ID0gUExVR0lOUy5pZTYgPSBmdW5jdGlvbihhcGkpIHtcblx0Ly8gUHJvY2VlZCBvbmx5IGlmIHRoZSBicm93c2VyIGlzIElFNlxuXHRyZXR1cm4gQlJPV1NFUi5pZSA9PT0gNiA/IG5ldyBJZTYoYXBpKSA6IEZBTFNFO1xufTtcblxuSUU2LmluaXRpYWxpemUgPSAncmVuZGVyJztcblxuQ0hFQ0tTLmllNiA9IHtcblx0J15jb250ZW50fHN0eWxlJCc6IGZ1bmN0aW9uKCkgeyBcblx0XHR0aGlzLnJlZHJhdygpO1xuXHR9XG59Ozt9KSk7XG59KCB3aW5kb3csIGRvY3VtZW50ICkpO1xuXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2pzL3BsdWdpbnMvanF1ZXJ5LXF0aXAvanF1ZXJ5LnF0aXAuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n")},function(module,exports){eval('/**\n * 对话框适配器\n * toastr不在额外添加、插件已经很方便了\n * 更多配置参照官网配置\n * paream： content,title\n * toastr.warning()\n * toastr.success()\n * toastr.error()\n * toastr.clear()\n * layer.msg(content, options, end) \n  */\njQuery(function(){\n\t//初始化标签对话框打开 eg:<a openDialog="流程设计" top="true" url=""></a>\n\tdialogHelper__.init();\n\tdialogHelper__.initDialogs();\n\tdialogHelper__.initCustDialogs();\n})\nvar dialogHelper__ = {};\ndialogHelper__.initDialogs = function(){\n\t\n\tjQuery.extend({\n\t\tDialog:{\n\t\t\t//icon:123456\n\t\t//1对号，2错，3问号，4锁，5难过脸，6笑脸，7，叹号\n\t\talert:function(content,fn,icon){\n\t\t\tif (fn && !jQuery.isFunction(fn)) icon=fn;\n\t\t\t\n\t\t\tif(icon == "error"){ icon = 2; }\n\t\t\tif(icon == "ask"){ icon = 3; }\n\t\t\tif(icon == "ok"){ icon = 1; }\n\t\t\tif(icon == "smiley"){ icon = 1; }\n\t\t\t\n\t\t\tvar conf = {skin:\'layer-ext-moon\',closeBtn: 0};\n\t\t\tif(icon)conf.icon = icon;\n\t\t\t\n\t\t\tconf.title = "提示信息"\n\t\t\t\n\t\t\ttop.layer.alert(content,conf,function(index){\n\t\t\t\tif(fn && jQuery.isFunction(fn))fn();\n\t\t\t\tif(top && top.layer){\n\t\t\t\t\ttop.layer.close(index);\n\t\t\t\t} \n\t\t\t\tlayer.close(index);\n\t\t\t});//http://layer.layui.com/skin.html#publish\n\t\t},\n\t\terror:function(content,fn){\n\t\t\tthis.alert(content,fn,2);\n\t\t},\n\t\tsuccess:function(content,fn){\n\t\t\tthis.alert(content,fn,6);\n\t\t},\n\t\twarning:function(content,fn){\n\t\t\tthis.alert(content,fn,7);\n\t\t},\n\t\t/**\n\t\t * 对话框\n\t\t * title:主题\n\t\t * content:内容\n\t\t * yesFn:确定回调函数\n\t\t * cancelFn:取消回调函数\n\t\t * conf:高级用法= =\n\t\t */\n\t\tconfirm:function(title,content,yesFn,cancelFn,conf){\n\t\t\tif(!conf){\n\t\t\t\tconf = {\n\t\t\t\t\t    btn: [\'确定\',\'取消\'],//按钮\n\t\t\t\t\t\ticon:3 \n\t\t\t\t\t}\n\t\t\t}\n\t\t\tvar tempfn = function(a){\n\t\t\t\tyesFn(a);\n\t\t\t\tlayer.closeAll(\'dialog\');\n\t\t\t}\n\t\t\tif(title){\n\t\t\t\tconf.title=title;\n\t\t\t}\n\t\t\tlayer.confirm(content,conf,tempfn,cancelFn);\n\t\t},\n\t\t/**@\n\t\t *  conf{title:头,url:访问url,height,width,data:data,topOpen:true}\\\n\t\t *  conf.btn==true/[btns123] 对应 fn conf.yes/conf.btn2,conf.btn3...\n\t\t */\n\t\topen:function(conf){\n\t\t\tif(conf.btn===true){\n\t\t\t\tconf.btn = ["确定","取消"];\n\t\t\t\tif(!conf.ok)alert("确定btn 没有回调？");\n\t\t\t}\n\t\t\tvar height=conf.height,\n\t\t\t\twidth=conf.width,\n\t\t\t\ttitle=conf.title,\n\t\t\t\turl=conf.url;\n\t\t\t\n\t\t\tvar openWindow = conf.topOpen ? top : window;\n\t\t\t\n\t\t\tvar iframeId ; \n\t\t\tif(url){\n\t\t\t\turl = dialogHelper__.getProjectUrl(url);\n\t\t\t\t \n\t\t\t\tconf.type = 1;\n\t\t\t\tiframeId ="dialogId_"+Math.random(1000);\n\t\t\t\tvar iframeHeight = conf.height > 360 ? "98%":"97%";\n\t\t\t\tvar iframe =\'<iframe  src="\'+url+\'" id="\'+iframeId+\'" name="\'+iframeId+\'" style="height:\'+iframeHeight+\';width:100%;border:none;"></iframe>\';\n\t\t\t\tconf.content = iframe;\n\t\t\t}\n\t\t\t\n\t\t\tif (!conf.type) {\n\t\t\t\tjQuery.Dialog.msg( \'请设置访问地址!或者指定对话框类型\');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t//弹出一个当前窗口大小的宽高\n\t\t\tif(!height){\n\t\t\t\theight = jQuery(openWindow).height();\n\t\t\t\twidth = jQuery(openWindow).width();\n\t\t\t}\n\t\t\t\n\t\t\tif(!height)height = 500;\n\t\t\tif(!width)width = 600;\n\t\t\t delete conf.url;\n\t\t\t delete conf.height;\n\t\t\t delete conf.width;\n\t\t\t\n\t\t\tvar dialogConf = {\n\t\t\t\t   // type: 2,\n\t\t\t\t    title: title,\n\t\t\t\t    maxmin: false, \n\t\t\t\t    closeBtn: 1,\n\t\t\t\t    shadeClose:false,\n\t\t\t\t    anim: -1 ,\n\t\t\t\t    area: [width+\'px\', height+\'px\'],\n\t\t\t\t    content: url\n\t\t\t\t};\n\t\t\tif(conf.ok){\n\t\t\t\tconf.yes = function(index, layero){\n\t\t\t\t\tif(iframeId){\n\t\t\t\t\t\tconf.ok(index,openWindow.document.getElementById(iframeId).contentWindow);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tconf.ok(index,layero);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!conf.btn){\n\t\t\t\t\tconf.btn = [\'确定\', \'取消\'];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tjQuery.extend(dialogConf,conf);\n\t\t\t\n\t\t\tvar index = openWindow.layer.open(dialogConf);\n\t\t\t\n\t\t\t// 记录index\n\t\t\tif(!openWindow.layerIndexRecord){openWindow.layerIndexRecord=[]}\n\t\t\topenWindow.layerIndexRecord.push(index);\n\t\t\t\n\t\t\tif(iframeId ){\n\t\t\t\tvar contentWindow = openWindow.document.getElementById(iframeId).contentWindow;\n\t\t\t\tcontentWindow.opener = window;\n\t\t\t\tif(conf.passData){\n\t\t\t\t\tcontentWindow.passData=conf.passData;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t//obj:window\n\t\tclose:function(obj){\n\t\t\tvar openner = parent;\n\t\t\t//若指定了当前window\n\t\t\tif(obj && typeof obj =="object"){\n\t\t\t\topenner =obj.parent;\n\t\t\t}\n\t\t\t//打开者\n\t\t\tvar openner = openner.layerIndexRecord ? openner : top ;\n\t\t\t//若是parent打开则直接清除掉所有记录\n\t\t\tvar index = openner.layerIndexRecord.pop();\n\t\t\tif(openner !==top ){\n\t\t\t\topenner.layerIndexRecord = null;\n\t\t\t}\n\t\t\tvar aa = openner.layer.close(index); \n\t\t},\n\t\tmsg:function(content){\n\t\t\ttop.layer.msg(content);\n\t\t}\n\t\t\n\t},\n\tToast:{\n\t\twarning:function(content,title){\n\t\t\tif(top.toastr){\n\t\t\t\ttop.toastr.warning(content,title)\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttoastr.warning(content,title);\n\t\t},\n\t\tsuccess:function(content,title){\n\t\t\tif(top.toastr){\n\t\t\t\ttop.toastr.success(content,title)\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttoastr.success(content,title);\n\t\t},\n\t\terror:function(content,title){\n\t\t\tif(!title)title = "错误提示！";\n\t\t\tif(top.toastr){\n\t\t\t\ttop.toastr.error(content,title)\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttoastr.error(content,title);\n\t\t}\n\t\t\n\t},\n\t//target eg:#id\n\tTips:function(content,target){\n\t\tlayer.tips(content, target);\n\t},\n\t//tab:{name:"tab名字",url:url,id:"标识"}\n\t\tTab:function(tab,fullTab){\n\t\t\ttop.addTab(tab,fullTab);\n\t\t}\n\t});\n\n}\n\ndialogHelper__ .init = function(){\n\t\tjQuery("body").delegate("[openDialog]",\'click\', function() {\n\t\t\tvar me = jQuery(this);\n\t\t\tvar url= dialogHelper__.getUrl(me);\n\t\t\tvar conf = {};\n\t\t\t\n\t\t\tvar dialogConf = me.attr("dialogConf");\n\t\t\tif(dialogConf){\n\t\t\t\tif(dialogConf.indexOf("{")==-1){\n\t\t\t\t\tdialogConf = "{"+dialogConf+"}";\n\t\t\t\t}\n\t\t\t\tdialogConf = eval("(" + dialogConf + ")"); \n\t\t\t\tconf.height = dialogConf.height;\n\t\t\t\tconf.width = dialogConf.width;\n\t\t\t}else{\n\t\t\t\tconf.height = 0;\n\t\t\t}\n\t\t\tvar text = me.attr("openDialog")|| me.text();\n\t\t\tconf.url = url;\n\t\t\tconf.title = text;\n\t\t\tconf.topOpen = me.attr("top");\n\t\t\tjQuery.Dialog.open(conf);\n\t\t});\n\t}\ndialogHelper__ .getUrl = function(obj){\n\t\tvar url = obj.attr("url");\n\t\tif(!url)return "";\n\t\t\n\t\tif(url.substr(0,7)!="http://" && url.indexOf("html")==-1){\n\t\t\turl = url + ".html";\n\t\t}\n\t\t\n\t\tif(url.indexOf("?")!=-1){\n\t\t\turl = url.format(jQuery.getParams());\n\t\t}\n\t\t\n\t\treturn url;\n\t}\ndialogHelper__.initCustDialogs = function(){\n\twindow.CustUtil = {\n\t\t/**\n\t\t * @key 自定义对话框的别名\n\t\t * @callback 回调函数\n\t\t * @param 调用动态参数\n\t\t * @dialogSetting 强行修改key对话框的参数，用这个json数据中有的字段覆盖原有对话框的配置\n\t\t * @initData 初始化回显的数据\n\t\t * @closeDialog 确认后是否关闭对话框\n\t\t */\n\t\topenCustDialog:function(key,param,callBack,initData,dialogSetting,closeDialog){\n\t\t\tif (jQuery.isFunction(param)) {\n\t\t\t\tdialogSetting = initData;\n\t\t\t\tinitData = callBack;\n\t\t\t\tcallBack = param;\n\t\t\t\tparam = {}; \n\t\t\t}\n\t\t\t\n\t\t\tif(!callBack){\n\t\t\t\tcallBack = function(data,innerwin) {\n\t\t\t\t\tjQuery.Dialog.alert(JSON.stringify(data),function(){\n\t\t\t\t\t\tjQuery.Dialog.close(innerwin);\n\t\t\t\t\t},6);\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tvar conf = {\n\t\t\t\t\theight:600,\n\t\t\t\t\twidth:800,  \n\t\t\t\t\turl: "/form/formCustDialog/formCustDialogShowList.html?key="+key,// url不为空则使用iframe类型对话框\n\t\t\t\t\ttitle:"",\n\t\t\t\t\ttopOpen:true,\n\t\t\t\t\tbtn:true, \n\t\t\t\t\tcloseBtn:1,\n\t\t\t};\n\t\t\tjQuery.post(__ctx+"/form/formCustDialog/getObject?key="+key,{},function(result){\n\t\t\t\tvar dialogConf = result.data;\n\t\t\t\tif(!dialogConf){\n\t\t\t\t\tjQuery.Dialog.error("对话框查找不到"+key);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconf.height = dialogConf.height;\n\t\t\t\tconf.width = dialogConf.width;\n\t\t\t\tconf.title = dialogConf.name;\n\t\t\t\twindow.CustUtil.handleParam(dialogConf,param);\n\t\t\t\t\n\t\t\t\tvar passData = {\n\t\t\t\t\tparams : param,\n\t\t\t\t\tinitData : initData,\n\t\t\t\t\tdialogSetting : dialogSetting\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tconf.passData = passData;\n\t\t\t\tif(dialogConf.style==="tree"){//树形url修改\n\t\t\t\t\tconf.url="/form/formCustDialog/formCustDialogShowTree.html?key="+key;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjQuery.Dialog.open(conf); \n\t\t\t},"json");\n\t\t\t\n\t\t\tconf.ok = function(index,innerWindow){\n\t\t\t\tcallBack(innerWindow.getData(),innerWindow);\n\t\t\t\tif(closeDialog){\n\t\t\t\t\tjQuery.Dialog.close(innerWindow);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * 自定义查询其实是自定义对话框的一种简略调用\n\t\t * @key 自定义对话框的别名\n\t\t * @callback 回调函数\n\t\t * @param 调用动态参数\n\t\t * @dialogSetting 强行修改key对话框的参数，用这个json数据中有的字段覆盖原有对话框的配置\n\t\t */\n\t\tdoCustQuery:function(key, param, callBack, dialogSetting){\n\t\t\tif (jQuery.isFunction(param)) {\n\t\t\t\tdialogSetting = callBack;\n\t\t\t\tcallBack = param;\n\t\t\t\tparam = {};\n\t\t\t}\n\t\t\t\n\t\t\tif(!param){\n\t\t\t\tparam = {};\n\t\t\t}\n\t\t\t\n\t\t\tif (!callBack) {\n\t\t\t\tcallBack = function(data) {\n\t\t\t\t\tjQuery.Dialog.alert(JSON.stringify(data));\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tjQuery.post(__ctx + "/form/formCustDialog/getObject?key=" + key, {}, function(result) {\n\t\t\t\tvar dialogConf = result.data;\n\t\t\t\tdialogConf = jQuery.extend(dialogConf, dialogSetting);\n\t\t\t\t\n\t\t\t\t//1 修改对话框的配置\n\t\t\t\tif (dialogConf.page) {// 默认有分页配置\n\t\t\t\t\tif (param.offset == null) {// 入参没有对分页页码\n\t\t\t\t\t\tparam.offset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (param.limit == null) {// 入参没有对分页长度\n\t\t\t\t\t\tparam.limit = dialogConf.pageSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//2 根据条件配置修改入参\n\t\t\t\twindow.CustUtil.handleParam(dialogConf,param);\n\t\t\t\t\n\t\t\t\t//3 发请求\n\t\t\t\tjQuery.post(__ctx + "/form/formCustDialog/listData_" + key, param, function(rlt) {\n\t\t\t\t\t//转一下返回字段\n\t\t\t\t\tvar datas = [];\n\t\t\t\t\tjQuery.each(rlt.rows, function(index,row) {\n\t\t\t\t\t\tvar data = {};\n\t\t\t\t\t\tjQuery.each(dialogConf.returnFields, function(i,field) {\n\t\t\t\t\t\t\tdata[field.returnName] = row[field.columnName];\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdatas.push(data);\n\t\t\t\t\t});\n\t\t\t\t\tcallBack(datas);\n\t\t\t\t}, "json");\n\t\t\t\t\n\t\t\t}, "json");\n\t\t},\n\t\t/**\n\t\t * 处理js传来参数结合对话框的条件处理一下\n\t\t */\n\t\thandleParam:function(dialog,param){\n\t\t\tif(!param){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tjQuery.each(dialog.conditionFields, function(index,field) {\n\t\t\t\tjQuery.each(param, function(key, val) {\n\t\t\t\t\tif (key !== field.columnName) {//找到key等于条件参数的\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t//帮忙key拼装配置中的查询条件，当然如果param中的key有写好的^这种写法这里是不干预的\n\t\t\t\t\tvar id = field.columnName + "^";\n\t\t\t\t\tif (field.dbType === "varchar") {\n\t\t\t\t\t\tid += "V";\n\t\t\t\t\t}\n\t\t\t\t\tif (field.dbType === "number") {\n\t\t\t\t\t\tid += "N";\n\t\t\t\t\t}\n\t\t\t\t\tif (field.dbType === "date") {\n\t\t\t\t\t\tid += "D";\n\t\t\t\t\t}\n\t\t\t\t\tid += field.condition;\n\t\t\t\t\tparam[id] = val;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\ndialogHelper__.getProjectUrl = function(url){\n\t//由于对话框只为前端页面打开，故此目前以/开头则自动加上前端的 projectpath，不以开头则说明相对路径。自动装载地址\n\tif(url && url.indexOf("http://")==-1 && url.substring(0,1)==="/"){\n\t\t var pathname =window.document.location.pathname;\n\t\t var projectPath = pathname.substring(0,pathname.substr(1).indexOf(\'/\')+1);\n\t\t // 特殊处理下流程设计器\n\t\t if(projectPath === \'\' || "/bus,/bpm,/sys,/org,/form,/flow-editor".indexOf(projectPath)!= -1){\n\t\t\t return url;\n\t\t }\n\t\tif(url.startWith(projectPath)){\n\t\t\treturn url;\n\t\t}\n\t\t return projectPath+url;\n\t}\n\treturn url;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvY29tbW9uL3Rvb2xzL2RpYWxvZ0NyZWF0b3IuanM/M2I2NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQyxxQkFBcUIsVUFBVTtBQUMvQixvQkFBb0IsVUFBVTtBQUM5Qix3QkFBd0IsVUFBVTs7QUFFbEMsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBO0FBQ0EsSUFBSSxFQUFFO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFzRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsV0FBVyxZQUFZO0FBQ3BJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0EsOEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQSw2QjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLOztBQUVMLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOWvueivneahhumAgumFjeWZqFxuICogdG9hc3Ry5LiN5Zyo6aKd5aSW5re75Yqg44CB5o+S5Lu25bey57uP5b6I5pa55L6/5LqGXG4gKiDmm7TlpJrphY3nva7lj4LnhaflrpjnvZHphY3nva5cbiAqIHBhcmVhbe+8miBjb250ZW50LHRpdGxlXG4gKiB0b2FzdHIud2FybmluZygpXG4gKiB0b2FzdHIuc3VjY2VzcygpXG4gKiB0b2FzdHIuZXJyb3IoKVxuICogdG9hc3RyLmNsZWFyKClcbiAqIGxheWVyLm1zZyhjb250ZW50LCBvcHRpb25zLCBlbmQpIFxuICAqL1xualF1ZXJ5KGZ1bmN0aW9uKCl7XG5cdC8v5Yid5aeL5YyW5qCH562+5a+56K+d5qGG5omT5byAIGVnOjxhIG9wZW5EaWFsb2c9XCLmtYHnqIvorr7orqFcIiB0b3A9XCJ0cnVlXCIgdXJsPVwiXCI+PC9hPlxuXHRkaWFsb2dIZWxwZXJfXy5pbml0KCk7XG5cdGRpYWxvZ0hlbHBlcl9fLmluaXREaWFsb2dzKCk7XG5cdGRpYWxvZ0hlbHBlcl9fLmluaXRDdXN0RGlhbG9ncygpO1xufSlcbnZhciBkaWFsb2dIZWxwZXJfXyA9IHt9O1xuZGlhbG9nSGVscGVyX18uaW5pdERpYWxvZ3MgPSBmdW5jdGlvbigpe1xuXHRcblx0alF1ZXJ5LmV4dGVuZCh7XG5cdFx0RGlhbG9nOntcblx0XHRcdC8vaWNvbjoxMjM0NTZcblx0XHQvLzHlr7nlj7fvvIwy6ZSZ77yMM+mXruWPt++8jDTplIHvvIw16Zq+6L+H6IS477yMNueskeiEuO+8jDfvvIzlj7nlj7dcblx0XHRhbGVydDpmdW5jdGlvbihjb250ZW50LGZuLGljb24pe1xuXHRcdFx0aWYgKGZuICYmICFqUXVlcnkuaXNGdW5jdGlvbihmbikpIGljb249Zm47XG5cdFx0XHRcblx0XHRcdGlmKGljb24gPT0gXCJlcnJvclwiKXsgaWNvbiA9IDI7IH1cblx0XHRcdGlmKGljb24gPT0gXCJhc2tcIil7IGljb24gPSAzOyB9XG5cdFx0XHRpZihpY29uID09IFwib2tcIil7IGljb24gPSAxOyB9XG5cdFx0XHRpZihpY29uID09IFwic21pbGV5XCIpeyBpY29uID0gMTsgfVxuXHRcdFx0XG5cdFx0XHR2YXIgY29uZiA9IHtza2luOidsYXllci1leHQtbW9vbicsY2xvc2VCdG46IDB9O1xuXHRcdFx0aWYoaWNvbiljb25mLmljb24gPSBpY29uO1xuXHRcdFx0XG5cdFx0XHRjb25mLnRpdGxlID0gXCLmj5DnpLrkv6Hmga9cIlxuXHRcdFx0XG5cdFx0XHR0b3AubGF5ZXIuYWxlcnQoY29udGVudCxjb25mLGZ1bmN0aW9uKGluZGV4KXtcblx0XHRcdFx0aWYoZm4gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oZm4pKWZuKCk7XG5cdFx0XHRcdGlmKHRvcCAmJiB0b3AubGF5ZXIpe1xuXHRcdFx0XHRcdHRvcC5sYXllci5jbG9zZShpbmRleCk7XG5cdFx0XHRcdH0gXG5cdFx0XHRcdGxheWVyLmNsb3NlKGluZGV4KTtcblx0XHRcdH0pOy8vaHR0cDovL2xheWVyLmxheXVpLmNvbS9za2luLmh0bWwjcHVibGlzaFxuXHRcdH0sXG5cdFx0ZXJyb3I6ZnVuY3Rpb24oY29udGVudCxmbil7XG5cdFx0XHR0aGlzLmFsZXJ0KGNvbnRlbnQsZm4sMik7XG5cdFx0fSxcblx0XHRzdWNjZXNzOmZ1bmN0aW9uKGNvbnRlbnQsZm4pe1xuXHRcdFx0dGhpcy5hbGVydChjb250ZW50LGZuLDYpO1xuXHRcdH0sXG5cdFx0d2FybmluZzpmdW5jdGlvbihjb250ZW50LGZuKXtcblx0XHRcdHRoaXMuYWxlcnQoY29udGVudCxmbiw3KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIOWvueivneahhlxuXHRcdCAqIHRpdGxlOuS4u+mimFxuXHRcdCAqIGNvbnRlbnQ65YaF5a65XG5cdFx0ICogeWVzRm4656Gu5a6a5Zue6LCD5Ye95pWwXG5cdFx0ICogY2FuY2VsRm465Y+W5raI5Zue6LCD5Ye95pWwXG5cdFx0ICogY29uZjrpq5jnuqfnlKjms5U9ID1cblx0XHQgKi9cblx0XHRjb25maXJtOmZ1bmN0aW9uKHRpdGxlLGNvbnRlbnQseWVzRm4sY2FuY2VsRm4sY29uZil7XG5cdFx0XHRpZighY29uZil7XG5cdFx0XHRcdGNvbmYgPSB7XG5cdFx0XHRcdFx0ICAgIGJ0bjogWyfnoa7lrponLCflj5bmtognXSwvL+aMiemSrlxuXHRcdFx0XHRcdFx0aWNvbjozIFxuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciB0ZW1wZm4gPSBmdW5jdGlvbihhKXtcblx0XHRcdFx0eWVzRm4oYSk7XG5cdFx0XHRcdGxheWVyLmNsb3NlQWxsKCdkaWFsb2cnKTtcblx0XHRcdH1cblx0XHRcdGlmKHRpdGxlKXtcblx0XHRcdFx0Y29uZi50aXRsZT10aXRsZTtcblx0XHRcdH1cblx0XHRcdGxheWVyLmNvbmZpcm0oY29udGVudCxjb25mLHRlbXBmbixjYW5jZWxGbik7XG5cdFx0fSxcblx0XHQvKipAXG5cdFx0ICogIGNvbmZ7dGl0bGU65aS0LHVybDrorr/pl651cmwsaGVpZ2h0LHdpZHRoLGRhdGE6ZGF0YSx0b3BPcGVuOnRydWV9XFxcblx0XHQgKiAgY29uZi5idG49PXRydWUvW2J0bnMxMjNdIOWvueW6lCBmbiBjb25mLnllcy9jb25mLmJ0bjIsY29uZi5idG4zLi4uXG5cdFx0ICovXG5cdFx0b3BlbjpmdW5jdGlvbihjb25mKXtcblx0XHRcdGlmKGNvbmYuYnRuPT09dHJ1ZSl7XG5cdFx0XHRcdGNvbmYuYnRuID0gW1wi56Gu5a6aXCIsXCLlj5bmtohcIl07XG5cdFx0XHRcdGlmKCFjb25mLm9rKWFsZXJ0KFwi56Gu5a6aYnRuIOayoeacieWbnuiwg++8n1wiKTtcblx0XHRcdH1cblx0XHRcdHZhciBoZWlnaHQ9Y29uZi5oZWlnaHQsXG5cdFx0XHRcdHdpZHRoPWNvbmYud2lkdGgsXG5cdFx0XHRcdHRpdGxlPWNvbmYudGl0bGUsXG5cdFx0XHRcdHVybD1jb25mLnVybDtcblx0XHRcdFxuXHRcdFx0dmFyIG9wZW5XaW5kb3cgPSBjb25mLnRvcE9wZW4gPyB0b3AgOiB3aW5kb3c7XG5cdFx0XHRcblx0XHRcdHZhciBpZnJhbWVJZCA7IFxuXHRcdFx0aWYodXJsKXtcblx0XHRcdFx0dXJsID0gZGlhbG9nSGVscGVyX18uZ2V0UHJvamVjdFVybCh1cmwpO1xuXHRcdFx0XHQgXG5cdFx0XHRcdGNvbmYudHlwZSA9IDE7XG5cdFx0XHRcdGlmcmFtZUlkID1cImRpYWxvZ0lkX1wiK01hdGgucmFuZG9tKDEwMDApO1xuXHRcdFx0XHR2YXIgaWZyYW1lSGVpZ2h0ID0gY29uZi5oZWlnaHQgPiAzNjAgPyBcIjk4JVwiOlwiOTclXCI7XG5cdFx0XHRcdHZhciBpZnJhbWUgPSc8aWZyYW1lICBzcmM9XCInK3VybCsnXCIgaWQ9XCInK2lmcmFtZUlkKydcIiBuYW1lPVwiJytpZnJhbWVJZCsnXCIgc3R5bGU9XCJoZWlnaHQ6JytpZnJhbWVIZWlnaHQrJzt3aWR0aDoxMDAlO2JvcmRlcjpub25lO1wiPjwvaWZyYW1lPic7XG5cdFx0XHRcdGNvbmYuY29udGVudCA9IGlmcmFtZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFjb25mLnR5cGUpIHtcblx0XHRcdFx0alF1ZXJ5LkRpYWxvZy5tc2coICfor7forr7nva7orr/pl67lnLDlnYAh5oiW6ICF5oyH5a6a5a+56K+d5qGG57G75Z6LJyk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly/lvLnlh7rkuIDkuKrlvZPliY3nqpflj6PlpKflsI/nmoTlrr3pq5hcblx0XHRcdGlmKCFoZWlnaHQpe1xuXHRcdFx0XHRoZWlnaHQgPSBqUXVlcnkob3BlbldpbmRvdykuaGVpZ2h0KCk7XG5cdFx0XHRcdHdpZHRoID0galF1ZXJ5KG9wZW5XaW5kb3cpLndpZHRoKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKCFoZWlnaHQpaGVpZ2h0ID0gNTAwO1xuXHRcdFx0aWYoIXdpZHRoKXdpZHRoID0gNjAwO1xuXHRcdFx0IGRlbGV0ZSBjb25mLnVybDtcblx0XHRcdCBkZWxldGUgY29uZi5oZWlnaHQ7XG5cdFx0XHQgZGVsZXRlIGNvbmYud2lkdGg7XG5cdFx0XHRcblx0XHRcdHZhciBkaWFsb2dDb25mID0ge1xuXHRcdFx0XHQgICAvLyB0eXBlOiAyLFxuXHRcdFx0XHQgICAgdGl0bGU6IHRpdGxlLFxuXHRcdFx0XHQgICAgbWF4bWluOiBmYWxzZSwgXG5cdFx0XHRcdCAgICBjbG9zZUJ0bjogMSxcblx0XHRcdFx0ICAgIHNoYWRlQ2xvc2U6ZmFsc2UsXG5cdFx0XHRcdCAgICBhbmltOiAtMSAsXG5cdFx0XHRcdCAgICBhcmVhOiBbd2lkdGgrJ3B4JywgaGVpZ2h0KydweCddLFxuXHRcdFx0XHQgICAgY29udGVudDogdXJsXG5cdFx0XHRcdH07XG5cdFx0XHRpZihjb25mLm9rKXtcblx0XHRcdFx0Y29uZi55ZXMgPSBmdW5jdGlvbihpbmRleCwgbGF5ZXJvKXtcblx0XHRcdFx0XHRpZihpZnJhbWVJZCl7XG5cdFx0XHRcdFx0XHRjb25mLm9rKGluZGV4LG9wZW5XaW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWZyYW1lSWQpLmNvbnRlbnRXaW5kb3cpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Y29uZi5vayhpbmRleCxsYXllcm8pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZighY29uZi5idG4pe1xuXHRcdFx0XHRcdGNvbmYuYnRuID0gWyfnoa7lrponLCAn5Y+W5raIJ107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0alF1ZXJ5LmV4dGVuZChkaWFsb2dDb25mLGNvbmYpO1xuXHRcdFx0XG5cdFx0XHR2YXIgaW5kZXggPSBvcGVuV2luZG93LmxheWVyLm9wZW4oZGlhbG9nQ29uZik7XG5cdFx0XHRcblx0XHRcdC8vIOiusOW9lWluZGV4XG5cdFx0XHRpZighb3BlbldpbmRvdy5sYXllckluZGV4UmVjb3JkKXtvcGVuV2luZG93LmxheWVySW5kZXhSZWNvcmQ9W119XG5cdFx0XHRvcGVuV2luZG93LmxheWVySW5kZXhSZWNvcmQucHVzaChpbmRleCk7XG5cdFx0XHRcblx0XHRcdGlmKGlmcmFtZUlkICl7XG5cdFx0XHRcdHZhciBjb250ZW50V2luZG93ID0gb3BlbldpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZnJhbWVJZCkuY29udGVudFdpbmRvdztcblx0XHRcdFx0Y29udGVudFdpbmRvdy5vcGVuZXIgPSB3aW5kb3c7XG5cdFx0XHRcdGlmKGNvbmYucGFzc0RhdGEpe1xuXHRcdFx0XHRcdGNvbnRlbnRXaW5kb3cucGFzc0RhdGE9Y29uZi5wYXNzRGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSxcblx0XHQvL29iajp3aW5kb3dcblx0XHRjbG9zZTpmdW5jdGlvbihvYmope1xuXHRcdFx0dmFyIG9wZW5uZXIgPSBwYXJlbnQ7XG5cdFx0XHQvL+iLpeaMh+WumuS6huW9k+WJjXdpbmRvd1xuXHRcdFx0aWYob2JqICYmIHR5cGVvZiBvYmogPT1cIm9iamVjdFwiKXtcblx0XHRcdFx0b3Blbm5lciA9b2JqLnBhcmVudDtcblx0XHRcdH1cblx0XHRcdC8v5omT5byA6ICFXG5cdFx0XHR2YXIgb3Blbm5lciA9IG9wZW5uZXIubGF5ZXJJbmRleFJlY29yZCA/IG9wZW5uZXIgOiB0b3AgO1xuXHRcdFx0Ly/oi6XmmK9wYXJlbnTmiZPlvIDliJnnm7TmjqXmuIXpmaTmjonmiYDmnInorrDlvZVcblx0XHRcdHZhciBpbmRleCA9IG9wZW5uZXIubGF5ZXJJbmRleFJlY29yZC5wb3AoKTtcblx0XHRcdGlmKG9wZW5uZXIgIT09dG9wICl7XG5cdFx0XHRcdG9wZW5uZXIubGF5ZXJJbmRleFJlY29yZCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYWEgPSBvcGVubmVyLmxheWVyLmNsb3NlKGluZGV4KTsgXG5cdFx0fSxcblx0XHRtc2c6ZnVuY3Rpb24oY29udGVudCl7XG5cdFx0XHR0b3AubGF5ZXIubXNnKGNvbnRlbnQpO1xuXHRcdH1cblx0XHRcblx0fSxcblx0VG9hc3Q6e1xuXHRcdHdhcm5pbmc6ZnVuY3Rpb24oY29udGVudCx0aXRsZSl7XG5cdFx0XHRpZih0b3AudG9hc3RyKXtcblx0XHRcdFx0dG9wLnRvYXN0ci53YXJuaW5nKGNvbnRlbnQsdGl0bGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRvYXN0ci53YXJuaW5nKGNvbnRlbnQsdGl0bGUpO1xuXHRcdH0sXG5cdFx0c3VjY2VzczpmdW5jdGlvbihjb250ZW50LHRpdGxlKXtcblx0XHRcdGlmKHRvcC50b2FzdHIpe1xuXHRcdFx0XHR0b3AudG9hc3RyLnN1Y2Nlc3MoY29udGVudCx0aXRsZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dG9hc3RyLnN1Y2Nlc3MoY29udGVudCx0aXRsZSk7XG5cdFx0fSxcblx0XHRlcnJvcjpmdW5jdGlvbihjb250ZW50LHRpdGxlKXtcblx0XHRcdGlmKCF0aXRsZSl0aXRsZSA9IFwi6ZSZ6K+v5o+Q56S677yBXCI7XG5cdFx0XHRpZih0b3AudG9hc3RyKXtcblx0XHRcdFx0dG9wLnRvYXN0ci5lcnJvcihjb250ZW50LHRpdGxlKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0b2FzdHIuZXJyb3IoY29udGVudCx0aXRsZSk7XG5cdFx0fVxuXHRcdFxuXHR9LFxuXHQvL3RhcmdldCBlZzojaWRcblx0VGlwczpmdW5jdGlvbihjb250ZW50LHRhcmdldCl7XG5cdFx0bGF5ZXIudGlwcyhjb250ZW50LCB0YXJnZXQpO1xuXHR9LFxuXHQvL3RhYjp7bmFtZTpcInRhYuWQjeWtl1wiLHVybDp1cmwsaWQ6XCLmoIfor4ZcIn1cblx0XHRUYWI6ZnVuY3Rpb24odGFiLGZ1bGxUYWIpe1xuXHRcdFx0dG9wLmFkZFRhYih0YWIsZnVsbFRhYik7XG5cdFx0fVxuXHR9KTtcblxufVxuXG5kaWFsb2dIZWxwZXJfXyAuaW5pdCA9IGZ1bmN0aW9uKCl7XG5cdFx0alF1ZXJ5KFwiYm9keVwiKS5kZWxlZ2F0ZShcIltvcGVuRGlhbG9nXVwiLCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lID0galF1ZXJ5KHRoaXMpO1xuXHRcdFx0dmFyIHVybD0gZGlhbG9nSGVscGVyX18uZ2V0VXJsKG1lKTtcblx0XHRcdHZhciBjb25mID0ge307XG5cdFx0XHRcblx0XHRcdHZhciBkaWFsb2dDb25mID0gbWUuYXR0cihcImRpYWxvZ0NvbmZcIik7XG5cdFx0XHRpZihkaWFsb2dDb25mKXtcblx0XHRcdFx0aWYoZGlhbG9nQ29uZi5pbmRleE9mKFwie1wiKT09LTEpe1xuXHRcdFx0XHRcdGRpYWxvZ0NvbmYgPSBcIntcIitkaWFsb2dDb25mK1wifVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRpYWxvZ0NvbmYgPSBldmFsKFwiKFwiICsgZGlhbG9nQ29uZiArIFwiKVwiKTsgXG5cdFx0XHRcdGNvbmYuaGVpZ2h0ID0gZGlhbG9nQ29uZi5oZWlnaHQ7XG5cdFx0XHRcdGNvbmYud2lkdGggPSBkaWFsb2dDb25mLndpZHRoO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGNvbmYuaGVpZ2h0ID0gMDtcblx0XHRcdH1cblx0XHRcdHZhciB0ZXh0ID0gbWUuYXR0cihcIm9wZW5EaWFsb2dcIil8fCBtZS50ZXh0KCk7XG5cdFx0XHRjb25mLnVybCA9IHVybDtcblx0XHRcdGNvbmYudGl0bGUgPSB0ZXh0O1xuXHRcdFx0Y29uZi50b3BPcGVuID0gbWUuYXR0cihcInRvcFwiKTtcblx0XHRcdGpRdWVyeS5EaWFsb2cub3Blbihjb25mKTtcblx0XHR9KTtcblx0fVxuZGlhbG9nSGVscGVyX18gLmdldFVybCA9IGZ1bmN0aW9uKG9iail7XG5cdFx0dmFyIHVybCA9IG9iai5hdHRyKFwidXJsXCIpO1xuXHRcdGlmKCF1cmwpcmV0dXJuIFwiXCI7XG5cdFx0XG5cdFx0aWYodXJsLnN1YnN0cigwLDcpIT1cImh0dHA6Ly9cIiAmJiB1cmwuaW5kZXhPZihcImh0bWxcIik9PS0xKXtcblx0XHRcdHVybCA9IHVybCArIFwiLmh0bWxcIjtcblx0XHR9XG5cdFx0XG5cdFx0aWYodXJsLmluZGV4T2YoXCI/XCIpIT0tMSl7XG5cdFx0XHR1cmwgPSB1cmwuZm9ybWF0KGpRdWVyeS5nZXRQYXJhbXMoKSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB1cmw7XG5cdH1cbmRpYWxvZ0hlbHBlcl9fLmluaXRDdXN0RGlhbG9ncyA9IGZ1bmN0aW9uKCl7XG5cdHdpbmRvdy5DdXN0VXRpbCA9IHtcblx0XHQvKipcblx0XHQgKiBAa2V5IOiHquWumuS5ieWvueivneahhueahOWIq+WQjVxuXHRcdCAqIEBjYWxsYmFjayDlm57osIPlh73mlbBcblx0XHQgKiBAcGFyYW0g6LCD55So5Yqo5oCB5Y+C5pWwXG5cdFx0ICogQGRpYWxvZ1NldHRpbmcg5by66KGM5L+u5pS5a2V55a+56K+d5qGG55qE5Y+C5pWw77yM55So6L+Z5LiqanNvbuaVsOaNruS4reacieeahOWtl+auteimhuebluWOn+acieWvueivneahhueahOmFjee9rlxuXHRcdCAqIEBpbml0RGF0YSDliJ3lp4vljJblm57mmL7nmoTmlbDmja5cblx0XHQgKiBAY2xvc2VEaWFsb2cg56Gu6K6k5ZCO5piv5ZCm5YWz6Zet5a+56K+d5qGGXG5cdFx0ICovXG5cdFx0b3BlbkN1c3REaWFsb2c6ZnVuY3Rpb24oa2V5LHBhcmFtLGNhbGxCYWNrLGluaXREYXRhLGRpYWxvZ1NldHRpbmcsY2xvc2VEaWFsb2cpe1xuXHRcdFx0aWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHBhcmFtKSkge1xuXHRcdFx0XHRkaWFsb2dTZXR0aW5nID0gaW5pdERhdGE7XG5cdFx0XHRcdGluaXREYXRhID0gY2FsbEJhY2s7XG5cdFx0XHRcdGNhbGxCYWNrID0gcGFyYW07XG5cdFx0XHRcdHBhcmFtID0ge307IFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZighY2FsbEJhY2spe1xuXHRcdFx0XHRjYWxsQmFjayA9IGZ1bmN0aW9uKGRhdGEsaW5uZXJ3aW4pIHtcblx0XHRcdFx0XHRqUXVlcnkuRGlhbG9nLmFsZXJ0KEpTT04uc3RyaW5naWZ5KGRhdGEpLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRqUXVlcnkuRGlhbG9nLmNsb3NlKGlubmVyd2luKTtcblx0XHRcdFx0XHR9LDYpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR2YXIgY29uZiA9IHtcblx0XHRcdFx0XHRoZWlnaHQ6NjAwLFxuXHRcdFx0XHRcdHdpZHRoOjgwMCwgIFxuXHRcdFx0XHRcdHVybDogXCIvZm9ybS9mb3JtQ3VzdERpYWxvZy9mb3JtQ3VzdERpYWxvZ1Nob3dMaXN0Lmh0bWw/a2V5PVwiK2tleSwvLyB1cmzkuI3kuLrnqbrliJnkvb/nlKhpZnJhbWXnsbvlnovlr7nor53moYZcblx0XHRcdFx0XHR0aXRsZTpcIlwiLFxuXHRcdFx0XHRcdHRvcE9wZW46dHJ1ZSxcblx0XHRcdFx0XHRidG46dHJ1ZSwgXG5cdFx0XHRcdFx0Y2xvc2VCdG46MSxcblx0XHRcdH07XG5cdFx0XHRqUXVlcnkucG9zdChfX2N0eCtcIi9mb3JtL2Zvcm1DdXN0RGlhbG9nL2dldE9iamVjdD9rZXk9XCIra2V5LHt9LGZ1bmN0aW9uKHJlc3VsdCl7XG5cdFx0XHRcdHZhciBkaWFsb2dDb25mID0gcmVzdWx0LmRhdGE7XG5cdFx0XHRcdGlmKCFkaWFsb2dDb25mKXtcblx0XHRcdFx0XHRqUXVlcnkuRGlhbG9nLmVycm9yKFwi5a+56K+d5qGG5p+l5om+5LiN5YiwXCIra2V5KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbmYuaGVpZ2h0ID0gZGlhbG9nQ29uZi5oZWlnaHQ7XG5cdFx0XHRcdGNvbmYud2lkdGggPSBkaWFsb2dDb25mLndpZHRoO1xuXHRcdFx0XHRjb25mLnRpdGxlID0gZGlhbG9nQ29uZi5uYW1lO1xuXHRcdFx0XHR3aW5kb3cuQ3VzdFV0aWwuaGFuZGxlUGFyYW0oZGlhbG9nQ29uZixwYXJhbSk7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgcGFzc0RhdGEgPSB7XG5cdFx0XHRcdFx0cGFyYW1zIDogcGFyYW0sXG5cdFx0XHRcdFx0aW5pdERhdGEgOiBpbml0RGF0YSxcblx0XHRcdFx0XHRkaWFsb2dTZXR0aW5nIDogZGlhbG9nU2V0dGluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uZi5wYXNzRGF0YSA9IHBhc3NEYXRhO1xuXHRcdFx0XHRpZihkaWFsb2dDb25mLnN0eWxlPT09XCJ0cmVlXCIpey8v5qCR5b2idXJs5L+u5pS5XG5cdFx0XHRcdFx0Y29uZi51cmw9XCIvZm9ybS9mb3JtQ3VzdERpYWxvZy9mb3JtQ3VzdERpYWxvZ1Nob3dUcmVlLmh0bWw/a2V5PVwiK2tleTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0alF1ZXJ5LkRpYWxvZy5vcGVuKGNvbmYpOyBcblx0XHRcdH0sXCJqc29uXCIpO1xuXHRcdFx0XG5cdFx0XHRjb25mLm9rID0gZnVuY3Rpb24oaW5kZXgsaW5uZXJXaW5kb3cpe1xuXHRcdFx0XHRjYWxsQmFjayhpbm5lcldpbmRvdy5nZXREYXRhKCksaW5uZXJXaW5kb3cpO1xuXHRcdFx0XHRpZihjbG9zZURpYWxvZyl7XG5cdFx0XHRcdFx0alF1ZXJ5LkRpYWxvZy5jbG9zZShpbm5lcldpbmRvdyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIOiHquWumuS5ieafpeivouWFtuWunuaYr+iHquWumuS5ieWvueivneahhueahOS4gOenjeeugOeVpeiwg+eUqFxuXHRcdCAqIEBrZXkg6Ieq5a6a5LmJ5a+56K+d5qGG55qE5Yir5ZCNXG5cdFx0ICogQGNhbGxiYWNrIOWbnuiwg+WHveaVsFxuXHRcdCAqIEBwYXJhbSDosIPnlKjliqjmgIHlj4LmlbBcblx0XHQgKiBAZGlhbG9nU2V0dGluZyDlvLrooYzkv67mlLlrZXnlr7nor53moYbnmoTlj4LmlbDvvIznlKjov5nkuKpqc29u5pWw5o2u5Lit5pyJ55qE5a2X5q616KaG55uW5Y6f5pyJ5a+56K+d5qGG55qE6YWN572uXG5cdFx0ICovXG5cdFx0ZG9DdXN0UXVlcnk6ZnVuY3Rpb24oa2V5LCBwYXJhbSwgY2FsbEJhY2ssIGRpYWxvZ1NldHRpbmcpe1xuXHRcdFx0aWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHBhcmFtKSkge1xuXHRcdFx0XHRkaWFsb2dTZXR0aW5nID0gY2FsbEJhY2s7XG5cdFx0XHRcdGNhbGxCYWNrID0gcGFyYW07XG5cdFx0XHRcdHBhcmFtID0ge307XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKCFwYXJhbSl7XG5cdFx0XHRcdHBhcmFtID0ge307XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICghY2FsbEJhY2spIHtcblx0XHRcdFx0Y2FsbEJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LkRpYWxvZy5hbGVydChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGpRdWVyeS5wb3N0KF9fY3R4ICsgXCIvZm9ybS9mb3JtQ3VzdERpYWxvZy9nZXRPYmplY3Q/a2V5PVwiICsga2V5LCB7fSwgZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdHZhciBkaWFsb2dDb25mID0gcmVzdWx0LmRhdGE7XG5cdFx0XHRcdGRpYWxvZ0NvbmYgPSBqUXVlcnkuZXh0ZW5kKGRpYWxvZ0NvbmYsIGRpYWxvZ1NldHRpbmcpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8xIOS/ruaUueWvueivneahhueahOmFjee9rlxuXHRcdFx0XHRpZiAoZGlhbG9nQ29uZi5wYWdlKSB7Ly8g6buY6K6k5pyJ5YiG6aG16YWN572uXG5cdFx0XHRcdFx0aWYgKHBhcmFtLm9mZnNldCA9PSBudWxsKSB7Ly8g5YWl5Y+C5rKh5pyJ5a+55YiG6aG16aG156CBXG5cdFx0XHRcdFx0XHRwYXJhbS5vZmZzZXQgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGFyYW0ubGltaXQgPT0gbnVsbCkgey8vIOWFpeWPguayoeacieWvueWIhumhtemVv+W6plxuXHRcdFx0XHRcdFx0cGFyYW0ubGltaXQgPSBkaWFsb2dDb25mLnBhZ2VTaXplO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8yIOagueaNruadoeS7tumFjee9ruS/ruaUueWFpeWPglxuXHRcdFx0XHR3aW5kb3cuQ3VzdFV0aWwuaGFuZGxlUGFyYW0oZGlhbG9nQ29uZixwYXJhbSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLzMg5Y+R6K+35rGCXG5cdFx0XHRcdGpRdWVyeS5wb3N0KF9fY3R4ICsgXCIvZm9ybS9mb3JtQ3VzdERpYWxvZy9saXN0RGF0YV9cIiArIGtleSwgcGFyYW0sIGZ1bmN0aW9uKHJsdCkge1xuXHRcdFx0XHRcdC8v6L2s5LiA5LiL6L+U5Zue5a2X5q61XG5cdFx0XHRcdFx0dmFyIGRhdGFzID0gW107XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2gocmx0LnJvd3MsIGZ1bmN0aW9uKGluZGV4LHJvdykge1xuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSB7fTtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKGRpYWxvZ0NvbmYucmV0dXJuRmllbGRzLCBmdW5jdGlvbihpLGZpZWxkKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGFbZmllbGQucmV0dXJuTmFtZV0gPSByb3dbZmllbGQuY29sdW1uTmFtZV07XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGRhdGFzLnB1c2goZGF0YSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y2FsbEJhY2soZGF0YXMpO1xuXHRcdFx0XHR9LCBcImpzb25cIik7XG5cdFx0XHRcdFxuXHRcdFx0fSwgXCJqc29uXCIpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICog5aSE55CGanPkvKDmnaXlj4LmlbDnu5PlkIjlr7nor53moYbnmoTmnaHku7blpITnkIbkuIDkuItcblx0XHQgKi9cblx0XHRoYW5kbGVQYXJhbTpmdW5jdGlvbihkaWFsb2cscGFyYW0pe1xuXHRcdFx0aWYoIXBhcmFtKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0alF1ZXJ5LmVhY2goZGlhbG9nLmNvbmRpdGlvbkZpZWxkcywgZnVuY3Rpb24oaW5kZXgsZmllbGQpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2gocGFyYW0sIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG5cdFx0XHRcdFx0aWYgKGtleSAhPT0gZmllbGQuY29sdW1uTmFtZSkgey8v5om+5Yiwa2V5562J5LqO5p2h5Lu25Y+C5pWw55qEXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8v5biu5b+Za2V55ou86KOF6YWN572u5Lit55qE5p+l6K+i5p2h5Lu277yM5b2T54S25aaC5p6ccGFyYW3kuK3nmoRrZXnmnInlhpnlpb3nmoRe6L+Z56eN5YaZ5rOV6L+Z6YeM5piv5LiN5bmy6aKE55qEXG5cdFx0XHRcdFx0dmFyIGlkID0gZmllbGQuY29sdW1uTmFtZSArIFwiXlwiO1xuXHRcdFx0XHRcdGlmIChmaWVsZC5kYlR5cGUgPT09IFwidmFyY2hhclwiKSB7XG5cdFx0XHRcdFx0XHRpZCArPSBcIlZcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZpZWxkLmRiVHlwZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0aWQgKz0gXCJOXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmaWVsZC5kYlR5cGUgPT09IFwiZGF0ZVwiKSB7XG5cdFx0XHRcdFx0XHRpZCArPSBcIkRcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWQgKz0gZmllbGQuY29uZGl0aW9uO1xuXHRcdFx0XHRcdHBhcmFtW2lkXSA9IHZhbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59XG5kaWFsb2dIZWxwZXJfXy5nZXRQcm9qZWN0VXJsID0gZnVuY3Rpb24odXJsKXtcblx0Ly/nlLHkuo7lr7nor53moYblj6rkuLrliY3nq6/pobXpnaLmiZPlvIDvvIzmlYXmraTnm67liY3ku6Uv5byA5aS05YiZ6Ieq5Yqo5Yqg5LiK5YmN56uv55qEIHByb2plY3RwYXRo77yM5LiN5Lul5byA5aS05YiZ6K+05piO55u45a+56Lev5b6E44CC6Ieq5Yqo6KOF6L295Zyw5Z2AXG5cdGlmKHVybCAmJiB1cmwuaW5kZXhPZihcImh0dHA6Ly9cIik9PS0xICYmIHVybC5zdWJzdHJpbmcoMCwxKT09PVwiL1wiKXtcblx0XHQgdmFyIHBhdGhuYW1lID13aW5kb3cuZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG5cdFx0IHZhciBwcm9qZWN0UGF0aCA9IHBhdGhuYW1lLnN1YnN0cmluZygwLHBhdGhuYW1lLnN1YnN0cigxKS5pbmRleE9mKCcvJykrMSk7XG5cdFx0IC8vIOeJueauiuWkhOeQhuS4i+a1geeoi+iuvuiuoeWZqFxuXHRcdCBpZihwcm9qZWN0UGF0aCA9PT0gJycgfHwgXCIvYnVzLC9icG0sL3N5cywvb3JnLC9mb3JtLC9mbG93LWVkaXRvclwiLmluZGV4T2YocHJvamVjdFBhdGgpIT0gLTEpe1xuXHRcdFx0IHJldHVybiB1cmw7XG5cdFx0IH1cblx0XHRpZih1cmwuc3RhcnRXaXRoKHByb2plY3RQYXRoKSl7XG5cdFx0XHRyZXR1cm4gdXJsO1xuXHRcdH1cblx0XHQgcmV0dXJuIHByb2plY3RQYXRoK3VybDtcblx0fVxuXHRyZXR1cm4gdXJsO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2pzL2NvbW1vbi90b29scy9kaWFsb2dDcmVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy90b2FzdHIvdG9hc3RyLm1pbi5jc3M/NDZjMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvanMvcGx1Z2lucy90b2FzdHIvdG9hc3RyLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["toastr"] = __webpack_require__(27);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy90b2FzdHIvdG9hc3RyLm1pbi5qcy1leHBvc2VkPzdkZWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMEciLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcInRvYXN0clwiXSA9IHJlcXVpcmUoXCItIS5cXFxcdG9hc3RyLm1pbi5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9leHBvc2UtbG9hZGVyP3RvYXN0ciEuL2Fzc2V0cy9qcy9wbHVnaW5zL3RvYXN0ci90b2FzdHIubWluLmpzLWV4cG9zZWRcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(e){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(e){return function(){function t(e,t,n){return f({type:O.error,iconClass:g().iconClasses.error,message:e,optionsOverride:n,title:t})}function n(t,n){return t||(t=g()),v=e("#"+t.containerId),v.length?v:(n&&(v=c(t)),v)}function i(e,t,n){return f({type:O.info,iconClass:g().iconClasses.info,message:e,optionsOverride:n,title:t})}function o(e){w=e}function s(e,t,n){return f({type:O.success,iconClass:g().iconClasses.success,message:e,optionsOverride:n,title:t})}function a(e,t,n){return f({type:O.warning,iconClass:g().iconClasses.warning,message:e,optionsOverride:n,title:t})}function r(e){var t=g();v||n(t),l(e,t)||u(t)}function d(t){var i=g();return v||n(i),t&&0===e(":focus",t).length?void h(t):void(v.children().length&&v.remove())}function u(t){for(var n=v.children(),i=n.length-1;i>=0;i--)l(e(n[i]),t)}function l(t,n){return t&&0===e(":focus",t).length?(t[n.hideMethod]({duration:n.hideDuration,easing:n.hideEasing,complete:function(){h(t)}}),!0):!1}function c(t){return v=e("<div/>").attr("id",t.containerId).addClass(t.positionClass).attr("aria-live","polite").attr("role","alert"),v.appendTo(e(t.target)),v}function p(){return{tapToDismiss:!0,toastClass:"toast",containerId:"toast-container",debug:!1,showMethod:"fadeIn",showDuration:300,showEasing:"swing",onShown:void 0,hideMethod:"fadeOut",hideDuration:1e3,hideEasing:"swing",onHidden:void 0,extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},iconClass:"toast-info",positionClass:"toast-top-right",timeOut:5e3,titleClass:"toast-title",messageClass:"toast-message",target:"body",closeHtml:\'<button type="button">&times;</button>\',newestOnTop:!0,preventDuplicates:!1,progressBar:!1}}function m(e){w&&w(e)}function f(t){function i(t){return!e(":focus",l).length||t?(clearTimeout(O.intervalId),l[r.hideMethod]({duration:r.hideDuration,easing:r.hideEasing,complete:function(){h(l),r.onHidden&&"hidden"!==b.state&&r.onHidden(),b.state="hidden",b.endTime=new Date,m(b)}})):void 0}function o(){(r.timeOut>0||r.extendedTimeOut>0)&&(u=setTimeout(i,r.extendedTimeOut),O.maxHideTime=parseFloat(r.extendedTimeOut),O.hideEta=(new Date).getTime()+O.maxHideTime)}function s(){clearTimeout(u),O.hideEta=0,l.stop(!0,!0)[r.showMethod]({duration:r.showDuration,easing:r.showEasing})}function a(){var e=(O.hideEta-(new Date).getTime())/O.maxHideTime*100;f.width(e+"%")}var r=g(),d=t.iconClass||r.iconClass;if("undefined"!=typeof t.optionsOverride&&(r=e.extend(r,t.optionsOverride),d=t.optionsOverride.iconClass||d),r.preventDuplicates){if(t.message===C)return;C=t.message}T++,v=n(r,!0);var u=null,l=e("<div/>"),c=e("<div/>"),p=e("<div/>"),f=e("<div/>"),w=e(r.closeHtml),O={intervalId:null,hideEta:null,maxHideTime:null},b={toastId:T,state:"visible",startTime:new Date,options:r,map:t};return t.iconClass&&l.addClass(r.toastClass).addClass(d),t.title&&(c.append(t.title).addClass(r.titleClass),l.append(c)),t.message&&(p.append(t.message).addClass(r.messageClass),l.append(p)),r.closeButton&&(w.addClass("toast-close-button").attr("role","button"),l.prepend(w)),r.progressBar&&(f.addClass("toast-progress"),l.prepend(f)),l.hide(),r.newestOnTop?v.prepend(l):v.append(l),l[r.showMethod]({duration:r.showDuration,easing:r.showEasing,complete:r.onShown}),r.timeOut>0&&(u=setTimeout(i,r.timeOut),O.maxHideTime=parseFloat(r.timeOut),O.hideEta=(new Date).getTime()+O.maxHideTime,r.progressBar&&(O.intervalId=setInterval(a,10))),l.hover(s,o),!r.onclick&&r.tapToDismiss&&l.click(i),r.closeButton&&w&&w.click(function(e){e.stopPropagation?e.stopPropagation():void 0!==e.cancelBubble&&e.cancelBubble!==!0&&(e.cancelBubble=!0),i(!0)}),r.onclick&&l.click(function(){r.onclick(),i()}),m(b),r.debug&&console&&console.log(b),l}function g(){return e.extend({},p(),b.options)}function h(e){v||(v=n()),e.is(":visible")||(e.remove(),e=null,0===v.children().length&&(v.remove(),C=void 0))}var v,w,C,T=0,O={error:"error",info:"info",success:"success",warning:"warning"},b={clear:r,remove:d,error:t,getContainer:n,info:i,options:{},subscribe:o,success:s,version:"2.1.0",warning:a};return b}()}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}(__webpack_require__(28));\n//# sourceMappingURL=/toastr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy90b2FzdHIvdG9hc3RyLm1pbi5qcz81MGU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZFQUFhLHVHQUF5QixrQkFBa0Isa0JBQWtCLFVBQVUsaUZBQWlGLEVBQUUsZ0JBQWdCLG9FQUFvRSxrQkFBa0IsVUFBVSwrRUFBK0UsRUFBRSxjQUFjLElBQUksa0JBQWtCLFVBQVUscUZBQXFGLEVBQUUsa0JBQWtCLFVBQVUscUZBQXFGLEVBQUUsY0FBYyxVQUFVLHFCQUFxQixjQUFjLFVBQVUsMkZBQTJGLGNBQWMsb0NBQW9DLEtBQUssaUJBQWlCLGdCQUFnQixxREFBcUQsZ0VBQWdFLE1BQU0sU0FBUyxjQUFjLGtKQUFrSixhQUFhLE9BQU8sMlBBQTJQLHNGQUFzRixnTEFBZ0wsK0RBQStELGNBQWMsUUFBUSxjQUFjLGNBQWMsNEVBQTRFLGdFQUFnRSw0RkFBNEYsVUFBVSxhQUFhLGlLQUFpSyxhQUFhLHlEQUF5RCw0Q0FBNEMsRUFBRSxhQUFhLHlEQUF5RCxlQUFlLHFDQUFxQyxrSUFBa0ksd0JBQXdCLFlBQVksY0FBYyx1RkFBdUYsOENBQThDLElBQUksOERBQThELGdaQUFnWiwrREFBK0Qsc1FBQXNRLDhHQUE4RyxnQ0FBZ0MsZ0JBQWdCLDBDQUEwQyxhQUFhLGtCQUFrQixnQkFBZ0IsY0FBYyxnR0FBZ0csaUJBQWlCLDhEQUE4RCxJQUFJLHlEQUF5RCxrREFBa0QsU0FBUyxHQUFHO0FBQUEscUdBQUUsd0JBQTBLO0FBQzNySSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlKXtlKFtcImpxdWVyeVwiXSxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsdCxuKXtyZXR1cm4gZih7dHlwZTpPLmVycm9yLGljb25DbGFzczpnKCkuaWNvbkNsYXNzZXMuZXJyb3IsbWVzc2FnZTplLG9wdGlvbnNPdmVycmlkZTpuLHRpdGxlOnR9KX1mdW5jdGlvbiBuKHQsbil7cmV0dXJuIHR8fCh0PWcoKSksdj1lKFwiI1wiK3QuY29udGFpbmVySWQpLHYubGVuZ3RoP3Y6KG4mJih2PWModCkpLHYpfWZ1bmN0aW9uIGkoZSx0LG4pe3JldHVybiBmKHt0eXBlOk8uaW5mbyxpY29uQ2xhc3M6ZygpLmljb25DbGFzc2VzLmluZm8sbWVzc2FnZTplLG9wdGlvbnNPdmVycmlkZTpuLHRpdGxlOnR9KX1mdW5jdGlvbiBvKGUpe3c9ZX1mdW5jdGlvbiBzKGUsdCxuKXtyZXR1cm4gZih7dHlwZTpPLnN1Y2Nlc3MsaWNvbkNsYXNzOmcoKS5pY29uQ2xhc3Nlcy5zdWNjZXNzLG1lc3NhZ2U6ZSxvcHRpb25zT3ZlcnJpZGU6bix0aXRsZTp0fSl9ZnVuY3Rpb24gYShlLHQsbil7cmV0dXJuIGYoe3R5cGU6Ty53YXJuaW5nLGljb25DbGFzczpnKCkuaWNvbkNsYXNzZXMud2FybmluZyxtZXNzYWdlOmUsb3B0aW9uc092ZXJyaWRlOm4sdGl0bGU6dH0pfWZ1bmN0aW9uIHIoZSl7dmFyIHQ9ZygpO3Z8fG4odCksbChlLHQpfHx1KHQpfWZ1bmN0aW9uIGQodCl7dmFyIGk9ZygpO3JldHVybiB2fHxuKGkpLHQmJjA9PT1lKFwiOmZvY3VzXCIsdCkubGVuZ3RoP3ZvaWQgaCh0KTp2b2lkKHYuY2hpbGRyZW4oKS5sZW5ndGgmJnYucmVtb3ZlKCkpfWZ1bmN0aW9uIHUodCl7Zm9yKHZhciBuPXYuY2hpbGRyZW4oKSxpPW4ubGVuZ3RoLTE7aT49MDtpLS0pbChlKG5baV0pLHQpfWZ1bmN0aW9uIGwodCxuKXtyZXR1cm4gdCYmMD09PWUoXCI6Zm9jdXNcIix0KS5sZW5ndGg/KHRbbi5oaWRlTWV0aG9kXSh7ZHVyYXRpb246bi5oaWRlRHVyYXRpb24sZWFzaW5nOm4uaGlkZUVhc2luZyxjb21wbGV0ZTpmdW5jdGlvbigpe2godCl9fSksITApOiExfWZ1bmN0aW9uIGModCl7cmV0dXJuIHY9ZShcIjxkaXYvPlwiKS5hdHRyKFwiaWRcIix0LmNvbnRhaW5lcklkKS5hZGRDbGFzcyh0LnBvc2l0aW9uQ2xhc3MpLmF0dHIoXCJhcmlhLWxpdmVcIixcInBvbGl0ZVwiKS5hdHRyKFwicm9sZVwiLFwiYWxlcnRcIiksdi5hcHBlbmRUbyhlKHQudGFyZ2V0KSksdn1mdW5jdGlvbiBwKCl7cmV0dXJue3RhcFRvRGlzbWlzczohMCx0b2FzdENsYXNzOlwidG9hc3RcIixjb250YWluZXJJZDpcInRvYXN0LWNvbnRhaW5lclwiLGRlYnVnOiExLHNob3dNZXRob2Q6XCJmYWRlSW5cIixzaG93RHVyYXRpb246MzAwLHNob3dFYXNpbmc6XCJzd2luZ1wiLG9uU2hvd246dm9pZCAwLGhpZGVNZXRob2Q6XCJmYWRlT3V0XCIsaGlkZUR1cmF0aW9uOjFlMyxoaWRlRWFzaW5nOlwic3dpbmdcIixvbkhpZGRlbjp2b2lkIDAsZXh0ZW5kZWRUaW1lT3V0OjFlMyxpY29uQ2xhc3Nlczp7ZXJyb3I6XCJ0b2FzdC1lcnJvclwiLGluZm86XCJ0b2FzdC1pbmZvXCIsc3VjY2VzczpcInRvYXN0LXN1Y2Nlc3NcIix3YXJuaW5nOlwidG9hc3Qtd2FybmluZ1wifSxpY29uQ2xhc3M6XCJ0b2FzdC1pbmZvXCIscG9zaXRpb25DbGFzczpcInRvYXN0LXRvcC1yaWdodFwiLHRpbWVPdXQ6NWUzLHRpdGxlQ2xhc3M6XCJ0b2FzdC10aXRsZVwiLG1lc3NhZ2VDbGFzczpcInRvYXN0LW1lc3NhZ2VcIix0YXJnZXQ6XCJib2R5XCIsY2xvc2VIdG1sOic8YnV0dG9uIHR5cGU9XCJidXR0b25cIj4mdGltZXM7PC9idXR0b24+JyxuZXdlc3RPblRvcDohMCxwcmV2ZW50RHVwbGljYXRlczohMSxwcm9ncmVzc0JhcjohMX19ZnVuY3Rpb24gbShlKXt3JiZ3KGUpfWZ1bmN0aW9uIGYodCl7ZnVuY3Rpb24gaSh0KXtyZXR1cm4hZShcIjpmb2N1c1wiLGwpLmxlbmd0aHx8dD8oY2xlYXJUaW1lb3V0KE8uaW50ZXJ2YWxJZCksbFtyLmhpZGVNZXRob2RdKHtkdXJhdGlvbjpyLmhpZGVEdXJhdGlvbixlYXNpbmc6ci5oaWRlRWFzaW5nLGNvbXBsZXRlOmZ1bmN0aW9uKCl7aChsKSxyLm9uSGlkZGVuJiZcImhpZGRlblwiIT09Yi5zdGF0ZSYmci5vbkhpZGRlbigpLGIuc3RhdGU9XCJoaWRkZW5cIixiLmVuZFRpbWU9bmV3IERhdGUsbShiKX19KSk6dm9pZCAwfWZ1bmN0aW9uIG8oKXsoci50aW1lT3V0PjB8fHIuZXh0ZW5kZWRUaW1lT3V0PjApJiYodT1zZXRUaW1lb3V0KGksci5leHRlbmRlZFRpbWVPdXQpLE8ubWF4SGlkZVRpbWU9cGFyc2VGbG9hdChyLmV4dGVuZGVkVGltZU91dCksTy5oaWRlRXRhPShuZXcgRGF0ZSkuZ2V0VGltZSgpK08ubWF4SGlkZVRpbWUpfWZ1bmN0aW9uIHMoKXtjbGVhclRpbWVvdXQodSksTy5oaWRlRXRhPTAsbC5zdG9wKCEwLCEwKVtyLnNob3dNZXRob2RdKHtkdXJhdGlvbjpyLnNob3dEdXJhdGlvbixlYXNpbmc6ci5zaG93RWFzaW5nfSl9ZnVuY3Rpb24gYSgpe3ZhciBlPShPLmhpZGVFdGEtKG5ldyBEYXRlKS5nZXRUaW1lKCkpL08ubWF4SGlkZVRpbWUqMTAwO2Yud2lkdGgoZStcIiVcIil9dmFyIHI9ZygpLGQ9dC5pY29uQ2xhc3N8fHIuaWNvbkNsYXNzO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0Lm9wdGlvbnNPdmVycmlkZSYmKHI9ZS5leHRlbmQocix0Lm9wdGlvbnNPdmVycmlkZSksZD10Lm9wdGlvbnNPdmVycmlkZS5pY29uQ2xhc3N8fGQpLHIucHJldmVudER1cGxpY2F0ZXMpe2lmKHQubWVzc2FnZT09PUMpcmV0dXJuO0M9dC5tZXNzYWdlfVQrKyx2PW4ociwhMCk7dmFyIHU9bnVsbCxsPWUoXCI8ZGl2Lz5cIiksYz1lKFwiPGRpdi8+XCIpLHA9ZShcIjxkaXYvPlwiKSxmPWUoXCI8ZGl2Lz5cIiksdz1lKHIuY2xvc2VIdG1sKSxPPXtpbnRlcnZhbElkOm51bGwsaGlkZUV0YTpudWxsLG1heEhpZGVUaW1lOm51bGx9LGI9e3RvYXN0SWQ6VCxzdGF0ZTpcInZpc2libGVcIixzdGFydFRpbWU6bmV3IERhdGUsb3B0aW9uczpyLG1hcDp0fTtyZXR1cm4gdC5pY29uQ2xhc3MmJmwuYWRkQ2xhc3Moci50b2FzdENsYXNzKS5hZGRDbGFzcyhkKSx0LnRpdGxlJiYoYy5hcHBlbmQodC50aXRsZSkuYWRkQ2xhc3Moci50aXRsZUNsYXNzKSxsLmFwcGVuZChjKSksdC5tZXNzYWdlJiYocC5hcHBlbmQodC5tZXNzYWdlKS5hZGRDbGFzcyhyLm1lc3NhZ2VDbGFzcyksbC5hcHBlbmQocCkpLHIuY2xvc2VCdXR0b24mJih3LmFkZENsYXNzKFwidG9hc3QtY2xvc2UtYnV0dG9uXCIpLmF0dHIoXCJyb2xlXCIsXCJidXR0b25cIiksbC5wcmVwZW5kKHcpKSxyLnByb2dyZXNzQmFyJiYoZi5hZGRDbGFzcyhcInRvYXN0LXByb2dyZXNzXCIpLGwucHJlcGVuZChmKSksbC5oaWRlKCksci5uZXdlc3RPblRvcD92LnByZXBlbmQobCk6di5hcHBlbmQobCksbFtyLnNob3dNZXRob2RdKHtkdXJhdGlvbjpyLnNob3dEdXJhdGlvbixlYXNpbmc6ci5zaG93RWFzaW5nLGNvbXBsZXRlOnIub25TaG93bn0pLHIudGltZU91dD4wJiYodT1zZXRUaW1lb3V0KGksci50aW1lT3V0KSxPLm1heEhpZGVUaW1lPXBhcnNlRmxvYXQoci50aW1lT3V0KSxPLmhpZGVFdGE9KG5ldyBEYXRlKS5nZXRUaW1lKCkrTy5tYXhIaWRlVGltZSxyLnByb2dyZXNzQmFyJiYoTy5pbnRlcnZhbElkPXNldEludGVydmFsKGEsMTApKSksbC5ob3ZlcihzLG8pLCFyLm9uY2xpY2smJnIudGFwVG9EaXNtaXNzJiZsLmNsaWNrKGkpLHIuY2xvc2VCdXR0b24mJncmJncuY2xpY2soZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKTp2b2lkIDAhPT1lLmNhbmNlbEJ1YmJsZSYmZS5jYW5jZWxCdWJibGUhPT0hMCYmKGUuY2FuY2VsQnViYmxlPSEwKSxpKCEwKX0pLHIub25jbGljayYmbC5jbGljayhmdW5jdGlvbigpe3Iub25jbGljaygpLGkoKX0pLG0oYiksci5kZWJ1ZyYmY29uc29sZSYmY29uc29sZS5sb2coYiksbH1mdW5jdGlvbiBnKCl7cmV0dXJuIGUuZXh0ZW5kKHt9LHAoKSxiLm9wdGlvbnMpfWZ1bmN0aW9uIGgoZSl7dnx8KHY9bigpKSxlLmlzKFwiOnZpc2libGVcIil8fChlLnJlbW92ZSgpLGU9bnVsbCwwPT09di5jaGlsZHJlbigpLmxlbmd0aCYmKHYucmVtb3ZlKCksQz12b2lkIDApKX12YXIgdix3LEMsVD0wLE89e2Vycm9yOlwiZXJyb3JcIixpbmZvOlwiaW5mb1wiLHN1Y2Nlc3M6XCJzdWNjZXNzXCIsd2FybmluZzpcIndhcm5pbmdcIn0sYj17Y2xlYXI6cixyZW1vdmU6ZCxlcnJvcjp0LGdldENvbnRhaW5lcjpuLGluZm86aSxvcHRpb25zOnt9LHN1YnNjcmliZTpvLHN1Y2Nlc3M6cyx2ZXJzaW9uOlwiMi4xLjBcIix3YXJuaW5nOmF9O3JldHVybiBifSgpfSl9KFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmU6ZnVuY3Rpb24oZSx0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz10KHJlcXVpcmUoXCJqcXVlcnlcIikpOndpbmRvdy50b2FzdHI9dCh3aW5kb3cualF1ZXJ5KX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9L3RvYXN0ci5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2pzL3BsdWdpbnMvdG9hc3RyL3RvYXN0ci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n')},function(module,exports){eval('module.exports = function() {\n\tthrow new Error("define cannot be used indirect");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcz8wYmJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n')},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;/*! layer-v2.1 弹层组件 License LGPL  http://layer.layui.com/ By 贤心 */\n;!function(a,b){"use strict";var c,d,e={getPath:function(){var a=document.scripts,b=a[a.length-1],c=b.src;if(!b.getAttribute("merge"))return c.substring(0,c.lastIndexOf("/")+1)}(),enter:function(a){13===a.keyCode&&a.preventDefault()},config:{},end:{},btn:["&#x786E;&#x5B9A;","&#x53D6;&#x6D88;"],type:["dialog","page","iframe","loading","tips"]},f={v:"2.1",ie6:!!a.ActiveXObject&&!a.XMLHttpRequest,index:0,path:e.getPath,config:function(a,b){var d=0;return a=a||{},f.cache=e.config=c.extend(e.config,a),f.path=e.config.path||f.path,"string"==typeof a.extend&&(a.extend=[a.extend]),f.use("skin/layer.css",a.extend&&a.extend.length>0?function g(){var c=a.extend;f.use(c[c[d]?d:d-1],d<c.length?function(){return++d,g}():b)}():b),this},use:function(a,b,d){var e=c("head")[0],a=a.replace(/\\s/g,""),g=/\\.css$/.test(a),h=document.createElement(g?"link":"script"),i="layui_layer_"+a.replace(/\\.|\\//g,"");return f.path?(g&&(h.rel="stylesheet"),h[g?"href":"src"]=/^http:\\/\\//.test(a)?a:f.path+a,h.id=i,c("#"+i)[0]||e.appendChild(h),function j(){(g?1989===parseInt(c("#"+i).css("width")):f[d||i])?function(){b&&b();try{g||e.removeChild(h)}catch(a){}}():setTimeout(j,100)}(),this):void 0},ready:function(a,b){var d="function"==typeof a;return d&&(b=a),f.config(c.extend(e.config,function(){return d?{}:{path:a}}()),b),this},alert:function(a,b,d){var e="function"==typeof b;return e&&(d=b),f.open(c.extend({content:a,yes:d},e?{}:b))},confirm:function(a,b,d,g){var h="function"==typeof b;return h&&(g=d,d=b),f.open(c.extend({content:a,btn:e.btn,yes:d,cancel:g},h?{}:b))},msg:function(a,d,g){var i="function"==typeof d,j=e.config.skin,k=(j?j+" "+j+"-msg":"")||"layui-layer-msg",l=h.anim.length-1;return i&&(g=d),f.open(c.extend({content:a,time:3e3,shade:!1,skin:k,title:!1,closeBtn:!1,btn:!1,end:g},i&&!e.config.skin?{skin:k+" layui-layer-hui",shift:l}:function(){return d=d||{},(-1===d.icon||d.icon===b&&!e.config.skin)&&(d.skin=k+" "+(d.skin||"layui-layer-hui")),d}()))},load:function(a,b){return f.open(c.extend({type:3,icon:a||0,shade:.01},b))},tips:function(a,b,d){return f.open(c.extend({type:4,content:[a,b],closeBtn:!1,time:3e3,maxWidth:210},d))}},g=function(a){var b=this;b.index=++f.index,b.config=c.extend({},b.config,e.config,a),b.creat()};g.pt=g.prototype;var h=["layui-layer",".layui-layer-title",".layui-layer-main",".layui-layer-dialog","layui-layer-iframe","layui-layer-content","layui-layer-btn","layui-layer-close"];h.anim=["layui-anim","layui-anim-01","layui-anim-02","layui-anim-03","layui-anim-04","layui-anim-05","layui-anim-06"],g.pt.config={type:0,shade:.3,fix:!0,move:h[1],title:"&#x4FE1;&#x606F;",offset:"auto",area:"auto",closeBtn:1,time:0,zIndex:19891014,maxWidth:360,shift:0,icon:-1,scrollbar:!0,tips:2},g.pt.vessel=function(a,b){var c=this,d=c.index,f=c.config,g=f.zIndex+d,i="object"==typeof f.title,j=f.maxmin&&(1===f.type||2===f.type),k=f.title?\'<div class="layui-layer-title" style="\'+(i?f.title[1]:"")+\'">\'+(i?f.title[0]:f.title)+"</div>":"";return f.zIndex=g,b([f.shade?\'<div class="layui-layer-shade" id="layui-layer-shade\'+d+\'" times="\'+d+\'" style="\'+("z-index:"+(g-1)+"; background-color:"+(f.shade[1]||"#000")+"; opacity:"+(f.shade[0]||f.shade)+"; filter:alpha(opacity="+(100*f.shade[0]||100*f.shade)+");")+\'"></div>\':"",\'<div class="\'+h[0]+" "+(h.anim[f.shift]||"")+(" layui-layer-"+e.type[f.type])+(0!=f.type&&2!=f.type||f.shade?"":" layui-layer-border")+" "+(f.skin||"")+\'" id="\'+h[0]+d+\'" type="\'+e.type[f.type]+\'" times="\'+d+\'" showtime="\'+f.time+\'" conType="\'+(a?"object":"string")+\'" style="z-index: \'+g+"; width:"+f.area[0]+";height:"+f.area[1]+(f.fix?"":";position:absolute;")+\'">\'+(a&&2!=f.type?"":k)+\'<div class="layui-layer-content\'+(0==f.type&&-1!==f.icon?" layui-layer-padding":"")+(3==f.type?" layui-layer-loading"+f.icon:"")+\'">\'+(0==f.type&&-1!==f.icon?\'<i class="layui-layer-ico layui-layer-ico\'+f.icon+\'"></i>\':"")+(1==f.type&&a?"":f.content||"")+\'</div><span class="layui-layer-setwin">\'+function(){var a=j?\'<a class="layui-layer-min" href="javascript:;"><cite></cite></a><a class="layui-layer-ico layui-layer-max" href="javascript:;"></a>\':"";return f.closeBtn&&(a+=\'<a class="layui-layer-ico \'+h[7]+" "+h[7]+(f.title?f.closeBtn:4==f.type?"1":"2")+\'" href="javascript:;"></a>\'),a}()+"</span>"+(f.btn?function(){var a="";"string"==typeof f.btn&&(f.btn=[f.btn]);for(var b=0,c=f.btn.length;c>b;b++)a+=\'<a class="\'+h[6]+b+\'">\'+f.btn[b]+"</a>";return\'<div class="\'+h[6]+\'">\'+a+"</div>"}():"")+"</div>"],k),c},g.pt.creat=function(){var a=this,b=a.config,g=a.index,i=b.content,j="object"==typeof i;switch("string"==typeof b.area&&(b.area="auto"===b.area?["",""]:[b.area,""]),b.type){case 0:b.btn="btn"in b?b.btn:e.btn[0],f.closeAll("dialog");break;case 2:var i=b.content=j?b.content:[b.content||"http://layer.layui.com","auto"];b.content=\'<iframe scrolling="\'+(b.content[1]||"auto")+\'" allowtransparency="true" id="\'+h[4]+g+\'" name="\'+h[4]+g+\'" onload="this.className=\\\'\\\';" class="layui-layer-load" frameborder="0" src="\'+b.content[0]+\'"></iframe>\';break;case 3:b.title=!1,b.closeBtn=!1,-1===b.icon&&0===b.icon,f.closeAll("loading");break;case 4:j||(b.content=[b.content,"body"]),b.follow=b.content[1],b.content=b.content[0]+\'<i class="layui-layer-TipsG"></i>\',b.title=!1,b.shade=!1,b.fix=!1,b.tips="object"==typeof b.tips?b.tips:[b.tips,!0],b.tipsMore||f.closeAll("tips")}a.vessel(j,function(d,e){c("body").append(d[0]),j?function(){2==b.type||4==b.type?function(){c("body").append(d[1])}():function(){i.parents("."+h[0])[0]||(i.show().addClass("layui-layer-wrap").wrap(d[1]),c("#"+h[0]+g).find("."+h[5]).before(e))}()}():c("body").append(d[1]),a.layero=c("#"+h[0]+g),b.scrollbar||h.html.css("overflow","hidden").attr("layer-full",g)}).auto(g),2==b.type&&f.ie6&&a.layero.find("iframe").attr("src",i[0]),c(document).off("keydown",e.enter).on("keydown",e.enter),a.layero.on("keydown",function(a){c(document).off("keydown",e.enter)}),4==b.type?a.tips():a.offset(),b.fix&&d.on("resize",function(){a.offset(),(/^\\d+%$/.test(b.area[0])||/^\\d+%$/.test(b.area[1]))&&a.auto(g),4==b.type&&a.tips()}),b.time<=0||setTimeout(function(){f.close(a.index)},b.time),a.move().callback()},g.pt.auto=function(a){function b(a){a=g.find(a),a.height(i[1]-j-k-2*(0|parseFloat(a.css("padding"))))}var e=this,f=e.config,g=c("#"+h[0]+a);""===f.area[0]&&f.maxWidth>0&&(/MSIE 7/.test(navigator.userAgent)&&f.btn&&g.width(g.innerWidth()),g.outerWidth()>f.maxWidth&&g.width(f.maxWidth));var i=[g.innerWidth(),g.innerHeight()],j=g.find(h[1]).outerHeight()||0,k=g.find("."+h[6]).outerHeight()||0;switch(f.type){case 2:b("iframe");break;default:""===f.area[1]?f.fix&&i[1]>=d.height()&&(i[1]=d.height(),b("."+h[5])):b("."+h[5])}return e},g.pt.offset=function(){var a=this,b=a.config,c=a.layero,e=[c.outerWidth(),c.outerHeight()],f="object"==typeof b.offset;a.offsetTop=(d.height()-e[1])/2,a.offsetLeft=(d.width()-e[0])/2,f?(a.offsetTop=b.offset[0],a.offsetLeft=b.offset[1]||a.offsetLeft):"auto"!==b.offset&&(a.offsetTop=b.offset,"rb"===b.offset&&(a.offsetTop=d.height()-e[1],a.offsetLeft=d.width()-e[0])),b.fix||(a.offsetTop=/%$/.test(a.offsetTop)?d.height()*parseFloat(a.offsetTop)/100:parseFloat(a.offsetTop),a.offsetLeft=/%$/.test(a.offsetLeft)?d.width()*parseFloat(a.offsetLeft)/100:parseFloat(a.offsetLeft),a.offsetTop+=d.scrollTop(),a.offsetLeft+=d.scrollLeft()),c.css({top:a.offsetTop,left:a.offsetLeft})},g.pt.tips=function(){var a=this,b=a.config,e=a.layero,f=[e.outerWidth(),e.outerHeight()],g=c(b.follow);g[0]||(g=c("body"));var i={width:g.outerWidth(),height:g.outerHeight(),top:g.offset().top,left:g.offset().left},j=e.find(".layui-layer-TipsG"),k=b.tips[0];b.tips[1]||j.remove(),i.autoLeft=function(){i.left+f[0]-d.width()>0?(i.tipLeft=i.left+i.width-f[0],j.css({right:12,left:"auto"})):i.tipLeft=i.left},i.where=[function(){i.autoLeft(),i.tipTop=i.top-f[1]-10,j.removeClass("layui-layer-TipsB").addClass("layui-layer-TipsT").css("border-right-color",b.tips[1])},function(){i.tipLeft=i.left+i.width+10,i.tipTop=i.top,j.removeClass("layui-layer-TipsL").addClass("layui-layer-TipsR").css("border-bottom-color",b.tips[1])},function(){i.autoLeft(),i.tipTop=i.top+i.height+10,j.removeClass("layui-layer-TipsT").addClass("layui-layer-TipsB").css("border-right-color",b.tips[1])},function(){i.tipLeft=i.left-f[0]-10,i.tipTop=i.top,j.removeClass("layui-layer-TipsR").addClass("layui-layer-TipsL").css("border-bottom-color",b.tips[1])}],i.where[k-1](),1===k?i.top-(d.scrollTop()+f[1]+16)<0&&i.where[2]():2===k?d.width()-(i.left+i.width+f[0]+16)>0||i.where[3]():3===k?i.top-d.scrollTop()+i.height+f[1]+16-d.height()>0&&i.where[0]():4===k&&f[0]+16-i.left>0&&i.where[1](),e.find("."+h[5]).css({"background-color":b.tips[1],"padding-right":b.closeBtn?"30px":""}),e.css({left:i.tipLeft,top:i.tipTop})},g.pt.move=function(){var a=this,b=a.config,e={setY:0,moveLayer:function(){var a=e.layero,b=parseInt(a.css("margin-left")),c=parseInt(e.move.css("left"));0===b||(c-=b),"fixed"!==a.css("position")&&(c-=a.parent().offset().left,e.setY=0),a.css({left:c,top:parseInt(e.move.css("top"))-e.setY})}},f=a.layero.find(b.move);return b.move&&f.attr("move","ok"),f.css({cursor:b.move?"move":"auto"}),c(b.move).on("mousedown",function(a){if(a.preventDefault(),"ok"===c(this).attr("move")){e.ismove=!0,e.layero=c(this).parents("."+h[0]);var f=e.layero.offset().left,g=e.layero.offset().top,i=e.layero.outerWidth()-6,j=e.layero.outerHeight()-6;c("#layui-layer-moves")[0]||c("body").append(\'<div id="layui-layer-moves" class="layui-layer-moves" style="left:\'+f+"px; top:"+g+"px; width:"+i+"px; height:"+j+\'px; z-index:2147483584"></div>\'),e.move=c("#layui-layer-moves"),b.moveType&&e.move.css({visibility:"hidden"}),e.moveX=a.pageX-e.move.position().left,e.moveY=a.pageY-e.move.position().top,"fixed"!==e.layero.css("position")||(e.setY=d.scrollTop())}}),c(document).mousemove(function(a){if(e.ismove){var c=a.pageX-e.moveX,f=a.pageY-e.moveY;if(a.preventDefault(),!b.moveOut){e.setY=d.scrollTop();var g=d.width()-e.move.outerWidth(),h=e.setY;0>c&&(c=0),c>g&&(c=g),h>f&&(f=h),f>d.height()-e.move.outerHeight()+e.setY&&(f=d.height()-e.move.outerHeight()+e.setY)}e.move.css({left:c,top:f}),b.moveType&&e.moveLayer(),c=f=g=h=null}}).mouseup(function(){try{e.ismove&&(e.moveLayer(),e.move.remove(),b.moveEnd&&b.moveEnd()),e.ismove=!1}catch(a){e.ismove=!1}}),a},g.pt.callback=function(){function a(){var a=g.cancel&&g.cancel(b.index);a===!1||f.close(b.index)}var b=this,d=b.layero,g=b.config;b.openLayer(),g.success&&(2==g.type?d.find("iframe").on("load",function(){g.success(d,b.index)}):g.success(d,b.index)),f.ie6&&b.IE6(d),d.find("."+h[6]).children("a").on("click",function(){var e=c(this).index();g["btn"+(e+1)]&&g["btn"+(e+1)](b.index,d),0===e?g.yes?g.yes(b.index,d):f.close(b.index):1===e?a():g["btn"+(e+1)]||f.close(b.index)}),d.find("."+h[7]).on("click",a),g.shadeClose&&c("#layui-layer-shade"+b.index).on("click",function(){f.close(b.index)}),d.find(".layui-layer-min").on("click",function(){f.min(b.index,g),g.min&&g.min(d)}),d.find(".layui-layer-max").on("click",function(){c(this).hasClass("layui-layer-maxmin")?(f.restore(b.index),g.restore&&g.restore(d)):(f.full(b.index,g),g.full&&g.full(d))}),g.end&&(e.end[b.index]=g.end)},e.reselect=function(){c.each(c("select"),function(a,b){var d=c(this);d.parents("."+h[0])[0]||1==d.attr("layer")&&c("."+h[0]).length<1&&d.removeAttr("layer").show(),d=null})},g.pt.IE6=function(a){function b(){a.css({top:f+(e.config.fix?d.scrollTop():0)})}var e=this,f=a.offset().top;b(),d.scroll(b),c("select").each(function(a,b){var d=c(this);d.parents("."+h[0])[0]||"none"===d.css("display")||d.attr({layer:"1"}).hide(),d=null})},g.pt.openLayer=function(){var a=this;f.zIndex=a.config.zIndex,f.setTop=function(a){var b=function(){f.zIndex++,a.css("z-index",f.zIndex+1)};return f.zIndex=parseInt(a[0].style.zIndex),a.on("mousedown",b),f.zIndex}},e.record=function(a){var b=[a.outerWidth(),a.outerHeight(),a.position().top,a.position().left+parseFloat(a.css("margin-left"))];a.find(".layui-layer-max").addClass("layui-layer-maxmin"),a.attr({area:b})},e.rescollbar=function(a){h.html.attr("layer-full")==a&&(h.html[0].style.removeProperty?h.html[0].style.removeProperty("overflow"):h.html[0].style.removeAttribute("overflow"),h.html.removeAttr("layer-full"))},a.layer=f,f.getChildFrame=function(a,b){return b=b||c("."+h[4]).attr("times"),c("#"+h[0]+b).find("iframe").contents().find(a)},f.getFrameIndex=function(a){return c("#"+a).parents("."+h[4]).attr("times")},f.iframeAuto=function(a){if(a){var b=f.getChildFrame("html",a).outerHeight(),d=c("#"+h[0]+a),e=d.find(h[1]).outerHeight()||0,g=d.find("."+h[6]).outerHeight()||0;d.css({height:b+e+g}),d.find("iframe").css({height:b})}},f.iframeSrc=function(a,b){c("#"+h[0]+a).find("iframe").attr("src",b)},f.style=function(a,b){var d=c("#"+h[0]+a),f=d.attr("type"),g=d.find(h[1]).outerHeight()||0,i=d.find("."+h[6]).outerHeight()||0;(f===e.type[1]||f===e.type[2])&&(d.css(b),f===e.type[2]&&d.find("iframe").css({height:parseFloat(b.height)-g-i}))},f.min=function(a,b){var d=c("#"+h[0]+a),g=d.find(h[1]).outerHeight()||0;e.record(d),f.style(a,{width:180,height:g,overflow:"hidden"}),d.find(".layui-layer-min").hide(),"page"===d.attr("type")&&d.find(h[4]).hide(),e.rescollbar(a)},f.restore=function(a){var b=c("#"+h[0]+a),d=b.attr("area").split(",");b.attr("type");f.style(a,{width:parseFloat(d[0]),height:parseFloat(d[1]),top:parseFloat(d[2]),left:parseFloat(d[3]),overflow:"visible"}),b.find(".layui-layer-max").removeClass("layui-layer-maxmin"),b.find(".layui-layer-min").show(),"page"===b.attr("type")&&b.find(h[4]).show(),e.rescollbar(a)},f.full=function(a){var b,g=c("#"+h[0]+a);e.record(g),h.html.attr("layer-full")||h.html.css("overflow","hidden").attr("layer-full",a),clearTimeout(b),b=setTimeout(function(){var b="fixed"===g.css("position");f.style(a,{top:b?0:d.scrollTop(),left:b?0:d.scrollLeft(),width:d.width(),height:d.height()}),g.find(".layui-layer-min").hide()},100)},f.title=function(a,b){var d=c("#"+h[0]+(b||f.index)).find(h[1]);d.html(a)},f.close=function(a){var b=c("#"+h[0]+a),d=b.attr("type");if(b[0]){if(d===e.type[1]&&"object"===b.attr("conType")){b.children(":not(."+h[5]+")").remove();for(var g=0;2>g;g++)b.find(".layui-layer-wrap").unwrap().hide()}else{if(d===e.type[2])try{var i=c("#"+h[4]+a)[0];i.contentWindow.document.write(""),i.contentWindow.close(),b.find("."+h[5])[0].removeChild(i)}catch(j){}b[0].innerHTML="",b.remove()}c("#layui-layer-moves, #layui-layer-shade"+a).remove(),f.ie6&&e.reselect(),e.rescollbar(a),c(document).off("keydown",e.enter),"function"==typeof e.end[a]&&e.end[a](),delete e.end[a]}},f.closeAll=function(a){c.each(c("."+h[0]),function(){var b=c(this),d=a?b.attr("type")===a:1;d&&f.close(b.attr("times")),d=null})},e.run=function(){c=jQuery,d=c(a),h.html=c("html"),f.open=function(a){var b=new g(a);return b.index}}, true?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return e.run(),f}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):function(){e.run(),f.use("skin/layer.css")}()}(window);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy9sYXllci9sYXllci5taW4uanM/MGRkMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLENBQUMsZUFBZSxhQUFhLFdBQVcsbUJBQW1CLCtDQUErQyx1RUFBdUUscUJBQXFCLG1DQUFtQyxVQUFVLE9BQU8sZUFBZSxRQUFRLFdBQVcsUUFBUSxvREFBb0QsSUFBSSw2RkFBNkYsUUFBUSxjQUFjLHFMQUFxTCxlQUFlLDBDQUEwQyxZQUFZLE1BQU0sV0FBVyxxQkFBcUIsZ0pBQWdKLDJJQUEySSw4REFBOEQsT0FBTyxJQUFJLG9CQUFvQixXQUFXLHFCQUFxQixnQkFBZ0IscUJBQXFCLDJCQUEyQixzREFBc0QsV0FBVyxFQUFFLFFBQVEsWUFBWSx1QkFBdUIsMkJBQTJCLGlDQUFpQyxnQkFBZ0IsS0FBSyxLQUFLLDJCQUEyQiwyQkFBMkIscUNBQXFDLG1DQUFtQyxLQUFLLEtBQUsscUJBQXFCLHdHQUF3RyxpQ0FBaUMscUVBQXFFLG9CQUFvQixrQ0FBa0MsWUFBWSxjQUFjLHlGQUF5RixLQUFLLG9CQUFvQix3QkFBd0IsMkJBQTJCLEtBQUssc0JBQXNCLHdCQUF3Qix1REFBdUQsTUFBTSxlQUFlLFdBQVcsc0NBQXNDLGlDQUFpQyxpQkFBaUIsc0tBQXNLLG1JQUFtSSxnREFBZ0QsUUFBUSwrR0FBK0csMkJBQTJCLDBOQUEwTixvSUFBb0ksMkNBQTJDLG1DQUFtQyx5REFBeUQscVRBQXFULHFCQUFxQiwrQkFBK0Isa0JBQWtCLGdWQUFnVixzREFBc0QsZ0ZBQWdGLFdBQVcsOEhBQThILFdBQVcsK0JBQStCLFNBQVMsd0NBQXdDLDJCQUEyQixJQUFJLGdEQUFnRCwwQ0FBMEMsc0JBQXNCLHVCQUF1QixpRUFBaUUscUZBQXFGLDJEQUEyRCxNQUFNLGdGQUFnRixpSkFBaUosNkVBQTZFLE1BQU0sOEVBQThFLE1BQU0sME9BQTBPLHlCQUF5QixvQ0FBb0MsZ0NBQWdDLHVCQUF1QixjQUFjLGtIQUFrSCxHQUFHLG1IQUFtSCxnS0FBZ0ssbUNBQW1DLGdFQUFnRSwrRkFBK0YsbUNBQW1DLGlCQUFpQiw2QkFBNkIsdUJBQXVCLGNBQWMsa0VBQWtFLHNDQUFzQyxrSkFBa0osMkdBQTJHLGVBQWUsbUJBQW1CLE1BQU0sMEZBQTBGLFNBQVMsd0JBQXdCLGdHQUFnRyx1Z0JBQXVnQixrQ0FBa0MsRUFBRSxzQkFBc0Isa0ZBQWtGLG9CQUFvQixPQUFPLG9GQUFvRiw0Q0FBNEMsNENBQTRDLDhEQUE4RCxxQkFBcUIsb0JBQW9CLHFCQUFxQix5SUFBeUksWUFBWSxpSkFBaUosWUFBWSw2SUFBNkksWUFBWSw4SUFBOEksZ1FBQWdRLGtFQUFrRSxTQUFTLDRCQUE0QixFQUFFLHNCQUFzQix5QkFBeUIsNEJBQTRCLCtFQUErRSx5RkFBeUYsOENBQThDLEdBQUcseUJBQXlCLDBDQUEwQyw0QkFBNEIsdUNBQXVDLG1EQUFtRCwrQ0FBK0MsMEdBQTBHLHdIQUF3SCxhQUFhLGVBQWUsZ0JBQWdCLHFGQUFxRixvQkFBb0IsMklBQTJJLG9DQUFvQyxhQUFhLHdDQUF3QyxrQ0FBa0MscUJBQXFCLDZDQUE2QyxzSEFBc0gsWUFBWSxhQUFhLDBDQUEwQyxxQkFBcUIsSUFBSSw2RUFBNkUsU0FBUyxhQUFhLElBQUksMEJBQTBCLGFBQWEsa0NBQWtDLHlCQUF5QixpQ0FBaUMsMEVBQTBFLHFCQUFxQiw2RkFBNkYsc0JBQXNCLG1JQUFtSSxxR0FBcUcsaUJBQWlCLG1EQUFtRCxpQ0FBaUMsbURBQW1ELDBIQUEwSCxnQ0FBZ0MsdUJBQXVCLGlDQUFpQyxjQUFjLHNHQUFzRyxFQUFFLHNCQUFzQixhQUFhLE9BQU8scUNBQXFDLEVBQUUsNEJBQTRCLCtDQUErQyxjQUFjLDJEQUEyRCxVQUFVLGdCQUFnQixFQUFFLDJCQUEyQixXQUFXLDhDQUE4QyxpQkFBaUIsd0NBQXdDLDBFQUEwRSxzQkFBc0IsMkdBQTJHLGtFQUFrRSxPQUFPLEVBQUUsMEJBQTBCLHNMQUFzTCx5Q0FBeUMsc0ZBQXNGLDZCQUE2QixnREFBZ0QsMEJBQTBCLE1BQU0sa0lBQWtJLE9BQU8sYUFBYSx3QkFBd0IsU0FBUyxHQUFHLDJCQUEyQiwyQ0FBMkMsdUJBQXVCLHlHQUF5RywrRUFBK0UsZ0NBQWdDLEdBQUcscUJBQXFCLG9EQUFvRCx1QkFBdUIscUNBQXFDLGlHQUFpRyx1QkFBdUIsZ0RBQWdELGVBQWUsV0FBVyw2R0FBNkcsOEpBQThKLG9CQUFvQixzQkFBc0Isb0lBQW9JLGtDQUFrQyxXQUFXLGdGQUFnRixvQ0FBb0MsTUFBTSx1QkFBdUIsMENBQTBDLFVBQVUscUJBQXFCLHFDQUFxQyxTQUFTLGdEQUFnRCx1Q0FBdUMsWUFBWSxJQUFJLGdEQUFnRCxLQUFLLHFCQUFxQix1QkFBdUIsOEZBQThGLFVBQVUsNkJBQTZCLHVMQUF1TCx3QkFBd0IsOEJBQThCLHVDQUF1QyxtQ0FBbUMsRUFBRSxrQkFBa0Isb0RBQW9ELGVBQWUsZ0JBQWdCLG9EQUE2QyxpQkFBaUI7QUFBQSxnSEFBYSxnQ0FBZ0MsR0FBRyIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBsYXllci12Mi4xIOW8ueWxgue7hOS7tiBMaWNlbnNlIExHUEwgIGh0dHA6Ly9sYXllci5sYXl1aS5jb20vIEJ5IOi0pOW/gyAqL1xuOyFmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO3ZhciBjLGQsZT17Z2V0UGF0aDpmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LnNjcmlwdHMsYj1hW2EubGVuZ3RoLTFdLGM9Yi5zcmM7aWYoIWIuZ2V0QXR0cmlidXRlKFwibWVyZ2VcIikpcmV0dXJuIGMuc3Vic3RyaW5nKDAsYy5sYXN0SW5kZXhPZihcIi9cIikrMSl9KCksZW50ZXI6ZnVuY3Rpb24oYSl7MTM9PT1hLmtleUNvZGUmJmEucHJldmVudERlZmF1bHQoKX0sY29uZmlnOnt9LGVuZDp7fSxidG46W1wiJiN4Nzg2RTsmI3g1QjlBO1wiLFwiJiN4NTNENjsmI3g2RDg4O1wiXSx0eXBlOltcImRpYWxvZ1wiLFwicGFnZVwiLFwiaWZyYW1lXCIsXCJsb2FkaW5nXCIsXCJ0aXBzXCJdfSxmPXt2OlwiMi4xXCIsaWU2OiEhYS5BY3RpdmVYT2JqZWN0JiYhYS5YTUxIdHRwUmVxdWVzdCxpbmRleDowLHBhdGg6ZS5nZXRQYXRoLGNvbmZpZzpmdW5jdGlvbihhLGIpe3ZhciBkPTA7cmV0dXJuIGE9YXx8e30sZi5jYWNoZT1lLmNvbmZpZz1jLmV4dGVuZChlLmNvbmZpZyxhKSxmLnBhdGg9ZS5jb25maWcucGF0aHx8Zi5wYXRoLFwic3RyaW5nXCI9PXR5cGVvZiBhLmV4dGVuZCYmKGEuZXh0ZW5kPVthLmV4dGVuZF0pLGYudXNlKFwic2tpbi9sYXllci5jc3NcIixhLmV4dGVuZCYmYS5leHRlbmQubGVuZ3RoPjA/ZnVuY3Rpb24gZygpe3ZhciBjPWEuZXh0ZW5kO2YudXNlKGNbY1tkXT9kOmQtMV0sZDxjLmxlbmd0aD9mdW5jdGlvbigpe3JldHVybisrZCxnfSgpOmIpfSgpOmIpLHRoaXN9LHVzZTpmdW5jdGlvbihhLGIsZCl7dmFyIGU9YyhcImhlYWRcIilbMF0sYT1hLnJlcGxhY2UoL1xccy9nLFwiXCIpLGc9L1xcLmNzcyQvLnRlc3QoYSksaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGc/XCJsaW5rXCI6XCJzY3JpcHRcIiksaT1cImxheXVpX2xheWVyX1wiK2EucmVwbGFjZSgvXFwufFxcLy9nLFwiXCIpO3JldHVybiBmLnBhdGg/KGcmJihoLnJlbD1cInN0eWxlc2hlZXRcIiksaFtnP1wiaHJlZlwiOlwic3JjXCJdPS9eaHR0cDpcXC9cXC8vLnRlc3QoYSk/YTpmLnBhdGgrYSxoLmlkPWksYyhcIiNcIitpKVswXXx8ZS5hcHBlbmRDaGlsZChoKSxmdW5jdGlvbiBqKCl7KGc/MTk4OT09PXBhcnNlSW50KGMoXCIjXCIraSkuY3NzKFwid2lkdGhcIikpOmZbZHx8aV0pP2Z1bmN0aW9uKCl7YiYmYigpO3RyeXtnfHxlLnJlbW92ZUNoaWxkKGgpfWNhdGNoKGEpe319KCk6c2V0VGltZW91dChqLDEwMCl9KCksdGhpcyk6dm9pZCAwfSxyZWFkeTpmdW5jdGlvbihhLGIpe3ZhciBkPVwiZnVuY3Rpb25cIj09dHlwZW9mIGE7cmV0dXJuIGQmJihiPWEpLGYuY29uZmlnKGMuZXh0ZW5kKGUuY29uZmlnLGZ1bmN0aW9uKCl7cmV0dXJuIGQ/e306e3BhdGg6YX19KCkpLGIpLHRoaXN9LGFsZXJ0OmZ1bmN0aW9uKGEsYixkKXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiO3JldHVybiBlJiYoZD1iKSxmLm9wZW4oYy5leHRlbmQoe2NvbnRlbnQ6YSx5ZXM6ZH0sZT97fTpiKSl9LGNvbmZpcm06ZnVuY3Rpb24oYSxiLGQsZyl7dmFyIGg9XCJmdW5jdGlvblwiPT10eXBlb2YgYjtyZXR1cm4gaCYmKGc9ZCxkPWIpLGYub3BlbihjLmV4dGVuZCh7Y29udGVudDphLGJ0bjplLmJ0bix5ZXM6ZCxjYW5jZWw6Z30saD97fTpiKSl9LG1zZzpmdW5jdGlvbihhLGQsZyl7dmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgZCxqPWUuY29uZmlnLnNraW4saz0oaj9qK1wiIFwiK2orXCItbXNnXCI6XCJcIil8fFwibGF5dWktbGF5ZXItbXNnXCIsbD1oLmFuaW0ubGVuZ3RoLTE7cmV0dXJuIGkmJihnPWQpLGYub3BlbihjLmV4dGVuZCh7Y29udGVudDphLHRpbWU6M2UzLHNoYWRlOiExLHNraW46ayx0aXRsZTohMSxjbG9zZUJ0bjohMSxidG46ITEsZW5kOmd9LGkmJiFlLmNvbmZpZy5za2luP3tza2luOmsrXCIgbGF5dWktbGF5ZXItaHVpXCIsc2hpZnQ6bH06ZnVuY3Rpb24oKXtyZXR1cm4gZD1kfHx7fSwoLTE9PT1kLmljb258fGQuaWNvbj09PWImJiFlLmNvbmZpZy5za2luKSYmKGQuc2tpbj1rK1wiIFwiKyhkLnNraW58fFwibGF5dWktbGF5ZXItaHVpXCIpKSxkfSgpKSl9LGxvYWQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZi5vcGVuKGMuZXh0ZW5kKHt0eXBlOjMsaWNvbjphfHwwLHNoYWRlOi4wMX0sYikpfSx0aXBzOmZ1bmN0aW9uKGEsYixkKXtyZXR1cm4gZi5vcGVuKGMuZXh0ZW5kKHt0eXBlOjQsY29udGVudDpbYSxiXSxjbG9zZUJ0bjohMSx0aW1lOjNlMyxtYXhXaWR0aDoyMTB9LGQpKX19LGc9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztiLmluZGV4PSsrZi5pbmRleCxiLmNvbmZpZz1jLmV4dGVuZCh7fSxiLmNvbmZpZyxlLmNvbmZpZyxhKSxiLmNyZWF0KCl9O2cucHQ9Zy5wcm90b3R5cGU7dmFyIGg9W1wibGF5dWktbGF5ZXJcIixcIi5sYXl1aS1sYXllci10aXRsZVwiLFwiLmxheXVpLWxheWVyLW1haW5cIixcIi5sYXl1aS1sYXllci1kaWFsb2dcIixcImxheXVpLWxheWVyLWlmcmFtZVwiLFwibGF5dWktbGF5ZXItY29udGVudFwiLFwibGF5dWktbGF5ZXItYnRuXCIsXCJsYXl1aS1sYXllci1jbG9zZVwiXTtoLmFuaW09W1wibGF5dWktYW5pbVwiLFwibGF5dWktYW5pbS0wMVwiLFwibGF5dWktYW5pbS0wMlwiLFwibGF5dWktYW5pbS0wM1wiLFwibGF5dWktYW5pbS0wNFwiLFwibGF5dWktYW5pbS0wNVwiLFwibGF5dWktYW5pbS0wNlwiXSxnLnB0LmNvbmZpZz17dHlwZTowLHNoYWRlOi4zLGZpeDohMCxtb3ZlOmhbMV0sdGl0bGU6XCImI3g0RkUxOyYjeDYwNkY7XCIsb2Zmc2V0OlwiYXV0b1wiLGFyZWE6XCJhdXRvXCIsY2xvc2VCdG46MSx0aW1lOjAsekluZGV4OjE5ODkxMDE0LG1heFdpZHRoOjM2MCxzaGlmdDowLGljb246LTEsc2Nyb2xsYmFyOiEwLHRpcHM6Mn0sZy5wdC52ZXNzZWw9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5pbmRleCxmPWMuY29uZmlnLGc9Zi56SW5kZXgrZCxpPVwib2JqZWN0XCI9PXR5cGVvZiBmLnRpdGxlLGo9Zi5tYXhtaW4mJigxPT09Zi50eXBlfHwyPT09Zi50eXBlKSxrPWYudGl0bGU/JzxkaXYgY2xhc3M9XCJsYXl1aS1sYXllci10aXRsZVwiIHN0eWxlPVwiJysoaT9mLnRpdGxlWzFdOlwiXCIpKydcIj4nKyhpP2YudGl0bGVbMF06Zi50aXRsZSkrXCI8L2Rpdj5cIjpcIlwiO3JldHVybiBmLnpJbmRleD1nLGIoW2Yuc2hhZGU/JzxkaXYgY2xhc3M9XCJsYXl1aS1sYXllci1zaGFkZVwiIGlkPVwibGF5dWktbGF5ZXItc2hhZGUnK2QrJ1wiIHRpbWVzPVwiJytkKydcIiBzdHlsZT1cIicrKFwiei1pbmRleDpcIisoZy0xKStcIjsgYmFja2dyb3VuZC1jb2xvcjpcIisoZi5zaGFkZVsxXXx8XCIjMDAwXCIpK1wiOyBvcGFjaXR5OlwiKyhmLnNoYWRlWzBdfHxmLnNoYWRlKStcIjsgZmlsdGVyOmFscGhhKG9wYWNpdHk9XCIrKDEwMCpmLnNoYWRlWzBdfHwxMDAqZi5zaGFkZSkrXCIpO1wiKSsnXCI+PC9kaXY+JzpcIlwiLCc8ZGl2IGNsYXNzPVwiJytoWzBdK1wiIFwiKyhoLmFuaW1bZi5zaGlmdF18fFwiXCIpKyhcIiBsYXl1aS1sYXllci1cIitlLnR5cGVbZi50eXBlXSkrKDAhPWYudHlwZSYmMiE9Zi50eXBlfHxmLnNoYWRlP1wiXCI6XCIgbGF5dWktbGF5ZXItYm9yZGVyXCIpK1wiIFwiKyhmLnNraW58fFwiXCIpKydcIiBpZD1cIicraFswXStkKydcIiB0eXBlPVwiJytlLnR5cGVbZi50eXBlXSsnXCIgdGltZXM9XCInK2QrJ1wiIHNob3d0aW1lPVwiJytmLnRpbWUrJ1wiIGNvblR5cGU9XCInKyhhP1wib2JqZWN0XCI6XCJzdHJpbmdcIikrJ1wiIHN0eWxlPVwiei1pbmRleDogJytnK1wiOyB3aWR0aDpcIitmLmFyZWFbMF0rXCI7aGVpZ2h0OlwiK2YuYXJlYVsxXSsoZi5maXg/XCJcIjpcIjtwb3NpdGlvbjphYnNvbHV0ZTtcIikrJ1wiPicrKGEmJjIhPWYudHlwZT9cIlwiOmspKyc8ZGl2IGNsYXNzPVwibGF5dWktbGF5ZXItY29udGVudCcrKDA9PWYudHlwZSYmLTEhPT1mLmljb24/XCIgbGF5dWktbGF5ZXItcGFkZGluZ1wiOlwiXCIpKygzPT1mLnR5cGU/XCIgbGF5dWktbGF5ZXItbG9hZGluZ1wiK2YuaWNvbjpcIlwiKSsnXCI+JysoMD09Zi50eXBlJiYtMSE9PWYuaWNvbj8nPGkgY2xhc3M9XCJsYXl1aS1sYXllci1pY28gbGF5dWktbGF5ZXItaWNvJytmLmljb24rJ1wiPjwvaT4nOlwiXCIpKygxPT1mLnR5cGUmJmE/XCJcIjpmLmNvbnRlbnR8fFwiXCIpKyc8L2Rpdj48c3BhbiBjbGFzcz1cImxheXVpLWxheWVyLXNldHdpblwiPicrZnVuY3Rpb24oKXt2YXIgYT1qPyc8YSBjbGFzcz1cImxheXVpLWxheWVyLW1pblwiIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj48Y2l0ZT48L2NpdGU+PC9hPjxhIGNsYXNzPVwibGF5dWktbGF5ZXItaWNvIGxheXVpLWxheWVyLW1heFwiIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj48L2E+JzpcIlwiO3JldHVybiBmLmNsb3NlQnRuJiYoYSs9JzxhIGNsYXNzPVwibGF5dWktbGF5ZXItaWNvICcraFs3XStcIiBcIitoWzddKyhmLnRpdGxlP2YuY2xvc2VCdG46ND09Zi50eXBlP1wiMVwiOlwiMlwiKSsnXCIgaHJlZj1cImphdmFzY3JpcHQ6O1wiPjwvYT4nKSxhfSgpK1wiPC9zcGFuPlwiKyhmLmJ0bj9mdW5jdGlvbigpe3ZhciBhPVwiXCI7XCJzdHJpbmdcIj09dHlwZW9mIGYuYnRuJiYoZi5idG49W2YuYnRuXSk7Zm9yKHZhciBiPTAsYz1mLmJ0bi5sZW5ndGg7Yz5iO2IrKylhKz0nPGEgY2xhc3M9XCInK2hbNl0rYisnXCI+JytmLmJ0bltiXStcIjwvYT5cIjtyZXR1cm4nPGRpdiBjbGFzcz1cIicraFs2XSsnXCI+JythK1wiPC9kaXY+XCJ9KCk6XCJcIikrXCI8L2Rpdj5cIl0sayksY30sZy5wdC5jcmVhdD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNvbmZpZyxnPWEuaW5kZXgsaT1iLmNvbnRlbnQsaj1cIm9iamVjdFwiPT10eXBlb2YgaTtzd2l0Y2goXCJzdHJpbmdcIj09dHlwZW9mIGIuYXJlYSYmKGIuYXJlYT1cImF1dG9cIj09PWIuYXJlYT9bXCJcIixcIlwiXTpbYi5hcmVhLFwiXCJdKSxiLnR5cGUpe2Nhc2UgMDpiLmJ0bj1cImJ0blwiaW4gYj9iLmJ0bjplLmJ0blswXSxmLmNsb3NlQWxsKFwiZGlhbG9nXCIpO2JyZWFrO2Nhc2UgMjp2YXIgaT1iLmNvbnRlbnQ9aj9iLmNvbnRlbnQ6W2IuY29udGVudHx8XCJodHRwOi8vbGF5ZXIubGF5dWkuY29tXCIsXCJhdXRvXCJdO2IuY29udGVudD0nPGlmcmFtZSBzY3JvbGxpbmc9XCInKyhiLmNvbnRlbnRbMV18fFwiYXV0b1wiKSsnXCIgYWxsb3d0cmFuc3BhcmVuY3k9XCJ0cnVlXCIgaWQ9XCInK2hbNF0rZysnXCIgbmFtZT1cIicraFs0XStnKydcIiBvbmxvYWQ9XCJ0aGlzLmNsYXNzTmFtZT1cXCdcXCc7XCIgY2xhc3M9XCJsYXl1aS1sYXllci1sb2FkXCIgZnJhbWVib3JkZXI9XCIwXCIgc3JjPVwiJytiLmNvbnRlbnRbMF0rJ1wiPjwvaWZyYW1lPic7YnJlYWs7Y2FzZSAzOmIudGl0bGU9ITEsYi5jbG9zZUJ0bj0hMSwtMT09PWIuaWNvbiYmMD09PWIuaWNvbixmLmNsb3NlQWxsKFwibG9hZGluZ1wiKTticmVhaztjYXNlIDQ6anx8KGIuY29udGVudD1bYi5jb250ZW50LFwiYm9keVwiXSksYi5mb2xsb3c9Yi5jb250ZW50WzFdLGIuY29udGVudD1iLmNvbnRlbnRbMF0rJzxpIGNsYXNzPVwibGF5dWktbGF5ZXItVGlwc0dcIj48L2k+JyxiLnRpdGxlPSExLGIuc2hhZGU9ITEsYi5maXg9ITEsYi50aXBzPVwib2JqZWN0XCI9PXR5cGVvZiBiLnRpcHM/Yi50aXBzOltiLnRpcHMsITBdLGIudGlwc01vcmV8fGYuY2xvc2VBbGwoXCJ0aXBzXCIpfWEudmVzc2VsKGosZnVuY3Rpb24oZCxlKXtjKFwiYm9keVwiKS5hcHBlbmQoZFswXSksaj9mdW5jdGlvbigpezI9PWIudHlwZXx8ND09Yi50eXBlP2Z1bmN0aW9uKCl7YyhcImJvZHlcIikuYXBwZW5kKGRbMV0pfSgpOmZ1bmN0aW9uKCl7aS5wYXJlbnRzKFwiLlwiK2hbMF0pWzBdfHwoaS5zaG93KCkuYWRkQ2xhc3MoXCJsYXl1aS1sYXllci13cmFwXCIpLndyYXAoZFsxXSksYyhcIiNcIitoWzBdK2cpLmZpbmQoXCIuXCIraFs1XSkuYmVmb3JlKGUpKX0oKX0oKTpjKFwiYm9keVwiKS5hcHBlbmQoZFsxXSksYS5sYXllcm89YyhcIiNcIitoWzBdK2cpLGIuc2Nyb2xsYmFyfHxoLmh0bWwuY3NzKFwib3ZlcmZsb3dcIixcImhpZGRlblwiKS5hdHRyKFwibGF5ZXItZnVsbFwiLGcpfSkuYXV0byhnKSwyPT1iLnR5cGUmJmYuaWU2JiZhLmxheWVyby5maW5kKFwiaWZyYW1lXCIpLmF0dHIoXCJzcmNcIixpWzBdKSxjKGRvY3VtZW50KS5vZmYoXCJrZXlkb3duXCIsZS5lbnRlcikub24oXCJrZXlkb3duXCIsZS5lbnRlciksYS5sYXllcm8ub24oXCJrZXlkb3duXCIsZnVuY3Rpb24oYSl7Yyhkb2N1bWVudCkub2ZmKFwia2V5ZG93blwiLGUuZW50ZXIpfSksND09Yi50eXBlP2EudGlwcygpOmEub2Zmc2V0KCksYi5maXgmJmQub24oXCJyZXNpemVcIixmdW5jdGlvbigpe2Eub2Zmc2V0KCksKC9eXFxkKyUkLy50ZXN0KGIuYXJlYVswXSl8fC9eXFxkKyUkLy50ZXN0KGIuYXJlYVsxXSkpJiZhLmF1dG8oZyksND09Yi50eXBlJiZhLnRpcHMoKX0pLGIudGltZTw9MHx8c2V0VGltZW91dChmdW5jdGlvbigpe2YuY2xvc2UoYS5pbmRleCl9LGIudGltZSksYS5tb3ZlKCkuY2FsbGJhY2soKX0sZy5wdC5hdXRvPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7YT1nLmZpbmQoYSksYS5oZWlnaHQoaVsxXS1qLWstMiooMHxwYXJzZUZsb2F0KGEuY3NzKFwicGFkZGluZ1wiKSkpKX12YXIgZT10aGlzLGY9ZS5jb25maWcsZz1jKFwiI1wiK2hbMF0rYSk7XCJcIj09PWYuYXJlYVswXSYmZi5tYXhXaWR0aD4wJiYoL01TSUUgNy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmZi5idG4mJmcud2lkdGgoZy5pbm5lcldpZHRoKCkpLGcub3V0ZXJXaWR0aCgpPmYubWF4V2lkdGgmJmcud2lkdGgoZi5tYXhXaWR0aCkpO3ZhciBpPVtnLmlubmVyV2lkdGgoKSxnLmlubmVySGVpZ2h0KCldLGo9Zy5maW5kKGhbMV0pLm91dGVySGVpZ2h0KCl8fDAsaz1nLmZpbmQoXCIuXCIraFs2XSkub3V0ZXJIZWlnaHQoKXx8MDtzd2l0Y2goZi50eXBlKXtjYXNlIDI6YihcImlmcmFtZVwiKTticmVhaztkZWZhdWx0OlwiXCI9PT1mLmFyZWFbMV0/Zi5maXgmJmlbMV0+PWQuaGVpZ2h0KCkmJihpWzFdPWQuaGVpZ2h0KCksYihcIi5cIitoWzVdKSk6YihcIi5cIitoWzVdKX1yZXR1cm4gZX0sZy5wdC5vZmZzZXQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jb25maWcsYz1hLmxheWVybyxlPVtjLm91dGVyV2lkdGgoKSxjLm91dGVySGVpZ2h0KCldLGY9XCJvYmplY3RcIj09dHlwZW9mIGIub2Zmc2V0O2Eub2Zmc2V0VG9wPShkLmhlaWdodCgpLWVbMV0pLzIsYS5vZmZzZXRMZWZ0PShkLndpZHRoKCktZVswXSkvMixmPyhhLm9mZnNldFRvcD1iLm9mZnNldFswXSxhLm9mZnNldExlZnQ9Yi5vZmZzZXRbMV18fGEub2Zmc2V0TGVmdCk6XCJhdXRvXCIhPT1iLm9mZnNldCYmKGEub2Zmc2V0VG9wPWIub2Zmc2V0LFwicmJcIj09PWIub2Zmc2V0JiYoYS5vZmZzZXRUb3A9ZC5oZWlnaHQoKS1lWzFdLGEub2Zmc2V0TGVmdD1kLndpZHRoKCktZVswXSkpLGIuZml4fHwoYS5vZmZzZXRUb3A9LyUkLy50ZXN0KGEub2Zmc2V0VG9wKT9kLmhlaWdodCgpKnBhcnNlRmxvYXQoYS5vZmZzZXRUb3ApLzEwMDpwYXJzZUZsb2F0KGEub2Zmc2V0VG9wKSxhLm9mZnNldExlZnQ9LyUkLy50ZXN0KGEub2Zmc2V0TGVmdCk/ZC53aWR0aCgpKnBhcnNlRmxvYXQoYS5vZmZzZXRMZWZ0KS8xMDA6cGFyc2VGbG9hdChhLm9mZnNldExlZnQpLGEub2Zmc2V0VG9wKz1kLnNjcm9sbFRvcCgpLGEub2Zmc2V0TGVmdCs9ZC5zY3JvbGxMZWZ0KCkpLGMuY3NzKHt0b3A6YS5vZmZzZXRUb3AsbGVmdDphLm9mZnNldExlZnR9KX0sZy5wdC50aXBzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY29uZmlnLGU9YS5sYXllcm8sZj1bZS5vdXRlcldpZHRoKCksZS5vdXRlckhlaWdodCgpXSxnPWMoYi5mb2xsb3cpO2dbMF18fChnPWMoXCJib2R5XCIpKTt2YXIgaT17d2lkdGg6Zy5vdXRlcldpZHRoKCksaGVpZ2h0Omcub3V0ZXJIZWlnaHQoKSx0b3A6Zy5vZmZzZXQoKS50b3AsbGVmdDpnLm9mZnNldCgpLmxlZnR9LGo9ZS5maW5kKFwiLmxheXVpLWxheWVyLVRpcHNHXCIpLGs9Yi50aXBzWzBdO2IudGlwc1sxXXx8ai5yZW1vdmUoKSxpLmF1dG9MZWZ0PWZ1bmN0aW9uKCl7aS5sZWZ0K2ZbMF0tZC53aWR0aCgpPjA/KGkudGlwTGVmdD1pLmxlZnQraS53aWR0aC1mWzBdLGouY3NzKHtyaWdodDoxMixsZWZ0OlwiYXV0b1wifSkpOmkudGlwTGVmdD1pLmxlZnR9LGkud2hlcmU9W2Z1bmN0aW9uKCl7aS5hdXRvTGVmdCgpLGkudGlwVG9wPWkudG9wLWZbMV0tMTAsai5yZW1vdmVDbGFzcyhcImxheXVpLWxheWVyLVRpcHNCXCIpLmFkZENsYXNzKFwibGF5dWktbGF5ZXItVGlwc1RcIikuY3NzKFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCIsYi50aXBzWzFdKX0sZnVuY3Rpb24oKXtpLnRpcExlZnQ9aS5sZWZ0K2kud2lkdGgrMTAsaS50aXBUb3A9aS50b3Asai5yZW1vdmVDbGFzcyhcImxheXVpLWxheWVyLVRpcHNMXCIpLmFkZENsYXNzKFwibGF5dWktbGF5ZXItVGlwc1JcIikuY3NzKFwiYm9yZGVyLWJvdHRvbS1jb2xvclwiLGIudGlwc1sxXSl9LGZ1bmN0aW9uKCl7aS5hdXRvTGVmdCgpLGkudGlwVG9wPWkudG9wK2kuaGVpZ2h0KzEwLGoucmVtb3ZlQ2xhc3MoXCJsYXl1aS1sYXllci1UaXBzVFwiKS5hZGRDbGFzcyhcImxheXVpLWxheWVyLVRpcHNCXCIpLmNzcyhcImJvcmRlci1yaWdodC1jb2xvclwiLGIudGlwc1sxXSl9LGZ1bmN0aW9uKCl7aS50aXBMZWZ0PWkubGVmdC1mWzBdLTEwLGkudGlwVG9wPWkudG9wLGoucmVtb3ZlQ2xhc3MoXCJsYXl1aS1sYXllci1UaXBzUlwiKS5hZGRDbGFzcyhcImxheXVpLWxheWVyLVRpcHNMXCIpLmNzcyhcImJvcmRlci1ib3R0b20tY29sb3JcIixiLnRpcHNbMV0pfV0saS53aGVyZVtrLTFdKCksMT09PWs/aS50b3AtKGQuc2Nyb2xsVG9wKCkrZlsxXSsxNik8MCYmaS53aGVyZVsyXSgpOjI9PT1rP2Qud2lkdGgoKS0oaS5sZWZ0K2kud2lkdGgrZlswXSsxNik+MHx8aS53aGVyZVszXSgpOjM9PT1rP2kudG9wLWQuc2Nyb2xsVG9wKCkraS5oZWlnaHQrZlsxXSsxNi1kLmhlaWdodCgpPjAmJmkud2hlcmVbMF0oKTo0PT09ayYmZlswXSsxNi1pLmxlZnQ+MCYmaS53aGVyZVsxXSgpLGUuZmluZChcIi5cIitoWzVdKS5jc3Moe1wiYmFja2dyb3VuZC1jb2xvclwiOmIudGlwc1sxXSxcInBhZGRpbmctcmlnaHRcIjpiLmNsb3NlQnRuP1wiMzBweFwiOlwiXCJ9KSxlLmNzcyh7bGVmdDppLnRpcExlZnQsdG9wOmkudGlwVG9wfSl9LGcucHQubW92ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNvbmZpZyxlPXtzZXRZOjAsbW92ZUxheWVyOmZ1bmN0aW9uKCl7dmFyIGE9ZS5sYXllcm8sYj1wYXJzZUludChhLmNzcyhcIm1hcmdpbi1sZWZ0XCIpKSxjPXBhcnNlSW50KGUubW92ZS5jc3MoXCJsZWZ0XCIpKTswPT09Ynx8KGMtPWIpLFwiZml4ZWRcIiE9PWEuY3NzKFwicG9zaXRpb25cIikmJihjLT1hLnBhcmVudCgpLm9mZnNldCgpLmxlZnQsZS5zZXRZPTApLGEuY3NzKHtsZWZ0OmMsdG9wOnBhcnNlSW50KGUubW92ZS5jc3MoXCJ0b3BcIikpLWUuc2V0WX0pfX0sZj1hLmxheWVyby5maW5kKGIubW92ZSk7cmV0dXJuIGIubW92ZSYmZi5hdHRyKFwibW92ZVwiLFwib2tcIiksZi5jc3Moe2N1cnNvcjpiLm1vdmU/XCJtb3ZlXCI6XCJhdXRvXCJ9KSxjKGIubW92ZSkub24oXCJtb3VzZWRvd25cIixmdW5jdGlvbihhKXtpZihhLnByZXZlbnREZWZhdWx0KCksXCJva1wiPT09Yyh0aGlzKS5hdHRyKFwibW92ZVwiKSl7ZS5pc21vdmU9ITAsZS5sYXllcm89Yyh0aGlzKS5wYXJlbnRzKFwiLlwiK2hbMF0pO3ZhciBmPWUubGF5ZXJvLm9mZnNldCgpLmxlZnQsZz1lLmxheWVyby5vZmZzZXQoKS50b3AsaT1lLmxheWVyby5vdXRlcldpZHRoKCktNixqPWUubGF5ZXJvLm91dGVySGVpZ2h0KCktNjtjKFwiI2xheXVpLWxheWVyLW1vdmVzXCIpWzBdfHxjKFwiYm9keVwiKS5hcHBlbmQoJzxkaXYgaWQ9XCJsYXl1aS1sYXllci1tb3Zlc1wiIGNsYXNzPVwibGF5dWktbGF5ZXItbW92ZXNcIiBzdHlsZT1cImxlZnQ6JytmK1wicHg7IHRvcDpcIitnK1wicHg7IHdpZHRoOlwiK2krXCJweDsgaGVpZ2h0OlwiK2orJ3B4OyB6LWluZGV4OjIxNDc0ODM1ODRcIj48L2Rpdj4nKSxlLm1vdmU9YyhcIiNsYXl1aS1sYXllci1tb3Zlc1wiKSxiLm1vdmVUeXBlJiZlLm1vdmUuY3NzKHt2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KSxlLm1vdmVYPWEucGFnZVgtZS5tb3ZlLnBvc2l0aW9uKCkubGVmdCxlLm1vdmVZPWEucGFnZVktZS5tb3ZlLnBvc2l0aW9uKCkudG9wLFwiZml4ZWRcIiE9PWUubGF5ZXJvLmNzcyhcInBvc2l0aW9uXCIpfHwoZS5zZXRZPWQuc2Nyb2xsVG9wKCkpfX0pLGMoZG9jdW1lbnQpLm1vdXNlbW92ZShmdW5jdGlvbihhKXtpZihlLmlzbW92ZSl7dmFyIGM9YS5wYWdlWC1lLm1vdmVYLGY9YS5wYWdlWS1lLm1vdmVZO2lmKGEucHJldmVudERlZmF1bHQoKSwhYi5tb3ZlT3V0KXtlLnNldFk9ZC5zY3JvbGxUb3AoKTt2YXIgZz1kLndpZHRoKCktZS5tb3ZlLm91dGVyV2lkdGgoKSxoPWUuc2V0WTswPmMmJihjPTApLGM+ZyYmKGM9ZyksaD5mJiYoZj1oKSxmPmQuaGVpZ2h0KCktZS5tb3ZlLm91dGVySGVpZ2h0KCkrZS5zZXRZJiYoZj1kLmhlaWdodCgpLWUubW92ZS5vdXRlckhlaWdodCgpK2Uuc2V0WSl9ZS5tb3ZlLmNzcyh7bGVmdDpjLHRvcDpmfSksYi5tb3ZlVHlwZSYmZS5tb3ZlTGF5ZXIoKSxjPWY9Zz1oPW51bGx9fSkubW91c2V1cChmdW5jdGlvbigpe3RyeXtlLmlzbW92ZSYmKGUubW92ZUxheWVyKCksZS5tb3ZlLnJlbW92ZSgpLGIubW92ZUVuZCYmYi5tb3ZlRW5kKCkpLGUuaXNtb3ZlPSExfWNhdGNoKGEpe2UuaXNtb3ZlPSExfX0pLGF9LGcucHQuY2FsbGJhY2s9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dmFyIGE9Zy5jYW5jZWwmJmcuY2FuY2VsKGIuaW5kZXgpO2E9PT0hMXx8Zi5jbG9zZShiLmluZGV4KX12YXIgYj10aGlzLGQ9Yi5sYXllcm8sZz1iLmNvbmZpZztiLm9wZW5MYXllcigpLGcuc3VjY2VzcyYmKDI9PWcudHlwZT9kLmZpbmQoXCJpZnJhbWVcIikub24oXCJsb2FkXCIsZnVuY3Rpb24oKXtnLnN1Y2Nlc3MoZCxiLmluZGV4KX0pOmcuc3VjY2VzcyhkLGIuaW5kZXgpKSxmLmllNiYmYi5JRTYoZCksZC5maW5kKFwiLlwiK2hbNl0pLmNoaWxkcmVuKFwiYVwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXt2YXIgZT1jKHRoaXMpLmluZGV4KCk7Z1tcImJ0blwiKyhlKzEpXSYmZ1tcImJ0blwiKyhlKzEpXShiLmluZGV4LGQpLDA9PT1lP2cueWVzP2cueWVzKGIuaW5kZXgsZCk6Zi5jbG9zZShiLmluZGV4KToxPT09ZT9hKCk6Z1tcImJ0blwiKyhlKzEpXXx8Zi5jbG9zZShiLmluZGV4KX0pLGQuZmluZChcIi5cIitoWzddKS5vbihcImNsaWNrXCIsYSksZy5zaGFkZUNsb3NlJiZjKFwiI2xheXVpLWxheWVyLXNoYWRlXCIrYi5pbmRleCkub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7Zi5jbG9zZShiLmluZGV4KX0pLGQuZmluZChcIi5sYXl1aS1sYXllci1taW5cIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7Zi5taW4oYi5pbmRleCxnKSxnLm1pbiYmZy5taW4oZCl9KSxkLmZpbmQoXCIubGF5dWktbGF5ZXItbWF4XCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2ModGhpcykuaGFzQ2xhc3MoXCJsYXl1aS1sYXllci1tYXhtaW5cIik/KGYucmVzdG9yZShiLmluZGV4KSxnLnJlc3RvcmUmJmcucmVzdG9yZShkKSk6KGYuZnVsbChiLmluZGV4LGcpLGcuZnVsbCYmZy5mdWxsKGQpKX0pLGcuZW5kJiYoZS5lbmRbYi5pbmRleF09Zy5lbmQpfSxlLnJlc2VsZWN0PWZ1bmN0aW9uKCl7Yy5lYWNoKGMoXCJzZWxlY3RcIiksZnVuY3Rpb24oYSxiKXt2YXIgZD1jKHRoaXMpO2QucGFyZW50cyhcIi5cIitoWzBdKVswXXx8MT09ZC5hdHRyKFwibGF5ZXJcIikmJmMoXCIuXCIraFswXSkubGVuZ3RoPDEmJmQucmVtb3ZlQXR0cihcImxheWVyXCIpLnNob3coKSxkPW51bGx9KX0sZy5wdC5JRTY9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe2EuY3NzKHt0b3A6ZisoZS5jb25maWcuZml4P2Quc2Nyb2xsVG9wKCk6MCl9KX12YXIgZT10aGlzLGY9YS5vZmZzZXQoKS50b3A7YigpLGQuc2Nyb2xsKGIpLGMoXCJzZWxlY3RcIikuZWFjaChmdW5jdGlvbihhLGIpe3ZhciBkPWModGhpcyk7ZC5wYXJlbnRzKFwiLlwiK2hbMF0pWzBdfHxcIm5vbmVcIj09PWQuY3NzKFwiZGlzcGxheVwiKXx8ZC5hdHRyKHtsYXllcjpcIjFcIn0pLmhpZGUoKSxkPW51bGx9KX0sZy5wdC5vcGVuTGF5ZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2YuekluZGV4PWEuY29uZmlnLnpJbmRleCxmLnNldFRvcD1mdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2YuekluZGV4KyssYS5jc3MoXCJ6LWluZGV4XCIsZi56SW5kZXgrMSl9O3JldHVybiBmLnpJbmRleD1wYXJzZUludChhWzBdLnN0eWxlLnpJbmRleCksYS5vbihcIm1vdXNlZG93blwiLGIpLGYuekluZGV4fX0sZS5yZWNvcmQ9ZnVuY3Rpb24oYSl7dmFyIGI9W2Eub3V0ZXJXaWR0aCgpLGEub3V0ZXJIZWlnaHQoKSxhLnBvc2l0aW9uKCkudG9wLGEucG9zaXRpb24oKS5sZWZ0K3BhcnNlRmxvYXQoYS5jc3MoXCJtYXJnaW4tbGVmdFwiKSldO2EuZmluZChcIi5sYXl1aS1sYXllci1tYXhcIikuYWRkQ2xhc3MoXCJsYXl1aS1sYXllci1tYXhtaW5cIiksYS5hdHRyKHthcmVhOmJ9KX0sZS5yZXNjb2xsYmFyPWZ1bmN0aW9uKGEpe2guaHRtbC5hdHRyKFwibGF5ZXItZnVsbFwiKT09YSYmKGguaHRtbFswXS5zdHlsZS5yZW1vdmVQcm9wZXJ0eT9oLmh0bWxbMF0uc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJvdmVyZmxvd1wiKTpoLmh0bWxbMF0uc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwib3ZlcmZsb3dcIiksaC5odG1sLnJlbW92ZUF0dHIoXCJsYXllci1mdWxsXCIpKX0sYS5sYXllcj1mLGYuZ2V0Q2hpbGRGcmFtZT1mdW5jdGlvbihhLGIpe3JldHVybiBiPWJ8fGMoXCIuXCIraFs0XSkuYXR0cihcInRpbWVzXCIpLGMoXCIjXCIraFswXStiKS5maW5kKFwiaWZyYW1lXCIpLmNvbnRlbnRzKCkuZmluZChhKX0sZi5nZXRGcmFtZUluZGV4PWZ1bmN0aW9uKGEpe3JldHVybiBjKFwiI1wiK2EpLnBhcmVudHMoXCIuXCIraFs0XSkuYXR0cihcInRpbWVzXCIpfSxmLmlmcmFtZUF1dG89ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9Zi5nZXRDaGlsZEZyYW1lKFwiaHRtbFwiLGEpLm91dGVySGVpZ2h0KCksZD1jKFwiI1wiK2hbMF0rYSksZT1kLmZpbmQoaFsxXSkub3V0ZXJIZWlnaHQoKXx8MCxnPWQuZmluZChcIi5cIitoWzZdKS5vdXRlckhlaWdodCgpfHwwO2QuY3NzKHtoZWlnaHQ6YitlK2d9KSxkLmZpbmQoXCJpZnJhbWVcIikuY3NzKHtoZWlnaHQ6Yn0pfX0sZi5pZnJhbWVTcmM9ZnVuY3Rpb24oYSxiKXtjKFwiI1wiK2hbMF0rYSkuZmluZChcImlmcmFtZVwiKS5hdHRyKFwic3JjXCIsYil9LGYuc3R5bGU9ZnVuY3Rpb24oYSxiKXt2YXIgZD1jKFwiI1wiK2hbMF0rYSksZj1kLmF0dHIoXCJ0eXBlXCIpLGc9ZC5maW5kKGhbMV0pLm91dGVySGVpZ2h0KCl8fDAsaT1kLmZpbmQoXCIuXCIraFs2XSkub3V0ZXJIZWlnaHQoKXx8MDsoZj09PWUudHlwZVsxXXx8Zj09PWUudHlwZVsyXSkmJihkLmNzcyhiKSxmPT09ZS50eXBlWzJdJiZkLmZpbmQoXCJpZnJhbWVcIikuY3NzKHtoZWlnaHQ6cGFyc2VGbG9hdChiLmhlaWdodCktZy1pfSkpfSxmLm1pbj1mdW5jdGlvbihhLGIpe3ZhciBkPWMoXCIjXCIraFswXSthKSxnPWQuZmluZChoWzFdKS5vdXRlckhlaWdodCgpfHwwO2UucmVjb3JkKGQpLGYuc3R5bGUoYSx7d2lkdGg6MTgwLGhlaWdodDpnLG92ZXJmbG93OlwiaGlkZGVuXCJ9KSxkLmZpbmQoXCIubGF5dWktbGF5ZXItbWluXCIpLmhpZGUoKSxcInBhZ2VcIj09PWQuYXR0cihcInR5cGVcIikmJmQuZmluZChoWzRdKS5oaWRlKCksZS5yZXNjb2xsYmFyKGEpfSxmLnJlc3RvcmU9ZnVuY3Rpb24oYSl7dmFyIGI9YyhcIiNcIitoWzBdK2EpLGQ9Yi5hdHRyKFwiYXJlYVwiKS5zcGxpdChcIixcIik7Yi5hdHRyKFwidHlwZVwiKTtmLnN0eWxlKGEse3dpZHRoOnBhcnNlRmxvYXQoZFswXSksaGVpZ2h0OnBhcnNlRmxvYXQoZFsxXSksdG9wOnBhcnNlRmxvYXQoZFsyXSksbGVmdDpwYXJzZUZsb2F0KGRbM10pLG92ZXJmbG93OlwidmlzaWJsZVwifSksYi5maW5kKFwiLmxheXVpLWxheWVyLW1heFwiKS5yZW1vdmVDbGFzcyhcImxheXVpLWxheWVyLW1heG1pblwiKSxiLmZpbmQoXCIubGF5dWktbGF5ZXItbWluXCIpLnNob3coKSxcInBhZ2VcIj09PWIuYXR0cihcInR5cGVcIikmJmIuZmluZChoWzRdKS5zaG93KCksZS5yZXNjb2xsYmFyKGEpfSxmLmZ1bGw9ZnVuY3Rpb24oYSl7dmFyIGIsZz1jKFwiI1wiK2hbMF0rYSk7ZS5yZWNvcmQoZyksaC5odG1sLmF0dHIoXCJsYXllci1mdWxsXCIpfHxoLmh0bWwuY3NzKFwib3ZlcmZsb3dcIixcImhpZGRlblwiKS5hdHRyKFwibGF5ZXItZnVsbFwiLGEpLGNsZWFyVGltZW91dChiKSxiPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgYj1cImZpeGVkXCI9PT1nLmNzcyhcInBvc2l0aW9uXCIpO2Yuc3R5bGUoYSx7dG9wOmI/MDpkLnNjcm9sbFRvcCgpLGxlZnQ6Yj8wOmQuc2Nyb2xsTGVmdCgpLHdpZHRoOmQud2lkdGgoKSxoZWlnaHQ6ZC5oZWlnaHQoKX0pLGcuZmluZChcIi5sYXl1aS1sYXllci1taW5cIikuaGlkZSgpfSwxMDApfSxmLnRpdGxlPWZ1bmN0aW9uKGEsYil7dmFyIGQ9YyhcIiNcIitoWzBdKyhifHxmLmluZGV4KSkuZmluZChoWzFdKTtkLmh0bWwoYSl9LGYuY2xvc2U9ZnVuY3Rpb24oYSl7dmFyIGI9YyhcIiNcIitoWzBdK2EpLGQ9Yi5hdHRyKFwidHlwZVwiKTtpZihiWzBdKXtpZihkPT09ZS50eXBlWzFdJiZcIm9iamVjdFwiPT09Yi5hdHRyKFwiY29uVHlwZVwiKSl7Yi5jaGlsZHJlbihcIjpub3QoLlwiK2hbNV0rXCIpXCIpLnJlbW92ZSgpO2Zvcih2YXIgZz0wOzI+ZztnKyspYi5maW5kKFwiLmxheXVpLWxheWVyLXdyYXBcIikudW53cmFwKCkuaGlkZSgpfWVsc2V7aWYoZD09PWUudHlwZVsyXSl0cnl7dmFyIGk9YyhcIiNcIitoWzRdK2EpWzBdO2kuY29udGVudFdpbmRvdy5kb2N1bWVudC53cml0ZShcIlwiKSxpLmNvbnRlbnRXaW5kb3cuY2xvc2UoKSxiLmZpbmQoXCIuXCIraFs1XSlbMF0ucmVtb3ZlQ2hpbGQoaSl9Y2F0Y2goail7fWJbMF0uaW5uZXJIVE1MPVwiXCIsYi5yZW1vdmUoKX1jKFwiI2xheXVpLWxheWVyLW1vdmVzLCAjbGF5dWktbGF5ZXItc2hhZGVcIithKS5yZW1vdmUoKSxmLmllNiYmZS5yZXNlbGVjdCgpLGUucmVzY29sbGJhcihhKSxjKGRvY3VtZW50KS5vZmYoXCJrZXlkb3duXCIsZS5lbnRlciksXCJmdW5jdGlvblwiPT10eXBlb2YgZS5lbmRbYV0mJmUuZW5kW2FdKCksZGVsZXRlIGUuZW5kW2FdfX0sZi5jbG9zZUFsbD1mdW5jdGlvbihhKXtjLmVhY2goYyhcIi5cIitoWzBdKSxmdW5jdGlvbigpe3ZhciBiPWModGhpcyksZD1hP2IuYXR0cihcInR5cGVcIik9PT1hOjE7ZCYmZi5jbG9zZShiLmF0dHIoXCJ0aW1lc1wiKSksZD1udWxsfSl9LGUucnVuPWZ1bmN0aW9uKCl7Yz1qUXVlcnksZD1jKGEpLGguaHRtbD1jKFwiaHRtbFwiKSxmLm9wZW49ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGcoYSk7cmV0dXJuIGIuaW5kZXh9fSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmU/ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGUucnVuKCksZn0pOmZ1bmN0aW9uKCl7ZS5ydW4oKSxmLnVzZShcInNraW4vbGF5ZXIuY3NzXCIpfSgpfSh3aW5kb3cpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvanMvcGx1Z2lucy9sYXllci9sYXllci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy9sYXllci9za2luL2xheWVyLmNzcz8yMWE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9qcy9wbHVnaW5zL2xheWVyL3NraW4vbGF5ZXIuY3NzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n \n @Name : layDate 5.0.9 日期时间控件\n @Author: 贤心\n @Site：http://www.layui.com/laydate/\n @License：MIT\n \n */\n\n;!function(){\n  \"use strict\";\n\n  var isLayui = window.layui && layui.define, ready = {\n    getPath: function(){\n      var jsPath = document.currentScript ? document.currentScript.src : function(){\n        var js = document.scripts\n        ,last = js.length - 1\n        ,src;\n        for(var i = last; i > 0; i--){\n          if(js[i].readyState === 'interactive'){\n            src = js[i].src;\n            break;\n          }\n        }\n        return src || js[last].src;\n      }();\n      return jsPath.substring(0, jsPath.lastIndexOf('/') + 1);\n    }()\n    \n    //获取节点的style属性值\n    ,getStyle: function(node, name){\n      var style = node.currentStyle ? node.currentStyle : window.getComputedStyle(node, null);\n      return style[style.getPropertyValue ? 'getPropertyValue' : 'getAttribute'](name);\n    }\n    \n    //载入CSS配件\n    ,link: function(href, fn, cssname){\n      // 不加载、自己手动处理css\n      if(typeof fn === 'function'){\n    \t  fn();\n    \t  return ;\n      }\n    \t\n      //未设置路径，则不主动加载css\n      if(!laydate.path) return;\n      \n      var head = document.getElementsByTagName(\"head\")[0], link = document.createElement('link');\n      if(typeof fn === 'string') cssname = fn;\n      var app = (cssname || href).replace(/\\.|\\//g, '');\n      var id = 'layuicss-'+ app, timeout = 0;\n      \n      link.rel = 'stylesheet';\n      link.href = laydate.path + href;\n      link.id = id;\n      \n      if(!document.getElementById(id)){\n        head.appendChild(link);\n      }\n      \n      if(typeof fn !== 'function') return;\n      \n      //轮询css是否加载完毕\n      (function poll() { \n        if(++timeout > 8 * 1000 / 100){\n          return window.console && console.error('laydate.css: Invalid');\n        };\n        parseInt(ready.getStyle(document.getElementById(id), 'width')) === 1989 ? fn() : setTimeout(poll, 100);\n      }());\n    }\n  }\n\n  ,laydate = {\n    v: '5.0.9'\n    ,config: {} //全局配置项\n    ,index: (window.laydate && window.laydate.v) ? 100000 : 0\n    ,path: ready.getPath\n    \n    //设置全局项\n    ,set: function(options){\n      var that = this;\n      that.config = lay.extend({}, that.config, options);\n      return that;\n    }\n    \n    //主体CSS等待事件\n    ,ready: function(fn){\n      var cssname = 'laydate', ver = ''\n      ,path = (isLayui ? 'modules/laydate/' : 'theme/') + 'default/laydate.css?v='+ laydate.v + ver;\n      isLayui ? layui.addcss(path, fn, cssname) : ready.link(path, fn, cssname);\n      return this;\n    }\n  }\n  \n  //操作当前实例\n  ,thisDate = function(){\n    var that = this;\n    return {\n      //提示框\n      hint: function(content){\n        that.hint.call(that, content);\n      }\n      ,config: that.config\n    };\n  }\n\n  //字符常量\n  ,MOD_NAME = 'laydate', ELEM = '.layui-laydate', THIS = 'layui-this', SHOW = 'layui-show', HIDE = 'layui-hide', DISABLED = 'laydate-disabled', TIPS_OUT = '开始日期超出了结束日期<br>建议重新选择', LIMIT_YEAR = [100, 200000]\n  \n  ,ELEM_STATIC = 'layui-laydate-static', ELEM_LIST = 'layui-laydate-list', ELEM_SELECTED = 'laydate-selected', ELEM_HINT = 'layui-laydate-hint', ELEM_PREV = 'laydate-day-prev', ELEM_NEXT = 'laydate-day-next', ELEM_FOOTER = 'layui-laydate-footer', ELEM_CONFIRM = '.laydate-btns-confirm', ELEM_TIME_TEXT = 'laydate-time-text', ELEM_TIME_BTN = '.laydate-btns-time'\n  \n  //组件构造器\n  ,Class = function(options){\n    var that = this;\n    that.index = ++laydate.index;\n    that.config = lay.extend({}, that.config, laydate.config, options);\n    laydate.ready(function(){\n      that.init();\n    });\n  }\n  \n  //DOM查找\n  ,lay = function(selector){   \n    return new LAY(selector);\n  }\n  \n  //DOM构造器\n  ,LAY = function(selector){\n    var index = 0\n    ,nativeDOM = typeof selector === 'object' ? [selector] : (\n      this.selector = selector\n      ,document.querySelectorAll(selector || null)\n    );\n    for(; index < nativeDOM.length; index++){\n      this.push(nativeDOM[index]);\n    }\n  };\n  \n  \n  /*\n    lay对象操作\n  */\n  \n  LAY.prototype = [];\n  LAY.prototype.constructor = LAY;\n  \n  //普通对象深度扩展\n  lay.extend = function(){\n    var ai = 1, args = arguments\n    ,clone = function(target, obj){\n      target = target || (obj.constructor === Array ? [] : {}); \n      for(var i in obj){\n        //如果值为对象，则进入递归，继续深度合并\n        target[i] = (obj[i] && (obj[i].constructor === Object))\n          ? clone(target[i], obj[i])\n        : obj[i];\n      }\n      return target;\n    }\n\n    args[0] = typeof args[0] === 'object' ? args[0] : {};\n\n    for(; ai < args.length; ai++){\n      if(typeof args[ai] === 'object'){\n        clone(args[0], args[ai])\n      }\n    }\n    return args[0];\n  };\n  \n  //ie版本\n  lay.ie = function(){\n    var agent = navigator.userAgent.toLowerCase();\n    return (!!window.ActiveXObject || \"ActiveXObject\" in window) ? (\n      (agent.match(/msie\\s(\\d+)/) || [])[1] || '11' //由于ie11并没有msie的标识\n    ) : false;\n  }();\n  \n  //中止冒泡\n  lay.stope = function(e){\n    e = e || window.event;\n    e.stopPropagation \n      ? e.stopPropagation() \n    : e.cancelBubble = true;\n  };\n  \n  //对象遍历\n  lay.each = function(obj, fn){\n    var key\n    ,that = this;\n    if(typeof fn !== 'function') return that;\n    obj = obj || [];\n    if(obj.constructor === Object){\n      for(key in obj){\n        if(fn.call(obj[key], key, obj[key])) break;\n      }\n    } else {\n      for(key = 0; key < obj.length; key++){\n        if(fn.call(obj[key], key, obj[key])) break;\n      }\n    }\n    return that;\n  };\n  \n  //数字前置补零\n  lay.digit = function(num, length, end){\n    var str = '';\n    num = String(num);\n    length = length || 2;\n    for(var i = num.length; i < length; i++){\n      str += '0';\n    }\n    return num < Math.pow(10, length) ? str + (num|0) : num;\n  };\n  \n  //创建元素\n  lay.elem = function(elemName, attr){\n    var elem = document.createElement(elemName);\n    lay.each(attr || {}, function(key, value){\n      elem.setAttribute(key, value);\n    });\n    return elem;\n  };\n  \n  //追加字符\n  LAY.addStr = function(str, new_str){\n    str = str.replace(/\\s+/, ' ');\n    new_str = new_str.replace(/\\s+/, ' ').split(' ');\n    lay.each(new_str, function(ii, item){\n      if(!new RegExp('\\\\b'+ item + '\\\\b').test(str)){\n        str = str + ' ' + item;\n      }\n    });\n    return str.replace(/^\\s|\\s$/, '');\n  };\n  \n  //移除值\n  LAY.removeStr = function(str, new_str){\n    str = str.replace(/\\s+/, ' ');\n    new_str = new_str.replace(/\\s+/, ' ').split(' ');\n    lay.each(new_str, function(ii, item){\n      var exp = new RegExp('\\\\b'+ item + '\\\\b')\n      if(exp.test(str)){\n        str = str.replace(exp, '');\n      }\n    });\n    return str.replace(/\\s+/, ' ').replace(/^\\s|\\s$/, '');\n  };\n  \n  //查找子元素\n  LAY.prototype.find = function(selector){\n    var that = this;\n    var index = 0, arr = []\n    ,isObject = typeof selector === 'object';\n    \n    this.each(function(i, item){\n      var nativeDOM = isObject ? [selector] : item.querySelectorAll(selector || null);\n      for(; index < nativeDOM.length; index++){\n        arr.push(nativeDOM[index]);\n      }\n      that.shift();\n    });\n    \n    if(!isObject){\n      that.selector =  (that.selector ? that.selector + ' ' : '') + selector\n    }\n    \n    lay.each(arr, function(i, item){\n      that.push(item);\n    });\n    \n    return that;\n  };\n  \n  //DOM遍历\n  LAY.prototype.each = function(fn){\n    return lay.each.call(this, this, fn);\n  };\n  \n  //添加css类\n  LAY.prototype.addClass = function(className, type){\n    return this.each(function(index, item){\n      item.className = LAY[type ? 'removeStr' : 'addStr'](item.className, className)\n    });\n  };\n  \n  //移除css类\n  LAY.prototype.removeClass = function(className){\n    return this.addClass(className, true);\n  };\n  \n  //是否包含css类\n  LAY.prototype.hasClass = function(className){\n    var has = false;\n    this.each(function(index, item){\n      if(new RegExp('\\\\b'+ className +'\\\\b').test(item.className)){\n        has = true;\n      }\n    });\n    return has;\n  };\n  \n  //添加或获取属性\n  LAY.prototype.attr = function(key, value){\n    var that = this;\n    return value === undefined ? function(){\n      if(that.length > 0) return that[0].getAttribute(key);\n    }() : that.each(function(index, item){\n      item.setAttribute(key, value);\n    });   \n  };\n  \n  //移除属性\n  LAY.prototype.removeAttr = function(key){\n    return this.each(function(index, item){\n      item.removeAttribute(key);\n    });\n  };\n  \n  //设置HTML内容\n  LAY.prototype.html = function(html){\n    return this.each(function(index, item){\n      item.innerHTML = html;\n    });\n  };\n  \n  //设置值\n  LAY.prototype.val = function(value){\n    return this.each(function(index, item){\n      item.value = value;\n    });\n  };\n  \n  //追加内容\n  LAY.prototype.append = function(elem){\n    return this.each(function(index, item){\n      typeof elem === 'object' \n        ? item.appendChild(elem)\n      :  item.innerHTML = item.innerHTML + elem;\n    });\n  };\n  \n  //移除内容\n  LAY.prototype.remove = function(elem){\n    return this.each(function(index, item){\n      elem ? item.removeChild(elem) : item.parentNode.removeChild(item);\n    });\n  };\n  \n  //事件绑定\n  LAY.prototype.on = function(eventName, fn){\n    return this.each(function(index, item){\n      item.attachEvent ? item.attachEvent('on' + eventName, function(e){\n        e.target = e.srcElement;\n        fn.call(item, e);\n      }) : item.addEventListener(eventName, fn, false);\n    });\n  };\n  \n  //解除事件\n  LAY.prototype.off = function(eventName, fn){\n    return this.each(function(index, item){\n      item.detachEvent \n        ? item.detachEvent('on'+ eventName, fn)  \n      : item.removeEventListener(eventName, fn, false);\n    });\n  };\n  \n  \n  /*\n    组件操作\n  */\n  \n  \n  //是否闰年\n  Class.isLeapYear = function(year){\n    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n  };\n  \n  //默认配置\n  Class.prototype.config = {\n    type: 'date' //控件类型，支持：year/month/date/time/datetime\n    ,range: false //是否开启范围选择，即双控件\n    ,format: 'yyyy-MM-dd' //默认日期格式\n    ,value: null //默认日期，支持传入new Date()，或者符合format参数设定的日期格式字符\n    ,min: '1900-1-1' //有效最小日期，年月日必须用“-”分割，时分秒必须用“:”分割。注意：它并不是遵循 format 设定的格式。\n    ,max: '2099-12-31' //有效最大日期，同上\n    ,trigger: 'focus' //呼出控件的事件\n    ,show: false //是否直接显示，如果设置true，则默认直接显示控件\n    ,showBottom: true //是否显示底部栏\n    ,btns: ['clear', 'now', 'confirm'] //右下角显示的按钮，会按照数组顺序排列\n    ,lang: 'cn' //语言，只支持cn/en，即中文和英文\n    ,theme: 'default' //主题\n    ,position: null //控件定位方式定位, 默认absolute，支持：fixed/absolute/static\n    ,calendar: false //是否开启公历重要节日，仅支持中文版\n    ,mark: {} //日期备注，如重要事件或活动标记\n    ,zIndex: null //控件层叠顺序\n    ,done: null //控件选择完毕后的回调，点击清空/现在/确定也均会触发\n    ,change: null //日期时间改变后的回调\n  };\n  \n  //多语言\n  Class.prototype.lang = function(){\n    var that = this\n    ,options = that.config\n    ,text = {\n      cn: {\n        weeks: ['日', '一', '二', '三', '四', '五', '六']\n        ,time: ['时', '分', '秒']\n        ,timeTips: '选择时间'\n        ,startTime: '开始时间'\n        ,endTime: '结束时间'\n        ,dateTips: '返回日期'\n        ,month: ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二']\n        ,tools: {\n          confirm: '确定'\n          ,clear: '清空'\n          ,now: '现在'\n        }\n      }\n      ,en: {\n        weeks: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\n        ,time: ['Hours', 'Minutes', 'Seconds']\n        ,timeTips: 'Select Time'\n        ,startTime: 'Start Time'\n        ,endTime: 'End Time'\n        ,dateTips: 'Select Date'\n        ,month: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n        ,tools: {\n          confirm: 'Confirm'\n          ,clear: 'Clear'\n          ,now: 'Now'\n        }\n      }\n    };\n    return text[options.lang] || text['cn'];\n  };\n  \n  //初始准备\n  Class.prototype.init = function(){\n    var that = this\n    ,options = that.config\n    ,dateType = 'yyyy|y|MM|M|dd|d|HH|H|mm|m|ss|s'\n    ,isStatic = options.position === 'static'\n    ,format = {\n      year: 'yyyy'\n      ,month: 'yyyy-MM'\n      ,date: 'yyyy-MM-dd'\n      ,time: 'HH:mm:ss'\n      ,datetime: 'yyyy-MM-dd HH:mm:ss'\n    };\n    \n    options.elem = lay(options.elem);\n    options.eventElem = lay(options.eventElem);\n    \n    if(!options.elem[0]) return;\n    \n    //日期范围分隔符\n    if(options.range === true) options.range = '-';\n    \n    //根据不同type，初始化默认format\n    if(options.format === format.date){\n      options.format = format[options.type];\n    }\n    \n    //将日期格式转化成数组\n    that.format = options.format.match(new RegExp(dateType + '|.', 'g')) || [];\n    \n    //生成正则表达式\n    that.EXP_IF = ''; \n    that.EXP_SPLIT = ''; \n    lay.each(that.format, function(i, item){\n      var EXP =  new RegExp(dateType).test(item) \n        ? '\\\\d{'+ function(){\n          if(new RegExp(dateType).test(that.format[i === 0 ? i + 1 : i - 1]||'')){\n            if(/^yyyy|y$/.test(item)) return 4;\n            return item.length;\n          }\n          if(/^yyyy$/.test(item)) return '1,4';\n          if(/^y$/.test(item)) return '1,308';\n          return '1,2';\n        }() +'}' \n      : '\\\\' + item;\n      that.EXP_IF = that.EXP_IF + EXP;\n      that.EXP_SPLIT = that.EXP_SPLIT + '(' + EXP + ')';\n    });\n    that.EXP_IF = new RegExp('^'+ (\n      options.range ? \n        that.EXP_IF + '\\\\s\\\\'+ options.range + '\\\\s' + that.EXP_IF\n      : that.EXP_IF\n    ) +'$');\n    that.EXP_SPLIT = new RegExp('^'+ that.EXP_SPLIT +'$', '');\n    \n    //如果不是input|textarea元素，则默认采用click事件\n    if(!that.isInput(options.elem[0])){\n      if(options.trigger === 'focus'){\n        options.trigger = 'click';\n      }\n    }\n    \n    //设置唯一KEY\n    if(!options.elem.attr('lay-key')){\n      options.elem.attr('lay-key', that.index);\n      options.eventElem.attr('lay-key', that.index);\n    }\n    \n    //记录重要日期\n    options.mark = lay.extend({}, (options.calendar && options.lang === 'cn') ? {\n      '0-1-1': '元旦'\n      ,'0-2-14': '情人'\n      ,'0-3-8': '妇女'\n      ,'0-3-12': '植树'\n      ,'0-4-1': '愚人'\n      ,'0-5-1': '劳动'\n      ,'0-5-4': '青年'\n      ,'0-6-1': '儿童'\n      ,'0-9-10': '教师'\n      ,'0-9-18': '国耻'\n      ,'0-10-1': '国庆'\n      ,'0-12-25': '圣诞'\n    } : {}, options.mark);\n    \n    //获取限制内日期\n    lay.each(['min', 'max'], function(i, item){\n      var ymd = [], hms = [];\n      if(typeof options[item] === 'number'){ //如果为数字\n        var day = options[item]\n        ,time = new Date().getTime()\n        ,STAMP = 86400000 //代表一天的时间戳\n        ,thisDate = new Date(\n          day ? (\n            day < STAMP ? time + day*STAMP : day //如果数字小于一天的时间戳，则数字为天数，否则为时间戳\n          ) : time\n        );\n        ymd = [thisDate.getFullYear(), thisDate.getMonth() + 1, thisDate.getDate()];\n        day < STAMP || (hms = [thisDate.getHours(), thisDate.getMinutes(), thisDate.getSeconds()]);\n      } else {\n        ymd = (options[item].match(/\\d+-\\d+-\\d+/) || [''])[0].split('-');\n        hms = (options[item].match(/\\d+:\\d+:\\d+/) || [''])[0].split(':');\n      }\n      options[item] = {\n        year: ymd[0] | 0 || new Date().getFullYear()\n        ,month: ymd[1] ? (ymd[1] | 0) - 1 : new Date().getMonth()\n        ,date: ymd[2] | 0 || new Date().getDate()\n        ,hours: hms[0] | 0\n        ,minutes: hms[1] | 0\n        ,seconds: hms[2] | 0\n      };\n    });\n    \n    that.elemID = 'layui-laydate'+ options.elem.attr('lay-key');\n    \n    if(options.show || isStatic) that.render();\n    isStatic || that.events();\n    \n    //默认赋值\n    if(options.value){\n      if(options.value.constructor === Date){\n        that.setValue(that.parse(0, that.systemDate(options.value))); \n      } else {\n        that.setValue(options.value); \n      }\n    }\n  };\n  \n  //控件主体渲染\n  Class.prototype.render = function(){\n    var that = this\n    ,options = that.config\n    ,lang = that.lang()\n    ,isStatic = options.position === 'static'\n    \n    //主面板\n    ,elem = that.elem = lay.elem('div', {\n      id: that.elemID\n      ,'class': [\n        'layui-laydate'\n        ,options.range ? ' layui-laydate-range' : ''\n        ,isStatic ? (' '+ ELEM_STATIC) : ''\n        ,options.theme && options.theme !== 'default' && !/^#/.test(options.theme) ? (' laydate-theme-' + options.theme) : ''\n      ].join('')\n    })\n    \n    //主区域\n    ,elemMain = that.elemMain = []\n    ,elemHeader = that.elemHeader = []\n    ,elemCont = that.elemCont = []\n    ,elemTable = that.table = []\n\n    //底部区域\n    ,divFooter = that.footer = lay.elem('div', {\n      'class': ELEM_FOOTER\n    });\n    \n    if(options.zIndex) elem.style.zIndex = options.zIndex;\n    \n    //单双日历区域\n    lay.each(new Array(2), function(i){\n      if(!options.range && i > 0){\n        return true;\n      }\n\n      //头部区域\n      var divHeader = lay.elem('div', {\n        'class': 'layui-laydate-header'\n      })\n      \n      //左右切换\n      ,headerChild = [function(){ //上一年\n        var elem = lay.elem('i', {\n          'class': 'layui-icon laydate-icon laydate-prev-y'\n        });\n        elem.innerHTML = '&#xe65a;';\n        return elem;\n      }(), function(){ //上一月\n        var elem = lay.elem('i', {\n          'class': 'layui-icon laydate-icon laydate-prev-m'\n        });\n        elem.innerHTML = '&#xe603;';\n        return elem;\n      }(), function(){ //年月选择\n        var elem = lay.elem('div', {\n          'class': 'laydate-set-ym'\n        }), spanY = lay.elem('span'), spanM = lay.elem('span');\n        elem.appendChild(spanY);\n        elem.appendChild(spanM);\n        return elem;\n      }(), function(){ //下一月\n        var elem = lay.elem('i', {\n          'class': 'layui-icon laydate-icon laydate-next-m'\n        });\n        elem.innerHTML = '&#xe602;';\n        return elem;\n      }(), function(){ //下一年\n        var elem = lay.elem('i', {\n          'class': 'layui-icon laydate-icon laydate-next-y'\n        });\n        elem.innerHTML = '&#xe65b;';\n        return elem;\n      }()]\n      \n      //日历内容区域\n      ,divContent = lay.elem('div', {\n        'class': 'layui-laydate-content'\n      })\n      ,table = lay.elem('table')\n      ,thead = lay.elem('thead'), theadTr = lay.elem('tr');\n      \n      //生成年月选择\n      lay.each(headerChild, function(i, item){\n        divHeader.appendChild(item);\n      });\n      \n       //生成表格\n      thead.appendChild(theadTr);\n      lay.each(new Array(6), function(i){ //表体\n        var tr = table.insertRow(0);\n        lay.each(new Array(7), function(j){\n          if(i === 0){\n            var th = lay.elem('th');\n            th.innerHTML = lang.weeks[j];\n            theadTr.appendChild(th);\n          }\n          tr.insertCell(j);\n        });\n      });\n      table.insertBefore(thead, table.children[0]); //表头\n      divContent.appendChild(table);\n      \n      elemMain[i] = lay.elem('div', {\n        'class': 'layui-laydate-main laydate-main-list-'+ i\n      });\n      \n      elemMain[i].appendChild(divHeader);\n      elemMain[i].appendChild(divContent);\n      \n      elemHeader.push(headerChild);\n      elemCont.push(divContent);\n      elemTable.push(table);\n    });\n    \n    //生成底部栏\n    lay(divFooter).html(function(){\n      var html = [], btns = [];\n      if(options.type === 'datetime'){\n        html.push('<span lay-type=\"datetime\" class=\"laydate-btns-time\">'+ lang.timeTips +'</span>');\n      }\n      lay.each(options.btns, function(i, item){\n        var title = lang.tools[item] || 'btn';\n        if(options.range && item === 'now') return;\n        if(isStatic && item === 'clear') title = options.lang === 'cn' ? '重置' : 'Reset';\n        btns.push('<span lay-type=\"'+ item +'\" class=\"laydate-btns-'+ item +'\">'+ title +'</span>');\n      });\n      html.push('<div class=\"laydate-footer-btns\">'+ btns.join('') +'</div>');\n      return html.join('');\n    }());\n    \n    //插入到主区域\n    lay.each(elemMain, function(i, main){\n      elem.appendChild(main);\n    });\n    options.showBottom && elem.appendChild(divFooter);\n    \n    //生成自定义主题\n    if(/^#/.test(options.theme)){\n      var style = lay.elem('style')\n      ,styleText = [\n        '#{{id}} .layui-laydate-header{background-color:{{theme}};}'\n        ,'#{{id}} .layui-this{background-color:{{theme}} !important;}'\n      ].join('').replace(/{{id}}/g, that.elemID).replace(/{{theme}}/g, options.theme);\n      \n      if('styleSheet' in style){\n        style.setAttribute('type', 'text/css');\n        style.styleSheet.cssText = styleText;\n      } else {\n        style.innerHTML = styleText;\n      }\n      \n      lay(elem).addClass('laydate-theme-molv');\n      elem.appendChild(style);\n    }\n    \n    //移除上一个控件\n    that.remove(Class.thisElemDate); \n    \n    //如果是静态定位，则插入到指定的容器中，否则，插入到body\n    isStatic ? options.elem.append(elem) : (\n      document.body.appendChild(elem)\n      ,that.position() //定位\n    );\n    \n    that.checkDate().calendar(); //初始校验\n    that.changeEvent(); //日期切换\n    \n    Class.thisElemDate = that.elemID;\n\n    typeof options.ready === 'function' && options.ready(lay.extend({}, options.dateTime, {\n      month: options.dateTime.month + 1\n    }));\n  };\n  \n  //控件移除\n  Class.prototype.remove = function(prev){\n    var that = this\n    ,options = that.config\n    ,elem = lay('#'+ (prev || that.elemID));\n    if(!elem.hasClass(ELEM_STATIC)){\n      that.checkDate(function(){\n        elem.remove();\n      });\n    }\n    return that;\n  };\n  \n  //定位算法\n  Class.prototype.position = function(){\n    var that = this\n    ,options = that.config\n    ,elem = that.bindElem || options.elem[0]\n    ,rect = elem.getBoundingClientRect() //绑定元素的坐标\n    ,elemWidth = that.elem.offsetWidth //控件的宽度\n    ,elemHeight = that.elem.offsetHeight //控件的高度\n    \n    //滚动条高度\n    ,scrollArea = function(type){\n      type = type ? 'scrollLeft' : 'scrollTop';\n      return document.body[type] | document.documentElement[type];\n    }\n    ,winArea = function(type){\n      return document.documentElement[type ? 'clientWidth' : 'clientHeight']\n    }, margin = 5, left = rect.left, top = rect.bottom;\n    \n    //如果右侧超出边界\n    if(left + elemWidth + margin > winArea('width')){\n      left = winArea('width') - elemWidth - margin;\n    }\n    \n    //如果底部超出边界\n    if(top + elemHeight + margin > winArea()){\n      top = rect.top > elemHeight //顶部是否有足够区域显示完全\n        ? rect.top - elemHeight \n      : winArea() - elemHeight;\n      top = top - margin*2;\n    }\n    \n    if(options.position){\n      that.elem.style.position = options.position;\n    }\n    that.elem.style.left = left + (options.position === 'fixed' ? 0 : scrollArea(1)) + 'px';\n    that.elem.style.top = top + (options.position === 'fixed' ? 0 : scrollArea()) + 'px';\n  };\n  \n  //提示\n  Class.prototype.hint = function(content){\n    var that = this\n    ,options = that.config\n    ,div = lay.elem('div', {\n      'class': ELEM_HINT\n    });\n    \n    div.innerHTML = content || '';\n    lay(that.elem).find('.'+ ELEM_HINT).remove();\n    that.elem.appendChild(div);\n\n    clearTimeout(that.hinTimer);\n    that.hinTimer = setTimeout(function(){\n      lay(that.elem).find('.'+ ELEM_HINT).remove();\n    }, 3000);\n  };\n  \n  //获取递增/减后的年月\n  Class.prototype.getAsYM = function(Y, M, type){\n    type ? M-- : M++;\n    if(M < 0){\n      M = 11;\n      Y--;\n    }\n    if(M > 11){\n      M = 0;\n      Y++;\n    }\n    return [Y, M];\n  };\n  \n  //系统消息\n  Class.prototype.systemDate = function(newDate){\n    var thisDate = newDate || new Date();\n    return {\n      year: thisDate.getFullYear() //年\n      ,month: thisDate.getMonth() //月\n      ,date: thisDate.getDate() //日\n      ,hours: newDate ? newDate.getHours() : 0 //时\n      ,minutes: newDate ? newDate.getMinutes() : 0 //分\n      ,seconds: newDate ? newDate.getSeconds() : 0 //秒\n    }\n  };\n  \n  //日期校验\n  Class.prototype.checkDate = function(fn){\n    var that = this\n    ,thisDate = new Date()\n    ,options = that.config\n    ,dateTime = options.dateTime = options.dateTime || that.systemDate()\n    ,thisMaxDate, error\n    \n    ,elem = that.bindElem || options.elem[0]\n    ,valType = that.isInput(elem) ? 'val' : 'html'\n    ,value = that.isInput(elem) ? elem.value : (options.position === 'static' ? '' : elem.innerHTML)\n    \n    //校验日期有效数字\n    ,checkValid = function(dateTime){\n      if(dateTime.year > LIMIT_YEAR[1]) dateTime.year = LIMIT_YEAR[1], error = true; //不能超过20万年\n      if(dateTime.month > 11) dateTime.month = 11, error = true;\n      if(dateTime.hours > 23) dateTime.hours = 0, error = true;\n      if(dateTime.minutes > 59) dateTime.minutes = 0, dateTime.hours++, error = true;\n      if(dateTime.seconds > 59) dateTime.seconds = 0, dateTime.minutes++, error = true;\n      \n      //计算当前月的最后一天\n      thisMaxDate = laydate.getEndDate(dateTime.month + 1, dateTime.year);\n      if(dateTime.date > thisMaxDate) dateTime.date = thisMaxDate, error = true;\n    }\n    \n    //获得初始化日期值\n    ,initDate = function(dateTime, value, index){\n      var startEnd = ['startTime', 'endTime'];\n      value = (value.match(that.EXP_SPLIT) || []).slice(1);\n      index = index || 0;\n      if(options.range){\n        that[startEnd[index]] = that[startEnd[index]] || {};\n      }\n      lay.each(that.format, function(i, item){\n        var thisv = parseFloat(value[i]);\n        if(value[i].length < item.length) error = true;\n        if(/yyyy|y/.test(item)){ //年\n          if(thisv < LIMIT_YEAR[0]) thisv = LIMIT_YEAR[0], error = true; //年不能低于100年\n          dateTime.year = thisv;\n        } else if(/MM|M/.test(item)){ //月\n          if(thisv < 1) thisv = 1, error = true;\n          dateTime.month = thisv - 1;\n        } else if(/dd|d/.test(item)){ //日\n          if(thisv < 1) thisv = 1, error = true;\n          dateTime.date = thisv;\n        } else if(/HH|H/.test(item)){ //时\n          if(thisv < 1) thisv = 0, error = true;\n          dateTime.hours = thisv;\n          options.range && (that[startEnd[index]].hours = thisv);\n        } else if(/mm|m/.test(item)){ //分\n          if(thisv < 1) thisv = 0, error = true;\n          dateTime.minutes = thisv;\n          options.range && (that[startEnd[index]].minutes = thisv);\n        } else if(/ss|s/.test(item)){ //秒\n          if(thisv < 1) thisv = 0, error = true;\n          dateTime.seconds = thisv;\n          options.range && (that[startEnd[index]].seconds = thisv);\n        }\n      });\n      checkValid(dateTime)\n    };\n    \n    if(fn === 'limit') return checkValid(dateTime), that;\n    \n    value = value || options.value;\n    if(typeof value === 'string'){\n      value = value.replace(/\\s+/g, ' ').replace(/^\\s|\\s$/g, '');\n    }\n    \n    //如果点击了开始，单未选择结束就关闭，则重新选择开始\n    if(that.startState && !that.endState){\n      delete that.startState;\n      that.endState = true;\n    };\n\n    if(typeof value === 'string' && value){\n      if(that.EXP_IF.test(value)){ //校验日期格式\n        if(options.range){\n          value = value.split(' '+ options.range +' ');\n          that.startDate = that.startDate || that.systemDate();\n          that.endDate = that.endDate || that.systemDate();\n          options.dateTime = lay.extend({}, that.startDate);\n          lay.each([that.startDate, that.endDate], function(i, item){\n            initDate(item, value[i], i);\n          });\n        } else {\n          initDate(dateTime, value)\n        }\n      } else {\n        that.hint('日期格式不合法<br>必须遵循下述格式：<br>'+ (\n          options.range ? (options.format + ' '+ options.range +' ' + options.format) : options.format\n        ) + '<br>已为你重置');\n        error = true;\n      }\n    } else if(value && value.constructor === Date){ //如果值为日期对象时\n      options.dateTime = that.systemDate(value);\n    } else {\n      options.dateTime = that.systemDate();\n      delete that.startState;\n      delete that.endState;\n      delete that.startDate;\n      delete that.endDate;\n      delete that.startTime;\n      delete that.endTime;\n    }\n\n    checkValid(dateTime);\n\n    if(error && value){\n      that.setValue(\n        options.range ? (that.endDate ? that.parse() : '') : that.parse()\n      );\n    }\n    fn && fn();\n    return that;\n  };\n  \n  //公历重要日期与自定义备注\n  Class.prototype.mark = function(td, YMD){\n    var that = this\n    ,mark, options = that.config;\n    lay.each(options.mark, function(key, title){\n      var keys = key.split('-');\n      if((keys[0] == YMD[0] || keys[0] == 0) //每年的每月\n      && (keys[1] == YMD[1] || keys[1] == 0) //每月的每日\n      && keys[2] == YMD[2]){ //特定日\n        mark = title || YMD[2];\n      }\n    });\n    mark && td.html('<span class=\"laydate-day-mark\">'+ mark +'</span>');\n    \n    return that;\n  };\n  \n  //无效日期范围的标记\n  Class.prototype.limit = function(elem, date, index, time){\n    var that = this\n    ,options = that.config, timestrap = {}\n    ,dateTime = options[index > 41 ? 'endDate' : 'dateTime']\n    ,isOut, thisDateTime = lay.extend({}, dateTime, date || {});\n    lay.each({\n      now: thisDateTime\n      ,min: options.min\n      ,max: options.max\n    }, function(key, item){\n      timestrap[key] = that.newDate(lay.extend({\n        year: item.year\n        ,month: item.month\n        ,date: item.date\n      }, function(){\n        var hms = {};\n        lay.each(time, function(i, keys){\n          hms[keys] = item[keys];\n        });\n        return hms;\n      }())).getTime();  //time：是否比较时分秒\n    });\n    \n    isOut = timestrap.now < timestrap.min || timestrap.now > timestrap.max;\n    elem && elem[isOut ? 'addClass' : 'removeClass'](DISABLED);\n    return isOut;\n  };\n  \n  //日历表\n  Class.prototype.calendar = function(value){\n    var that = this\n    ,options = that.config\n    ,dateTime = value || options.dateTime\n    ,thisDate = new Date(), startWeek, prevMaxDate, thisMaxDate\n    ,lang = that.lang()\n    \n    ,isAlone = options.type !== 'date' && options.type !== 'datetime'\n    ,index = value ? 1 : 0\n    ,tds = lay(that.table[index]).find('td')\n    ,elemYM = lay(that.elemHeader[index][2]).find('span');\n    \n    if(dateTime.year < LIMIT_YEAR[0]) dateTime.year = LIMIT_YEAR[0], that.hint('最低只能支持到公元'+ LIMIT_YEAR[0] +'年');\n    if(dateTime.year > LIMIT_YEAR[1]) dateTime.year = LIMIT_YEAR[1], that.hint('最高只能支持到公元'+ LIMIT_YEAR[1] +'年');\n    \n    //记录初始值\n    if(!that.firstDate){\n      that.firstDate = lay.extend({}, dateTime);\n    }\n    \n    //计算当前月第一天的星期\n    thisDate.setFullYear(dateTime.year, dateTime.month, 1);\n    startWeek = thisDate.getDay();\n    \n    prevMaxDate = laydate.getEndDate(dateTime.month || 12, dateTime.year); //计算上个月的最后一天\n    thisMaxDate = laydate.getEndDate(dateTime.month + 1, dateTime.year); //计算当前月的最后一天\n    \n    //赋值日\n    lay.each(tds, function(index, item){\n      var YMD = [dateTime.year, dateTime.month], st = 0;\n      item = lay(item);\n      item.removeAttr('class');\n      if(index < startWeek){\n        st = prevMaxDate - startWeek + index;\n        item.addClass('laydate-day-prev');\n        YMD = that.getAsYM(dateTime.year, dateTime.month, 'sub');\n      } else if(index >= startWeek && index < thisMaxDate + startWeek){\n        st = index - startWeek;\n        if(!options.range){\n          st + 1 === dateTime.date && item.addClass(THIS);\n        }\n      } else {\n        st = index - thisMaxDate - startWeek;\n        item.addClass('laydate-day-next');\n        YMD = that.getAsYM(dateTime.year, dateTime.month);\n      }\n      YMD[1]++;\n      YMD[2] = st + 1;\n      item.attr('lay-ymd', YMD.join('-')).html(YMD[2]);\n      that.mark(item, YMD).limit(item, {\n        year: YMD[0]\n        ,month: YMD[1] - 1\n        ,date: YMD[2]\n      }, index);\n    });  \n    \n    //同步头部年月\n    lay(elemYM[0]).attr('lay-ym', dateTime.year + '-' + (dateTime.month + 1));\n    lay(elemYM[1]).attr('lay-ym', dateTime.year + '-' + (dateTime.month + 1));\n    \n    if(options.lang === 'cn'){\n      lay(elemYM[0]).attr('lay-type', 'year').html(dateTime.year + '年')\n      lay(elemYM[1]).attr('lay-type', 'month').html((dateTime.month + 1) + '月');\n    } else {\n      lay(elemYM[0]).attr('lay-type', 'month').html(lang.month[dateTime.month]);\n      lay(elemYM[1]).attr('lay-type', 'year').html(dateTime.year);\n    }\n\n    //初始默认选择器\n    if(isAlone){\n      if(options.range){\n        value ? that.endDate = (that.endDate || {\n          year: dateTime.year + (options.type === 'year' ? 1 : 0)\n          ,month: dateTime.month + (options.type === 'month' ? 0 : -1)\n        }) : (that.startDate = that.startDate || {\n          year: dateTime.year\n          ,month: dateTime.month\n        });\n        if(value){\n          that.listYM = [\n            [that.startDate.year, that.startDate.month + 1]\n            ,[that.endDate.year, that.endDate.month + 1]\n          ];  \n          that.list(options.type, 0).list(options.type, 1);\n          //同步按钮可点状态\n          options.type === 'time' ? that.setBtnStatus('时间'\n            ,lay.extend({}, that.systemDate(), that.startTime)\n            ,lay.extend({}, that.systemDate(), that.endTime)\n          ) : that.setBtnStatus(true);\n        }        \n      }\n      if(!options.range){\n        that.listYM = [[dateTime.year, dateTime.month + 1]];\n        that.list(options.type, 0);\n      }\n    }\n    \n    //赋值双日历\n    if(options.range && !value){\n      var EYM = that.getAsYM(dateTime.year, dateTime.month)\n      that.calendar(lay.extend({}, dateTime, {\n        year: EYM[0]\n        ,month: EYM[1]\n      }));\n    }\n    \n    //通过检测当前有效日期，来设定确定按钮是否可点\n    if(!options.range) that.limit(lay(that.footer).find(ELEM_CONFIRM), null, 0, ['hours', 'minutes', 'seconds']);\n    \n    //标记选择范围\n    if(options.range && value && !isAlone) that.stampRange();\n    return that;\n  };\n\n  //生成年月时分秒列表\n  Class.prototype.list = function(type, index){\n    var that = this\n    ,options = that.config\n    ,dateTime = options.dateTime\n    ,lang = that.lang()\n    ,isAlone = options.range && options.type !== 'date' && options.type !== 'datetime' //独立范围选择器\n    \n    ,ul = lay.elem('ul', {\n      'class': ELEM_LIST + ' ' + ({\n        year: 'laydate-year-list'\n        ,month: 'laydate-month-list'\n        ,time: 'laydate-time-list'\n      })[type]\n    })\n    ,elemHeader = that.elemHeader[index]\n    ,elemYM = lay(elemHeader[2]).find('span')\n    ,elemCont = that.elemCont[index || 0]\n    ,haveList = lay(elemCont).find('.'+ ELEM_LIST)[0]\n    ,isCN = options.lang === 'cn'\n    ,text = isCN ? '年' : ''\n   \n    ,listYM = that.listYM[index] || {}\n    ,hms = ['hours', 'minutes', 'seconds']\n    ,startEnd = ['startTime', 'endTime'][index];\n\n    if(listYM[0] < 1) listYM[0] = 1;\n    \n    if(type === 'year'){ //年列表\n      var yearNum, startY = yearNum = listYM[0] - 7;\n      if(startY < 1) startY = yearNum = 1;\n      lay.each(new Array(15), function(i){\n        var li = lay.elem('li', {\n          'lay-ym': yearNum\n        }), ymd = {year: yearNum};\n        yearNum == listYM[0] && lay(li).addClass(THIS);\n        li.innerHTML = yearNum + text;\n        ul.appendChild(li);\n        if(yearNum < that.firstDate.year){\n          ymd.month = options.min.month;\n          ymd.date = options.min.date;\n        } else if(yearNum >= that.firstDate.year){\n          ymd.month = options.max.month;\n          ymd.date = options.max.date;\n        }\n        that.limit(lay(li), ymd, index);\n        yearNum++;\n      });\n      lay(elemYM[isCN ? 0 : 1]).attr('lay-ym', (yearNum - 8) + '-' + listYM[1])\n      .html((startY + text) + ' - ' + (yearNum - 1 + text));\n    } else if(type === 'month'){ //月列表\n      lay.each(new Array(12), function(i){\n        var li = lay.elem('li', {\n          'lay-ym': i\n        }), ymd = {year: listYM[0], month: i};\n        i + 1 == listYM[1] && lay(li).addClass(THIS);\n        li.innerHTML = lang.month[i] + (isCN ? '月' : '');\n        ul.appendChild(li);\n        if(listYM[0] < that.firstDate.year){\n          ymd.date = options.min.date;\n        } else if(listYM[0] >= that.firstDate.year){\n          ymd.date = options.max.date;\n        }\n        that.limit(lay(li), ymd, index);\n      });\n      lay(elemYM[isCN ? 0 : 1]).attr('lay-ym', listYM[0] + '-' + listYM[1])\n      .html(listYM[0] + text);\n    } else if(type === 'time'){ //时间列表\n      //检测时分秒状态是否在有效日期时间范围内\n      var setTimeStatus = function(){\n        lay(ul).find('ol').each(function(i, ol){\n          lay(ol).find('li').each(function(ii, li){\n            that.limit(lay(li), [{\n              hours: ii\n            }, {\n              hours: that[startEnd].hours\n              ,minutes: ii\n            }, {\n              hours: that[startEnd].hours\n              ,minutes: that[startEnd].minutes\n              ,seconds: ii\n            }][i], index, [['hours'], ['hours', 'minutes'], ['hours', 'minutes', 'seconds']][i]);\n          });\n        });\n        if(!options.range) that.limit(lay(that.footer).find(ELEM_CONFIRM), that[startEnd], 0, ['hours', 'minutes', 'seconds']);\n      };\n      if(options.range){\n        if(!that[startEnd]) that[startEnd] = {\n          hours: 0\n          ,minutes: 0\n          ,seconds: 0\n        };\n      } else {\n        that[startEnd] = dateTime;\n      }\n      lay.each([24, 60, 60], function(i, item){\n        var li = lay.elem('li'), childUL = ['<p>'+ lang.time[i] +'</p><ol>'];\n        lay.each(new Array(item), function(ii){\n          childUL.push('<li'+ (that[startEnd][hms[i]] === ii ? ' class=\"'+ THIS +'\"' : '') +'>'+ lay.digit(ii, 2) +'</li>');\n        });\n        li.innerHTML = childUL.join('') + '</ol>';\n        ul.appendChild(li);\n      });\n      setTimeStatus();\n    }\n    \n    //插入容器\n    if(haveList) elemCont.removeChild(haveList);\n    elemCont.appendChild(ul);\n    \n    //年月\n    if(type === 'year' || type === 'month'){      \n      //显示切换箭头\n      lay(that.elemMain[index]).addClass('laydate-ym-show');\n      \n      //选中\n      lay(ul).find('li').on('click', function(){\n        var ym = lay(this).attr('lay-ym') | 0;\n        if(lay(this).hasClass(DISABLED)) return;\n        \n        if(index === 0){\n          dateTime[type] = ym;\n          if(isAlone) that.startDate[type] = ym;\n          that.limit(lay(that.footer).find(ELEM_CONFIRM), null, 0);\n        } else { //范围选择\n          if(isAlone){ //非date/datetime类型\n            that.endDate[type] = ym;\n          } else { //date/datetime类型\n            var YM = type === 'year' \n              ? that.getAsYM(ym, listYM[1] - 1, 'sub') \n            : that.getAsYM(listYM[0], ym, 'sub');\n            lay.extend(dateTime, {\n              year: YM[0]\n              ,month: YM[1]\n            });\n          }\n        }\n        \n        if(options.type === 'year' || options.type === 'month'){\n          lay(ul).find('.'+ THIS).removeClass(THIS);\n          lay(this).addClass(THIS);\n          \n          //如果为年月选择器，点击了年列表，则切换到月选择器\n          if(options.type === 'month' && type === 'year'){\n            that.listYM[index][0] = ym;\n            isAlone && (that[['startDate', 'endDate'][index]].year = ym);\n            that.list('month', index);\n          }\n        } else {\n          that.checkDate('limit').calendar();\n          that.closeList();\n        }\n\n        that.setBtnStatus(); //同步按钮可点状态\n        options.range || that.done(null, 'change');\n        lay(that.footer).find(ELEM_TIME_BTN).removeClass(DISABLED);\n      });\n    } else {\n      var span = lay.elem('span', {\n        'class': ELEM_TIME_TEXT\n      }), scroll = function(){ //滚动条定位\n        lay(ul).find('ol').each(function(i){\n          var ol = this\n          ,li = lay(ol).find('li')\n          ol.scrollTop = 30*(that[startEnd][hms[i]] - 2);\n          if(ol.scrollTop <= 0){\n            li.each(function(ii, item){\n              if(!lay(this).hasClass(DISABLED)){\n                ol.scrollTop = 30*(ii - 2);\n                return true;\n              }\n            });\n          }\n        });\n      }, haveSpan = lay(elemHeader[2]).find('.'+ ELEM_TIME_TEXT);\n      scroll()\n      span.innerHTML = options.range ? [lang.startTime,lang.endTime][index] : lang.timeTips\n      lay(that.elemMain[index]).addClass('laydate-time-show');\n      if(haveSpan[0]) haveSpan.remove();\n      elemHeader[2].appendChild(span);\n\n      lay(ul).find('ol').each(function(i){\n        var ol = this;\n        //选择时分秒\n        lay(ol).find('li').on('click', function(){\n          var value = this.innerHTML | 0;\n          if(lay(this).hasClass(DISABLED)) return;\n          if(options.range){\n            that[startEnd][hms[i]]  = value;\n          } else {\n            dateTime[hms[i]] = value;\n          }\n          lay(ol).find('.'+ THIS).removeClass(THIS);\n          lay(this).addClass(THIS);\n\n          setTimeStatus();\n          scroll();\n          (that.endDate || options.type === 'time') && that.done(null, 'change');\n          \n          //同步按钮可点状态\n          that.setBtnStatus();\n        });\n      });\n    }\n    \n    return that;\n  };\n  \n  //记录列表切换后的年月\n  Class.prototype.listYM = [];\n  \n  //关闭列表\n  Class.prototype.closeList = function(){\n    var that = this\n    ,options = that.config;\n    \n    lay.each(that.elemCont, function(index, item){\n      lay(this).find('.'+ ELEM_LIST).remove();\n      lay(that.elemMain[index]).removeClass('laydate-ym-show laydate-time-show');\n    });\n    lay(that.elem).find('.'+ ELEM_TIME_TEXT).remove();\n  };\n  \n  //检测结束日期是否超出开始日期\n  Class.prototype.setBtnStatus = function(tips, start, end){\n    var that = this\n    ,options = that.config\n    ,isOut, elemBtn = lay(that.footer).find(ELEM_CONFIRM)\n    ,isAlone = options.range && options.type !== 'date' && options.type !== 'time';\n    if(isAlone){\n      start = start || that.startDate;\n      end = end || that.endDate;\n      isOut = that.newDate(start).getTime() > that.newDate(end).getTime();\n      \n      //如果不在有效日期内，直接禁用按钮，否则比较开始和结束日期\n      (that.limit(null, start) || that.limit(null, end)) \n        ? elemBtn.addClass(DISABLED)\n      : elemBtn[isOut ? 'addClass' : 'removeClass'](DISABLED);\n      \n      //是否异常提示\n      if(tips && isOut) that.hint(\n        typeof tips === 'string' ? TIPS_OUT.replace(/日期/g, tips) : TIPS_OUT\n      );\n    }\n  };\n  \n  //转义为规定格式的日期字符\n  Class.prototype.parse = function(state, date){\n    var that = this\n    ,options = that.config\n    ,dateTime = date || (state \n      ? lay.extend({}, that.endDate, that.endTime)\n    : (options.range ? lay.extend({}, that.startDate, that.startTime) : options.dateTime))\n    ,format = that.format.concat();\n\n    //转义为规定格式\n    lay.each(format, function(i, item){\n      if(/yyyy|y/.test(item)){ //年\n        format[i] = lay.digit(dateTime.year, item.length);\n      } else if(/MM|M/.test(item)){ //月\n        format[i] = lay.digit(dateTime.month + 1, item.length);\n      } else if(/dd|d/.test(item)){ //日\n        format[i] = lay.digit(dateTime.date, item.length);\n      } else if(/HH|H/.test(item)){ //时\n        format[i] = lay.digit(dateTime.hours, item.length);\n      } else if(/mm|m/.test(item)){ //分\n        format[i] = lay.digit(dateTime.minutes, item.length);\n      } else if(/ss|s/.test(item)){ //秒\n        format[i] = lay.digit(dateTime.seconds, item.length);\n      }\n    });\n    \n    //返回日期范围字符\n    if(options.range && !state){\n      return format.join('') + ' '+ options.range +' ' + that.parse(1);\n    }\n    \n    return format.join('');\n  };\n  \n  //创建指定日期时间对象\n  Class.prototype.newDate = function(dateTime){\n    dateTime = dateTime || {};\n    return new Date(\n      dateTime.year || 1\n      ,dateTime.month || 0\n      ,dateTime.date || 1\n      ,dateTime.hours || 0\n      ,dateTime.minutes || 0\n      ,dateTime.seconds || 0\n    );\n  };\n  \n  //赋值\n  Class.prototype.setValue = function(value){\n    var that = this\n    ,options = that.config\n    ,elem = that.bindElem || options.elem[0]\n    ,valType = that.isInput(elem) ? 'val' : 'html'\n    \n    options.position === 'static' || lay(elem)[valType](value || '');\n    return this;\n  };\n  \n  //标记范围内的日期\n  Class.prototype.stampRange = function(){\n    var that = this\n    ,options = that.config\n    ,startTime, endTime\n    ,tds = lay(that.elem).find('td');\n    \n    if(options.range && !that.endDate) lay(that.footer).find(ELEM_CONFIRM).addClass(DISABLED);\n    if(!that.endDate) return;\n\n    startTime = that.newDate({\n      year: that.startDate.year\n      ,month: that.startDate.month\n      ,date: that.startDate.date\n    }).getTime();\n    \n    endTime = that.newDate({\n      year: that.endDate.year\n      ,month: that.endDate.month\n      ,date: that.endDate.date\n    }).getTime();\n    \n    if(startTime > endTime) return that.hint(TIPS_OUT);\n    \n    lay.each(tds, function(i, item){\n      var ymd = lay(item).attr('lay-ymd').split('-')\n      ,thisTime = that.newDate({\n        year: ymd[0]\n        ,month: ymd[1] - 1\n        ,date: ymd[2]\n      }).getTime();\n      lay(item).removeClass(ELEM_SELECTED + ' ' + THIS);\n      if(thisTime === startTime || thisTime === endTime){\n        lay(item).addClass(\n          lay(item).hasClass(ELEM_PREV) || lay(item).hasClass(ELEM_NEXT)\n            ? ELEM_SELECTED\n          : THIS\n        );\n      }\n      if(thisTime > startTime && thisTime < endTime){\n        lay(item).addClass(ELEM_SELECTED);\n      }\n    });\n  };\n  \n  //执行done/change回调\n  Class.prototype.done = function(param, type){\n    var that = this\n    ,options = that.config\n    ,start = lay.extend({}, that.startDate ? lay.extend(that.startDate, that.startTime) : options.dateTime)\n    ,end = lay.extend({}, lay.extend(that.endDate, that.endTime))\n    \n    lay.each([start, end], function(i, item){\n      if(!('month' in item)) return;\n      lay.extend(item, {\n        month: item.month + 1\n      });\n    });\n    \n    param = param || [that.parse(), start, end];\n    typeof options[type || 'done'] === 'function' && options[type || 'done'].apply(options, param);\n    \n    return that;\n  };\n  \n  //选择日期\n  Class.prototype.choose = function(td){\n    var that = this\n    ,options = that.config\n    ,dateTime = options.dateTime\n\n    ,tds = lay(that.elem).find('td')\n    ,YMD = td.attr('lay-ymd').split('-')\n    \n    ,setDateTime = function(one){\n      var thisDate = new Date();\n      \n      //同步dateTime\n      one && lay.extend(dateTime, YMD);\n      \n      //记录开始日期\n      if(options.range){\n        that.startDate ? lay.extend(that.startDate, YMD) : (\n          that.startDate = lay.extend({}, YMD, that.startTime)\n        );\n        that.startYMD = YMD;\n      }\n    };\n    \n    YMD = {\n      year: YMD[0] | 0\n      ,month: (YMD[1] | 0) - 1\n      ,date: YMD[2] | 0\n    };\n    \n    if(td.hasClass(DISABLED)) return;\n\n    //范围选择\n    if(options.range){\n      \n      lay.each(['startTime', 'endTime'], function(i, item){\n        that[item] = that[item] || {\n          hours: 0\n          ,minutes: 0\n          ,seconds: 0\n        };\n      });\n      \n      if(that.endState){ //重新选择\n        setDateTime();\n        delete that.endState;\n        delete that.endDate;\n        that.startState = true;\n        tds.removeClass(THIS + ' ' + ELEM_SELECTED);\n        td.addClass(THIS);\n      } else if(that.startState){ //选中截止\n        td.addClass(THIS);\n        \n        that.endDate ? lay.extend(that.endDate, YMD) : (\n          that.endDate = lay.extend({}, YMD, that.endTime)\n        );\n        \n        //判断是否顺时或逆时选择\n        if(that.newDate(YMD).getTime() < that.newDate(that.startYMD).getTime()){\n          var startDate = lay.extend({}, that.endDate, {\n            hours: that.startDate.hours\n            ,minutes: that.startDate.minutes\n            ,seconds: that.startDate.seconds\n          });\n          lay.extend(that.endDate, that.startDate, {\n            hours: that.endDate.hours\n            ,minutes: that.endDate.minutes\n            ,seconds: that.endDate.seconds\n          });\n          that.startDate = startDate;\n        }\n        \n        options.showBottom || that.done();\n        that.stampRange(); //标记范围内的日期\n        that.endState = true;\n        that.done(null, 'change');\n      } else { //选中开始\n        td.addClass(THIS);\n        setDateTime(); \n        that.startState = true;\n      }\n      lay(that.footer).find(ELEM_CONFIRM)[that.endDate ? 'removeClass' : 'addClass'](DISABLED);\n    } else if(options.position === 'static'){ //直接嵌套的选中\n      setDateTime(true);\n      that.calendar().done().done(null, 'change');\n    } else if(options.type === 'date'){\n      setDateTime(true);\n      that.setValue(that.parse()).remove().done();\n    } else if(options.type === 'datetime'){\n      setDateTime(true);\n      that.calendar().done(null, 'change');\n    }\n  };\n  \n  //底部按钮\n  Class.prototype.tool = function(btn, type){\n    var that = this\n    ,options = that.config\n    ,dateTime = options.dateTime\n    ,isStatic = options.position === 'static'\n    ,active = {\n      //选择时间\n      datetime: function(){\n        if(lay(btn).hasClass(DISABLED)) return;\n        that.list('time', 0);\n        options.range && that.list('time', 1);\n        lay(btn).attr('lay-type', 'date').html(that.lang().dateTips);\n      }\n      \n      //选择日期\n      ,date: function(){\n        that.closeList();\n        lay(btn).attr('lay-type', 'datetime').html(that.lang().timeTips);\n      }\n      \n      //清空、重置\n      ,clear: function(){\n        that.setValue('').remove();\n        isStatic && (\n          lay.extend(dateTime, that.firstDate)\n          ,that.calendar()\n        )\n        options.range && (\n          delete that.startState\n          ,delete that.endState\n          ,delete that.endDate\n          ,delete that.startTime\n          ,delete that.endTime\n        );\n        that.done(['', {}, {}]);\n      }\n      \n      //现在\n      ,now: function(){\n        var thisDate = new Date();\n        lay.extend(dateTime, that.systemDate(), {\n          hours: thisDate.getHours()\n          ,minutes: thisDate.getMinutes()\n          ,seconds: thisDate.getSeconds()\n        });\n        that.setValue(that.parse()).remove();\n        isStatic && that.calendar();\n        that.done();\n      }\n      \n      //确定\n      ,confirm: function(){\n        if(options.range){\n          if(!that.endDate) return that.hint('请先选择日期范围');\n          if(lay(btn).hasClass(DISABLED)) return that.hint(\n            options.type === 'time' ? TIPS_OUT.replace(/日期/g, '时间') : TIPS_OUT\n          );\n        } else {\n          if(lay(btn).hasClass(DISABLED)) return that.hint('不在有效日期或时间范围内');\n        }\n        that.done();\n        that.setValue(that.parse()).remove()\n      }\n    };\n    active[type] && active[type]();\n  };\n  \n  //统一切换处理\n  Class.prototype.change = function(index){\n    var that = this\n    ,options = that.config\n    ,dateTime = options.dateTime\n    ,isAlone = options.range && (options.type === 'year' || options.type === 'month')\n    \n    ,elemCont = that.elemCont[index || 0]\n    ,listYM = that.listYM[index]\n    ,addSubYeay = function(type){\n      var startEnd = ['startDate', 'endDate'][index]\n      ,isYear = lay(elemCont).find('.laydate-year-list')[0]\n      ,isMonth = lay(elemCont).find('.laydate-month-list')[0];\n      \n      //切换年列表\n      if(isYear){\n        listYM[0] = type ? listYM[0] - 15 : listYM[0] + 15;\n        that.list('year', index);\n      }\n      \n      if(isMonth){ //切换月面板中的年\n        type ? listYM[0]-- : listYM[0]++;\n        that.list('month', index);\n      }\n      \n      if(isYear || isMonth){\n        lay.extend(dateTime, {\n          year: listYM[0]\n        });\n        if(isAlone) that[startEnd].year = listYM[0];\n        options.range || that.done(null, 'change');\n        that.setBtnStatus();      \n        options.range || that.limit(lay(that.footer).find(ELEM_CONFIRM), {\n          year: listYM[0]\n        });\n      }\n      return isYear || isMonth;\n    };\n    \n    return {\n      prevYear: function(){\n        if(addSubYeay('sub')) return;\n        dateTime.year--;\n        that.checkDate('limit').calendar();\n        options.range || that.done(null, 'change');\n      }\n      ,prevMonth: function(){\n        var YM = that.getAsYM(dateTime.year, dateTime.month, 'sub');\n        lay.extend(dateTime, {\n          year: YM[0]\n          ,month: YM[1]\n        });\n        that.checkDate('limit').calendar();\n        options.range || that.done(null, 'change');\n      }\n      ,nextMonth: function(){\n        var YM = that.getAsYM(dateTime.year, dateTime.month);\n        lay.extend(dateTime, {\n          year: YM[0]\n          ,month: YM[1]\n        });\n        that.checkDate('limit').calendar();\n        options.range || that.done(null, 'change');\n      }\n      ,nextYear: function(){\n        if(addSubYeay()) return;\n        dateTime.year++\n        that.checkDate('limit').calendar();\n        options.range || that.done(null, 'change');\n      }\n    };\n  };\n  \n  //日期切换事件\n  Class.prototype.changeEvent = function(){\n    var that = this\n    ,options = that.config;\n\n    //日期选择事件\n    lay(that.elem).on('click', function(e){\n      lay.stope(e);\n    });\n    \n    //年月切换\n    lay.each(that.elemHeader, function(i, header){\n      //上一年\n      lay(header[0]).on('click', function(e){\n        that.change(i).prevYear();\n      });\n      \n      //上一月\n      lay(header[1]).on('click', function(e){\n        that.change(i).prevMonth();\n      });\n      \n      //选择年月\n      lay(header[2]).find('span').on('click', function(e){\n        var othis = lay(this)\n        ,layYM = othis.attr('lay-ym')\n        ,layType = othis.attr('lay-type');\n        \n        if(!layYM) return;\n        \n        layYM = layYM.split('-');\n\n        that.listYM[i] = [layYM[0] | 0, layYM[1] | 0];\n        that.list(layType, i);\n        lay(that.footer).find(ELEM_TIME_BTN).addClass(DISABLED);\n      });\n\n      //下一月\n      lay(header[3]).on('click', function(e){\n        that.change(i).nextMonth();\n      });\n      \n      //下一年\n      lay(header[4]).on('click', function(e){\n        that.change(i).nextYear();\n      });\n    });\n    \n    //点击日期\n    lay.each(that.table, function(i, table){\n      var tds = lay(table).find('td');\n      tds.on('click', function(){\n        that.choose(lay(this));\n      });\n    });\n    \n    //点击底部按钮\n    lay(that.footer).find('span').on('click', function(){\n      var type = lay(this).attr('lay-type');\n      that.tool(this, type);\n    });\n  };\n  \n  //是否输入框\n  Class.prototype.isInput = function(elem){\n    return /input|textarea/.test(elem.tagName.toLocaleLowerCase());\n  };\n\n  //绑定的元素事件处理\n  Class.prototype.events = function(){\n    var that = this\n    ,options = that.config\n\n    //绑定呼出控件事件\n    ,showEvent = function(elem, bind){\n      elem.on(options.trigger, function(){\n        bind && (that.bindElem = this);\n        that.render();\n      });\n    };\n    \n    if(!options.elem[0] || options.elem[0].eventHandler) return;\n    \n    showEvent(options.elem, 'bind');\n    showEvent(options.eventElem);\n    \n    //绑定关闭控件事件\n    lay(document).on('click', function(e){\n      if(e.target === options.elem[0] \n      || e.target === options.eventElem[0]\n      || e.target === lay(options.closeStop)[0]){\n        return;\n      }\n      that.remove();\n    }).on('keydown', function(e){\n      if(e.keyCode === 13){\n        if(lay('#'+ that.elemID)[0] && that.elemID === Class.thisElem){\n          e.preventDefault();\n          lay(that.footer).find(ELEM_CONFIRM)[0].click();\n        }\n      }\n    });\n    \n    //自适应定位\n    lay(window).on('resize', function(){\n      if(!that.elem || !lay(ELEM)[0]){\n        return false;\n      }\n      that.position();\n    });\n    \n    options.elem[0].eventHandler = true;\n  };\n\n  \n  //核心接口\n  laydate.render = function(options){\n    var inst = new Class(options);\n    return thisDate.call(inst);\n  };\n  \n  //得到某月的最后一天\n  laydate.getEndDate = function(month, year){\n    var thisDate = new Date();\n    //设置日期为下个月的第一天\n    thisDate.setFullYear(\n      year || thisDate.getFullYear()\n      ,month || (thisDate.getMonth() + 1)\n    ,1);\n    //减去一天，得到当前月最后一天\n    return new Date(thisDate.getTime() - 1000*60*60*24).getDate();\n  };\n  \n  //暴露lay\n  window.lay = window.lay || lay;\n  window.laydate = window.laydate || laydate;\n  \n  //加载方式\n  isLayui ? (\n    laydate.ready()\n    ,layui.define(function(exports){ //layui加载\n      laydate.path = layui.cache.dir;\n      exports(MOD_NAME, laydate);\n    })\n  ) : (\n    ( true) ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){ //requirejs加载\n      return laydate;\n    }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : function(){ //普通script标签加载\n      laydate.ready();\n      window.laydate = laydate\n    }()\n  );\n\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy9sYXllci9sYXlkYXRlL2xheWRhdGUuanM/MTU5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxFO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCO0FBQ0Esd0I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUs7O0FBRVY7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUU7QUFDQSxPQUFPO0FBQ1AscUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUksdUJBQXVCLG1CQUFtQixTQUFTO0FBQ25FLGFBQWEsSUFBSSxhQUFhLG1CQUFtQixPQUFPLGFBQWE7QUFDckUsNEJBQTRCLElBQUksNEJBQTRCLE9BQU87O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDLHVCQUF1Qjs7QUFFdkI7O0FBRUEsc0VBQXNFO0FBQ3RFO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsd0VBQXdFO0FBQ3hFO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckM7QUFDQTtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4Q0FBOEM7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU8sZUFBZTtBQUN0QixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEVBQTBFO0FBQzFFLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxFOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQSxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSywyQkFBMkI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLDBCQUEwQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLHNCQUFzQjtBQUN0QjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU8sdUJBQXVCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLE9BQU8sNEJBQTRCO0FBQ25DO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkM7QUFDQSxPQUFPLDRCQUE0QjtBQUNuQztBQUNBLE9BQU8sNEJBQTRCO0FBQ25DO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0Esc0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdDQUF3QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyREFBcUU7QUFDckU7QUFDQSxLQUFLO0FBQUEsa0hBQWU7QUFDcEI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gXG4gQE5hbWUgOiBsYXlEYXRlIDUuMC45IOaXpeacn+aXtumXtOaOp+S7tlxuIEBBdXRob3I6IOi0pOW/g1xuIEBTaXRl77yaaHR0cDovL3d3dy5sYXl1aS5jb20vbGF5ZGF0ZS9cbiBATGljZW5zZe+8mk1JVFxuIFxuICovXG5cbjshZnVuY3Rpb24oKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGlzTGF5dWkgPSB3aW5kb3cubGF5dWkgJiYgbGF5dWkuZGVmaW5lLCByZWFkeSA9IHtcbiAgICBnZXRQYXRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGpzUGF0aCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBqcyA9IGRvY3VtZW50LnNjcmlwdHNcbiAgICAgICAgLGxhc3QgPSBqcy5sZW5ndGggLSAxXG4gICAgICAgICxzcmM7XG4gICAgICAgIGZvcih2YXIgaSA9IGxhc3Q7IGkgPiAwOyBpLS0pe1xuICAgICAgICAgIGlmKGpzW2ldLnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpe1xuICAgICAgICAgICAgc3JjID0ganNbaV0uc3JjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmMgfHwganNbbGFzdF0uc3JjO1xuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGpzUGF0aC5zdWJzdHJpbmcoMCwganNQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9KClcbiAgICBcbiAgICAvL+iOt+WPluiKgueCueeahHN0eWxl5bGe5oCn5YC8XG4gICAgLGdldFN0eWxlOiBmdW5jdGlvbihub2RlLCBuYW1lKXtcbiAgICAgIHZhciBzdHlsZSA9IG5vZGUuY3VycmVudFN0eWxlID8gbm9kZS5jdXJyZW50U3R5bGUgOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKTtcbiAgICAgIHJldHVybiBzdHlsZVtzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlID8gJ2dldFByb3BlcnR5VmFsdWUnIDogJ2dldEF0dHJpYnV0ZSddKG5hbWUpO1xuICAgIH1cbiAgICBcbiAgICAvL+i9veWFpUNTU+mFjeS7tlxuICAgICxsaW5rOiBmdW5jdGlvbihocmVmLCBmbiwgY3NzbmFtZSl7XG4gICAgICAvLyDkuI3liqDovb3jgIHoh6rlt7HmiYvliqjlpITnkIZjc3NcbiAgICAgIGlmKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgXHQgIGZuKCk7XG4gICAgXHQgIHJldHVybiA7XG4gICAgICB9XG4gICAgXHRcbiAgICAgIC8v5pyq6K6+572u6Lev5b6E77yM5YiZ5LiN5Li75Yqo5Yqg6L29Y3NzXG4gICAgICBpZighbGF5ZGF0ZS5wYXRoKSByZXR1cm47XG4gICAgICBcbiAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgaWYodHlwZW9mIGZuID09PSAnc3RyaW5nJykgY3NzbmFtZSA9IGZuO1xuICAgICAgdmFyIGFwcCA9IChjc3NuYW1lIHx8IGhyZWYpLnJlcGxhY2UoL1xcLnxcXC8vZywgJycpO1xuICAgICAgdmFyIGlkID0gJ2xheXVpY3NzLScrIGFwcCwgdGltZW91dCA9IDA7XG4gICAgICBcbiAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgICAgbGluay5ocmVmID0gbGF5ZGF0ZS5wYXRoICsgaHJlZjtcbiAgICAgIGxpbmsuaWQgPSBpZDtcbiAgICAgIFxuICAgICAgaWYoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSl7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgICAgXG4gICAgICAvL+i9ruivomNzc+aYr+WQpuWKoOi9veWujOavlVxuICAgICAgKGZ1bmN0aW9uIHBvbGwoKSB7IFxuICAgICAgICBpZigrK3RpbWVvdXQgPiA4ICogMTAwMCAvIDEwMCl7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUuZXJyb3IoJ2xheWRhdGUuY3NzOiBJbnZhbGlkJyk7XG4gICAgICAgIH07XG4gICAgICAgIHBhcnNlSW50KHJlYWR5LmdldFN0eWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSwgJ3dpZHRoJykpID09PSAxOTg5ID8gZm4oKSA6IHNldFRpbWVvdXQocG9sbCwgMTAwKTtcbiAgICAgIH0oKSk7XG4gICAgfVxuICB9XG5cbiAgLGxheWRhdGUgPSB7XG4gICAgdjogJzUuMC45J1xuICAgICxjb25maWc6IHt9IC8v5YWo5bGA6YWN572u6aG5XG4gICAgLGluZGV4OiAod2luZG93LmxheWRhdGUgJiYgd2luZG93LmxheWRhdGUudikgPyAxMDAwMDAgOiAwXG4gICAgLHBhdGg6IHJlYWR5LmdldFBhdGhcbiAgICBcbiAgICAvL+iuvue9ruWFqOWxgOmhuVxuICAgICxzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhhdC5jb25maWcgPSBsYXkuZXh0ZW5kKHt9LCB0aGF0LmNvbmZpZywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhhdDtcbiAgICB9XG4gICAgXG4gICAgLy/kuLvkvZNDU1PnrYnlvoXkuovku7ZcbiAgICAscmVhZHk6IGZ1bmN0aW9uKGZuKXtcbiAgICAgIHZhciBjc3NuYW1lID0gJ2xheWRhdGUnLCB2ZXIgPSAnJ1xuICAgICAgLHBhdGggPSAoaXNMYXl1aSA/ICdtb2R1bGVzL2xheWRhdGUvJyA6ICd0aGVtZS8nKSArICdkZWZhdWx0L2xheWRhdGUuY3NzP3Y9JysgbGF5ZGF0ZS52ICsgdmVyO1xuICAgICAgaXNMYXl1aSA/IGxheXVpLmFkZGNzcyhwYXRoLCBmbiwgY3NzbmFtZSkgOiByZWFkeS5saW5rKHBhdGgsIGZuLCBjc3NuYW1lKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICBcbiAgLy/mk43kvZzlvZPliY3lrp7kvotcbiAgLHRoaXNEYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8v5o+Q56S65qGGXG4gICAgICBoaW50OiBmdW5jdGlvbihjb250ZW50KXtcbiAgICAgICAgdGhhdC5oaW50LmNhbGwodGhhdCwgY29udGVudCk7XG4gICAgICB9XG4gICAgICAsY29uZmlnOiB0aGF0LmNvbmZpZ1xuICAgIH07XG4gIH1cblxuICAvL+Wtl+espuW4uOmHj1xuICAsTU9EX05BTUUgPSAnbGF5ZGF0ZScsIEVMRU0gPSAnLmxheXVpLWxheWRhdGUnLCBUSElTID0gJ2xheXVpLXRoaXMnLCBTSE9XID0gJ2xheXVpLXNob3cnLCBISURFID0gJ2xheXVpLWhpZGUnLCBESVNBQkxFRCA9ICdsYXlkYXRlLWRpc2FibGVkJywgVElQU19PVVQgPSAn5byA5aeL5pel5pyf6LaF5Ye65LqG57uT5p2f5pel5pyfPGJyPuW7uuiurumHjeaWsOmAieaLqScsIExJTUlUX1lFQVIgPSBbMTAwLCAyMDAwMDBdXG4gIFxuICAsRUxFTV9TVEFUSUMgPSAnbGF5dWktbGF5ZGF0ZS1zdGF0aWMnLCBFTEVNX0xJU1QgPSAnbGF5dWktbGF5ZGF0ZS1saXN0JywgRUxFTV9TRUxFQ1RFRCA9ICdsYXlkYXRlLXNlbGVjdGVkJywgRUxFTV9ISU5UID0gJ2xheXVpLWxheWRhdGUtaGludCcsIEVMRU1fUFJFViA9ICdsYXlkYXRlLWRheS1wcmV2JywgRUxFTV9ORVhUID0gJ2xheWRhdGUtZGF5LW5leHQnLCBFTEVNX0ZPT1RFUiA9ICdsYXl1aS1sYXlkYXRlLWZvb3RlcicsIEVMRU1fQ09ORklSTSA9ICcubGF5ZGF0ZS1idG5zLWNvbmZpcm0nLCBFTEVNX1RJTUVfVEVYVCA9ICdsYXlkYXRlLXRpbWUtdGV4dCcsIEVMRU1fVElNRV9CVE4gPSAnLmxheWRhdGUtYnRucy10aW1lJ1xuICBcbiAgLy/nu4Tku7bmnoTpgKDlmahcbiAgLENsYXNzID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuaW5kZXggPSArK2xheWRhdGUuaW5kZXg7XG4gICAgdGhhdC5jb25maWcgPSBsYXkuZXh0ZW5kKHt9LCB0aGF0LmNvbmZpZywgbGF5ZGF0ZS5jb25maWcsIG9wdGlvbnMpO1xuICAgIGxheWRhdGUucmVhZHkoZnVuY3Rpb24oKXtcbiAgICAgIHRoYXQuaW5pdCgpO1xuICAgIH0pO1xuICB9XG4gIFxuICAvL0RPTeafpeaJvlxuICAsbGF5ID0gZnVuY3Rpb24oc2VsZWN0b3IpeyAgIFxuICAgIHJldHVybiBuZXcgTEFZKHNlbGVjdG9yKTtcbiAgfVxuICBcbiAgLy9ET03mnoTpgKDlmahcbiAgLExBWSA9IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICB2YXIgaW5kZXggPSAwXG4gICAgLG5hdGl2ZURPTSA9IHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcgPyBbc2VsZWN0b3JdIDogKFxuICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yXG4gICAgICAsZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciB8fCBudWxsKVxuICAgICk7XG4gICAgZm9yKDsgaW5kZXggPCBuYXRpdmVET00ubGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgIHRoaXMucHVzaChuYXRpdmVET01baW5kZXhdKTtcbiAgICB9XG4gIH07XG4gIFxuICBcbiAgLypcbiAgICBsYXnlr7nosaHmk43kvZxcbiAgKi9cbiAgXG4gIExBWS5wcm90b3R5cGUgPSBbXTtcbiAgTEFZLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExBWTtcbiAgXG4gIC8v5pmu6YCa5a+56LGh5rex5bqm5omp5bGVXG4gIGxheS5leHRlbmQgPSBmdW5jdGlvbigpe1xuICAgIHZhciBhaSA9IDEsIGFyZ3MgPSBhcmd1bWVudHNcbiAgICAsY2xvbmUgPSBmdW5jdGlvbih0YXJnZXQsIG9iail7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgKG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBbXSA6IHt9KTsgXG4gICAgICBmb3IodmFyIGkgaW4gb2JqKXtcbiAgICAgICAgLy/lpoLmnpzlgLzkuLrlr7nosaHvvIzliJnov5vlhaXpgJLlvZLvvIznu6fnu63mt7HluqblkIjlubZcbiAgICAgICAgdGFyZ2V0W2ldID0gKG9ialtpXSAmJiAob2JqW2ldLmNvbnN0cnVjdG9yID09PSBPYmplY3QpKVxuICAgICAgICAgID8gY2xvbmUodGFyZ2V0W2ldLCBvYmpbaV0pXG4gICAgICAgIDogb2JqW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnID8gYXJnc1swXSA6IHt9O1xuXG4gICAgZm9yKDsgYWkgPCBhcmdzLmxlbmd0aDsgYWkrKyl7XG4gICAgICBpZih0eXBlb2YgYXJnc1thaV0gPT09ICdvYmplY3QnKXtcbiAgICAgICAgY2xvbmUoYXJnc1swXSwgYXJnc1thaV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmdzWzBdO1xuICB9O1xuICBcbiAgLy9pZeeJiOacrFxuICBsYXkuaWUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKCEhd2luZG93LkFjdGl2ZVhPYmplY3QgfHwgXCJBY3RpdmVYT2JqZWN0XCIgaW4gd2luZG93KSA/IChcbiAgICAgIChhZ2VudC5tYXRjaCgvbXNpZVxccyhcXGQrKS8pIHx8IFtdKVsxXSB8fCAnMTEnIC8v55Sx5LqOaWUxMeW5tuayoeaciW1zaWXnmoTmoIfor4ZcbiAgICApIDogZmFsc2U7XG4gIH0oKTtcbiAgXG4gIC8v5Lit5q2i5YaS5rOhXG4gIGxheS5zdG9wZSA9IGZ1bmN0aW9uKGUpe1xuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbiBcbiAgICAgID8gZS5zdG9wUHJvcGFnYXRpb24oKSBcbiAgICA6IGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgfTtcbiAgXG4gIC8v5a+56LGh6YGN5Y6GXG4gIGxheS5lYWNoID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gICAgdmFyIGtleVxuICAgICx0aGF0ID0gdGhpcztcbiAgICBpZih0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHJldHVybiB0aGF0O1xuICAgIG9iaiA9IG9iaiB8fCBbXTtcbiAgICBpZihvYmouY29uc3RydWN0b3IgPT09IE9iamVjdCl7XG4gICAgICBmb3Ioa2V5IGluIG9iail7XG4gICAgICAgIGlmKGZuLmNhbGwob2JqW2tleV0sIGtleSwgb2JqW2tleV0pKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGtleSA9IDA7IGtleSA8IG9iai5sZW5ndGg7IGtleSsrKXtcbiAgICAgICAgaWYoZm4uY2FsbChvYmpba2V5XSwga2V5LCBvYmpba2V5XSkpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhhdDtcbiAgfTtcbiAgXG4gIC8v5pWw5a2X5YmN572u6KGl6Zu2XG4gIGxheS5kaWdpdCA9IGZ1bmN0aW9uKG51bSwgbGVuZ3RoLCBlbmQpe1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBudW0gPSBTdHJpbmcobnVtKTtcbiAgICBsZW5ndGggPSBsZW5ndGggfHwgMjtcbiAgICBmb3IodmFyIGkgPSBudW0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspe1xuICAgICAgc3RyICs9ICcwJztcbiAgICB9XG4gICAgcmV0dXJuIG51bSA8IE1hdGgucG93KDEwLCBsZW5ndGgpID8gc3RyICsgKG51bXwwKSA6IG51bTtcbiAgfTtcbiAgXG4gIC8v5Yib5bu65YWD57SgXG4gIGxheS5lbGVtID0gZnVuY3Rpb24oZWxlbU5hbWUsIGF0dHIpe1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtTmFtZSk7XG4gICAgbGF5LmVhY2goYXR0ciB8fCB7fSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbTtcbiAgfTtcbiAgXG4gIC8v6L+95Yqg5a2X56ymXG4gIExBWS5hZGRTdHIgPSBmdW5jdGlvbihzdHIsIG5ld19zdHIpe1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHMrLywgJyAnKTtcbiAgICBuZXdfc3RyID0gbmV3X3N0ci5yZXBsYWNlKC9cXHMrLywgJyAnKS5zcGxpdCgnICcpO1xuICAgIGxheS5lYWNoKG5ld19zdHIsIGZ1bmN0aW9uKGlpLCBpdGVtKXtcbiAgICAgIGlmKCFuZXcgUmVnRXhwKCdcXFxcYicrIGl0ZW0gKyAnXFxcXGInKS50ZXN0KHN0cikpe1xuICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyBpdGVtO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxcc3xcXHMkLywgJycpO1xuICB9O1xuICBcbiAgLy/np7vpmaTlgLxcbiAgTEFZLnJlbW92ZVN0ciA9IGZ1bmN0aW9uKHN0ciwgbmV3X3N0cil7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xccysvLCAnICcpO1xuICAgIG5ld19zdHIgPSBuZXdfc3RyLnJlcGxhY2UoL1xccysvLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgbGF5LmVhY2gobmV3X3N0ciwgZnVuY3Rpb24oaWksIGl0ZW0pe1xuICAgICAgdmFyIGV4cCA9IG5ldyBSZWdFeHAoJ1xcXFxiJysgaXRlbSArICdcXFxcYicpXG4gICAgICBpZihleHAudGVzdChzdHIpKXtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZXhwLCAnJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMrLywgJyAnKS5yZXBsYWNlKC9eXFxzfFxccyQvLCAnJyk7XG4gIH07XG4gIFxuICAvL+afpeaJvuWtkOWFg+e0oFxuICBMQVkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IDAsIGFyciA9IFtdXG4gICAgLGlzT2JqZWN0ID0gdHlwZW9mIHNlbGVjdG9yID09PSAnb2JqZWN0JztcbiAgICBcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgaXRlbSl7XG4gICAgICB2YXIgbmF0aXZlRE9NID0gaXNPYmplY3QgPyBbc2VsZWN0b3JdIDogaXRlbS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yIHx8IG51bGwpO1xuICAgICAgZm9yKDsgaW5kZXggPCBuYXRpdmVET00ubGVuZ3RoOyBpbmRleCsrKXtcbiAgICAgICAgYXJyLnB1c2gobmF0aXZlRE9NW2luZGV4XSk7XG4gICAgICB9XG4gICAgICB0aGF0LnNoaWZ0KCk7XG4gICAgfSk7XG4gICAgXG4gICAgaWYoIWlzT2JqZWN0KXtcbiAgICAgIHRoYXQuc2VsZWN0b3IgPSAgKHRoYXQuc2VsZWN0b3IgPyB0aGF0LnNlbGVjdG9yICsgJyAnIDogJycpICsgc2VsZWN0b3JcbiAgICB9XG4gICAgXG4gICAgbGF5LmVhY2goYXJyLCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgIHRoYXQucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdGhhdDtcbiAgfTtcbiAgXG4gIC8vRE9N6YGN5Y6GXG4gIExBWS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGZuKXtcbiAgICByZXR1cm4gbGF5LmVhY2guY2FsbCh0aGlzLCB0aGlzLCBmbik7XG4gIH07XG4gIFxuICAvL+a3u+WKoGNzc+exu1xuICBMQVkucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lLCB0eXBlKXtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBpdGVtKXtcbiAgICAgIGl0ZW0uY2xhc3NOYW1lID0gTEFZW3R5cGUgPyAncmVtb3ZlU3RyJyA6ICdhZGRTdHInXShpdGVtLmNsYXNzTmFtZSwgY2xhc3NOYW1lKVxuICAgIH0pO1xuICB9O1xuICBcbiAgLy/np7vpmaRjc3PnsbtcbiAgTEFZLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSl7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ2xhc3MoY2xhc3NOYW1lLCB0cnVlKTtcbiAgfTtcbiAgXG4gIC8v5piv5ZCm5YyF5ZCrY3Nz57G7XG4gIExBWS5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUpe1xuICAgIHZhciBoYXMgPSBmYWxzZTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGl0ZW0pe1xuICAgICAgaWYobmV3IFJlZ0V4cCgnXFxcXGInKyBjbGFzc05hbWUgKydcXFxcYicpLnRlc3QoaXRlbS5jbGFzc05hbWUpKXtcbiAgICAgICAgaGFzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGFzO1xuICB9O1xuICBcbiAgLy/mt7vliqDmiJbojrflj5blsZ7mgKdcbiAgTEFZLnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24oKXtcbiAgICAgIGlmKHRoYXQubGVuZ3RoID4gMCkgcmV0dXJuIHRoYXRbMF0uZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgfSgpIDogdGhhdC5lYWNoKGZ1bmN0aW9uKGluZGV4LCBpdGVtKXtcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH0pOyAgIFxuICB9O1xuICBcbiAgLy/np7vpmaTlsZ7mgKdcbiAgTEFZLnByb3RvdHlwZS5yZW1vdmVBdHRyID0gZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBpdGVtKXtcbiAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvL+iuvue9rkhUTUzlhoXlrrlcbiAgTEFZLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCl7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCwgaXRlbSl7XG4gICAgICBpdGVtLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvL+iuvue9ruWAvFxuICBMQVkucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBpdGVtKXtcbiAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8v6L+95Yqg5YaF5a65XG4gIExBWS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oZWxlbSl7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCwgaXRlbSl7XG4gICAgICB0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcgXG4gICAgICAgID8gaXRlbS5hcHBlbmRDaGlsZChlbGVtKVxuICAgICAgOiAgaXRlbS5pbm5lckhUTUwgPSBpdGVtLmlubmVySFRNTCArIGVsZW07XG4gICAgfSk7XG4gIH07XG4gIFxuICAvL+enu+mZpOWGheWuuVxuICBMQVkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGVsZW0pe1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGl0ZW0pe1xuICAgICAgZWxlbSA/IGl0ZW0ucmVtb3ZlQ2hpbGQoZWxlbSkgOiBpdGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaXRlbSk7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvL+S6i+S7tue7keWumlxuICBMQVkucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnROYW1lLCBmbil7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCwgaXRlbSl7XG4gICAgICBpdGVtLmF0dGFjaEV2ZW50ID8gaXRlbS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBmdW5jdGlvbihlKXtcbiAgICAgICAgZS50YXJnZXQgPSBlLnNyY0VsZW1lbnQ7XG4gICAgICAgIGZuLmNhbGwoaXRlbSwgZSk7XG4gICAgICB9KSA6IGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvL+ino+mZpOS6i+S7tlxuICBMQVkucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZm4pe1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGl0ZW0pe1xuICAgICAgaXRlbS5kZXRhY2hFdmVudCBcbiAgICAgICAgPyBpdGVtLmRldGFjaEV2ZW50KCdvbicrIGV2ZW50TmFtZSwgZm4pICBcbiAgICAgIDogaXRlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIFxuICAvKlxuICAgIOe7hOS7tuaTjeS9nFxuICAqL1xuICBcbiAgXG4gIC8v5piv5ZCm6Zew5bm0XG4gIENsYXNzLmlzTGVhcFllYXIgPSBmdW5jdGlvbih5ZWFyKXtcbiAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gIH07XG4gIFxuICAvL+m7mOiupOmFjee9rlxuICBDbGFzcy5wcm90b3R5cGUuY29uZmlnID0ge1xuICAgIHR5cGU6ICdkYXRlJyAvL+aOp+S7tuexu+Wei++8jOaUr+aMge+8mnllYXIvbW9udGgvZGF0ZS90aW1lL2RhdGV0aW1lXG4gICAgLHJhbmdlOiBmYWxzZSAvL+aYr+WQpuW8gOWQr+iMg+WbtOmAieaLqe+8jOWNs+WPjOaOp+S7tlxuICAgICxmb3JtYXQ6ICd5eXl5LU1NLWRkJyAvL+m7mOiupOaXpeacn+agvOW8j1xuICAgICx2YWx1ZTogbnVsbCAvL+m7mOiupOaXpeacn++8jOaUr+aMgeS8oOWFpW5ldyBEYXRlKCnvvIzmiJbogIXnrKblkIhmb3JtYXTlj4LmlbDorr7lrprnmoTml6XmnJ/moLzlvI/lrZfnrKZcbiAgICAsbWluOiAnMTkwMC0xLTEnIC8v5pyJ5pWI5pyA5bCP5pel5pyf77yM5bm05pyI5pel5b+F6aG755So4oCcLeKAneWIhuWJsu+8jOaXtuWIhuenkuW/hemhu+eUqOKAnDrigJ3liIblibLjgILms6jmhI/vvJrlroPlubbkuI3mmK/pgbXlvqogZm9ybWF0IOiuvuWumueahOagvOW8j+OAglxuICAgICxtYXg6ICcyMDk5LTEyLTMxJyAvL+acieaViOacgOWkp+aXpeacn++8jOWQjOS4ilxuICAgICx0cmlnZ2VyOiAnZm9jdXMnIC8v5ZG85Ye65o6n5Lu255qE5LqL5Lu2XG4gICAgLHNob3c6IGZhbHNlIC8v5piv5ZCm55u05o6l5pi+56S677yM5aaC5p6c6K6+572udHJ1Ze+8jOWImem7mOiupOebtOaOpeaYvuekuuaOp+S7tlxuICAgICxzaG93Qm90dG9tOiB0cnVlIC8v5piv5ZCm5pi+56S65bqV6YOo5qCPXG4gICAgLGJ0bnM6IFsnY2xlYXInLCAnbm93JywgJ2NvbmZpcm0nXSAvL+WPs+S4i+inkuaYvuekuueahOaMiemSru+8jOS8muaMieeFp+aVsOe7hOmhuuW6j+aOkuWIl1xuICAgICxsYW5nOiAnY24nIC8v6K+t6KiA77yM5Y+q5pSv5oyBY24vZW7vvIzljbPkuK3mloflkozoi7HmlodcbiAgICAsdGhlbWU6ICdkZWZhdWx0JyAvL+S4u+mimFxuICAgICxwb3NpdGlvbjogbnVsbCAvL+aOp+S7tuWumuS9jeaWueW8j+WumuS9jSwg6buY6K6kYWJzb2x1dGXvvIzmlK/mjIHvvJpmaXhlZC9hYnNvbHV0ZS9zdGF0aWNcbiAgICAsY2FsZW5kYXI6IGZhbHNlIC8v5piv5ZCm5byA5ZCv5YWs5Y6G6YeN6KaB6IqC5pel77yM5LuF5pSv5oyB5Lit5paH54mIXG4gICAgLG1hcms6IHt9IC8v5pel5pyf5aSH5rOo77yM5aaC6YeN6KaB5LqL5Lu25oiW5rS75Yqo5qCH6K6wXG4gICAgLHpJbmRleDogbnVsbCAvL+aOp+S7tuWxguWPoOmhuuW6j1xuICAgICxkb25lOiBudWxsIC8v5o6n5Lu26YCJ5oup5a6M5q+V5ZCO55qE5Zue6LCD77yM54K55Ye75riF56m6L+eOsOWcqC/noa7lrprkuZ/lnYfkvJrop6blj5FcbiAgICAsY2hhbmdlOiBudWxsIC8v5pel5pyf5pe26Ze05pS55Y+Y5ZCO55qE5Zue6LCDXG4gIH07XG4gIFxuICAvL+WkmuivreiogFxuICBDbGFzcy5wcm90b3R5cGUubGFuZyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICx0ZXh0ID0ge1xuICAgICAgY246IHtcbiAgICAgICAgd2Vla3M6IFsn5pelJywgJ+S4gCcsICfkuownLCAn5LiJJywgJ+WbmycsICfkupQnLCAn5YWtJ11cbiAgICAgICAgLHRpbWU6IFsn5pe2JywgJ+WIhicsICfnp5InXVxuICAgICAgICAsdGltZVRpcHM6ICfpgInmi6nml7bpl7QnXG4gICAgICAgICxzdGFydFRpbWU6ICflvIDlp4vml7bpl7QnXG4gICAgICAgICxlbmRUaW1lOiAn57uT5p2f5pe26Ze0J1xuICAgICAgICAsZGF0ZVRpcHM6ICfov5Tlm57ml6XmnJ8nXG4gICAgICAgICxtb250aDogWyfkuIAnLCAn5LqMJywgJ+S4iScsICflm5snLCAn5LqUJywgJ+WFrScsICfkuIMnLCAn5YWrJywgJ+S5nScsICfljYEnLCAn5Y2B5LiAJywgJ+WNgeS6jCddXG4gICAgICAgICx0b29sczoge1xuICAgICAgICAgIGNvbmZpcm06ICfnoa7lrponXG4gICAgICAgICAgLGNsZWFyOiAn5riF56m6J1xuICAgICAgICAgICxub3c6ICfnjrDlnKgnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICxlbjoge1xuICAgICAgICB3ZWVrczogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddXG4gICAgICAgICx0aW1lOiBbJ0hvdXJzJywgJ01pbnV0ZXMnLCAnU2Vjb25kcyddXG4gICAgICAgICx0aW1lVGlwczogJ1NlbGVjdCBUaW1lJ1xuICAgICAgICAsc3RhcnRUaW1lOiAnU3RhcnQgVGltZSdcbiAgICAgICAgLGVuZFRpbWU6ICdFbmQgVGltZSdcbiAgICAgICAgLGRhdGVUaXBzOiAnU2VsZWN0IERhdGUnXG4gICAgICAgICxtb250aDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddXG4gICAgICAgICx0b29sczoge1xuICAgICAgICAgIGNvbmZpcm06ICdDb25maXJtJ1xuICAgICAgICAgICxjbGVhcjogJ0NsZWFyJ1xuICAgICAgICAgICxub3c6ICdOb3cnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0ZXh0W29wdGlvbnMubGFuZ10gfHwgdGV4dFsnY24nXTtcbiAgfTtcbiAgXG4gIC8v5Yid5aeL5YeG5aSHXG4gIENsYXNzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsb3B0aW9ucyA9IHRoYXQuY29uZmlnXG4gICAgLGRhdGVUeXBlID0gJ3l5eXl8eXxNTXxNfGRkfGR8SEh8SHxtbXxtfHNzfHMnXG4gICAgLGlzU3RhdGljID0gb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3N0YXRpYydcbiAgICAsZm9ybWF0ID0ge1xuICAgICAgeWVhcjogJ3l5eXknXG4gICAgICAsbW9udGg6ICd5eXl5LU1NJ1xuICAgICAgLGRhdGU6ICd5eXl5LU1NLWRkJ1xuICAgICAgLHRpbWU6ICdISDptbTpzcydcbiAgICAgICxkYXRldGltZTogJ3l5eXktTU0tZGQgSEg6bW06c3MnXG4gICAgfTtcbiAgICBcbiAgICBvcHRpb25zLmVsZW0gPSBsYXkob3B0aW9ucy5lbGVtKTtcbiAgICBvcHRpb25zLmV2ZW50RWxlbSA9IGxheShvcHRpb25zLmV2ZW50RWxlbSk7XG4gICAgXG4gICAgaWYoIW9wdGlvbnMuZWxlbVswXSkgcmV0dXJuO1xuICAgIFxuICAgIC8v5pel5pyf6IyD5Zu05YiG6ZqU56ymXG4gICAgaWYob3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSkgb3B0aW9ucy5yYW5nZSA9ICctJztcbiAgICBcbiAgICAvL+agueaNruS4jeWQjHR5cGXvvIzliJ3lp4vljJbpu5jorqRmb3JtYXRcbiAgICBpZihvcHRpb25zLmZvcm1hdCA9PT0gZm9ybWF0LmRhdGUpe1xuICAgICAgb3B0aW9ucy5mb3JtYXQgPSBmb3JtYXRbb3B0aW9ucy50eXBlXTtcbiAgICB9XG4gICAgXG4gICAgLy/lsIbml6XmnJ/moLzlvI/ovazljJbmiJDmlbDnu4RcbiAgICB0aGF0LmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0Lm1hdGNoKG5ldyBSZWdFeHAoZGF0ZVR5cGUgKyAnfC4nLCAnZycpKSB8fCBbXTtcbiAgICBcbiAgICAvL+eUn+aIkOato+WImeihqOi+vuW8j1xuICAgIHRoYXQuRVhQX0lGID0gJyc7IFxuICAgIHRoYXQuRVhQX1NQTElUID0gJyc7IFxuICAgIGxheS5lYWNoKHRoYXQuZm9ybWF0LCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgIHZhciBFWFAgPSAgbmV3IFJlZ0V4cChkYXRlVHlwZSkudGVzdChpdGVtKSBcbiAgICAgICAgPyAnXFxcXGR7JysgZnVuY3Rpb24oKXtcbiAgICAgICAgICBpZihuZXcgUmVnRXhwKGRhdGVUeXBlKS50ZXN0KHRoYXQuZm9ybWF0W2kgPT09IDAgPyBpICsgMSA6IGkgLSAxXXx8JycpKXtcbiAgICAgICAgICAgIGlmKC9eeXl5eXx5JC8udGVzdChpdGVtKSkgcmV0dXJuIDQ7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKC9eeXl5eSQvLnRlc3QoaXRlbSkpIHJldHVybiAnMSw0JztcbiAgICAgICAgICBpZigvXnkkLy50ZXN0KGl0ZW0pKSByZXR1cm4gJzEsMzA4JztcbiAgICAgICAgICByZXR1cm4gJzEsMic7XG4gICAgICAgIH0oKSArJ30nIFxuICAgICAgOiAnXFxcXCcgKyBpdGVtO1xuICAgICAgdGhhdC5FWFBfSUYgPSB0aGF0LkVYUF9JRiArIEVYUDtcbiAgICAgIHRoYXQuRVhQX1NQTElUID0gdGhhdC5FWFBfU1BMSVQgKyAnKCcgKyBFWFAgKyAnKSc7XG4gICAgfSk7XG4gICAgdGhhdC5FWFBfSUYgPSBuZXcgUmVnRXhwKCdeJysgKFxuICAgICAgb3B0aW9ucy5yYW5nZSA/IFxuICAgICAgICB0aGF0LkVYUF9JRiArICdcXFxcc1xcXFwnKyBvcHRpb25zLnJhbmdlICsgJ1xcXFxzJyArIHRoYXQuRVhQX0lGXG4gICAgICA6IHRoYXQuRVhQX0lGXG4gICAgKSArJyQnKTtcbiAgICB0aGF0LkVYUF9TUExJVCA9IG5ldyBSZWdFeHAoJ14nKyB0aGF0LkVYUF9TUExJVCArJyQnLCAnJyk7XG4gICAgXG4gICAgLy/lpoLmnpzkuI3mmK9pbnB1dHx0ZXh0YXJlYeWFg+e0oO+8jOWImem7mOiupOmHh+eUqGNsaWNr5LqL5Lu2XG4gICAgaWYoIXRoYXQuaXNJbnB1dChvcHRpb25zLmVsZW1bMF0pKXtcbiAgICAgIGlmKG9wdGlvbnMudHJpZ2dlciA9PT0gJ2ZvY3VzJyl7XG4gICAgICAgIG9wdGlvbnMudHJpZ2dlciA9ICdjbGljayc7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8v6K6+572u5ZSv5LiAS0VZXG4gICAgaWYoIW9wdGlvbnMuZWxlbS5hdHRyKCdsYXkta2V5Jykpe1xuICAgICAgb3B0aW9ucy5lbGVtLmF0dHIoJ2xheS1rZXknLCB0aGF0LmluZGV4KTtcbiAgICAgIG9wdGlvbnMuZXZlbnRFbGVtLmF0dHIoJ2xheS1rZXknLCB0aGF0LmluZGV4KTtcbiAgICB9XG4gICAgXG4gICAgLy/orrDlvZXph43opoHml6XmnJ9cbiAgICBvcHRpb25zLm1hcmsgPSBsYXkuZXh0ZW5kKHt9LCAob3B0aW9ucy5jYWxlbmRhciAmJiBvcHRpb25zLmxhbmcgPT09ICdjbicpID8ge1xuICAgICAgJzAtMS0xJzogJ+WFg+aXpidcbiAgICAgICwnMC0yLTE0JzogJ+aDheS6uidcbiAgICAgICwnMC0zLTgnOiAn5aaH5aWzJ1xuICAgICAgLCcwLTMtMTInOiAn5qSN5qCRJ1xuICAgICAgLCcwLTQtMSc6ICfmhJrkuronXG4gICAgICAsJzAtNS0xJzogJ+WKs+WKqCdcbiAgICAgICwnMC01LTQnOiAn6Z2S5bm0J1xuICAgICAgLCcwLTYtMSc6ICflhL/nq6UnXG4gICAgICAsJzAtOS0xMCc6ICfmlZnluIgnXG4gICAgICAsJzAtOS0xOCc6ICflm73ogLsnXG4gICAgICAsJzAtMTAtMSc6ICflm73luoYnXG4gICAgICAsJzAtMTItMjUnOiAn5Zyj6K+eJ1xuICAgIH0gOiB7fSwgb3B0aW9ucy5tYXJrKTtcbiAgICBcbiAgICAvL+iOt+WPlumZkOWItuWGheaXpeacn1xuICAgIGxheS5lYWNoKFsnbWluJywgJ21heCddLCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgIHZhciB5bWQgPSBbXSwgaG1zID0gW107XG4gICAgICBpZih0eXBlb2Ygb3B0aW9uc1tpdGVtXSA9PT0gJ251bWJlcicpeyAvL+WmguaenOS4uuaVsOWtl1xuICAgICAgICB2YXIgZGF5ID0gb3B0aW9uc1tpdGVtXVxuICAgICAgICAsdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgICxTVEFNUCA9IDg2NDAwMDAwIC8v5Luj6KGo5LiA5aSp55qE5pe26Ze05oizXG4gICAgICAgICx0aGlzRGF0ZSA9IG5ldyBEYXRlKFxuICAgICAgICAgIGRheSA/IChcbiAgICAgICAgICAgIGRheSA8IFNUQU1QID8gdGltZSArIGRheSpTVEFNUCA6IGRheSAvL+WmguaenOaVsOWtl+Wwj+S6juS4gOWkqeeahOaXtumXtOaIs++8jOWImeaVsOWtl+S4uuWkqeaVsO+8jOWQpuWImeS4uuaXtumXtOaIs1xuICAgICAgICAgICkgOiB0aW1lXG4gICAgICAgICk7XG4gICAgICAgIHltZCA9IFt0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzRGF0ZS5nZXRNb250aCgpICsgMSwgdGhpc0RhdGUuZ2V0RGF0ZSgpXTtcbiAgICAgICAgZGF5IDwgU1RBTVAgfHwgKGhtcyA9IFt0aGlzRGF0ZS5nZXRIb3VycygpLCB0aGlzRGF0ZS5nZXRNaW51dGVzKCksIHRoaXNEYXRlLmdldFNlY29uZHMoKV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeW1kID0gKG9wdGlvbnNbaXRlbV0ubWF0Y2goL1xcZCstXFxkKy1cXGQrLykgfHwgWycnXSlbMF0uc3BsaXQoJy0nKTtcbiAgICAgICAgaG1zID0gKG9wdGlvbnNbaXRlbV0ubWF0Y2goL1xcZCs6XFxkKzpcXGQrLykgfHwgWycnXSlbMF0uc3BsaXQoJzonKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnNbaXRlbV0gPSB7XG4gICAgICAgIHllYXI6IHltZFswXSB8IDAgfHwgbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpXG4gICAgICAgICxtb250aDogeW1kWzFdID8gKHltZFsxXSB8IDApIC0gMSA6IG5ldyBEYXRlKCkuZ2V0TW9udGgoKVxuICAgICAgICAsZGF0ZTogeW1kWzJdIHwgMCB8fCBuZXcgRGF0ZSgpLmdldERhdGUoKVxuICAgICAgICAsaG91cnM6IGhtc1swXSB8IDBcbiAgICAgICAgLG1pbnV0ZXM6IGhtc1sxXSB8IDBcbiAgICAgICAgLHNlY29uZHM6IGhtc1syXSB8IDBcbiAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgdGhhdC5lbGVtSUQgPSAnbGF5dWktbGF5ZGF0ZScrIG9wdGlvbnMuZWxlbS5hdHRyKCdsYXkta2V5Jyk7XG4gICAgXG4gICAgaWYob3B0aW9ucy5zaG93IHx8IGlzU3RhdGljKSB0aGF0LnJlbmRlcigpO1xuICAgIGlzU3RhdGljIHx8IHRoYXQuZXZlbnRzKCk7XG4gICAgXG4gICAgLy/pu5jorqTotYvlgLxcbiAgICBpZihvcHRpb25zLnZhbHVlKXtcbiAgICAgIGlmKG9wdGlvbnMudmFsdWUuY29uc3RydWN0b3IgPT09IERhdGUpe1xuICAgICAgICB0aGF0LnNldFZhbHVlKHRoYXQucGFyc2UoMCwgdGhhdC5zeXN0ZW1EYXRlKG9wdGlvbnMudmFsdWUpKSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5zZXRWYWx1ZShvcHRpb25zLnZhbHVlKTsgXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBcbiAgLy/mjqfku7bkuLvkvZPmuLLmn5NcbiAgQ2xhc3MucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxsYW5nID0gdGhhdC5sYW5nKClcbiAgICAsaXNTdGF0aWMgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnc3RhdGljJ1xuICAgIFxuICAgIC8v5Li76Z2i5p2/XG4gICAgLGVsZW0gPSB0aGF0LmVsZW0gPSBsYXkuZWxlbSgnZGl2Jywge1xuICAgICAgaWQ6IHRoYXQuZWxlbUlEXG4gICAgICAsJ2NsYXNzJzogW1xuICAgICAgICAnbGF5dWktbGF5ZGF0ZSdcbiAgICAgICAgLG9wdGlvbnMucmFuZ2UgPyAnIGxheXVpLWxheWRhdGUtcmFuZ2UnIDogJydcbiAgICAgICAgLGlzU3RhdGljID8gKCcgJysgRUxFTV9TVEFUSUMpIDogJydcbiAgICAgICAgLG9wdGlvbnMudGhlbWUgJiYgb3B0aW9ucy50aGVtZSAhPT0gJ2RlZmF1bHQnICYmICEvXiMvLnRlc3Qob3B0aW9ucy50aGVtZSkgPyAoJyBsYXlkYXRlLXRoZW1lLScgKyBvcHRpb25zLnRoZW1lKSA6ICcnXG4gICAgICBdLmpvaW4oJycpXG4gICAgfSlcbiAgICBcbiAgICAvL+S4u+WMuuWfn1xuICAgICxlbGVtTWFpbiA9IHRoYXQuZWxlbU1haW4gPSBbXVxuICAgICxlbGVtSGVhZGVyID0gdGhhdC5lbGVtSGVhZGVyID0gW11cbiAgICAsZWxlbUNvbnQgPSB0aGF0LmVsZW1Db250ID0gW11cbiAgICAsZWxlbVRhYmxlID0gdGhhdC50YWJsZSA9IFtdXG5cbiAgICAvL+W6lemDqOWMuuWfn1xuICAgICxkaXZGb290ZXIgPSB0aGF0LmZvb3RlciA9IGxheS5lbGVtKCdkaXYnLCB7XG4gICAgICAnY2xhc3MnOiBFTEVNX0ZPT1RFUlxuICAgIH0pO1xuICAgIFxuICAgIGlmKG9wdGlvbnMuekluZGV4KSBlbGVtLnN0eWxlLnpJbmRleCA9IG9wdGlvbnMuekluZGV4O1xuICAgIFxuICAgIC8v5Y2V5Y+M5pel5Y6G5Yy65Z+fXG4gICAgbGF5LmVhY2gobmV3IEFycmF5KDIpLCBmdW5jdGlvbihpKXtcbiAgICAgIGlmKCFvcHRpb25zLnJhbmdlICYmIGkgPiAwKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8v5aS06YOo5Yy65Z+fXG4gICAgICB2YXIgZGl2SGVhZGVyID0gbGF5LmVsZW0oJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogJ2xheXVpLWxheWRhdGUtaGVhZGVyJ1xuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy/lt6blj7PliIfmjaJcbiAgICAgICxoZWFkZXJDaGlsZCA9IFtmdW5jdGlvbigpeyAvL+S4iuS4gOW5tFxuICAgICAgICB2YXIgZWxlbSA9IGxheS5lbGVtKCdpJywge1xuICAgICAgICAgICdjbGFzcyc6ICdsYXl1aS1pY29uIGxheWRhdGUtaWNvbiBsYXlkYXRlLXByZXYteSdcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW0uaW5uZXJIVE1MID0gJyYjeGU2NWE7JztcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICB9KCksIGZ1bmN0aW9uKCl7IC8v5LiK5LiA5pyIXG4gICAgICAgIHZhciBlbGVtID0gbGF5LmVsZW0oJ2knLCB7XG4gICAgICAgICAgJ2NsYXNzJzogJ2xheXVpLWljb24gbGF5ZGF0ZS1pY29uIGxheWRhdGUtcHJldi1tJ1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbS5pbm5lckhUTUwgPSAnJiN4ZTYwMzsnO1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgIH0oKSwgZnVuY3Rpb24oKXsgLy/lubTmnIjpgInmi6lcbiAgICAgICAgdmFyIGVsZW0gPSBsYXkuZWxlbSgnZGl2Jywge1xuICAgICAgICAgICdjbGFzcyc6ICdsYXlkYXRlLXNldC15bSdcbiAgICAgICAgfSksIHNwYW5ZID0gbGF5LmVsZW0oJ3NwYW4nKSwgc3Bhbk0gPSBsYXkuZWxlbSgnc3BhbicpO1xuICAgICAgICBlbGVtLmFwcGVuZENoaWxkKHNwYW5ZKTtcbiAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChzcGFuTSk7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgfSgpLCBmdW5jdGlvbigpeyAvL+S4i+S4gOaciFxuICAgICAgICB2YXIgZWxlbSA9IGxheS5lbGVtKCdpJywge1xuICAgICAgICAgICdjbGFzcyc6ICdsYXl1aS1pY29uIGxheWRhdGUtaWNvbiBsYXlkYXRlLW5leHQtbSdcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW0uaW5uZXJIVE1MID0gJyYjeGU2MDI7JztcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICB9KCksIGZ1bmN0aW9uKCl7IC8v5LiL5LiA5bm0XG4gICAgICAgIHZhciBlbGVtID0gbGF5LmVsZW0oJ2knLCB7XG4gICAgICAgICAgJ2NsYXNzJzogJ2xheXVpLWljb24gbGF5ZGF0ZS1pY29uIGxheWRhdGUtbmV4dC15J1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbS5pbm5lckhUTUwgPSAnJiN4ZTY1YjsnO1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgIH0oKV1cbiAgICAgIFxuICAgICAgLy/ml6XljoblhoXlrrnljLrln59cbiAgICAgICxkaXZDb250ZW50ID0gbGF5LmVsZW0oJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogJ2xheXVpLWxheWRhdGUtY29udGVudCdcbiAgICAgIH0pXG4gICAgICAsdGFibGUgPSBsYXkuZWxlbSgndGFibGUnKVxuICAgICAgLHRoZWFkID0gbGF5LmVsZW0oJ3RoZWFkJyksIHRoZWFkVHIgPSBsYXkuZWxlbSgndHInKTtcbiAgICAgIFxuICAgICAgLy/nlJ/miJDlubTmnIjpgInmi6lcbiAgICAgIGxheS5lYWNoKGhlYWRlckNoaWxkLCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgICAgZGl2SGVhZGVyLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgICAvL+eUn+aIkOihqOagvFxuICAgICAgdGhlYWQuYXBwZW5kQ2hpbGQodGhlYWRUcik7XG4gICAgICBsYXkuZWFjaChuZXcgQXJyYXkoNiksIGZ1bmN0aW9uKGkpeyAvL+ihqOS9k1xuICAgICAgICB2YXIgdHIgPSB0YWJsZS5pbnNlcnRSb3coMCk7XG4gICAgICAgIGxheS5lYWNoKG5ldyBBcnJheSg3KSwgZnVuY3Rpb24oail7XG4gICAgICAgICAgaWYoaSA9PT0gMCl7XG4gICAgICAgICAgICB2YXIgdGggPSBsYXkuZWxlbSgndGgnKTtcbiAgICAgICAgICAgIHRoLmlubmVySFRNTCA9IGxhbmcud2Vla3Nbal07XG4gICAgICAgICAgICB0aGVhZFRyLmFwcGVuZENoaWxkKHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHIuaW5zZXJ0Q2VsbChqKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRhYmxlLmluc2VydEJlZm9yZSh0aGVhZCwgdGFibGUuY2hpbGRyZW5bMF0pOyAvL+ihqOWktFxuICAgICAgZGl2Q29udGVudC5hcHBlbmRDaGlsZCh0YWJsZSk7XG4gICAgICBcbiAgICAgIGVsZW1NYWluW2ldID0gbGF5LmVsZW0oJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogJ2xheXVpLWxheWRhdGUtbWFpbiBsYXlkYXRlLW1haW4tbGlzdC0nKyBpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZWxlbU1haW5baV0uYXBwZW5kQ2hpbGQoZGl2SGVhZGVyKTtcbiAgICAgIGVsZW1NYWluW2ldLmFwcGVuZENoaWxkKGRpdkNvbnRlbnQpO1xuICAgICAgXG4gICAgICBlbGVtSGVhZGVyLnB1c2goaGVhZGVyQ2hpbGQpO1xuICAgICAgZWxlbUNvbnQucHVzaChkaXZDb250ZW50KTtcbiAgICAgIGVsZW1UYWJsZS5wdXNoKHRhYmxlKTtcbiAgICB9KTtcbiAgICBcbiAgICAvL+eUn+aIkOW6lemDqOagj1xuICAgIGxheShkaXZGb290ZXIpLmh0bWwoZnVuY3Rpb24oKXtcbiAgICAgIHZhciBodG1sID0gW10sIGJ0bnMgPSBbXTtcbiAgICAgIGlmKG9wdGlvbnMudHlwZSA9PT0gJ2RhdGV0aW1lJyl7XG4gICAgICAgIGh0bWwucHVzaCgnPHNwYW4gbGF5LXR5cGU9XCJkYXRldGltZVwiIGNsYXNzPVwibGF5ZGF0ZS1idG5zLXRpbWVcIj4nKyBsYW5nLnRpbWVUaXBzICsnPC9zcGFuPicpO1xuICAgICAgfVxuICAgICAgbGF5LmVhY2gob3B0aW9ucy5idG5zLCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgICAgdmFyIHRpdGxlID0gbGFuZy50b29sc1tpdGVtXSB8fCAnYnRuJztcbiAgICAgICAgaWYob3B0aW9ucy5yYW5nZSAmJiBpdGVtID09PSAnbm93JykgcmV0dXJuO1xuICAgICAgICBpZihpc1N0YXRpYyAmJiBpdGVtID09PSAnY2xlYXInKSB0aXRsZSA9IG9wdGlvbnMubGFuZyA9PT0gJ2NuJyA/ICfph43nva4nIDogJ1Jlc2V0JztcbiAgICAgICAgYnRucy5wdXNoKCc8c3BhbiBsYXktdHlwZT1cIicrIGl0ZW0gKydcIiBjbGFzcz1cImxheWRhdGUtYnRucy0nKyBpdGVtICsnXCI+JysgdGl0bGUgKyc8L3NwYW4+Jyk7XG4gICAgICB9KTtcbiAgICAgIGh0bWwucHVzaCgnPGRpdiBjbGFzcz1cImxheWRhdGUtZm9vdGVyLWJ0bnNcIj4nKyBidG5zLmpvaW4oJycpICsnPC9kaXY+Jyk7XG4gICAgICByZXR1cm4gaHRtbC5qb2luKCcnKTtcbiAgICB9KCkpO1xuICAgIFxuICAgIC8v5o+S5YWl5Yiw5Li75Yy65Z+fXG4gICAgbGF5LmVhY2goZWxlbU1haW4sIGZ1bmN0aW9uKGksIG1haW4pe1xuICAgICAgZWxlbS5hcHBlbmRDaGlsZChtYWluKTtcbiAgICB9KTtcbiAgICBvcHRpb25zLnNob3dCb3R0b20gJiYgZWxlbS5hcHBlbmRDaGlsZChkaXZGb290ZXIpO1xuICAgIFxuICAgIC8v55Sf5oiQ6Ieq5a6a5LmJ5Li76aKYXG4gICAgaWYoL14jLy50ZXN0KG9wdGlvbnMudGhlbWUpKXtcbiAgICAgIHZhciBzdHlsZSA9IGxheS5lbGVtKCdzdHlsZScpXG4gICAgICAsc3R5bGVUZXh0ID0gW1xuICAgICAgICAnI3t7aWR9fSAubGF5dWktbGF5ZGF0ZS1oZWFkZXJ7YmFja2dyb3VuZC1jb2xvcjp7e3RoZW1lfX07fSdcbiAgICAgICAgLCcje3tpZH19IC5sYXl1aS10aGlze2JhY2tncm91bmQtY29sb3I6e3t0aGVtZX19ICFpbXBvcnRhbnQ7fSdcbiAgICAgIF0uam9pbignJykucmVwbGFjZSgve3tpZH19L2csIHRoYXQuZWxlbUlEKS5yZXBsYWNlKC97e3RoZW1lfX0vZywgb3B0aW9ucy50aGVtZSk7XG4gICAgICBcbiAgICAgIGlmKCdzdHlsZVNoZWV0JyBpbiBzdHlsZSl7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBzdHlsZVRleHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGxheShlbGVtKS5hZGRDbGFzcygnbGF5ZGF0ZS10aGVtZS1tb2x2Jyk7XG4gICAgICBlbGVtLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgXG4gICAgLy/np7vpmaTkuIrkuIDkuKrmjqfku7ZcbiAgICB0aGF0LnJlbW92ZShDbGFzcy50aGlzRWxlbURhdGUpOyBcbiAgICBcbiAgICAvL+WmguaenOaYr+mdmeaAgeWumuS9je+8jOWImeaPkuWFpeWIsOaMh+WumueahOWuueWZqOS4re+8jOWQpuWIme+8jOaPkuWFpeWIsGJvZHlcbiAgICBpc1N0YXRpYyA/IG9wdGlvbnMuZWxlbS5hcHBlbmQoZWxlbSkgOiAoXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pXG4gICAgICAsdGhhdC5wb3NpdGlvbigpIC8v5a6a5L2NXG4gICAgKTtcbiAgICBcbiAgICB0aGF0LmNoZWNrRGF0ZSgpLmNhbGVuZGFyKCk7IC8v5Yid5aeL5qCh6aqMXG4gICAgdGhhdC5jaGFuZ2VFdmVudCgpOyAvL+aXpeacn+WIh+aNolxuICAgIFxuICAgIENsYXNzLnRoaXNFbGVtRGF0ZSA9IHRoYXQuZWxlbUlEO1xuXG4gICAgdHlwZW9mIG9wdGlvbnMucmVhZHkgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5yZWFkeShsYXkuZXh0ZW5kKHt9LCBvcHRpb25zLmRhdGVUaW1lLCB7XG4gICAgICBtb250aDogb3B0aW9ucy5kYXRlVGltZS5tb250aCArIDFcbiAgICB9KSk7XG4gIH07XG4gIFxuICAvL+aOp+S7tuenu+mZpFxuICBDbGFzcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocHJldil7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxlbGVtID0gbGF5KCcjJysgKHByZXYgfHwgdGhhdC5lbGVtSUQpKTtcbiAgICBpZighZWxlbS5oYXNDbGFzcyhFTEVNX1NUQVRJQykpe1xuICAgICAgdGhhdC5jaGVja0RhdGUoZnVuY3Rpb24oKXtcbiAgICAgICAgZWxlbS5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhhdDtcbiAgfTtcbiAgXG4gIC8v5a6a5L2N566X5rOVXG4gIENsYXNzLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxlbGVtID0gdGhhdC5iaW5kRWxlbSB8fCBvcHRpb25zLmVsZW1bMF1cbiAgICAscmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgLy/nu5HlrprlhYPntKDnmoTlnZDmoIdcbiAgICAsZWxlbVdpZHRoID0gdGhhdC5lbGVtLm9mZnNldFdpZHRoIC8v5o6n5Lu255qE5a695bqmXG4gICAgLGVsZW1IZWlnaHQgPSB0aGF0LmVsZW0ub2Zmc2V0SGVpZ2h0IC8v5o6n5Lu255qE6auY5bqmXG4gICAgXG4gICAgLy/mu5rliqjmnaHpq5jluqZcbiAgICAsc2Nyb2xsQXJlYSA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgdHlwZSA9IHR5cGUgPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJztcbiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5W3R5cGVdIHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3R5cGVdO1xuICAgIH1cbiAgICAsd2luQXJlYSA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFt0eXBlID8gJ2NsaWVudFdpZHRoJyA6ICdjbGllbnRIZWlnaHQnXVxuICAgIH0sIG1hcmdpbiA9IDUsIGxlZnQgPSByZWN0LmxlZnQsIHRvcCA9IHJlY3QuYm90dG9tO1xuICAgIFxuICAgIC8v5aaC5p6c5Y+z5L6n6LaF5Ye66L6555WMXG4gICAgaWYobGVmdCArIGVsZW1XaWR0aCArIG1hcmdpbiA+IHdpbkFyZWEoJ3dpZHRoJykpe1xuICAgICAgbGVmdCA9IHdpbkFyZWEoJ3dpZHRoJykgLSBlbGVtV2lkdGggLSBtYXJnaW47XG4gICAgfVxuICAgIFxuICAgIC8v5aaC5p6c5bqV6YOo6LaF5Ye66L6555WMXG4gICAgaWYodG9wICsgZWxlbUhlaWdodCArIG1hcmdpbiA+IHdpbkFyZWEoKSl7XG4gICAgICB0b3AgPSByZWN0LnRvcCA+IGVsZW1IZWlnaHQgLy/pobbpg6jmmK/lkKbmnInotrPlpJ/ljLrln5/mmL7npLrlrozlhahcbiAgICAgICAgPyByZWN0LnRvcCAtIGVsZW1IZWlnaHQgXG4gICAgICA6IHdpbkFyZWEoKSAtIGVsZW1IZWlnaHQ7XG4gICAgICB0b3AgPSB0b3AgLSBtYXJnaW4qMjtcbiAgICB9XG4gICAgXG4gICAgaWYob3B0aW9ucy5wb3NpdGlvbil7XG4gICAgICB0aGF0LmVsZW0uc3R5bGUucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGF0LmVsZW0uc3R5bGUubGVmdCA9IGxlZnQgKyAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyA/IDAgOiBzY3JvbGxBcmVhKDEpKSArICdweCc7XG4gICAgdGhhdC5lbGVtLnN0eWxlLnRvcCA9IHRvcCArIChvcHRpb25zLnBvc2l0aW9uID09PSAnZml4ZWQnID8gMCA6IHNjcm9sbEFyZWEoKSkgKyAncHgnO1xuICB9O1xuICBcbiAgLy/mj5DnpLpcbiAgQ2xhc3MucHJvdG90eXBlLmhpbnQgPSBmdW5jdGlvbihjb250ZW50KXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsb3B0aW9ucyA9IHRoYXQuY29uZmlnXG4gICAgLGRpdiA9IGxheS5lbGVtKCdkaXYnLCB7XG4gICAgICAnY2xhc3MnOiBFTEVNX0hJTlRcbiAgICB9KTtcbiAgICBcbiAgICBkaXYuaW5uZXJIVE1MID0gY29udGVudCB8fCAnJztcbiAgICBsYXkodGhhdC5lbGVtKS5maW5kKCcuJysgRUxFTV9ISU5UKS5yZW1vdmUoKTtcbiAgICB0aGF0LmVsZW0uYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgIGNsZWFyVGltZW91dCh0aGF0LmhpblRpbWVyKTtcbiAgICB0aGF0LmhpblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgbGF5KHRoYXQuZWxlbSkuZmluZCgnLicrIEVMRU1fSElOVCkucmVtb3ZlKCk7XG4gICAgfSwgMzAwMCk7XG4gIH07XG4gIFxuICAvL+iOt+WPlumAkuWini/lh4/lkI7nmoTlubTmnIhcbiAgQ2xhc3MucHJvdG90eXBlLmdldEFzWU0gPSBmdW5jdGlvbihZLCBNLCB0eXBlKXtcbiAgICB0eXBlID8gTS0tIDogTSsrO1xuICAgIGlmKE0gPCAwKXtcbiAgICAgIE0gPSAxMTtcbiAgICAgIFktLTtcbiAgICB9XG4gICAgaWYoTSA+IDExKXtcbiAgICAgIE0gPSAwO1xuICAgICAgWSsrO1xuICAgIH1cbiAgICByZXR1cm4gW1ksIE1dO1xuICB9O1xuICBcbiAgLy/ns7vnu5/mtojmga9cbiAgQ2xhc3MucHJvdG90eXBlLnN5c3RlbURhdGUgPSBmdW5jdGlvbihuZXdEYXRlKXtcbiAgICB2YXIgdGhpc0RhdGUgPSBuZXdEYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkgLy/lubRcbiAgICAgICxtb250aDogdGhpc0RhdGUuZ2V0TW9udGgoKSAvL+aciFxuICAgICAgLGRhdGU6IHRoaXNEYXRlLmdldERhdGUoKSAvL+aXpVxuICAgICAgLGhvdXJzOiBuZXdEYXRlID8gbmV3RGF0ZS5nZXRIb3VycygpIDogMCAvL+aXtlxuICAgICAgLG1pbnV0ZXM6IG5ld0RhdGUgPyBuZXdEYXRlLmdldE1pbnV0ZXMoKSA6IDAgLy/liIZcbiAgICAgICxzZWNvbmRzOiBuZXdEYXRlID8gbmV3RGF0ZS5nZXRTZWNvbmRzKCkgOiAwIC8v56eSXG4gICAgfVxuICB9O1xuICBcbiAgLy/ml6XmnJ/moKHpqoxcbiAgQ2xhc3MucHJvdG90eXBlLmNoZWNrRGF0ZSA9IGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsdGhpc0RhdGUgPSBuZXcgRGF0ZSgpXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxkYXRlVGltZSA9IG9wdGlvbnMuZGF0ZVRpbWUgPSBvcHRpb25zLmRhdGVUaW1lIHx8IHRoYXQuc3lzdGVtRGF0ZSgpXG4gICAgLHRoaXNNYXhEYXRlLCBlcnJvclxuICAgIFxuICAgICxlbGVtID0gdGhhdC5iaW5kRWxlbSB8fCBvcHRpb25zLmVsZW1bMF1cbiAgICAsdmFsVHlwZSA9IHRoYXQuaXNJbnB1dChlbGVtKSA/ICd2YWwnIDogJ2h0bWwnXG4gICAgLHZhbHVlID0gdGhhdC5pc0lucHV0KGVsZW0pID8gZWxlbS52YWx1ZSA6IChvcHRpb25zLnBvc2l0aW9uID09PSAnc3RhdGljJyA/ICcnIDogZWxlbS5pbm5lckhUTUwpXG4gICAgXG4gICAgLy/moKHpqozml6XmnJ/mnInmlYjmlbDlrZdcbiAgICAsY2hlY2tWYWxpZCA9IGZ1bmN0aW9uKGRhdGVUaW1lKXtcbiAgICAgIGlmKGRhdGVUaW1lLnllYXIgPiBMSU1JVF9ZRUFSWzFdKSBkYXRlVGltZS55ZWFyID0gTElNSVRfWUVBUlsxXSwgZXJyb3IgPSB0cnVlOyAvL+S4jeiDvei2hei/hzIw5LiH5bm0XG4gICAgICBpZihkYXRlVGltZS5tb250aCA+IDExKSBkYXRlVGltZS5tb250aCA9IDExLCBlcnJvciA9IHRydWU7XG4gICAgICBpZihkYXRlVGltZS5ob3VycyA+IDIzKSBkYXRlVGltZS5ob3VycyA9IDAsIGVycm9yID0gdHJ1ZTtcbiAgICAgIGlmKGRhdGVUaW1lLm1pbnV0ZXMgPiA1OSkgZGF0ZVRpbWUubWludXRlcyA9IDAsIGRhdGVUaW1lLmhvdXJzKyssIGVycm9yID0gdHJ1ZTtcbiAgICAgIGlmKGRhdGVUaW1lLnNlY29uZHMgPiA1OSkgZGF0ZVRpbWUuc2Vjb25kcyA9IDAsIGRhdGVUaW1lLm1pbnV0ZXMrKywgZXJyb3IgPSB0cnVlO1xuICAgICAgXG4gICAgICAvL+iuoeeul+W9k+WJjeaciOeahOacgOWQjuS4gOWkqVxuICAgICAgdGhpc01heERhdGUgPSBsYXlkYXRlLmdldEVuZERhdGUoZGF0ZVRpbWUubW9udGggKyAxLCBkYXRlVGltZS55ZWFyKTtcbiAgICAgIGlmKGRhdGVUaW1lLmRhdGUgPiB0aGlzTWF4RGF0ZSkgZGF0ZVRpbWUuZGF0ZSA9IHRoaXNNYXhEYXRlLCBlcnJvciA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8v6I635b6X5Yid5aeL5YyW5pel5pyf5YC8XG4gICAgLGluaXREYXRlID0gZnVuY3Rpb24oZGF0ZVRpbWUsIHZhbHVlLCBpbmRleCl7XG4gICAgICB2YXIgc3RhcnRFbmQgPSBbJ3N0YXJ0VGltZScsICdlbmRUaW1lJ107XG4gICAgICB2YWx1ZSA9ICh2YWx1ZS5tYXRjaCh0aGF0LkVYUF9TUExJVCkgfHwgW10pLnNsaWNlKDEpO1xuICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgICAgaWYob3B0aW9ucy5yYW5nZSl7XG4gICAgICAgIHRoYXRbc3RhcnRFbmRbaW5kZXhdXSA9IHRoYXRbc3RhcnRFbmRbaW5kZXhdXSB8fCB7fTtcbiAgICAgIH1cbiAgICAgIGxheS5lYWNoKHRoYXQuZm9ybWF0LCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgICAgdmFyIHRoaXN2ID0gcGFyc2VGbG9hdCh2YWx1ZVtpXSk7XG4gICAgICAgIGlmKHZhbHVlW2ldLmxlbmd0aCA8IGl0ZW0ubGVuZ3RoKSBlcnJvciA9IHRydWU7XG4gICAgICAgIGlmKC95eXl5fHkvLnRlc3QoaXRlbSkpeyAvL+W5tFxuICAgICAgICAgIGlmKHRoaXN2IDwgTElNSVRfWUVBUlswXSkgdGhpc3YgPSBMSU1JVF9ZRUFSWzBdLCBlcnJvciA9IHRydWU7IC8v5bm05LiN6IO95L2O5LqOMTAw5bm0XG4gICAgICAgICAgZGF0ZVRpbWUueWVhciA9IHRoaXN2O1xuICAgICAgICB9IGVsc2UgaWYoL01NfE0vLnRlc3QoaXRlbSkpeyAvL+aciFxuICAgICAgICAgIGlmKHRoaXN2IDwgMSkgdGhpc3YgPSAxLCBlcnJvciA9IHRydWU7XG4gICAgICAgICAgZGF0ZVRpbWUubW9udGggPSB0aGlzdiAtIDE7XG4gICAgICAgIH0gZWxzZSBpZigvZGR8ZC8udGVzdChpdGVtKSl7IC8v5pelXG4gICAgICAgICAgaWYodGhpc3YgPCAxKSB0aGlzdiA9IDEsIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBkYXRlVGltZS5kYXRlID0gdGhpc3Y7XG4gICAgICAgIH0gZWxzZSBpZigvSEh8SC8udGVzdChpdGVtKSl7IC8v5pe2XG4gICAgICAgICAgaWYodGhpc3YgPCAxKSB0aGlzdiA9IDAsIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBkYXRlVGltZS5ob3VycyA9IHRoaXN2O1xuICAgICAgICAgIG9wdGlvbnMucmFuZ2UgJiYgKHRoYXRbc3RhcnRFbmRbaW5kZXhdXS5ob3VycyA9IHRoaXN2KTtcbiAgICAgICAgfSBlbHNlIGlmKC9tbXxtLy50ZXN0KGl0ZW0pKXsgLy/liIZcbiAgICAgICAgICBpZih0aGlzdiA8IDEpIHRoaXN2ID0gMCwgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGRhdGVUaW1lLm1pbnV0ZXMgPSB0aGlzdjtcbiAgICAgICAgICBvcHRpb25zLnJhbmdlICYmICh0aGF0W3N0YXJ0RW5kW2luZGV4XV0ubWludXRlcyA9IHRoaXN2KTtcbiAgICAgICAgfSBlbHNlIGlmKC9zc3xzLy50ZXN0KGl0ZW0pKXsgLy/np5JcbiAgICAgICAgICBpZih0aGlzdiA8IDEpIHRoaXN2ID0gMCwgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGRhdGVUaW1lLnNlY29uZHMgPSB0aGlzdjtcbiAgICAgICAgICBvcHRpb25zLnJhbmdlICYmICh0aGF0W3N0YXJ0RW5kW2luZGV4XV0uc2Vjb25kcyA9IHRoaXN2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjaGVja1ZhbGlkKGRhdGVUaW1lKVxuICAgIH07XG4gICAgXG4gICAgaWYoZm4gPT09ICdsaW1pdCcpIHJldHVybiBjaGVja1ZhbGlkKGRhdGVUaW1lKSwgdGhhdDtcbiAgICBcbiAgICB2YWx1ZSA9IHZhbHVlIHx8IG9wdGlvbnMudmFsdWU7XG4gICAgaWYodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyl7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC9eXFxzfFxccyQvZywgJycpO1xuICAgIH1cbiAgICBcbiAgICAvL+WmguaenOeCueWHu+S6huW8gOWni++8jOWNleacqumAieaLqee7k+adn+WwseWFs+mXre+8jOWImemHjeaWsOmAieaLqeW8gOWni1xuICAgIGlmKHRoYXQuc3RhcnRTdGF0ZSAmJiAhdGhhdC5lbmRTdGF0ZSl7XG4gICAgICBkZWxldGUgdGhhdC5zdGFydFN0YXRlO1xuICAgICAgdGhhdC5lbmRTdGF0ZSA9IHRydWU7XG4gICAgfTtcblxuICAgIGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUpe1xuICAgICAgaWYodGhhdC5FWFBfSUYudGVzdCh2YWx1ZSkpeyAvL+agoemqjOaXpeacn+agvOW8j1xuICAgICAgICBpZihvcHRpb25zLnJhbmdlKXtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJysgb3B0aW9ucy5yYW5nZSArJyAnKTtcbiAgICAgICAgICB0aGF0LnN0YXJ0RGF0ZSA9IHRoYXQuc3RhcnREYXRlIHx8IHRoYXQuc3lzdGVtRGF0ZSgpO1xuICAgICAgICAgIHRoYXQuZW5kRGF0ZSA9IHRoYXQuZW5kRGF0ZSB8fCB0aGF0LnN5c3RlbURhdGUoKTtcbiAgICAgICAgICBvcHRpb25zLmRhdGVUaW1lID0gbGF5LmV4dGVuZCh7fSwgdGhhdC5zdGFydERhdGUpO1xuICAgICAgICAgIGxheS5lYWNoKFt0aGF0LnN0YXJ0RGF0ZSwgdGhhdC5lbmREYXRlXSwgZnVuY3Rpb24oaSwgaXRlbSl7XG4gICAgICAgICAgICBpbml0RGF0ZShpdGVtLCB2YWx1ZVtpXSwgaSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdERhdGUoZGF0ZVRpbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmhpbnQoJ+aXpeacn+agvOW8j+S4jeWQiOazlTxicj7lv4XpobvpgbXlvqrkuIvov7DmoLzlvI/vvJo8YnI+JysgKFxuICAgICAgICAgIG9wdGlvbnMucmFuZ2UgPyAob3B0aW9ucy5mb3JtYXQgKyAnICcrIG9wdGlvbnMucmFuZ2UgKycgJyArIG9wdGlvbnMuZm9ybWF0KSA6IG9wdGlvbnMuZm9ybWF0XG4gICAgICAgICkgKyAnPGJyPuW3suS4uuS9oOmHjee9ricpO1xuICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBEYXRlKXsgLy/lpoLmnpzlgLzkuLrml6XmnJ/lr7nosaHml7ZcbiAgICAgIG9wdGlvbnMuZGF0ZVRpbWUgPSB0aGF0LnN5c3RlbURhdGUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmRhdGVUaW1lID0gdGhhdC5zeXN0ZW1EYXRlKCk7XG4gICAgICBkZWxldGUgdGhhdC5zdGFydFN0YXRlO1xuICAgICAgZGVsZXRlIHRoYXQuZW5kU3RhdGU7XG4gICAgICBkZWxldGUgdGhhdC5zdGFydERhdGU7XG4gICAgICBkZWxldGUgdGhhdC5lbmREYXRlO1xuICAgICAgZGVsZXRlIHRoYXQuc3RhcnRUaW1lO1xuICAgICAgZGVsZXRlIHRoYXQuZW5kVGltZTtcbiAgICB9XG5cbiAgICBjaGVja1ZhbGlkKGRhdGVUaW1lKTtcblxuICAgIGlmKGVycm9yICYmIHZhbHVlKXtcbiAgICAgIHRoYXQuc2V0VmFsdWUoXG4gICAgICAgIG9wdGlvbnMucmFuZ2UgPyAodGhhdC5lbmREYXRlID8gdGhhdC5wYXJzZSgpIDogJycpIDogdGhhdC5wYXJzZSgpXG4gICAgICApO1xuICAgIH1cbiAgICBmbiAmJiBmbigpO1xuICAgIHJldHVybiB0aGF0O1xuICB9O1xuICBcbiAgLy/lhazljobph43opoHml6XmnJ/kuI7oh6rlrprkuYnlpIfms6hcbiAgQ2xhc3MucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbih0ZCwgWU1EKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsbWFyaywgb3B0aW9ucyA9IHRoYXQuY29uZmlnO1xuICAgIGxheS5lYWNoKG9wdGlvbnMubWFyaywgZnVuY3Rpb24oa2V5LCB0aXRsZSl7XG4gICAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLScpO1xuICAgICAgaWYoKGtleXNbMF0gPT0gWU1EWzBdIHx8IGtleXNbMF0gPT0gMCkgLy/mr4/lubTnmoTmr4/mnIhcbiAgICAgICYmIChrZXlzWzFdID09IFlNRFsxXSB8fCBrZXlzWzFdID09IDApIC8v5q+P5pyI55qE5q+P5pelXG4gICAgICAmJiBrZXlzWzJdID09IFlNRFsyXSl7IC8v54m55a6a5pelXG4gICAgICAgIG1hcmsgPSB0aXRsZSB8fCBZTURbMl07XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWFyayAmJiB0ZC5odG1sKCc8c3BhbiBjbGFzcz1cImxheWRhdGUtZGF5LW1hcmtcIj4nKyBtYXJrICsnPC9zcGFuPicpO1xuICAgIFxuICAgIHJldHVybiB0aGF0O1xuICB9O1xuICBcbiAgLy/ml6DmlYjml6XmnJ/ojIPlm7TnmoTmoIforrBcbiAgQ2xhc3MucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24oZWxlbSwgZGF0ZSwgaW5kZXgsIHRpbWUpe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICxvcHRpb25zID0gdGhhdC5jb25maWcsIHRpbWVzdHJhcCA9IHt9XG4gICAgLGRhdGVUaW1lID0gb3B0aW9uc1tpbmRleCA+IDQxID8gJ2VuZERhdGUnIDogJ2RhdGVUaW1lJ11cbiAgICAsaXNPdXQsIHRoaXNEYXRlVGltZSA9IGxheS5leHRlbmQoe30sIGRhdGVUaW1lLCBkYXRlIHx8IHt9KTtcbiAgICBsYXkuZWFjaCh7XG4gICAgICBub3c6IHRoaXNEYXRlVGltZVxuICAgICAgLG1pbjogb3B0aW9ucy5taW5cbiAgICAgICxtYXg6IG9wdGlvbnMubWF4XG4gICAgfSwgZnVuY3Rpb24oa2V5LCBpdGVtKXtcbiAgICAgIHRpbWVzdHJhcFtrZXldID0gdGhhdC5uZXdEYXRlKGxheS5leHRlbmQoe1xuICAgICAgICB5ZWFyOiBpdGVtLnllYXJcbiAgICAgICAgLG1vbnRoOiBpdGVtLm1vbnRoXG4gICAgICAgICxkYXRlOiBpdGVtLmRhdGVcbiAgICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBobXMgPSB7fTtcbiAgICAgICAgbGF5LmVhY2godGltZSwgZnVuY3Rpb24oaSwga2V5cyl7XG4gICAgICAgICAgaG1zW2tleXNdID0gaXRlbVtrZXlzXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBobXM7XG4gICAgICB9KCkpKS5nZXRUaW1lKCk7ICAvL3RpbWXvvJrmmK/lkKbmr5TovoPml7bliIbnp5JcbiAgICB9KTtcbiAgICBcbiAgICBpc091dCA9IHRpbWVzdHJhcC5ub3cgPCB0aW1lc3RyYXAubWluIHx8IHRpbWVzdHJhcC5ub3cgPiB0aW1lc3RyYXAubWF4O1xuICAgIGVsZW0gJiYgZWxlbVtpc091dCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShESVNBQkxFRCk7XG4gICAgcmV0dXJuIGlzT3V0O1xuICB9O1xuICBcbiAgLy/ml6XljobooahcbiAgQ2xhc3MucHJvdG90eXBlLmNhbGVuZGFyID0gZnVuY3Rpb24odmFsdWUpe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICxvcHRpb25zID0gdGhhdC5jb25maWdcbiAgICAsZGF0ZVRpbWUgPSB2YWx1ZSB8fCBvcHRpb25zLmRhdGVUaW1lXG4gICAgLHRoaXNEYXRlID0gbmV3IERhdGUoKSwgc3RhcnRXZWVrLCBwcmV2TWF4RGF0ZSwgdGhpc01heERhdGVcbiAgICAsbGFuZyA9IHRoYXQubGFuZygpXG4gICAgXG4gICAgLGlzQWxvbmUgPSBvcHRpb25zLnR5cGUgIT09ICdkYXRlJyAmJiBvcHRpb25zLnR5cGUgIT09ICdkYXRldGltZSdcbiAgICAsaW5kZXggPSB2YWx1ZSA/IDEgOiAwXG4gICAgLHRkcyA9IGxheSh0aGF0LnRhYmxlW2luZGV4XSkuZmluZCgndGQnKVxuICAgICxlbGVtWU0gPSBsYXkodGhhdC5lbGVtSGVhZGVyW2luZGV4XVsyXSkuZmluZCgnc3BhbicpO1xuICAgIFxuICAgIGlmKGRhdGVUaW1lLnllYXIgPCBMSU1JVF9ZRUFSWzBdKSBkYXRlVGltZS55ZWFyID0gTElNSVRfWUVBUlswXSwgdGhhdC5oaW50KCfmnIDkvY7lj6rog73mlK/mjIHliLDlhazlhYMnKyBMSU1JVF9ZRUFSWzBdICsn5bm0Jyk7XG4gICAgaWYoZGF0ZVRpbWUueWVhciA+IExJTUlUX1lFQVJbMV0pIGRhdGVUaW1lLnllYXIgPSBMSU1JVF9ZRUFSWzFdLCB0aGF0LmhpbnQoJ+acgOmrmOWPquiDveaUr+aMgeWIsOWFrOWFgycrIExJTUlUX1lFQVJbMV0gKyflubQnKTtcbiAgICBcbiAgICAvL+iusOW9leWIneWni+WAvFxuICAgIGlmKCF0aGF0LmZpcnN0RGF0ZSl7XG4gICAgICB0aGF0LmZpcnN0RGF0ZSA9IGxheS5leHRlbmQoe30sIGRhdGVUaW1lKTtcbiAgICB9XG4gICAgXG4gICAgLy/orqHnrpflvZPliY3mnIjnrKzkuIDlpKnnmoTmmJ/mnJ9cbiAgICB0aGlzRGF0ZS5zZXRGdWxsWWVhcihkYXRlVGltZS55ZWFyLCBkYXRlVGltZS5tb250aCwgMSk7XG4gICAgc3RhcnRXZWVrID0gdGhpc0RhdGUuZ2V0RGF5KCk7XG4gICAgXG4gICAgcHJldk1heERhdGUgPSBsYXlkYXRlLmdldEVuZERhdGUoZGF0ZVRpbWUubW9udGggfHwgMTIsIGRhdGVUaW1lLnllYXIpOyAvL+iuoeeul+S4iuS4quaciOeahOacgOWQjuS4gOWkqVxuICAgIHRoaXNNYXhEYXRlID0gbGF5ZGF0ZS5nZXRFbmREYXRlKGRhdGVUaW1lLm1vbnRoICsgMSwgZGF0ZVRpbWUueWVhcik7IC8v6K6h566X5b2T5YmN5pyI55qE5pyA5ZCO5LiA5aSpXG4gICAgXG4gICAgLy/otYvlgLzml6VcbiAgICBsYXkuZWFjaCh0ZHMsIGZ1bmN0aW9uKGluZGV4LCBpdGVtKXtcbiAgICAgIHZhciBZTUQgPSBbZGF0ZVRpbWUueWVhciwgZGF0ZVRpbWUubW9udGhdLCBzdCA9IDA7XG4gICAgICBpdGVtID0gbGF5KGl0ZW0pO1xuICAgICAgaXRlbS5yZW1vdmVBdHRyKCdjbGFzcycpO1xuICAgICAgaWYoaW5kZXggPCBzdGFydFdlZWspe1xuICAgICAgICBzdCA9IHByZXZNYXhEYXRlIC0gc3RhcnRXZWVrICsgaW5kZXg7XG4gICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ2xheWRhdGUtZGF5LXByZXYnKTtcbiAgICAgICAgWU1EID0gdGhhdC5nZXRBc1lNKGRhdGVUaW1lLnllYXIsIGRhdGVUaW1lLm1vbnRoLCAnc3ViJyk7XG4gICAgICB9IGVsc2UgaWYoaW5kZXggPj0gc3RhcnRXZWVrICYmIGluZGV4IDwgdGhpc01heERhdGUgKyBzdGFydFdlZWspe1xuICAgICAgICBzdCA9IGluZGV4IC0gc3RhcnRXZWVrO1xuICAgICAgICBpZighb3B0aW9ucy5yYW5nZSl7XG4gICAgICAgICAgc3QgKyAxID09PSBkYXRlVGltZS5kYXRlICYmIGl0ZW0uYWRkQ2xhc3MoVEhJUyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ID0gaW5kZXggLSB0aGlzTWF4RGF0ZSAtIHN0YXJ0V2VlaztcbiAgICAgICAgaXRlbS5hZGRDbGFzcygnbGF5ZGF0ZS1kYXktbmV4dCcpO1xuICAgICAgICBZTUQgPSB0aGF0LmdldEFzWU0oZGF0ZVRpbWUueWVhciwgZGF0ZVRpbWUubW9udGgpO1xuICAgICAgfVxuICAgICAgWU1EWzFdKys7XG4gICAgICBZTURbMl0gPSBzdCArIDE7XG4gICAgICBpdGVtLmF0dHIoJ2xheS15bWQnLCBZTUQuam9pbignLScpKS5odG1sKFlNRFsyXSk7XG4gICAgICB0aGF0Lm1hcmsoaXRlbSwgWU1EKS5saW1pdChpdGVtLCB7XG4gICAgICAgIHllYXI6IFlNRFswXVxuICAgICAgICAsbW9udGg6IFlNRFsxXSAtIDFcbiAgICAgICAgLGRhdGU6IFlNRFsyXVxuICAgICAgfSwgaW5kZXgpO1xuICAgIH0pOyAgXG4gICAgXG4gICAgLy/lkIzmraXlpLTpg6jlubTmnIhcbiAgICBsYXkoZWxlbVlNWzBdKS5hdHRyKCdsYXkteW0nLCBkYXRlVGltZS55ZWFyICsgJy0nICsgKGRhdGVUaW1lLm1vbnRoICsgMSkpO1xuICAgIGxheShlbGVtWU1bMV0pLmF0dHIoJ2xheS15bScsIGRhdGVUaW1lLnllYXIgKyAnLScgKyAoZGF0ZVRpbWUubW9udGggKyAxKSk7XG4gICAgXG4gICAgaWYob3B0aW9ucy5sYW5nID09PSAnY24nKXtcbiAgICAgIGxheShlbGVtWU1bMF0pLmF0dHIoJ2xheS10eXBlJywgJ3llYXInKS5odG1sKGRhdGVUaW1lLnllYXIgKyAn5bm0JylcbiAgICAgIGxheShlbGVtWU1bMV0pLmF0dHIoJ2xheS10eXBlJywgJ21vbnRoJykuaHRtbCgoZGF0ZVRpbWUubW9udGggKyAxKSArICfmnIgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5KGVsZW1ZTVswXSkuYXR0cignbGF5LXR5cGUnLCAnbW9udGgnKS5odG1sKGxhbmcubW9udGhbZGF0ZVRpbWUubW9udGhdKTtcbiAgICAgIGxheShlbGVtWU1bMV0pLmF0dHIoJ2xheS10eXBlJywgJ3llYXInKS5odG1sKGRhdGVUaW1lLnllYXIpO1xuICAgIH1cblxuICAgIC8v5Yid5aeL6buY6K6k6YCJ5oup5ZmoXG4gICAgaWYoaXNBbG9uZSl7XG4gICAgICBpZihvcHRpb25zLnJhbmdlKXtcbiAgICAgICAgdmFsdWUgPyB0aGF0LmVuZERhdGUgPSAodGhhdC5lbmREYXRlIHx8IHtcbiAgICAgICAgICB5ZWFyOiBkYXRlVGltZS55ZWFyICsgKG9wdGlvbnMudHlwZSA9PT0gJ3llYXInID8gMSA6IDApXG4gICAgICAgICAgLG1vbnRoOiBkYXRlVGltZS5tb250aCArIChvcHRpb25zLnR5cGUgPT09ICdtb250aCcgPyAwIDogLTEpXG4gICAgICAgIH0pIDogKHRoYXQuc3RhcnREYXRlID0gdGhhdC5zdGFydERhdGUgfHwge1xuICAgICAgICAgIHllYXI6IGRhdGVUaW1lLnllYXJcbiAgICAgICAgICAsbW9udGg6IGRhdGVUaW1lLm1vbnRoXG4gICAgICAgIH0pO1xuICAgICAgICBpZih2YWx1ZSl7XG4gICAgICAgICAgdGhhdC5saXN0WU0gPSBbXG4gICAgICAgICAgICBbdGhhdC5zdGFydERhdGUueWVhciwgdGhhdC5zdGFydERhdGUubW9udGggKyAxXVxuICAgICAgICAgICAgLFt0aGF0LmVuZERhdGUueWVhciwgdGhhdC5lbmREYXRlLm1vbnRoICsgMV1cbiAgICAgICAgICBdOyAgXG4gICAgICAgICAgdGhhdC5saXN0KG9wdGlvbnMudHlwZSwgMCkubGlzdChvcHRpb25zLnR5cGUsIDEpO1xuICAgICAgICAgIC8v5ZCM5q2l5oyJ6ZKu5Y+v54K554q25oCBXG4gICAgICAgICAgb3B0aW9ucy50eXBlID09PSAndGltZScgPyB0aGF0LnNldEJ0blN0YXR1cygn5pe26Ze0J1xuICAgICAgICAgICAgLGxheS5leHRlbmQoe30sIHRoYXQuc3lzdGVtRGF0ZSgpLCB0aGF0LnN0YXJ0VGltZSlcbiAgICAgICAgICAgICxsYXkuZXh0ZW5kKHt9LCB0aGF0LnN5c3RlbURhdGUoKSwgdGhhdC5lbmRUaW1lKVxuICAgICAgICAgICkgOiB0aGF0LnNldEJ0blN0YXR1cyh0cnVlKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgICB9XG4gICAgICBpZighb3B0aW9ucy5yYW5nZSl7XG4gICAgICAgIHRoYXQubGlzdFlNID0gW1tkYXRlVGltZS55ZWFyLCBkYXRlVGltZS5tb250aCArIDFdXTtcbiAgICAgICAgdGhhdC5saXN0KG9wdGlvbnMudHlwZSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8v6LWL5YC85Y+M5pel5Y6GXG4gICAgaWYob3B0aW9ucy5yYW5nZSAmJiAhdmFsdWUpe1xuICAgICAgdmFyIEVZTSA9IHRoYXQuZ2V0QXNZTShkYXRlVGltZS55ZWFyLCBkYXRlVGltZS5tb250aClcbiAgICAgIHRoYXQuY2FsZW5kYXIobGF5LmV4dGVuZCh7fSwgZGF0ZVRpbWUsIHtcbiAgICAgICAgeWVhcjogRVlNWzBdXG4gICAgICAgICxtb250aDogRVlNWzFdXG4gICAgICB9KSk7XG4gICAgfVxuICAgIFxuICAgIC8v6YCa6L+H5qOA5rWL5b2T5YmN5pyJ5pWI5pel5pyf77yM5p2l6K6+5a6a56Gu5a6a5oyJ6ZKu5piv5ZCm5Y+v54K5XG4gICAgaWYoIW9wdGlvbnMucmFuZ2UpIHRoYXQubGltaXQobGF5KHRoYXQuZm9vdGVyKS5maW5kKEVMRU1fQ09ORklSTSksIG51bGwsIDAsIFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ10pO1xuICAgIFxuICAgIC8v5qCH6K6w6YCJ5oup6IyD5Zu0XG4gICAgaWYob3B0aW9ucy5yYW5nZSAmJiB2YWx1ZSAmJiAhaXNBbG9uZSkgdGhhdC5zdGFtcFJhbmdlKCk7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH07XG5cbiAgLy/nlJ/miJDlubTmnIjml7bliIbnp5LliJfooahcbiAgQ2xhc3MucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbih0eXBlLCBpbmRleCl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxkYXRlVGltZSA9IG9wdGlvbnMuZGF0ZVRpbWVcbiAgICAsbGFuZyA9IHRoYXQubGFuZygpXG4gICAgLGlzQWxvbmUgPSBvcHRpb25zLnJhbmdlICYmIG9wdGlvbnMudHlwZSAhPT0gJ2RhdGUnICYmIG9wdGlvbnMudHlwZSAhPT0gJ2RhdGV0aW1lJyAvL+eLrOeri+iMg+WbtOmAieaLqeWZqFxuICAgIFxuICAgICx1bCA9IGxheS5lbGVtKCd1bCcsIHtcbiAgICAgICdjbGFzcyc6IEVMRU1fTElTVCArICcgJyArICh7XG4gICAgICAgIHllYXI6ICdsYXlkYXRlLXllYXItbGlzdCdcbiAgICAgICAgLG1vbnRoOiAnbGF5ZGF0ZS1tb250aC1saXN0J1xuICAgICAgICAsdGltZTogJ2xheWRhdGUtdGltZS1saXN0J1xuICAgICAgfSlbdHlwZV1cbiAgICB9KVxuICAgICxlbGVtSGVhZGVyID0gdGhhdC5lbGVtSGVhZGVyW2luZGV4XVxuICAgICxlbGVtWU0gPSBsYXkoZWxlbUhlYWRlclsyXSkuZmluZCgnc3BhbicpXG4gICAgLGVsZW1Db250ID0gdGhhdC5lbGVtQ29udFtpbmRleCB8fCAwXVxuICAgICxoYXZlTGlzdCA9IGxheShlbGVtQ29udCkuZmluZCgnLicrIEVMRU1fTElTVClbMF1cbiAgICAsaXNDTiA9IG9wdGlvbnMubGFuZyA9PT0gJ2NuJ1xuICAgICx0ZXh0ID0gaXNDTiA/ICflubQnIDogJydcbiAgIFxuICAgICxsaXN0WU0gPSB0aGF0Lmxpc3RZTVtpbmRleF0gfHwge31cbiAgICAsaG1zID0gWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXVxuICAgICxzdGFydEVuZCA9IFsnc3RhcnRUaW1lJywgJ2VuZFRpbWUnXVtpbmRleF07XG5cbiAgICBpZihsaXN0WU1bMF0gPCAxKSBsaXN0WU1bMF0gPSAxO1xuICAgIFxuICAgIGlmKHR5cGUgPT09ICd5ZWFyJyl7IC8v5bm05YiX6KGoXG4gICAgICB2YXIgeWVhck51bSwgc3RhcnRZID0geWVhck51bSA9IGxpc3RZTVswXSAtIDc7XG4gICAgICBpZihzdGFydFkgPCAxKSBzdGFydFkgPSB5ZWFyTnVtID0gMTtcbiAgICAgIGxheS5lYWNoKG5ldyBBcnJheSgxNSksIGZ1bmN0aW9uKGkpe1xuICAgICAgICB2YXIgbGkgPSBsYXkuZWxlbSgnbGknLCB7XG4gICAgICAgICAgJ2xheS15bSc6IHllYXJOdW1cbiAgICAgICAgfSksIHltZCA9IHt5ZWFyOiB5ZWFyTnVtfTtcbiAgICAgICAgeWVhck51bSA9PSBsaXN0WU1bMF0gJiYgbGF5KGxpKS5hZGRDbGFzcyhUSElTKTtcbiAgICAgICAgbGkuaW5uZXJIVE1MID0geWVhck51bSArIHRleHQ7XG4gICAgICAgIHVsLmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgaWYoeWVhck51bSA8IHRoYXQuZmlyc3REYXRlLnllYXIpe1xuICAgICAgICAgIHltZC5tb250aCA9IG9wdGlvbnMubWluLm1vbnRoO1xuICAgICAgICAgIHltZC5kYXRlID0gb3B0aW9ucy5taW4uZGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmKHllYXJOdW0gPj0gdGhhdC5maXJzdERhdGUueWVhcil7XG4gICAgICAgICAgeW1kLm1vbnRoID0gb3B0aW9ucy5tYXgubW9udGg7XG4gICAgICAgICAgeW1kLmRhdGUgPSBvcHRpb25zLm1heC5kYXRlO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQubGltaXQobGF5KGxpKSwgeW1kLCBpbmRleCk7XG4gICAgICAgIHllYXJOdW0rKztcbiAgICAgIH0pO1xuICAgICAgbGF5KGVsZW1ZTVtpc0NOID8gMCA6IDFdKS5hdHRyKCdsYXkteW0nLCAoeWVhck51bSAtIDgpICsgJy0nICsgbGlzdFlNWzFdKVxuICAgICAgLmh0bWwoKHN0YXJ0WSArIHRleHQpICsgJyAtICcgKyAoeWVhck51bSAtIDEgKyB0ZXh0KSk7XG4gICAgfSBlbHNlIGlmKHR5cGUgPT09ICdtb250aCcpeyAvL+aciOWIl+ihqFxuICAgICAgbGF5LmVhY2gobmV3IEFycmF5KDEyKSwgZnVuY3Rpb24oaSl7XG4gICAgICAgIHZhciBsaSA9IGxheS5lbGVtKCdsaScsIHtcbiAgICAgICAgICAnbGF5LXltJzogaVxuICAgICAgICB9KSwgeW1kID0ge3llYXI6IGxpc3RZTVswXSwgbW9udGg6IGl9O1xuICAgICAgICBpICsgMSA9PSBsaXN0WU1bMV0gJiYgbGF5KGxpKS5hZGRDbGFzcyhUSElTKTtcbiAgICAgICAgbGkuaW5uZXJIVE1MID0gbGFuZy5tb250aFtpXSArIChpc0NOID8gJ+aciCcgOiAnJyk7XG4gICAgICAgIHVsLmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgaWYobGlzdFlNWzBdIDwgdGhhdC5maXJzdERhdGUueWVhcil7XG4gICAgICAgICAgeW1kLmRhdGUgPSBvcHRpb25zLm1pbi5kYXRlO1xuICAgICAgICB9IGVsc2UgaWYobGlzdFlNWzBdID49IHRoYXQuZmlyc3REYXRlLnllYXIpe1xuICAgICAgICAgIHltZC5kYXRlID0gb3B0aW9ucy5tYXguZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0LmxpbWl0KGxheShsaSksIHltZCwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBsYXkoZWxlbVlNW2lzQ04gPyAwIDogMV0pLmF0dHIoJ2xheS15bScsIGxpc3RZTVswXSArICctJyArIGxpc3RZTVsxXSlcbiAgICAgIC5odG1sKGxpc3RZTVswXSArIHRleHQpO1xuICAgIH0gZWxzZSBpZih0eXBlID09PSAndGltZScpeyAvL+aXtumXtOWIl+ihqFxuICAgICAgLy/mo4DmtYvml7bliIbnp5LnirbmgIHmmK/lkKblnKjmnInmlYjml6XmnJ/ml7bpl7TojIPlm7TlhoVcbiAgICAgIHZhciBzZXRUaW1lU3RhdHVzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgbGF5KHVsKS5maW5kKCdvbCcpLmVhY2goZnVuY3Rpb24oaSwgb2wpe1xuICAgICAgICAgIGxheShvbCkuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uKGlpLCBsaSl7XG4gICAgICAgICAgICB0aGF0LmxpbWl0KGxheShsaSksIFt7XG4gICAgICAgICAgICAgIGhvdXJzOiBpaVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBob3VyczogdGhhdFtzdGFydEVuZF0uaG91cnNcbiAgICAgICAgICAgICAgLG1pbnV0ZXM6IGlpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGhvdXJzOiB0aGF0W3N0YXJ0RW5kXS5ob3Vyc1xuICAgICAgICAgICAgICAsbWludXRlczogdGhhdFtzdGFydEVuZF0ubWludXRlc1xuICAgICAgICAgICAgICAsc2Vjb25kczogaWlcbiAgICAgICAgICAgIH1dW2ldLCBpbmRleCwgW1snaG91cnMnXSwgWydob3VycycsICdtaW51dGVzJ10sIFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ11dW2ldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKCFvcHRpb25zLnJhbmdlKSB0aGF0LmxpbWl0KGxheSh0aGF0LmZvb3RlcikuZmluZChFTEVNX0NPTkZJUk0pLCB0aGF0W3N0YXJ0RW5kXSwgMCwgWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSk7XG4gICAgICB9O1xuICAgICAgaWYob3B0aW9ucy5yYW5nZSl7XG4gICAgICAgIGlmKCF0aGF0W3N0YXJ0RW5kXSkgdGhhdFtzdGFydEVuZF0gPSB7XG4gICAgICAgICAgaG91cnM6IDBcbiAgICAgICAgICAsbWludXRlczogMFxuICAgICAgICAgICxzZWNvbmRzOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0W3N0YXJ0RW5kXSA9IGRhdGVUaW1lO1xuICAgICAgfVxuICAgICAgbGF5LmVhY2goWzI0LCA2MCwgNjBdLCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgICAgdmFyIGxpID0gbGF5LmVsZW0oJ2xpJyksIGNoaWxkVUwgPSBbJzxwPicrIGxhbmcudGltZVtpXSArJzwvcD48b2w+J107XG4gICAgICAgIGxheS5lYWNoKG5ldyBBcnJheShpdGVtKSwgZnVuY3Rpb24oaWkpe1xuICAgICAgICAgIGNoaWxkVUwucHVzaCgnPGxpJysgKHRoYXRbc3RhcnRFbmRdW2htc1tpXV0gPT09IGlpID8gJyBjbGFzcz1cIicrIFRISVMgKydcIicgOiAnJykgKyc+JysgbGF5LmRpZ2l0KGlpLCAyKSArJzwvbGk+Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaS5pbm5lckhUTUwgPSBjaGlsZFVMLmpvaW4oJycpICsgJzwvb2w+JztcbiAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lU3RhdHVzKCk7XG4gICAgfVxuICAgIFxuICAgIC8v5o+S5YWl5a655ZmoXG4gICAgaWYoaGF2ZUxpc3QpIGVsZW1Db250LnJlbW92ZUNoaWxkKGhhdmVMaXN0KTtcbiAgICBlbGVtQ29udC5hcHBlbmRDaGlsZCh1bCk7XG4gICAgXG4gICAgLy/lubTmnIhcbiAgICBpZih0eXBlID09PSAneWVhcicgfHwgdHlwZSA9PT0gJ21vbnRoJyl7ICAgICAgXG4gICAgICAvL+aYvuekuuWIh+aNoueureWktFxuICAgICAgbGF5KHRoYXQuZWxlbU1haW5baW5kZXhdKS5hZGRDbGFzcygnbGF5ZGF0ZS15bS1zaG93Jyk7XG4gICAgICBcbiAgICAgIC8v6YCJ5LitXG4gICAgICBsYXkodWwpLmZpbmQoJ2xpJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHltID0gbGF5KHRoaXMpLmF0dHIoJ2xheS15bScpIHwgMDtcbiAgICAgICAgaWYobGF5KHRoaXMpLmhhc0NsYXNzKERJU0FCTEVEKSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgaWYoaW5kZXggPT09IDApe1xuICAgICAgICAgIGRhdGVUaW1lW3R5cGVdID0geW07XG4gICAgICAgICAgaWYoaXNBbG9uZSkgdGhhdC5zdGFydERhdGVbdHlwZV0gPSB5bTtcbiAgICAgICAgICB0aGF0LmxpbWl0KGxheSh0aGF0LmZvb3RlcikuZmluZChFTEVNX0NPTkZJUk0pLCBudWxsLCAwKTtcbiAgICAgICAgfSBlbHNlIHsgLy/ojIPlm7TpgInmi6lcbiAgICAgICAgICBpZihpc0Fsb25lKXsgLy/pnZ5kYXRlL2RhdGV0aW1l57G75Z6LXG4gICAgICAgICAgICB0aGF0LmVuZERhdGVbdHlwZV0gPSB5bTtcbiAgICAgICAgICB9IGVsc2UgeyAvL2RhdGUvZGF0ZXRpbWXnsbvlnotcbiAgICAgICAgICAgIHZhciBZTSA9IHR5cGUgPT09ICd5ZWFyJyBcbiAgICAgICAgICAgICAgPyB0aGF0LmdldEFzWU0oeW0sIGxpc3RZTVsxXSAtIDEsICdzdWInKSBcbiAgICAgICAgICAgIDogdGhhdC5nZXRBc1lNKGxpc3RZTVswXSwgeW0sICdzdWInKTtcbiAgICAgICAgICAgIGxheS5leHRlbmQoZGF0ZVRpbWUsIHtcbiAgICAgICAgICAgICAgeWVhcjogWU1bMF1cbiAgICAgICAgICAgICAgLG1vbnRoOiBZTVsxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihvcHRpb25zLnR5cGUgPT09ICd5ZWFyJyB8fCBvcHRpb25zLnR5cGUgPT09ICdtb250aCcpe1xuICAgICAgICAgIGxheSh1bCkuZmluZCgnLicrIFRISVMpLnJlbW92ZUNsYXNzKFRISVMpO1xuICAgICAgICAgIGxheSh0aGlzKS5hZGRDbGFzcyhUSElTKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL+WmguaenOS4uuW5tOaciOmAieaLqeWZqO+8jOeCueWHu+S6huW5tOWIl+ihqO+8jOWImeWIh+aNouWIsOaciOmAieaLqeWZqFxuICAgICAgICAgIGlmKG9wdGlvbnMudHlwZSA9PT0gJ21vbnRoJyAmJiB0eXBlID09PSAneWVhcicpe1xuICAgICAgICAgICAgdGhhdC5saXN0WU1baW5kZXhdWzBdID0geW07XG4gICAgICAgICAgICBpc0Fsb25lICYmICh0aGF0W1snc3RhcnREYXRlJywgJ2VuZERhdGUnXVtpbmRleF1dLnllYXIgPSB5bSk7XG4gICAgICAgICAgICB0aGF0Lmxpc3QoJ21vbnRoJywgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmNoZWNrRGF0ZSgnbGltaXQnKS5jYWxlbmRhcigpO1xuICAgICAgICAgIHRoYXQuY2xvc2VMaXN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LnNldEJ0blN0YXR1cygpOyAvL+WQjOatpeaMiemSruWPr+eCueeKtuaAgVxuICAgICAgICBvcHRpb25zLnJhbmdlIHx8IHRoYXQuZG9uZShudWxsLCAnY2hhbmdlJyk7XG4gICAgICAgIGxheSh0aGF0LmZvb3RlcikuZmluZChFTEVNX1RJTUVfQlROKS5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNwYW4gPSBsYXkuZWxlbSgnc3BhbicsIHtcbiAgICAgICAgJ2NsYXNzJzogRUxFTV9USU1FX1RFWFRcbiAgICAgIH0pLCBzY3JvbGwgPSBmdW5jdGlvbigpeyAvL+a7muWKqOadoeWumuS9jVxuICAgICAgICBsYXkodWwpLmZpbmQoJ29sJykuZWFjaChmdW5jdGlvbihpKXtcbiAgICAgICAgICB2YXIgb2wgPSB0aGlzXG4gICAgICAgICAgLGxpID0gbGF5KG9sKS5maW5kKCdsaScpXG4gICAgICAgICAgb2wuc2Nyb2xsVG9wID0gMzAqKHRoYXRbc3RhcnRFbmRdW2htc1tpXV0gLSAyKTtcbiAgICAgICAgICBpZihvbC5zY3JvbGxUb3AgPD0gMCl7XG4gICAgICAgICAgICBsaS5lYWNoKGZ1bmN0aW9uKGlpLCBpdGVtKXtcbiAgICAgICAgICAgICAgaWYoIWxheSh0aGlzKS5oYXNDbGFzcyhESVNBQkxFRCkpe1xuICAgICAgICAgICAgICAgIG9sLnNjcm9sbFRvcCA9IDMwKihpaSAtIDIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgaGF2ZVNwYW4gPSBsYXkoZWxlbUhlYWRlclsyXSkuZmluZCgnLicrIEVMRU1fVElNRV9URVhUKTtcbiAgICAgIHNjcm9sbCgpXG4gICAgICBzcGFuLmlubmVySFRNTCA9IG9wdGlvbnMucmFuZ2UgPyBbbGFuZy5zdGFydFRpbWUsbGFuZy5lbmRUaW1lXVtpbmRleF0gOiBsYW5nLnRpbWVUaXBzXG4gICAgICBsYXkodGhhdC5lbGVtTWFpbltpbmRleF0pLmFkZENsYXNzKCdsYXlkYXRlLXRpbWUtc2hvdycpO1xuICAgICAgaWYoaGF2ZVNwYW5bMF0pIGhhdmVTcGFuLnJlbW92ZSgpO1xuICAgICAgZWxlbUhlYWRlclsyXS5hcHBlbmRDaGlsZChzcGFuKTtcblxuICAgICAgbGF5KHVsKS5maW5kKCdvbCcpLmVhY2goZnVuY3Rpb24oaSl7XG4gICAgICAgIHZhciBvbCA9IHRoaXM7XG4gICAgICAgIC8v6YCJ5oup5pe25YiG56eSXG4gICAgICAgIGxheShvbCkuZmluZCgnbGknKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5uZXJIVE1MIHwgMDtcbiAgICAgICAgICBpZihsYXkodGhpcykuaGFzQ2xhc3MoRElTQUJMRUQpKSByZXR1cm47XG4gICAgICAgICAgaWYob3B0aW9ucy5yYW5nZSl7XG4gICAgICAgICAgICB0aGF0W3N0YXJ0RW5kXVtobXNbaV1dICA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlVGltZVtobXNbaV1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxheShvbCkuZmluZCgnLicrIFRISVMpLnJlbW92ZUNsYXNzKFRISVMpO1xuICAgICAgICAgIGxheSh0aGlzKS5hZGRDbGFzcyhUSElTKTtcblxuICAgICAgICAgIHNldFRpbWVTdGF0dXMoKTtcbiAgICAgICAgICBzY3JvbGwoKTtcbiAgICAgICAgICAodGhhdC5lbmREYXRlIHx8IG9wdGlvbnMudHlwZSA9PT0gJ3RpbWUnKSAmJiB0aGF0LmRvbmUobnVsbCwgJ2NoYW5nZScpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8v5ZCM5q2l5oyJ6ZKu5Y+v54K554q25oCBXG4gICAgICAgICAgdGhhdC5zZXRCdG5TdGF0dXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRoYXQ7XG4gIH07XG4gIFxuICAvL+iusOW9leWIl+ihqOWIh+aNouWQjueahOW5tOaciFxuICBDbGFzcy5wcm90b3R5cGUubGlzdFlNID0gW107XG4gIFxuICAvL+WFs+mXreWIl+ihqFxuICBDbGFzcy5wcm90b3R5cGUuY2xvc2VMaXN0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsb3B0aW9ucyA9IHRoYXQuY29uZmlnO1xuICAgIFxuICAgIGxheS5lYWNoKHRoYXQuZWxlbUNvbnQsIGZ1bmN0aW9uKGluZGV4LCBpdGVtKXtcbiAgICAgIGxheSh0aGlzKS5maW5kKCcuJysgRUxFTV9MSVNUKS5yZW1vdmUoKTtcbiAgICAgIGxheSh0aGF0LmVsZW1NYWluW2luZGV4XSkucmVtb3ZlQ2xhc3MoJ2xheWRhdGUteW0tc2hvdyBsYXlkYXRlLXRpbWUtc2hvdycpO1xuICAgIH0pO1xuICAgIGxheSh0aGF0LmVsZW0pLmZpbmQoJy4nKyBFTEVNX1RJTUVfVEVYVCkucmVtb3ZlKCk7XG4gIH07XG4gIFxuICAvL+ajgOa1i+e7k+adn+aXpeacn+aYr+WQpui2heWHuuW8gOWni+aXpeacn1xuICBDbGFzcy5wcm90b3R5cGUuc2V0QnRuU3RhdHVzID0gZnVuY3Rpb24odGlwcywgc3RhcnQsIGVuZCl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxpc091dCwgZWxlbUJ0biA9IGxheSh0aGF0LmZvb3RlcikuZmluZChFTEVNX0NPTkZJUk0pXG4gICAgLGlzQWxvbmUgPSBvcHRpb25zLnJhbmdlICYmIG9wdGlvbnMudHlwZSAhPT0gJ2RhdGUnICYmIG9wdGlvbnMudHlwZSAhPT0gJ3RpbWUnO1xuICAgIGlmKGlzQWxvbmUpe1xuICAgICAgc3RhcnQgPSBzdGFydCB8fCB0aGF0LnN0YXJ0RGF0ZTtcbiAgICAgIGVuZCA9IGVuZCB8fCB0aGF0LmVuZERhdGU7XG4gICAgICBpc091dCA9IHRoYXQubmV3RGF0ZShzdGFydCkuZ2V0VGltZSgpID4gdGhhdC5uZXdEYXRlKGVuZCkuZ2V0VGltZSgpO1xuICAgICAgXG4gICAgICAvL+WmguaenOS4jeWcqOacieaViOaXpeacn+WGhe+8jOebtOaOpeemgeeUqOaMiemSru+8jOWQpuWImeavlOi+g+W8gOWni+WSjOe7k+adn+aXpeacn1xuICAgICAgKHRoYXQubGltaXQobnVsbCwgc3RhcnQpIHx8IHRoYXQubGltaXQobnVsbCwgZW5kKSkgXG4gICAgICAgID8gZWxlbUJ0bi5hZGRDbGFzcyhESVNBQkxFRClcbiAgICAgIDogZWxlbUJ0bltpc091dCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShESVNBQkxFRCk7XG4gICAgICBcbiAgICAgIC8v5piv5ZCm5byC5bi45o+Q56S6XG4gICAgICBpZih0aXBzICYmIGlzT3V0KSB0aGF0LmhpbnQoXG4gICAgICAgIHR5cGVvZiB0aXBzID09PSAnc3RyaW5nJyA/IFRJUFNfT1VULnJlcGxhY2UoL+aXpeacny9nLCB0aXBzKSA6IFRJUFNfT1VUXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8v6L2s5LmJ5Li66KeE5a6a5qC85byP55qE5pel5pyf5a2X56ymXG4gIENsYXNzLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHN0YXRlLCBkYXRlKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsb3B0aW9ucyA9IHRoYXQuY29uZmlnXG4gICAgLGRhdGVUaW1lID0gZGF0ZSB8fCAoc3RhdGUgXG4gICAgICA/IGxheS5leHRlbmQoe30sIHRoYXQuZW5kRGF0ZSwgdGhhdC5lbmRUaW1lKVxuICAgIDogKG9wdGlvbnMucmFuZ2UgPyBsYXkuZXh0ZW5kKHt9LCB0aGF0LnN0YXJ0RGF0ZSwgdGhhdC5zdGFydFRpbWUpIDogb3B0aW9ucy5kYXRlVGltZSkpXG4gICAgLGZvcm1hdCA9IHRoYXQuZm9ybWF0LmNvbmNhdCgpO1xuXG4gICAgLy/ovazkuYnkuLrop4TlrprmoLzlvI9cbiAgICBsYXkuZWFjaChmb3JtYXQsIGZ1bmN0aW9uKGksIGl0ZW0pe1xuICAgICAgaWYoL3l5eXl8eS8udGVzdChpdGVtKSl7IC8v5bm0XG4gICAgICAgIGZvcm1hdFtpXSA9IGxheS5kaWdpdChkYXRlVGltZS55ZWFyLCBpdGVtLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYoL01NfE0vLnRlc3QoaXRlbSkpeyAvL+aciFxuICAgICAgICBmb3JtYXRbaV0gPSBsYXkuZGlnaXQoZGF0ZVRpbWUubW9udGggKyAxLCBpdGVtLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYoL2RkfGQvLnRlc3QoaXRlbSkpeyAvL+aXpVxuICAgICAgICBmb3JtYXRbaV0gPSBsYXkuZGlnaXQoZGF0ZVRpbWUuZGF0ZSwgaXRlbS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmKC9ISHxILy50ZXN0KGl0ZW0pKXsgLy/ml7ZcbiAgICAgICAgZm9ybWF0W2ldID0gbGF5LmRpZ2l0KGRhdGVUaW1lLmhvdXJzLCBpdGVtLmxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYoL21tfG0vLnRlc3QoaXRlbSkpeyAvL+WIhlxuICAgICAgICBmb3JtYXRbaV0gPSBsYXkuZGlnaXQoZGF0ZVRpbWUubWludXRlcywgaXRlbS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmKC9zc3xzLy50ZXN0KGl0ZW0pKXsgLy/np5JcbiAgICAgICAgZm9ybWF0W2ldID0gbGF5LmRpZ2l0KGRhdGVUaW1lLnNlY29uZHMsIGl0ZW0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvL+i/lOWbnuaXpeacn+iMg+WbtOWtl+esplxuICAgIGlmKG9wdGlvbnMucmFuZ2UgJiYgIXN0YXRlKXtcbiAgICAgIHJldHVybiBmb3JtYXQuam9pbignJykgKyAnICcrIG9wdGlvbnMucmFuZ2UgKycgJyArIHRoYXQucGFyc2UoMSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmb3JtYXQuam9pbignJyk7XG4gIH07XG4gIFxuICAvL+WIm+W7uuaMh+WumuaXpeacn+aXtumXtOWvueixoVxuICBDbGFzcy5wcm90b3R5cGUubmV3RGF0ZSA9IGZ1bmN0aW9uKGRhdGVUaW1lKXtcbiAgICBkYXRlVGltZSA9IGRhdGVUaW1lIHx8IHt9O1xuICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgIGRhdGVUaW1lLnllYXIgfHwgMVxuICAgICAgLGRhdGVUaW1lLm1vbnRoIHx8IDBcbiAgICAgICxkYXRlVGltZS5kYXRlIHx8IDFcbiAgICAgICxkYXRlVGltZS5ob3VycyB8fCAwXG4gICAgICAsZGF0ZVRpbWUubWludXRlcyB8fCAwXG4gICAgICAsZGF0ZVRpbWUuc2Vjb25kcyB8fCAwXG4gICAgKTtcbiAgfTtcbiAgXG4gIC8v6LWL5YC8XG4gIENsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsb3B0aW9ucyA9IHRoYXQuY29uZmlnXG4gICAgLGVsZW0gPSB0aGF0LmJpbmRFbGVtIHx8IG9wdGlvbnMuZWxlbVswXVxuICAgICx2YWxUeXBlID0gdGhhdC5pc0lucHV0KGVsZW0pID8gJ3ZhbCcgOiAnaHRtbCdcbiAgICBcbiAgICBvcHRpb25zLnBvc2l0aW9uID09PSAnc3RhdGljJyB8fCBsYXkoZWxlbSlbdmFsVHlwZV0odmFsdWUgfHwgJycpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBcbiAgLy/moIforrDojIPlm7TlhoXnmoTml6XmnJ9cbiAgQ2xhc3MucHJvdG90eXBlLnN0YW1wUmFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICxvcHRpb25zID0gdGhhdC5jb25maWdcbiAgICAsc3RhcnRUaW1lLCBlbmRUaW1lXG4gICAgLHRkcyA9IGxheSh0aGF0LmVsZW0pLmZpbmQoJ3RkJyk7XG4gICAgXG4gICAgaWYob3B0aW9ucy5yYW5nZSAmJiAhdGhhdC5lbmREYXRlKSBsYXkodGhhdC5mb290ZXIpLmZpbmQoRUxFTV9DT05GSVJNKS5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgaWYoIXRoYXQuZW5kRGF0ZSkgcmV0dXJuO1xuXG4gICAgc3RhcnRUaW1lID0gdGhhdC5uZXdEYXRlKHtcbiAgICAgIHllYXI6IHRoYXQuc3RhcnREYXRlLnllYXJcbiAgICAgICxtb250aDogdGhhdC5zdGFydERhdGUubW9udGhcbiAgICAgICxkYXRlOiB0aGF0LnN0YXJ0RGF0ZS5kYXRlXG4gICAgfSkuZ2V0VGltZSgpO1xuICAgIFxuICAgIGVuZFRpbWUgPSB0aGF0Lm5ld0RhdGUoe1xuICAgICAgeWVhcjogdGhhdC5lbmREYXRlLnllYXJcbiAgICAgICxtb250aDogdGhhdC5lbmREYXRlLm1vbnRoXG4gICAgICAsZGF0ZTogdGhhdC5lbmREYXRlLmRhdGVcbiAgICB9KS5nZXRUaW1lKCk7XG4gICAgXG4gICAgaWYoc3RhcnRUaW1lID4gZW5kVGltZSkgcmV0dXJuIHRoYXQuaGludChUSVBTX09VVCk7XG4gICAgXG4gICAgbGF5LmVhY2godGRzLCBmdW5jdGlvbihpLCBpdGVtKXtcbiAgICAgIHZhciB5bWQgPSBsYXkoaXRlbSkuYXR0cignbGF5LXltZCcpLnNwbGl0KCctJylcbiAgICAgICx0aGlzVGltZSA9IHRoYXQubmV3RGF0ZSh7XG4gICAgICAgIHllYXI6IHltZFswXVxuICAgICAgICAsbW9udGg6IHltZFsxXSAtIDFcbiAgICAgICAgLGRhdGU6IHltZFsyXVxuICAgICAgfSkuZ2V0VGltZSgpO1xuICAgICAgbGF5KGl0ZW0pLnJlbW92ZUNsYXNzKEVMRU1fU0VMRUNURUQgKyAnICcgKyBUSElTKTtcbiAgICAgIGlmKHRoaXNUaW1lID09PSBzdGFydFRpbWUgfHwgdGhpc1RpbWUgPT09IGVuZFRpbWUpe1xuICAgICAgICBsYXkoaXRlbSkuYWRkQ2xhc3MoXG4gICAgICAgICAgbGF5KGl0ZW0pLmhhc0NsYXNzKEVMRU1fUFJFVikgfHwgbGF5KGl0ZW0pLmhhc0NsYXNzKEVMRU1fTkVYVClcbiAgICAgICAgICAgID8gRUxFTV9TRUxFQ1RFRFxuICAgICAgICAgIDogVEhJU1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYodGhpc1RpbWUgPiBzdGFydFRpbWUgJiYgdGhpc1RpbWUgPCBlbmRUaW1lKXtcbiAgICAgICAgbGF5KGl0ZW0pLmFkZENsYXNzKEVMRU1fU0VMRUNURUQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBcbiAgLy/miafooYxkb25lL2NoYW5nZeWbnuiwg1xuICBDbGFzcy5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uKHBhcmFtLCB0eXBlKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsb3B0aW9ucyA9IHRoYXQuY29uZmlnXG4gICAgLHN0YXJ0ID0gbGF5LmV4dGVuZCh7fSwgdGhhdC5zdGFydERhdGUgPyBsYXkuZXh0ZW5kKHRoYXQuc3RhcnREYXRlLCB0aGF0LnN0YXJ0VGltZSkgOiBvcHRpb25zLmRhdGVUaW1lKVxuICAgICxlbmQgPSBsYXkuZXh0ZW5kKHt9LCBsYXkuZXh0ZW5kKHRoYXQuZW5kRGF0ZSwgdGhhdC5lbmRUaW1lKSlcbiAgICBcbiAgICBsYXkuZWFjaChbc3RhcnQsIGVuZF0sIGZ1bmN0aW9uKGksIGl0ZW0pe1xuICAgICAgaWYoISgnbW9udGgnIGluIGl0ZW0pKSByZXR1cm47XG4gICAgICBsYXkuZXh0ZW5kKGl0ZW0sIHtcbiAgICAgICAgbW9udGg6IGl0ZW0ubW9udGggKyAxXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBwYXJhbSA9IHBhcmFtIHx8IFt0aGF0LnBhcnNlKCksIHN0YXJ0LCBlbmRdO1xuICAgIHR5cGVvZiBvcHRpb25zW3R5cGUgfHwgJ2RvbmUnXSA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zW3R5cGUgfHwgJ2RvbmUnXS5hcHBseShvcHRpb25zLCBwYXJhbSk7XG4gICAgXG4gICAgcmV0dXJuIHRoYXQ7XG4gIH07XG4gIFxuICAvL+mAieaLqeaXpeacn1xuICBDbGFzcy5wcm90b3R5cGUuY2hvb3NlID0gZnVuY3Rpb24odGQpe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICxvcHRpb25zID0gdGhhdC5jb25maWdcbiAgICAsZGF0ZVRpbWUgPSBvcHRpb25zLmRhdGVUaW1lXG5cbiAgICAsdGRzID0gbGF5KHRoYXQuZWxlbSkuZmluZCgndGQnKVxuICAgICxZTUQgPSB0ZC5hdHRyKCdsYXkteW1kJykuc3BsaXQoJy0nKVxuICAgIFxuICAgICxzZXREYXRlVGltZSA9IGZ1bmN0aW9uKG9uZSl7XG4gICAgICB2YXIgdGhpc0RhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgXG4gICAgICAvL+WQjOatpWRhdGVUaW1lXG4gICAgICBvbmUgJiYgbGF5LmV4dGVuZChkYXRlVGltZSwgWU1EKTtcbiAgICAgIFxuICAgICAgLy/orrDlvZXlvIDlp4vml6XmnJ9cbiAgICAgIGlmKG9wdGlvbnMucmFuZ2Upe1xuICAgICAgICB0aGF0LnN0YXJ0RGF0ZSA/IGxheS5leHRlbmQodGhhdC5zdGFydERhdGUsIFlNRCkgOiAoXG4gICAgICAgICAgdGhhdC5zdGFydERhdGUgPSBsYXkuZXh0ZW5kKHt9LCBZTUQsIHRoYXQuc3RhcnRUaW1lKVxuICAgICAgICApO1xuICAgICAgICB0aGF0LnN0YXJ0WU1EID0gWU1EO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgWU1EID0ge1xuICAgICAgeWVhcjogWU1EWzBdIHwgMFxuICAgICAgLG1vbnRoOiAoWU1EWzFdIHwgMCkgLSAxXG4gICAgICAsZGF0ZTogWU1EWzJdIHwgMFxuICAgIH07XG4gICAgXG4gICAgaWYodGQuaGFzQ2xhc3MoRElTQUJMRUQpKSByZXR1cm47XG5cbiAgICAvL+iMg+WbtOmAieaLqVxuICAgIGlmKG9wdGlvbnMucmFuZ2Upe1xuICAgICAgXG4gICAgICBsYXkuZWFjaChbJ3N0YXJ0VGltZScsICdlbmRUaW1lJ10sIGZ1bmN0aW9uKGksIGl0ZW0pe1xuICAgICAgICB0aGF0W2l0ZW1dID0gdGhhdFtpdGVtXSB8fCB7XG4gICAgICAgICAgaG91cnM6IDBcbiAgICAgICAgICAsbWludXRlczogMFxuICAgICAgICAgICxzZWNvbmRzOiAwXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYodGhhdC5lbmRTdGF0ZSl7IC8v6YeN5paw6YCJ5oupXG4gICAgICAgIHNldERhdGVUaW1lKCk7XG4gICAgICAgIGRlbGV0ZSB0aGF0LmVuZFN0YXRlO1xuICAgICAgICBkZWxldGUgdGhhdC5lbmREYXRlO1xuICAgICAgICB0aGF0LnN0YXJ0U3RhdGUgPSB0cnVlO1xuICAgICAgICB0ZHMucmVtb3ZlQ2xhc3MoVEhJUyArICcgJyArIEVMRU1fU0VMRUNURUQpO1xuICAgICAgICB0ZC5hZGRDbGFzcyhUSElTKTtcbiAgICAgIH0gZWxzZSBpZih0aGF0LnN0YXJ0U3RhdGUpeyAvL+mAieS4reaIquatolxuICAgICAgICB0ZC5hZGRDbGFzcyhUSElTKTtcbiAgICAgICAgXG4gICAgICAgIHRoYXQuZW5kRGF0ZSA/IGxheS5leHRlbmQodGhhdC5lbmREYXRlLCBZTUQpIDogKFxuICAgICAgICAgIHRoYXQuZW5kRGF0ZSA9IGxheS5leHRlbmQoe30sIFlNRCwgdGhhdC5lbmRUaW1lKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy/liKTmlq3mmK/lkKbpobrml7bmiJbpgIbml7bpgInmi6lcbiAgICAgICAgaWYodGhhdC5uZXdEYXRlKFlNRCkuZ2V0VGltZSgpIDwgdGhhdC5uZXdEYXRlKHRoYXQuc3RhcnRZTUQpLmdldFRpbWUoKSl7XG4gICAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGxheS5leHRlbmQoe30sIHRoYXQuZW5kRGF0ZSwge1xuICAgICAgICAgICAgaG91cnM6IHRoYXQuc3RhcnREYXRlLmhvdXJzXG4gICAgICAgICAgICAsbWludXRlczogdGhhdC5zdGFydERhdGUubWludXRlc1xuICAgICAgICAgICAgLHNlY29uZHM6IHRoYXQuc3RhcnREYXRlLnNlY29uZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXkuZXh0ZW5kKHRoYXQuZW5kRGF0ZSwgdGhhdC5zdGFydERhdGUsIHtcbiAgICAgICAgICAgIGhvdXJzOiB0aGF0LmVuZERhdGUuaG91cnNcbiAgICAgICAgICAgICxtaW51dGVzOiB0aGF0LmVuZERhdGUubWludXRlc1xuICAgICAgICAgICAgLHNlY29uZHM6IHRoYXQuZW5kRGF0ZS5zZWNvbmRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhhdC5zdGFydERhdGUgPSBzdGFydERhdGU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG9wdGlvbnMuc2hvd0JvdHRvbSB8fCB0aGF0LmRvbmUoKTtcbiAgICAgICAgdGhhdC5zdGFtcFJhbmdlKCk7IC8v5qCH6K6w6IyD5Zu05YaF55qE5pel5pyfXG4gICAgICAgIHRoYXQuZW5kU3RhdGUgPSB0cnVlO1xuICAgICAgICB0aGF0LmRvbmUobnVsbCwgJ2NoYW5nZScpO1xuICAgICAgfSBlbHNlIHsgLy/pgInkuK3lvIDlp4tcbiAgICAgICAgdGQuYWRkQ2xhc3MoVEhJUyk7XG4gICAgICAgIHNldERhdGVUaW1lKCk7IFxuICAgICAgICB0aGF0LnN0YXJ0U3RhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGF5KHRoYXQuZm9vdGVyKS5maW5kKEVMRU1fQ09ORklSTSlbdGhhdC5lbmREYXRlID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddKERJU0FCTEVEKTtcbiAgICB9IGVsc2UgaWYob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpeyAvL+ebtOaOpeW1jOWll+eahOmAieS4rVxuICAgICAgc2V0RGF0ZVRpbWUodHJ1ZSk7XG4gICAgICB0aGF0LmNhbGVuZGFyKCkuZG9uZSgpLmRvbmUobnVsbCwgJ2NoYW5nZScpO1xuICAgIH0gZWxzZSBpZihvcHRpb25zLnR5cGUgPT09ICdkYXRlJyl7XG4gICAgICBzZXREYXRlVGltZSh0cnVlKTtcbiAgICAgIHRoYXQuc2V0VmFsdWUodGhhdC5wYXJzZSgpKS5yZW1vdmUoKS5kb25lKCk7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMudHlwZSA9PT0gJ2RhdGV0aW1lJyl7XG4gICAgICBzZXREYXRlVGltZSh0cnVlKTtcbiAgICAgIHRoYXQuY2FsZW5kYXIoKS5kb25lKG51bGwsICdjaGFuZ2UnKTtcbiAgICB9XG4gIH07XG4gIFxuICAvL+W6lemDqOaMiemSrlxuICBDbGFzcy5wcm90b3R5cGUudG9vbCA9IGZ1bmN0aW9uKGJ0biwgdHlwZSl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxkYXRlVGltZSA9IG9wdGlvbnMuZGF0ZVRpbWVcbiAgICAsaXNTdGF0aWMgPSBvcHRpb25zLnBvc2l0aW9uID09PSAnc3RhdGljJ1xuICAgICxhY3RpdmUgPSB7XG4gICAgICAvL+mAieaLqeaXtumXtFxuICAgICAgZGF0ZXRpbWU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGxheShidG4pLmhhc0NsYXNzKERJU0FCTEVEKSkgcmV0dXJuO1xuICAgICAgICB0aGF0Lmxpc3QoJ3RpbWUnLCAwKTtcbiAgICAgICAgb3B0aW9ucy5yYW5nZSAmJiB0aGF0Lmxpc3QoJ3RpbWUnLCAxKTtcbiAgICAgICAgbGF5KGJ0bikuYXR0cignbGF5LXR5cGUnLCAnZGF0ZScpLmh0bWwodGhhdC5sYW5nKCkuZGF0ZVRpcHMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvL+mAieaLqeaXpeacn1xuICAgICAgLGRhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoYXQuY2xvc2VMaXN0KCk7XG4gICAgICAgIGxheShidG4pLmF0dHIoJ2xheS10eXBlJywgJ2RhdGV0aW1lJykuaHRtbCh0aGF0LmxhbmcoKS50aW1lVGlwcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8v5riF56m644CB6YeN572uXG4gICAgICAsY2xlYXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoYXQuc2V0VmFsdWUoJycpLnJlbW92ZSgpO1xuICAgICAgICBpc1N0YXRpYyAmJiAoXG4gICAgICAgICAgbGF5LmV4dGVuZChkYXRlVGltZSwgdGhhdC5maXJzdERhdGUpXG4gICAgICAgICAgLHRoYXQuY2FsZW5kYXIoKVxuICAgICAgICApXG4gICAgICAgIG9wdGlvbnMucmFuZ2UgJiYgKFxuICAgICAgICAgIGRlbGV0ZSB0aGF0LnN0YXJ0U3RhdGVcbiAgICAgICAgICAsZGVsZXRlIHRoYXQuZW5kU3RhdGVcbiAgICAgICAgICAsZGVsZXRlIHRoYXQuZW5kRGF0ZVxuICAgICAgICAgICxkZWxldGUgdGhhdC5zdGFydFRpbWVcbiAgICAgICAgICAsZGVsZXRlIHRoYXQuZW5kVGltZVxuICAgICAgICApO1xuICAgICAgICB0aGF0LmRvbmUoWycnLCB7fSwge31dKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy/njrDlnKhcbiAgICAgICxub3c6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB0aGlzRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxheS5leHRlbmQoZGF0ZVRpbWUsIHRoYXQuc3lzdGVtRGF0ZSgpLCB7XG4gICAgICAgICAgaG91cnM6IHRoaXNEYXRlLmdldEhvdXJzKClcbiAgICAgICAgICAsbWludXRlczogdGhpc0RhdGUuZ2V0TWludXRlcygpXG4gICAgICAgICAgLHNlY29uZHM6IHRoaXNEYXRlLmdldFNlY29uZHMoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhhdC5zZXRWYWx1ZSh0aGF0LnBhcnNlKCkpLnJlbW92ZSgpO1xuICAgICAgICBpc1N0YXRpYyAmJiB0aGF0LmNhbGVuZGFyKCk7XG4gICAgICAgIHRoYXQuZG9uZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvL+ehruWumlxuICAgICAgLGNvbmZpcm06IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKG9wdGlvbnMucmFuZ2Upe1xuICAgICAgICAgIGlmKCF0aGF0LmVuZERhdGUpIHJldHVybiB0aGF0LmhpbnQoJ+ivt+WFiOmAieaLqeaXpeacn+iMg+WbtCcpO1xuICAgICAgICAgIGlmKGxheShidG4pLmhhc0NsYXNzKERJU0FCTEVEKSkgcmV0dXJuIHRoYXQuaGludChcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9PT0gJ3RpbWUnID8gVElQU19PVVQucmVwbGFjZSgv5pel5pyfL2csICfml7bpl7QnKSA6IFRJUFNfT1VUXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihsYXkoYnRuKS5oYXNDbGFzcyhESVNBQkxFRCkpIHJldHVybiB0aGF0LmhpbnQoJ+S4jeWcqOacieaViOaXpeacn+aIluaXtumXtOiMg+WbtOWGhScpO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuZG9uZSgpO1xuICAgICAgICB0aGF0LnNldFZhbHVlKHRoYXQucGFyc2UoKSkucmVtb3ZlKClcbiAgICAgIH1cbiAgICB9O1xuICAgIGFjdGl2ZVt0eXBlXSAmJiBhY3RpdmVbdHlwZV0oKTtcbiAgfTtcbiAgXG4gIC8v57uf5LiA5YiH5o2i5aSE55CGXG4gIENsYXNzLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbihpbmRleCl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuICAgICxkYXRlVGltZSA9IG9wdGlvbnMuZGF0ZVRpbWVcbiAgICAsaXNBbG9uZSA9IG9wdGlvbnMucmFuZ2UgJiYgKG9wdGlvbnMudHlwZSA9PT0gJ3llYXInIHx8IG9wdGlvbnMudHlwZSA9PT0gJ21vbnRoJylcbiAgICBcbiAgICAsZWxlbUNvbnQgPSB0aGF0LmVsZW1Db250W2luZGV4IHx8IDBdXG4gICAgLGxpc3RZTSA9IHRoYXQubGlzdFlNW2luZGV4XVxuICAgICxhZGRTdWJZZWF5ID0gZnVuY3Rpb24odHlwZSl7XG4gICAgICB2YXIgc3RhcnRFbmQgPSBbJ3N0YXJ0RGF0ZScsICdlbmREYXRlJ11baW5kZXhdXG4gICAgICAsaXNZZWFyID0gbGF5KGVsZW1Db250KS5maW5kKCcubGF5ZGF0ZS15ZWFyLWxpc3QnKVswXVxuICAgICAgLGlzTW9udGggPSBsYXkoZWxlbUNvbnQpLmZpbmQoJy5sYXlkYXRlLW1vbnRoLWxpc3QnKVswXTtcbiAgICAgIFxuICAgICAgLy/liIfmjaLlubTliJfooahcbiAgICAgIGlmKGlzWWVhcil7XG4gICAgICAgIGxpc3RZTVswXSA9IHR5cGUgPyBsaXN0WU1bMF0gLSAxNSA6IGxpc3RZTVswXSArIDE1O1xuICAgICAgICB0aGF0Lmxpc3QoJ3llYXInLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKGlzTW9udGgpeyAvL+WIh+aNouaciOmdouadv+S4reeahOW5tFxuICAgICAgICB0eXBlID8gbGlzdFlNWzBdLS0gOiBsaXN0WU1bMF0rKztcbiAgICAgICAgdGhhdC5saXN0KCdtb250aCcsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoaXNZZWFyIHx8IGlzTW9udGgpe1xuICAgICAgICBsYXkuZXh0ZW5kKGRhdGVUaW1lLCB7XG4gICAgICAgICAgeWVhcjogbGlzdFlNWzBdXG4gICAgICAgIH0pO1xuICAgICAgICBpZihpc0Fsb25lKSB0aGF0W3N0YXJ0RW5kXS55ZWFyID0gbGlzdFlNWzBdO1xuICAgICAgICBvcHRpb25zLnJhbmdlIHx8IHRoYXQuZG9uZShudWxsLCAnY2hhbmdlJyk7XG4gICAgICAgIHRoYXQuc2V0QnRuU3RhdHVzKCk7ICAgICAgXG4gICAgICAgIG9wdGlvbnMucmFuZ2UgfHwgdGhhdC5saW1pdChsYXkodGhhdC5mb290ZXIpLmZpbmQoRUxFTV9DT05GSVJNKSwge1xuICAgICAgICAgIHllYXI6IGxpc3RZTVswXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1llYXIgfHwgaXNNb250aDtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBwcmV2WWVhcjogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoYWRkU3ViWWVheSgnc3ViJykpIHJldHVybjtcbiAgICAgICAgZGF0ZVRpbWUueWVhci0tO1xuICAgICAgICB0aGF0LmNoZWNrRGF0ZSgnbGltaXQnKS5jYWxlbmRhcigpO1xuICAgICAgICBvcHRpb25zLnJhbmdlIHx8IHRoYXQuZG9uZShudWxsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICAscHJldk1vbnRoOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgWU0gPSB0aGF0LmdldEFzWU0oZGF0ZVRpbWUueWVhciwgZGF0ZVRpbWUubW9udGgsICdzdWInKTtcbiAgICAgICAgbGF5LmV4dGVuZChkYXRlVGltZSwge1xuICAgICAgICAgIHllYXI6IFlNWzBdXG4gICAgICAgICAgLG1vbnRoOiBZTVsxXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhhdC5jaGVja0RhdGUoJ2xpbWl0JykuY2FsZW5kYXIoKTtcbiAgICAgICAgb3B0aW9ucy5yYW5nZSB8fCB0aGF0LmRvbmUobnVsbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgICAgLG5leHRNb250aDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIFlNID0gdGhhdC5nZXRBc1lNKGRhdGVUaW1lLnllYXIsIGRhdGVUaW1lLm1vbnRoKTtcbiAgICAgICAgbGF5LmV4dGVuZChkYXRlVGltZSwge1xuICAgICAgICAgIHllYXI6IFlNWzBdXG4gICAgICAgICAgLG1vbnRoOiBZTVsxXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhhdC5jaGVja0RhdGUoJ2xpbWl0JykuY2FsZW5kYXIoKTtcbiAgICAgICAgb3B0aW9ucy5yYW5nZSB8fCB0aGF0LmRvbmUobnVsbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgICAgLG5leHRZZWFyOiBmdW5jdGlvbigpe1xuICAgICAgICBpZihhZGRTdWJZZWF5KCkpIHJldHVybjtcbiAgICAgICAgZGF0ZVRpbWUueWVhcisrXG4gICAgICAgIHRoYXQuY2hlY2tEYXRlKCdsaW1pdCcpLmNhbGVuZGFyKCk7XG4gICAgICAgIG9wdGlvbnMucmFuZ2UgfHwgdGhhdC5kb25lKG51bGwsICdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBcbiAgLy/ml6XmnJ/liIfmjaLkuovku7ZcbiAgQ2xhc3MucHJvdG90eXBlLmNoYW5nZUV2ZW50ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsb3B0aW9ucyA9IHRoYXQuY29uZmlnO1xuXG4gICAgLy/ml6XmnJ/pgInmi6nkuovku7ZcbiAgICBsYXkodGhhdC5lbGVtKS5vbignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgIGxheS5zdG9wZShlKTtcbiAgICB9KTtcbiAgICBcbiAgICAvL+W5tOaciOWIh+aNolxuICAgIGxheS5lYWNoKHRoYXQuZWxlbUhlYWRlciwgZnVuY3Rpb24oaSwgaGVhZGVyKXtcbiAgICAgIC8v5LiK5LiA5bm0XG4gICAgICBsYXkoaGVhZGVyWzBdKS5vbignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgdGhhdC5jaGFuZ2UoaSkucHJldlllYXIoKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvL+S4iuS4gOaciFxuICAgICAgbGF5KGhlYWRlclsxXSkub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHRoYXQuY2hhbmdlKGkpLnByZXZNb250aCgpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8v6YCJ5oup5bm05pyIXG4gICAgICBsYXkoaGVhZGVyWzJdKS5maW5kKCdzcGFuJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBvdGhpcyA9IGxheSh0aGlzKVxuICAgICAgICAsbGF5WU0gPSBvdGhpcy5hdHRyKCdsYXkteW0nKVxuICAgICAgICAsbGF5VHlwZSA9IG90aGlzLmF0dHIoJ2xheS10eXBlJyk7XG4gICAgICAgIFxuICAgICAgICBpZighbGF5WU0pIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGxheVlNID0gbGF5WU0uc3BsaXQoJy0nKTtcblxuICAgICAgICB0aGF0Lmxpc3RZTVtpXSA9IFtsYXlZTVswXSB8IDAsIGxheVlNWzFdIHwgMF07XG4gICAgICAgIHRoYXQubGlzdChsYXlUeXBlLCBpKTtcbiAgICAgICAgbGF5KHRoYXQuZm9vdGVyKS5maW5kKEVMRU1fVElNRV9CVE4pLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICAgIH0pO1xuXG4gICAgICAvL+S4i+S4gOaciFxuICAgICAgbGF5KGhlYWRlclszXSkub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHRoYXQuY2hhbmdlKGkpLm5leHRNb250aCgpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8v5LiL5LiA5bm0XG4gICAgICBsYXkoaGVhZGVyWzRdKS5vbignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgdGhhdC5jaGFuZ2UoaSkubmV4dFllYXIoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8v54K55Ye75pel5pyfXG4gICAgbGF5LmVhY2godGhhdC50YWJsZSwgZnVuY3Rpb24oaSwgdGFibGUpe1xuICAgICAgdmFyIHRkcyA9IGxheSh0YWJsZSkuZmluZCgndGQnKTtcbiAgICAgIHRkcy5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICB0aGF0LmNob29zZShsYXkodGhpcykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy/ngrnlh7vlupXpg6jmjInpkq5cbiAgICBsYXkodGhhdC5mb290ZXIpLmZpbmQoJ3NwYW4nKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHR5cGUgPSBsYXkodGhpcykuYXR0cignbGF5LXR5cGUnKTtcbiAgICAgIHRoYXQudG9vbCh0aGlzLCB0eXBlKTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8v5piv5ZCm6L6T5YWl5qGGXG4gIENsYXNzLnByb3RvdHlwZS5pc0lucHV0ID0gZnVuY3Rpb24oZWxlbSl7XG4gICAgcmV0dXJuIC9pbnB1dHx0ZXh0YXJlYS8udGVzdChlbGVtLnRhZ05hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gIH07XG5cbiAgLy/nu5HlrprnmoTlhYPntKDkuovku7blpITnkIZcbiAgQ2xhc3MucHJvdG90eXBlLmV2ZW50cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLG9wdGlvbnMgPSB0aGF0LmNvbmZpZ1xuXG4gICAgLy/nu5Hlrprlkbzlh7rmjqfku7bkuovku7ZcbiAgICAsc2hvd0V2ZW50ID0gZnVuY3Rpb24oZWxlbSwgYmluZCl7XG4gICAgICBlbGVtLm9uKG9wdGlvbnMudHJpZ2dlciwgZnVuY3Rpb24oKXtcbiAgICAgICAgYmluZCAmJiAodGhhdC5iaW5kRWxlbSA9IHRoaXMpO1xuICAgICAgICB0aGF0LnJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBpZighb3B0aW9ucy5lbGVtWzBdIHx8IG9wdGlvbnMuZWxlbVswXS5ldmVudEhhbmRsZXIpIHJldHVybjtcbiAgICBcbiAgICBzaG93RXZlbnQob3B0aW9ucy5lbGVtLCAnYmluZCcpO1xuICAgIHNob3dFdmVudChvcHRpb25zLmV2ZW50RWxlbSk7XG4gICAgXG4gICAgLy/nu5HlrprlhbPpl63mjqfku7bkuovku7ZcbiAgICBsYXkoZG9jdW1lbnQpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgaWYoZS50YXJnZXQgPT09IG9wdGlvbnMuZWxlbVswXSBcbiAgICAgIHx8IGUudGFyZ2V0ID09PSBvcHRpb25zLmV2ZW50RWxlbVswXVxuICAgICAgfHwgZS50YXJnZXQgPT09IGxheShvcHRpb25zLmNsb3NlU3RvcClbMF0pe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGF0LnJlbW92ZSgpO1xuICAgIH0pLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICBpZihlLmtleUNvZGUgPT09IDEzKXtcbiAgICAgICAgaWYobGF5KCcjJysgdGhhdC5lbGVtSUQpWzBdICYmIHRoYXQuZWxlbUlEID09PSBDbGFzcy50aGlzRWxlbSl7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGxheSh0aGF0LmZvb3RlcikuZmluZChFTEVNX0NPTkZJUk0pWzBdLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvL+iHqumAguW6lOWumuS9jVxuICAgIGxheSh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbigpe1xuICAgICAgaWYoIXRoYXQuZWxlbSB8fCAhbGF5KEVMRU0pWzBdKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhhdC5wb3NpdGlvbigpO1xuICAgIH0pO1xuICAgIFxuICAgIG9wdGlvbnMuZWxlbVswXS5ldmVudEhhbmRsZXIgPSB0cnVlO1xuICB9O1xuXG4gIFxuICAvL+aguOW/g+aOpeWPo1xuICBsYXlkYXRlLnJlbmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIHZhciBpbnN0ID0gbmV3IENsYXNzKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzRGF0ZS5jYWxsKGluc3QpO1xuICB9O1xuICBcbiAgLy/lvpfliLDmn5DmnIjnmoTmnIDlkI7kuIDlpKlcbiAgbGF5ZGF0ZS5nZXRFbmREYXRlID0gZnVuY3Rpb24obW9udGgsIHllYXIpe1xuICAgIHZhciB0aGlzRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgLy/orr7nva7ml6XmnJ/kuLrkuIvkuKrmnIjnmoTnrKzkuIDlpKlcbiAgICB0aGlzRGF0ZS5zZXRGdWxsWWVhcihcbiAgICAgIHllYXIgfHwgdGhpc0RhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgLG1vbnRoIHx8ICh0aGlzRGF0ZS5nZXRNb250aCgpICsgMSlcbiAgICAsMSk7XG4gICAgLy/lh4/ljrvkuIDlpKnvvIzlvpfliLDlvZPliY3mnIjmnIDlkI7kuIDlpKlcbiAgICByZXR1cm4gbmV3IERhdGUodGhpc0RhdGUuZ2V0VGltZSgpIC0gMTAwMCo2MCo2MCoyNCkuZ2V0RGF0ZSgpO1xuICB9O1xuICBcbiAgLy/mmrTpnLJsYXlcbiAgd2luZG93LmxheSA9IHdpbmRvdy5sYXkgfHwgbGF5O1xuICB3aW5kb3cubGF5ZGF0ZSA9IHdpbmRvdy5sYXlkYXRlIHx8IGxheWRhdGU7XG4gIFxuICAvL+WKoOi9veaWueW8j1xuICBpc0xheXVpID8gKFxuICAgIGxheWRhdGUucmVhZHkoKVxuICAgICxsYXl1aS5kZWZpbmUoZnVuY3Rpb24oZXhwb3J0cyl7IC8vbGF5dWnliqDovb1cbiAgICAgIGxheWRhdGUucGF0aCA9IGxheXVpLmNhY2hlLmRpcjtcbiAgICAgIGV4cG9ydHMoTU9EX05BTUUsIGxheWRhdGUpO1xuICAgIH0pXG4gICkgOiAoXG4gICAgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgPyBkZWZpbmUoZnVuY3Rpb24oKXsgLy9yZXF1aXJlanPliqDovb1cbiAgICAgIHJldHVybiBsYXlkYXRlO1xuICAgIH0pIDogZnVuY3Rpb24oKXsgLy/mma7pgJpzY3JpcHTmoIfnrb7liqDovb1cbiAgICAgIGxheWRhdGUucmVhZHkoKTtcbiAgICAgIHdpbmRvdy5sYXlkYXRlID0gbGF5ZGF0ZVxuICAgIH0oKVxuICApO1xuXG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvanMvcGx1Z2lucy9sYXllci9sYXlkYXRlL2xheWRhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy9sYXllci9sYXlkYXRlL3RoZW1lL2RlZmF1bHQvbGF5ZGF0ZS5jc3M/MWIwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvanMvcGx1Z2lucy9sYXllci9sYXlkYXRlL3RoZW1lL2RlZmF1bHQvbGF5ZGF0ZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy96dHJlZS9jc3MvelRyZWVTdHlsZS5jc3M/MDE5MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvanMvcGx1Z2lucy96dHJlZS9jc3MvelRyZWVTdHlsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n")},function(module,exports){eval('\n/*\n * JQuery zTree core v3.5.17-beta.2\n * http://zTree.me/\n *\n * Copyright (c) 2010 Hunter.z\n *\n * Licensed same as jquery - MIT License\n * http://www.opensource.org/licenses/mit-license.php\n *\n * email: hunter.z@263.net\n * Date: 2014-05-08\n */\n(function($){\n\tvar settings = {}, roots = {}, caches = {},\n\t//default consts of core\n\t_consts = {\n\t\tclassName: {\n\t\t\tBUTTON: "button",\n\t\t\tLEVEL: "level",\n\t\t\tICO_LOADING: "ico_loading",\n\t\t\tSWITCH: "switch"\n\t\t},\n\t\tevent: {\n\t\t\tNODECREATED: "ztree_nodeCreated",\n\t\t\tCLICK: "ztree_click",\n\t\t\tEXPAND: "ztree_expand",\n\t\t\tCOLLAPSE: "ztree_collapse",\n\t\t\tASYNC_SUCCESS: "ztree_async_success",\n\t\t\tASYNC_ERROR: "ztree_async_error",\n\t\t\tREMOVE: "ztree_remove"\n\t\t},\n\t\tid: {\n\t\t\tA: "_a",\n\t\t\tICON: "_ico",\n\t\t\tSPAN: "_span",\n\t\t\tSWITCH: "_switch",\n\t\t\tUL: "_ul"\n\t\t},\n\t\tline: {\n\t\t\tROOT: "root",\n\t\t\tROOTS: "roots",\n\t\t\tCENTER: "center",\n\t\t\tBOTTOM: "bottom",\n\t\t\tNOLINE: "noline",\n\t\t\tLINE: "line"\n\t\t},\n\t\tfolder: {\n\t\t\tOPEN: "open",\n\t\t\tCLOSE: "close",\n\t\t\tDOCU: "docu"\n\t\t},\n\t\tnode: {\n\t\t\tCURSELECTED: "curSelectedNode",\n\t\t\tSELECTLI:"SELECT_LI"\n\t\t}\n\t},\n\t//default setting of core\n\t_setting = {\n\t\ttreeId: "",\n\t\ttreeObj: null,\n\t\tview: {\n\t\t\taddDiyDom: null,\n\t\t\tautoCancelSelected: true,\n\t\t\tdblClickExpand: true,\n\t\t\texpandSpeed: "fast",\n\t\t\tfontCss: {},\n\t\t\tnameIsHTML: false,\n\t\t\tselectedMulti: true,\n\t\t\tshowIcon: true,\n\t\t\tshowLine: true,\n\t\t\tshowTitle: true,\n\t\t\ttxtSelectedEnable: false\n\t\t},\n\t\tdata: {\n\t\t\tkey: {\n\t\t\t\tchildren: "children",\n\t\t\t\tname: "name",\n\t\t\t\ttitle: "",\n\t\t\t\turl: "url"\n\t\t\t},\n\t\t\tsimpleData: {\n\t\t\t\tenable: false,\n\t\t\t\tidKey: "id",\n\t\t\t\tpIdKey: "pId",\n\t\t\t\trootPId: null\n\t\t\t},\n\t\t\tkeep: {\n\t\t\t\tparent: false,\n\t\t\t\tleaf: false\n\t\t\t}\n\t\t},\n\t\tasync: {\n\t\t\tenable: false,\n\t\t\tcontentType: "application/x-www-form-urlencoded",\n\t\t\ttype: "post",\n\t\t\tdataType: "text",\n\t\t\turl: "",\n\t\t\tautoParam: [],\n\t\t\totherParam: [],\n\t\t\tdataFilter: null\n\t\t},\n\t\tcallback: {\n\t\t\tbeforeAsync:null,\n\t\t\tbeforeClick:null,\n\t\t\tbeforeDblClick:null,\n\t\t\tbeforeRightClick:null,\n\t\t\tbeforeMouseDown:null,\n\t\t\tbeforeMouseUp:null,\n\t\t\tbeforeExpand:null,\n\t\t\tbeforeCollapse:null,\n\t\t\tbeforeRemove:null,\n\n\t\t\tonAsyncError:null,\n\t\t\tonAsyncSuccess:null,\n\t\t\tonNodeCreated:null,\n\t\t\tonClick:null,\n\t\t\tonDblClick:null,\n\t\t\tonRightClick:null,\n\t\t\tonMouseDown:null,\n\t\t\tonMouseUp:null,\n\t\t\tonExpand:null,\n\t\t\tonCollapse:null,\n\t\t\tonRemove:null\n\t\t}\n\t},\n\t//default root of core\n\t//zTree use root to save full data\n\t_initRoot = function (setting) {\n\t\tvar r = data.getRoot(setting);\n\t\tif (!r) {\n\t\t\tr = {};\n\t\t\tdata.setRoot(setting, r);\n\t\t}\n\t\tr[setting.data.key.children] = [];\n\t\tr.expandTriggerFlag = false;\n\t\tr.curSelectedList = [];\n\t\tr.noSelection = true;\n\t\tr.createdNodes = [];\n\t\tr.zId = 0;\n\t\tr._ver = (new Date()).getTime();\n\t},\n\t//default cache of core\n\t_initCache = function(setting) {\n\t\tvar c = data.getCache(setting);\n\t\tif (!c) {\n\t\t\tc = {};\n\t\t\tdata.setCache(setting, c);\n\t\t}\n\t\tc.nodes = [];\n\t\tc.doms = [];\n\t},\n\t//default bindEvent of core\n\t_bindEvent = function(setting) {\n\t\tvar o = setting.treeObj,\n\t\tc = consts.event;\n\t\to.bind(c.NODECREATED, function (event, treeId, node) {\n\t\t\ttools.apply(setting.callback.onNodeCreated, [event, treeId, node]);\n\t\t});\n\n\t\to.bind(c.CLICK, function (event, srcEvent, treeId, node, clickFlag) {\n\t\t\ttools.apply(setting.callback.onClick, [srcEvent, treeId, node, clickFlag]);\n\t\t});\n\n\t\to.bind(c.EXPAND, function (event, treeId, node) {\n\t\t\ttools.apply(setting.callback.onExpand, [event, treeId, node]);\n\t\t});\n\n\t\to.bind(c.COLLAPSE, function (event, treeId, node) {\n\t\t\ttools.apply(setting.callback.onCollapse, [event, treeId, node]);\n\t\t});\n\n\t\to.bind(c.ASYNC_SUCCESS, function (event, treeId, node, msg) {\n\t\t\ttools.apply(setting.callback.onAsyncSuccess, [event, treeId, node, msg]);\n\t\t});\n\n\t\to.bind(c.ASYNC_ERROR, function (event, treeId, node, XMLHttpRequest, textStatus, errorThrown) {\n\t\t\ttools.apply(setting.callback.onAsyncError, [event, treeId, node, XMLHttpRequest, textStatus, errorThrown]);\n\t\t});\n\n\t\to.bind(c.REMOVE, function (event, treeId, treeNode) {\n\t\t\ttools.apply(setting.callback.onRemove, [event, treeId, treeNode]);\n\t\t});\n\t},\n\t_unbindEvent = function(setting) {\n\t\tvar o = setting.treeObj,\n\t\tc = consts.event;\n\t\to.unbind(c.NODECREATED)\n\t\t.unbind(c.CLICK)\n\t\t.unbind(c.EXPAND)\n\t\t.unbind(c.COLLAPSE)\n\t\t.unbind(c.ASYNC_SUCCESS)\n\t\t.unbind(c.ASYNC_ERROR)\n\t\t.unbind(c.REMOVE);\n\t},\n\t//default event proxy of core\n\t_eventProxy = function(event) {\n\t\tvar target = event.target,\n\t\tsetting = data.getSetting(event.data.treeId),\n\t\ttId = "", node = null,\n\t\tnodeEventType = "", treeEventType = "",\n\t\tnodeEventCallback = null, treeEventCallback = null,\n\t\ttmp = null;\n\n\t\tif (tools.eqs(event.type, "mousedown")) {\n\t\t\ttreeEventType = "mousedown";\n\t\t} else if (tools.eqs(event.type, "mouseup")) {\n\t\t\ttreeEventType = "mouseup";\n\t\t} else if (tools.eqs(event.type, "contextmenu")) {\n\t\t\ttreeEventType = "contextmenu";\n\t\t} else if (tools.eqs(event.type, "click")) {\n\t\t\tif (tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.SWITCH) !== null) {\n\t\t\t\ttId = tools.getNodeMainDom(target).id;\n\t\t\t\tnodeEventType = "switchNode";\n\t\t\t} else {\n\t\t\t\ttmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);\n\t\t\t\tif (tmp) {\n\t\t\t\t\ttId = tools.getNodeMainDom(tmp).id;\n\t\t\t\t\tnodeEventType = "clickNode";\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tools.eqs(event.type, "dblclick")) {\n\t\t\ttreeEventType = "dblclick";\n\t\t\ttmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);\n\t\t\tif (tmp) {\n\t\t\t\ttId = tools.getNodeMainDom(tmp).id;\n\t\t\t\tnodeEventType = "switchNode";\n\t\t\t}\n\t\t}\n\t\tif (treeEventType.length > 0 && tId.length == 0) {\n\t\t\ttmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);\n\t\t\tif (tmp) {tId = tools.getNodeMainDom(tmp).id;}\n\t\t}\n\t\t// event to node\n\t\tif (tId.length>0) {\n\t\t\tnode = data.getNodeCache(setting, tId);\n\t\t\tswitch (nodeEventType) {\n\t\t\t\tcase "switchNode" :\n\t\t\t\t\tif (!node.isParent) {\n\t\t\t\t\t\tnodeEventType = "";\n\t\t\t\t\t} else if (tools.eqs(event.type, "click")\n\t\t\t\t\t\t|| (tools.eqs(event.type, "dblclick") && tools.apply(setting.view.dblClickExpand, [setting.treeId, node], setting.view.dblClickExpand))) {\n\t\t\t\t\t\tnodeEventCallback = handler.onSwitchNode;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnodeEventType = "";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase "clickNode" :\n\t\t\t\t\tnodeEventCallback = handler.onClickNode;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// event to zTree\n\t\tswitch (treeEventType) {\n\t\t\tcase "mousedown" :\n\t\t\t\ttreeEventCallback = handler.onZTreeMousedown;\n\t\t\t\tbreak;\n\t\t\tcase "mouseup" :\n\t\t\t\ttreeEventCallback = handler.onZTreeMouseup;\n\t\t\t\tbreak;\n\t\t\tcase "dblclick" :\n\t\t\t\ttreeEventCallback = handler.onZTreeDblclick;\n\t\t\t\tbreak;\n\t\t\tcase "contextmenu" :\n\t\t\t\ttreeEventCallback = handler.onZTreeContextmenu;\n\t\t\t\tbreak;\n\t\t}\n\t\tvar proxyResult = {\n\t\t\tstop: false,\n\t\t\tnode: node,\n\t\t\tnodeEventType: nodeEventType,\n\t\t\tnodeEventCallback: nodeEventCallback,\n\t\t\ttreeEventType: treeEventType,\n\t\t\ttreeEventCallback: treeEventCallback\n\t\t};\n\t\treturn proxyResult\n\t},\n\t//default init node of core\n\t_initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {\n\t\tif (!n) return;\n\t\tvar r = data.getRoot(setting),\n\t\tchildKey = setting.data.key.children;\n\t\tn.level = level;\n\t\tn.tId = setting.treeId + "_" + (++r.zId);\n\t\tn.parentTId = parentNode ? parentNode.tId : null;\n\t\tn.open = (typeof n.open == "string") ? tools.eqs(n.open, "true") : !!n.open;\n\t\tif (n[childKey] && n[childKey].length > 0) {\n\t\t\tn.isParent = true;\n\t\t\tn.zAsync = true;\n\t\t} else {\n\t\t\tn.isParent = (typeof n.isParent == "string") ? tools.eqs(n.isParent, "true") : !!n.isParent;\n\t\t\tn.open = (n.isParent && !setting.async.enable) ? n.open : false;\n\t\t\tn.zAsync = !n.isParent;\n\t\t}\n\t\tn.isFirstNode = isFirstNode;\n\t\tn.isLastNode = isLastNode;\n\t\tn.getParentNode = function() {return data.getNodeCache(setting, n.parentTId);};\n\t\tn.getPreNode = function() {return data.getPreNode(setting, n);};\n\t\tn.getNextNode = function() {return data.getNextNode(setting, n);};\n\t\tn.isAjaxing = false;\n\t\tdata.fixPIdKeyValue(setting, n);\n\t},\n\t_init = {\n\t\tbind: [_bindEvent],\n\t\tunbind: [_unbindEvent],\n\t\tcaches: [_initCache],\n\t\tnodes: [_initNode],\n\t\tproxys: [_eventProxy],\n\t\troots: [_initRoot],\n\t\tbeforeA: [],\n\t\tafterA: [],\n\t\tinnerBeforeA: [],\n\t\tinnerAfterA: [],\n\t\tzTreeTools: []\n\t},\n\t//method of operate data\n\tdata = {\n\t\taddNodeCache: function(setting, node) {\n\t\t\tdata.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = node;\n\t\t},\n\t\tgetNodeCacheId: function(tId) {\n\t\t\treturn tId.substring(tId.lastIndexOf("_")+1);\n\t\t},\n\t\taddAfterA: function(afterA) {\n\t\t\t_init.afterA.push(afterA);\n\t\t},\n\t\taddBeforeA: function(beforeA) {\n\t\t\t_init.beforeA.push(beforeA);\n\t\t},\n\t\taddInnerAfterA: function(innerAfterA) {\n\t\t\t_init.innerAfterA.push(innerAfterA);\n\t\t},\n\t\taddInnerBeforeA: function(innerBeforeA) {\n\t\t\t_init.innerBeforeA.push(innerBeforeA);\n\t\t},\n\t\taddInitBind: function(bindEvent) {\n\t\t\t_init.bind.push(bindEvent);\n\t\t},\n\t\taddInitUnBind: function(unbindEvent) {\n\t\t\t_init.unbind.push(unbindEvent);\n\t\t},\n\t\taddInitCache: function(initCache) {\n\t\t\t_init.caches.push(initCache);\n\t\t},\n\t\taddInitNode: function(initNode) {\n\t\t\t_init.nodes.push(initNode);\n\t\t},\n\t\taddInitProxy: function(initProxy, isFirst) {\n\t\t\tif (!!isFirst) {\n\t\t\t\t_init.proxys.splice(0,0,initProxy);\n\t\t\t} else {\n\t\t\t\t_init.proxys.push(initProxy);\n\t\t\t}\n\t\t},\n\t\taddInitRoot: function(initRoot) {\n\t\t\t_init.roots.push(initRoot);\n\t\t},\n\t\taddNodesData: function(setting, parentNode, nodes) {\n\t\t\tvar childKey = setting.data.key.children;\n\t\t\tif (!parentNode[childKey]) parentNode[childKey] = [];\n\t\t\tif (parentNode[childKey].length > 0) {\n\t\t\t\tparentNode[childKey][parentNode[childKey].length - 1].isLastNode = false;\n\t\t\t\tview.setNodeLineIcos(setting, parentNode[childKey][parentNode[childKey].length - 1]);\n\t\t\t}\n\t\t\tparentNode.isParent = true;\n\t\t\tparentNode[childKey] = parentNode[childKey].concat(nodes);\n\t\t},\n\t\taddSelectedNode: function(setting, node) {\n\t\t\tvar root = data.getRoot(setting);\n\t\t\tif (!data.isSelectedNode(setting, node)) {\n\t\t\t\troot.curSelectedList.push(node);\n\t\t\t}\n\t\t},\n\t\taddCreatedNode: function(setting, node) {\n\t\t\tif (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {\n\t\t\t\tvar root = data.getRoot(setting);\n\t\t\t\troot.createdNodes.push(node);\n\t\t\t}\n\t\t},\n\t\taddZTreeTools: function(zTreeTools) {\n\t\t\t_init.zTreeTools.push(zTreeTools);\n\t\t},\n\t\texSetting: function(s) {\n\t\t\t$.extend(true, _setting, s);\n\t\t},\n\t\tfixPIdKeyValue: function(setting, node) {\n\t\t\tif (setting.data.simpleData.enable) {\n\t\t\t\tnode[setting.data.simpleData.pIdKey] = node.parentTId ? node.getParentNode()[setting.data.simpleData.idKey] : setting.data.simpleData.rootPId;\n\t\t\t}\n\t\t},\n\t\tgetAfterA: function(setting, node, array) {\n\t\t\tfor (var i=0, j=_init.afterA.length; i<j; i++) {\n\t\t\t\t_init.afterA[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tgetBeforeA: function(setting, node, array) {\n\t\t\tfor (var i=0, j=_init.beforeA.length; i<j; i++) {\n\t\t\t\t_init.beforeA[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tgetInnerAfterA: function(setting, node, array) {\n\t\t\tfor (var i=0, j=_init.innerAfterA.length; i<j; i++) {\n\t\t\t\t_init.innerAfterA[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tgetInnerBeforeA: function(setting, node, array) {\n\t\t\tfor (var i=0, j=_init.innerBeforeA.length; i<j; i++) {\n\t\t\t\t_init.innerBeforeA[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tgetCache: function(setting) {\n\t\t\treturn caches[setting.treeId];\n\t\t},\n\t\tgetNextNode: function(setting, node) {\n\t\t\tif (!node) return null;\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tp = node.parentTId ? node.getParentNode() : data.getRoot(setting);\n\t\t\tfor (var i=0, l=p[childKey].length-1; i<=l; i++) {\n\t\t\t\tif (p[childKey][i] === node) {\n\t\t\t\t\treturn (i==l ? null : p[childKey][i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tgetNodeByParam: function(setting, nodes, key, value) {\n\t\t\tif (!nodes || !key) return null;\n\t\t\tvar childKey = setting.data.key.children;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tif (nodes[i][key] == value) {\n\t\t\t\t\treturn nodes[i];\n\t\t\t\t}\n\t\t\t\tvar tmp = data.getNodeByParam(setting, nodes[i][childKey], key, value);\n\t\t\t\tif (tmp) return tmp;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tgetNodeCache: function(setting, tId) {\n\t\t\tif (!tId) return null;\n\t\t\tvar n = caches[setting.treeId].nodes[data.getNodeCacheId(tId)];\n\t\t\treturn n ? n : null;\n\t\t},\n\t\tgetNodeName: function(setting, node) {\n\t\t\tvar nameKey = setting.data.key.name;\n\t\t\treturn "" + node[nameKey];\n\t\t},\n\t\tgetNodeTitle: function(setting, node) {\n\t\t\tvar t = setting.data.key.title === "" ? setting.data.key.name : setting.data.key.title;\n\t\t\treturn "" + node[t];\n\t\t},\n\t\tgetNodes: function(setting) {\n\t\t\treturn data.getRoot(setting)[setting.data.key.children];\n\t\t},\n\t\tgetNodesByParam: function(setting, nodes, key, value) {\n\t\t\tif (!nodes || !key) return [];\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tresult = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tif (nodes[i][key] == value) {\n\t\t\t\t\tresult.push(nodes[i]);\n\t\t\t\t}\n\t\t\t\tresult = result.concat(data.getNodesByParam(setting, nodes[i][childKey], key, value));\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetNodesByParamFuzzy: function(setting, nodes, key, value) {\n\t\t\tif (!nodes || !key) return [];\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tresult = [];\n\t\t\tvalue = value.toLowerCase();\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tif (typeof nodes[i][key] == "string" && nodes[i][key].toLowerCase().indexOf(value)>-1) {\n\t\t\t\t\tresult.push(nodes[i]);\n\t\t\t\t}\n\t\t\t\tresult = result.concat(data.getNodesByParamFuzzy(setting, nodes[i][childKey], key, value));\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetNodesByFilter: function(setting, nodes, filter, isSingle, invokeParam) {\n\t\t\tif (!nodes) return (isSingle ? null : []);\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tresult = isSingle ? null : [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tif (tools.apply(filter, [nodes[i], invokeParam], false)) {\n\t\t\t\t\tif (isSingle) {return nodes[i];}\n\t\t\t\t\tresult.push(nodes[i]);\n\t\t\t\t}\n\t\t\t\tvar tmpResult = data.getNodesByFilter(setting, nodes[i][childKey], filter, isSingle, invokeParam);\n\t\t\t\tif (isSingle && !!tmpResult) {return tmpResult;}\n\t\t\t\tresult = isSingle ? tmpResult : result.concat(tmpResult);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetPreNode: function(setting, node) {\n\t\t\tif (!node) return null;\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tp = node.parentTId ? node.getParentNode() : data.getRoot(setting);\n\t\t\tfor (var i=0, l=p[childKey].length; i<l; i++) {\n\t\t\t\tif (p[childKey][i] === node) {\n\t\t\t\t\treturn (i==0 ? null : p[childKey][i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tgetRoot: function(setting) {\n\t\t\treturn setting ? roots[setting.treeId] : null;\n\t\t},\n\t\tgetRoots: function() {\n\t\t\treturn roots;\n\t\t},\n\t\tgetSetting: function(treeId) {\n\t\t\treturn settings[treeId];\n\t\t},\n\t\tgetSettings: function() {\n\t\t\treturn settings;\n\t\t},\n\t\tgetZTreeTools: function(treeId) {\n\t\t\tvar r = this.getRoot(this.getSetting(treeId));\n\t\t\treturn r ? r.treeTools : null;\n\t\t},\n\t\tinitCache: function(setting) {\n\t\t\tfor (var i=0, j=_init.caches.length; i<j; i++) {\n\t\t\t\t_init.caches[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tinitNode: function(setting, level, node, parentNode, preNode, nextNode) {\n\t\t\tfor (var i=0, j=_init.nodes.length; i<j; i++) {\n\t\t\t\t_init.nodes[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tinitRoot: function(setting) {\n\t\t\tfor (var i=0, j=_init.roots.length; i<j; i++) {\n\t\t\t\t_init.roots[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tisSelectedNode: function(setting, node) {\n\t\t\tvar root = data.getRoot(setting);\n\t\t\tfor (var i=0, j=root.curSelectedList.length; i<j; i++) {\n\t\t\t\tif(node === root.curSelectedList[i]) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tremoveNodeCache: function(setting, node) {\n\t\t\tvar childKey = setting.data.key.children;\n\t\t\tif (node[childKey]) {\n\t\t\t\tfor (var i=0, l=node[childKey].length; i<l; i++) {\n\t\t\t\t\targuments.callee(setting, node[childKey][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = null;\n\t\t},\n\t\tremoveSelectedNode: function(setting, node) {\n\t\t\tvar root = data.getRoot(setting);\n\t\t\tfor (var i=0, j=root.curSelectedList.length; i<j; i++) {\n\t\t\t\tif(node === root.curSelectedList[i] || !data.getNodeCache(setting, root.curSelectedList[i].tId)) {\n\t\t\t\t\troot.curSelectedList.splice(i, 1);\n\t\t\t\t\ti--;j--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsetCache: function(setting, cache) {\n\t\t\tcaches[setting.treeId] = cache;\n\t\t},\n\t\tsetRoot: function(setting, root) {\n\t\t\troots[setting.treeId] = root;\n\t\t},\n\t\tsetZTreeTools: function(setting, zTreeTools) {\n\t\t\tfor (var i=0, j=_init.zTreeTools.length; i<j; i++) {\n\t\t\t\t_init.zTreeTools[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\ttransformToArrayFormat: function (setting, nodes) {\n\t\t\tif (!nodes) return [];\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tr = [];\n\t\t\tif (tools.isArray(nodes)) {\n\t\t\t\tfor (var i=0, l=nodes.length; i<l; i++) {\n\t\t\t\t\tr.push(nodes[i]);\n\t\t\t\t\tif (nodes[i][childKey])\n\t\t\t\t\t\tr = r.concat(data.transformToArrayFormat(setting, nodes[i][childKey]));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr.push(nodes);\n\t\t\t\tif (nodes[childKey])\n\t\t\t\t\tr = r.concat(data.transformToArrayFormat(setting, nodes[childKey]));\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\t\ttransformTozTreeFormat: function(setting, sNodes) {\n\t\t\tvar i,l,\n\t\t\tkey = setting.data.simpleData.idKey,\n\t\t\tparentKey = setting.data.simpleData.pIdKey,\n\t\t\tchildKey = setting.data.key.children;\n\t\t\tif (!key || key=="" || !sNodes) return [];\n\n\t\t\tif (tools.isArray(sNodes)) {\n\t\t\t\tvar r = [];\n\t\t\t\tvar tmpMap = [];\n\t\t\t\tfor (i=0, l=sNodes.length; i<l; i++) {\n\t\t\t\t\ttmpMap[sNodes[i][key]] = sNodes[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0, l=sNodes.length; i<l; i++) {\n\t\t\t\t\tif (tmpMap[sNodes[i][parentKey]] && sNodes[i][key] != sNodes[i][parentKey]) {\n\t\t\t\t\t\tif (!tmpMap[sNodes[i][parentKey]][childKey])\n\t\t\t\t\t\t\ttmpMap[sNodes[i][parentKey]][childKey] = [];\n\t\t\t\t\t\ttmpMap[sNodes[i][parentKey]][childKey].push(sNodes[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr.push(sNodes[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}else {\n\t\t\t\treturn [sNodes];\n\t\t\t}\n\t\t}\n\t},\n\t//method of event proxy\n\tevent = {\n\t\tbindEvent: function(setting) {\n\t\t\tfor (var i=0, j=_init.bind.length; i<j; i++) {\n\t\t\t\t_init.bind[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tunbindEvent: function(setting) {\n\t\t\tfor (var i=0, j=_init.unbind.length; i<j; i++) {\n\t\t\t\t_init.unbind[i].apply(this, arguments);\n\t\t\t}\n\t\t},\n\t\tbindTree: function(setting) {\n\t\t\tvar eventParam = {\n\t\t\t\ttreeId: setting.treeId\n\t\t\t},\n\t\t\to = setting.treeObj;\n\t\t\tif (!setting.view.txtSelectedEnable) {\n\t\t\t\t// for can\'t select text\n\t\t\t\to.bind(\'selectstart\', function(e){\n\t\t\t\t\tvar node\n\t\t\t\t\tvar n = e.originalEvent.srcElement.nodeName.toLowerCase();\n\t\t\t\t\treturn (n === "input" || n === "textarea" );\n\t\t\t\t}).css({\n\t\t\t\t\t"-moz-user-select":"-moz-none"\n\t\t\t\t});\n\t\t\t}\n\t\t\to.bind(\'click\', eventParam, event.proxy);\n\t\t\to.bind(\'dblclick\', eventParam, event.proxy);\n\t\t\to.bind(\'mouseover\', eventParam, event.proxy);\n\t\t\to.bind(\'mouseout\', eventParam, event.proxy);\n\t\t\to.bind(\'mousedown\', eventParam, event.proxy);\n\t\t\to.bind(\'mouseup\', eventParam, event.proxy);\n\t\t\to.bind(\'contextmenu\', eventParam, event.proxy);\n\t\t},\n\t\tunbindTree: function(setting) {\n\t\t\tvar o = setting.treeObj;\n\t\t\to.unbind(\'click\', event.proxy)\n\t\t\t.unbind(\'dblclick\', event.proxy)\n\t\t\t.unbind(\'mouseover\', event.proxy)\n\t\t\t.unbind(\'mouseout\', event.proxy)\n\t\t\t.unbind(\'mousedown\', event.proxy)\n\t\t\t.unbind(\'mouseup\', event.proxy)\n\t\t\t.unbind(\'contextmenu\', event.proxy);\n\t\t},\n\t\tdoProxy: function(e) {\n\t\t\tvar results = [];\n\t\t\tfor (var i=0, j=_init.proxys.length; i<j; i++) {\n\t\t\t\tvar proxyResult = _init.proxys[i].apply(this, arguments);\n\t\t\t\tresults.push(proxyResult);\n\t\t\t\tif (proxyResult.stop) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t},\n\t\tproxy: function(e) {\n\t\t\tvar setting = data.getSetting(e.data.treeId);\n\t\t\tif (!tools.uCanDo(setting, e)) return true;\n\t\t\tvar results = event.doProxy(e),\n\t\t\tr = true, x = false;\n\t\t\tfor (var i=0, l=results.length; i<l; i++) {\n\t\t\t\tvar proxyResult = results[i];\n\t\t\t\tif (proxyResult.nodeEventCallback) {\n\t\t\t\t\tx = true;\n\t\t\t\t\tr = proxyResult.nodeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;\n\t\t\t\t}\n\t\t\t\tif (proxyResult.treeEventCallback) {\n\t\t\t\t\tx = true;\n\t\t\t\t\tr = proxyResult.treeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t},\n\t//method of event handler\n\thandler = {\n\t\tonSwitchNode: function (event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId);\n\t\t\tif (node.open) {\n\t\t\t\tif (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false) return true;\n\t\t\t\tdata.getRoot(setting).expandTriggerFlag = true;\n\t\t\t\tview.switchNode(setting, node);\n\t\t\t} else {\n\t\t\t\tif (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false) return true;\n\t\t\t\tdata.getRoot(setting).expandTriggerFlag = true;\n\t\t\t\tview.switchNode(setting, node);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tonClickNode: function (event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId),\n\t\t\tclickFlag = ( (setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey)) && data.isSelectedNode(setting, node)) ? 0 : (setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey) && setting.view.selectedMulti) ? 2 : 1;\n\t\t\tif (tools.apply(setting.callback.beforeClick, [setting.treeId, node, clickFlag], true) == false) return true;\n\t\t\tif (clickFlag === 0) {\n\t\t\t\tview.cancelPreSelectedNode(setting, node);\n\t\t\t} else {\n\t\t\t\tview.selectNode(setting, node, clickFlag === 2);\n\t\t\t}\n\t\t\tsetting.treeObj.trigger(consts.event.CLICK, [event, setting.treeId, node, clickFlag]);\n\t\t\treturn true;\n\t\t},\n\t\tonZTreeMousedown: function(event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId);\n\t\t\tif (tools.apply(setting.callback.beforeMouseDown, [setting.treeId, node], true)) {\n\t\t\t\ttools.apply(setting.callback.onMouseDown, [event, setting.treeId, node]);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tonZTreeMouseup: function(event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId);\n\t\t\tif (tools.apply(setting.callback.beforeMouseUp, [setting.treeId, node], true)) {\n\t\t\t\ttools.apply(setting.callback.onMouseUp, [event, setting.treeId, node]);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tonZTreeDblclick: function(event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId);\n\t\t\tif (tools.apply(setting.callback.beforeDblClick, [setting.treeId, node], true)) {\n\t\t\t\ttools.apply(setting.callback.onDblClick, [event, setting.treeId, node]);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tonZTreeContextmenu: function(event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId);\n\t\t\tif (tools.apply(setting.callback.beforeRightClick, [setting.treeId, node], true)) {\n\t\t\t\ttools.apply(setting.callback.onRightClick, [event, setting.treeId, node]);\n\t\t\t}\n\t\t\treturn (typeof setting.callback.onRightClick) != "function";\n\t\t}\n\t},\n\t//method of tools for zTree\n\ttools = {\n\t\tapply: function(fun, param, defaultValue) {\n\t\t\tif ((typeof fun) == "function") {\n\t\t\t\treturn fun.apply(zt, param?param:[]);\n\t\t\t}\n\t\t\treturn defaultValue;\n\t\t},\n\t\tcanAsync: function(setting, node) {\n\t\t\tvar childKey = setting.data.key.children;\n\t\t\treturn (setting.async.enable && node && node.isParent && !(node.zAsync || (node[childKey] && node[childKey].length > 0)));\n\t\t},\n\t\tclone: function (obj){\n\t\t\tif (obj === null) return null;\n\t\t\tvar o = tools.isArray(obj) ? [] : {};\n\t\t\tfor(var i in obj){\n\t\t\t\to[i] = (obj[i] instanceof Date) ? new Date(obj[i].getTime()) : (typeof obj[i] === "object" ? arguments.callee(obj[i]) : obj[i]);\n\t\t\t}\n\t\t\treturn o;\n\t\t},\n\t\teqs: function(str1, str2) {\n\t\t\treturn str1.toLowerCase() === str2.toLowerCase();\n\t\t},\n\t\tisArray: function(arr) {\n\t\t\treturn Object.prototype.toString.apply(arr) === "[object Array]";\n\t\t},\n\t\t$: function(node, exp, setting) {\n\t\t\tif (!!exp && typeof exp != "string") {\n\t\t\t\tsetting = exp;\n\t\t\t\texp = "";\n\t\t\t}\n\t\t\tif (typeof node == "string") {\n\t\t\t\treturn $(node, setting ? setting.treeObj.get(0).ownerDocument : null);\n\t\t\t} else {\n\t\t\t\treturn $("#" + node.tId + exp, setting ? setting.treeObj : null);\n\t\t\t}\n\t\t},\n\t\tgetMDom: function (setting, curDom, targetExpr) {\n\t\t\tif (!curDom) return null;\n\t\t\twhile (curDom && curDom.id !== setting.treeId) {\n\t\t\t\tfor (var i=0, l=targetExpr.length; curDom.tagName && i<l; i++) {\n\t\t\t\t\tif (tools.eqs(curDom.tagName, targetExpr[i].tagName) && curDom.getAttribute(targetExpr[i].attrName) !== null) {\n\t\t\t\t\t\treturn curDom;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurDom = curDom.parentNode;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tgetNodeMainDom:function(target) {\n\t\t\treturn ($(target).parent("li").get(0) || $(target).parentsUntil("li").parent().get(0));\n\t\t},\n\t\tisChildOrSelf: function(dom, parentId) {\n\t\t\treturn ( $(dom).closest("#" + parentId).length> 0 );\n\t\t},\n\t\tuCanDo: function(setting, e) {\n\t\t\treturn true;\n\t\t}\n\t},\n\t//method of operate ztree dom\n\tview = {\n\t\taddNodes: function(setting, parentNode, newNodes, isSilent) {\n\t\t\tif (setting.data.keep.leaf && parentNode && !parentNode.isParent) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!tools.isArray(newNodes)) {\n\t\t\t\tnewNodes = [newNodes];\n\t\t\t}\n\t\t\tif (setting.data.simpleData.enable) {\n\t\t\t\tnewNodes = data.transformTozTreeFormat(setting, newNodes);\n\t\t\t}\n\t\t\tif (parentNode) {\n\t\t\t\tvar target_switchObj = $$(parentNode, consts.id.SWITCH, setting),\n\t\t\t\ttarget_icoObj = $$(parentNode, consts.id.ICON, setting),\n\t\t\t\ttarget_ulObj = $$(parentNode, consts.id.UL, setting);\n\n\t\t\t\tif (!parentNode.open) {\n\t\t\t\t\tview.replaceSwitchClass(parentNode, target_switchObj, consts.folder.CLOSE);\n\t\t\t\t\tview.replaceIcoClass(parentNode, target_icoObj, consts.folder.CLOSE);\n\t\t\t\t\tparentNode.open = false;\n\t\t\t\t\ttarget_ulObj.css({\n\t\t\t\t\t\t"display": "none"\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tdata.addNodesData(setting, parentNode, newNodes);\n\t\t\t\tview.createNodes(setting, parentNode.level + 1, newNodes, parentNode);\n\t\t\t\tif (!isSilent) {\n\t\t\t\t\tview.expandCollapseParentNode(setting, parentNode, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata.addNodesData(setting, data.getRoot(setting), newNodes);\n\t\t\t\tview.createNodes(setting, 0, newNodes, null);\n\t\t\t}\n\t\t},\n\t\tappendNodes: function(setting, level, nodes, parentNode, initFlag, openFlag) {\n\t\t\tif (!nodes) return [];\n\t\t\tvar html = [],\n\t\t\tchildKey = setting.data.key.children;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar node = nodes[i];\n\t\t\t\tif (initFlag) {\n\t\t\t\t\tvar tmpPNode = (parentNode) ? parentNode: data.getRoot(setting),\n\t\t\t\t\ttmpPChild = tmpPNode[childKey],\n\t\t\t\t\tisFirstNode = ((tmpPChild.length == nodes.length) && (i == 0)),\n\t\t\t\t\tisLastNode = (i == (nodes.length - 1));\n\t\t\t\t\tdata.initNode(setting, level, node, parentNode, isFirstNode, isLastNode, openFlag);\n\t\t\t\t\tdata.addNodeCache(setting, node);\n\t\t\t\t}\n\n\t\t\t\tvar childHtml = [];\n\t\t\t\tif (node[childKey] && node[childKey].length > 0) {\n\t\t\t\t\t//make child html first, because checkType\n\t\t\t\t\tchildHtml = view.appendNodes(setting, level + 1, node[childKey], node, initFlag, openFlag && node.open);\n\t\t\t\t}\n\t\t\t\tif (openFlag) {\n\n\t\t\t\t\tview.makeDOMNodeMainBefore(html, setting, node);\n\t\t\t\t\tview.makeDOMNodeLine(html, setting, node);\n\t\t\t\t\tdata.getBeforeA(setting, node, html);\n\t\t\t\t\tview.makeDOMNodeNameBefore(html, setting, node);\n\t\t\t\t\tdata.getInnerBeforeA(setting, node, html);\n\t\t\t\t\tview.makeDOMNodeIcon(html, setting, node);\n\t\t\t\t\tdata.getInnerAfterA(setting, node, html);\n\t\t\t\t\tview.makeDOMNodeNameAfter(html, setting, node);\n\t\t\t\t\tdata.getAfterA(setting, node, html);\n\t\t\t\t\tif (node.isParent && node.open) {\n\t\t\t\t\t\tview.makeUlHtml(setting, node, html, childHtml.join(\'\'));\n\t\t\t\t\t}\n\t\t\t\t\tview.makeDOMNodeMainAfter(html, setting, node);\n\t\t\t\t\tdata.addCreatedNode(setting, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn html;\n\t\t},\n\t\tappendParentULDom: function(setting, node) {\n\t\t\tvar html = [],\n\t\t\tnObj = $$(node, setting);\n\t\t\tif (!nObj.get(0) && !!node.parentTId) {\n\t\t\t\tview.appendParentULDom(setting, node.getParentNode());\n\t\t\t\tnObj = $$(node, setting);\n\t\t\t}\n\t\t\tvar ulObj = $$(node, consts.id.UL, setting);\n\t\t\tif (ulObj.get(0)) {\n\t\t\t\tulObj.remove();\n\t\t\t}\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tchildHtml = view.appendNodes(setting, node.level+1, node[childKey], node, false, true);\n\t\t\tview.makeUlHtml(setting, node, html, childHtml.join(\'\'));\n\t\t\tnObj.append(html.join(\'\'));\n\t\t},\n\t\tasyncNode: function(setting, node, isSilent, callback) {\n\t\t\tvar i, l;\n\t\t\tif (node && !node.isParent) {\n\t\t\t\ttools.apply(callback);\n\t\t\t\treturn false;\n\t\t\t} else if (node && node.isAjaxing) {\n\t\t\t\treturn false;\n\t\t\t} else if (tools.apply(setting.callback.beforeAsync, [setting.treeId, node], true) == false) {\n\t\t\t\ttools.apply(callback);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (node) {\n\t\t\t\tnode.isAjaxing = true;\n\t\t\t\tvar icoObj = $$(node, consts.id.ICON, setting);\n\t\t\t\ticoObj.attr({"style":"", "class":consts.className.BUTTON + " " + consts.className.ICO_LOADING});\n\t\t\t}\n\n\t\t\tvar tmpParam = {};\n\t\t\tfor (i = 0, l = setting.async.autoParam.length; node && i < l; i++) {\n\t\t\t\tvar pKey = setting.async.autoParam[i].split("="), spKey = pKey;\n\t\t\t\tif (pKey.length>1) {\n\t\t\t\t\tspKey = pKey[1];\n\t\t\t\t\tpKey = pKey[0];\n\t\t\t\t}\n\t\t\t\ttmpParam[spKey] = node[pKey];\n\t\t\t}\n\t\t\tif (tools.isArray(setting.async.otherParam)) {\n\t\t\t\tfor (i = 0, l = setting.async.otherParam.length; i < l; i += 2) {\n\t\t\t\t\ttmpParam[setting.async.otherParam[i]] = setting.async.otherParam[i + 1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var p in setting.async.otherParam) {\n\t\t\t\t\ttmpParam[p] = setting.async.otherParam[p];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar _tmpV = data.getRoot(setting)._ver;\n\t\t\t$.ajax({\n\t\t\t\tcontentType: setting.async.contentType,\n\t\t\t\ttype: setting.async.type,\n\t\t\t\turl: tools.apply(setting.async.url, [setting.treeId, node], setting.async.url),\n\t\t\t\tdata: tmpParam,\n\t\t\t\tdataType: setting.async.dataType,\n\t\t\t\tsuccess: function(msg) {\n\t\t\t\t\tif (_tmpV != data.getRoot(setting)._ver) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar newNodes = [];\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!msg || msg.length == 0) {\n\t\t\t\t\t\t\tnewNodes = [];\n\t\t\t\t\t\t} else if (typeof msg == "string") {\n\t\t\t\t\t\t\tnewNodes = eval("(" + msg + ")");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewNodes = msg;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(err) {\n\t\t\t\t\t\tnewNodes = msg;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnode.isAjaxing = null;\n\t\t\t\t\t\tnode.zAsync = true;\n\t\t\t\t\t}\n\t\t\t\t\tview.setNodeLineIcos(setting, node);\n\t\t\t\t\tif (newNodes && newNodes !== "") {\n\t\t\t\t\t\tnewNodes = tools.apply(setting.async.dataFilter, [setting.treeId, node, newNodes], newNodes);\n\t\t\t\t\t\tview.addNodes(setting, node, !!newNodes ? tools.clone(newNodes) : [], !!isSilent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tview.addNodes(setting, node, [], !!isSilent);\n\t\t\t\t\t}\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.ASYNC_SUCCESS, [setting.treeId, node, msg]);\n\t\t\t\t\ttools.apply(callback);\n\t\t\t\t},\n\t\t\t\terror: function(XMLHttpRequest, textStatus, errorThrown) {\n\t\t\t\t\tif (_tmpV != data.getRoot(setting)._ver) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (node) node.isAjaxing = null;\n\t\t\t\t\tview.setNodeLineIcos(setting, node);\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.ASYNC_ERROR, [setting.treeId, node, XMLHttpRequest, textStatus, errorThrown]);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\tcancelPreSelectedNode: function (setting, node) {\n\t\t\tvar list = data.getRoot(setting).curSelectedList;\n\t\t\tfor (var i=0, j=list.length-1; j>=i; j--) {\n\t\t\t\tif (!node || node === list[j]) {\n\t\t\t\t\t$$(list[j], consts.id.A, setting).removeClass(consts.node.CURSELECTED);\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tdata.removeSelectedNode(setting, node);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!node) data.getRoot(setting).curSelectedList = [];\n\t\t},\n\t\tcreateNodeCallback: function(setting) {\n\t\t\tif (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {\n\t\t\t\tvar root = data.getRoot(setting);\n\t\t\t\twhile (root.createdNodes.length>0) {\n\t\t\t\t\tvar node = root.createdNodes.shift();\n\t\t\t\t\ttools.apply(setting.view.addDiyDom, [setting.treeId, node]);\n\t\t\t\t\tif (!!setting.callback.onNodeCreated) {\n\t\t\t\t\t\tsetting.treeObj.trigger(consts.event.NODECREATED, [setting.treeId, node]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcreateNodes: function(setting, level, nodes, parentNode) {\n\t\t\tif (!nodes || nodes.length == 0) return;\n\t\t\tvar root = data.getRoot(setting),\n\t\t\tchildKey = setting.data.key.children,\n\t\t\topenFlag = !parentNode || parentNode.open || !!$$(parentNode[childKey][0], setting).get(0);\n\t\t\troot.createdNodes = [];\n\t\t\tvar zTreeHtml = view.appendNodes(setting, level, nodes, parentNode, true, openFlag);\n\t\t\tif (!parentNode) {\n\t\t\t\tsetting.treeObj.append(zTreeHtml.join(\'\'));\n\t\t\t} else {\n\t\t\t\tvar ulObj = $$(parentNode, consts.id.UL, setting);\n\t\t\t\tif (ulObj.get(0)) {\n\t\t\t\t\tulObj.append(zTreeHtml.join(\'\'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tview.createNodeCallback(setting);\n\t\t},\n\t\tdestroy: function(setting) {\n\t\t\tif (!setting) return;\n\t\t\tdata.initCache(setting);\n\t\t\tdata.initRoot(setting);\n\t\t\tevent.unbindTree(setting);\n\t\t\tevent.unbindEvent(setting);\n\t\t\tsetting.treeObj.empty();\n\t\t\tdelete settings[setting.treeId];\n\t\t},\n\t\texpandCollapseNode: function(setting, node, expandFlag, animateFlag, callback) {\n\t\t\tvar root = data.getRoot(setting),\n\t\t\tchildKey = setting.data.key.children;\n\t\t\tif (!node) {\n\t\t\t\ttools.apply(callback, []);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (root.expandTriggerFlag) {\n\t\t\t\tvar _callback = callback;\n\t\t\t\tcallback = function(){\n\t\t\t\t\tif (_callback) _callback();\n\t\t\t\t\tif (node.open) {\n\t\t\t\t\t\tsetting.treeObj.trigger(consts.event.EXPAND, [setting.treeId, node]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetting.treeObj.trigger(consts.event.COLLAPSE, [setting.treeId, node]);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\troot.expandTriggerFlag = false;\n\t\t\t}\n\t\t\tif (!node.open && node.isParent && ((!$$(node, consts.id.UL, setting).get(0)) || (node[childKey] && node[childKey].length>0 && !$$(node[childKey][0], setting).get(0)))) {\n\t\t\t\tview.appendParentULDom(setting, node);\n\t\t\t\tview.createNodeCallback(setting);\n\t\t\t}\n\t\t\tif (node.open == expandFlag) {\n\t\t\t\ttools.apply(callback, []);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar ulObj = $$(node, consts.id.UL, setting),\n\t\t\tswitchObj = $$(node, consts.id.SWITCH, setting),\n\t\t\ticoObj = $$(node, consts.id.ICON, setting);\n\n\t\t\tif (node.isParent) {\n\t\t\t\tnode.open = !node.open;\n\t\t\t\tif (node.iconOpen && node.iconClose) {\n\t\t\t\t\ticoObj.attr("style", view.makeNodeIcoStyle(setting, node));\n\t\t\t\t\t//zxh add\n\t\t\t\t\t//icoObj.attr("class", view.makeNodeIcoClass(setting, node));\n\t\t\t\t}\n\n\t\t\t\tif (node.open) {\n\t\t\t\t\tview.replaceSwitchClass(node, switchObj, consts.folder.OPEN);\n\t\t\t\t\tview.replaceIcoClass(node, icoObj, consts.folder.OPEN);\n\t\t\t\t\tif (animateFlag == false || setting.view.expandSpeed == "") {\n\t\t\t\t\t\tulObj.show();\n\t\t\t\t\t\ttools.apply(callback, []);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (node[childKey] && node[childKey].length > 0) {\n\t\t\t\t\t\t\tulObj.slideDown(setting.view.expandSpeed, callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tulObj.show();\n\t\t\t\t\t\t\ttools.apply(callback, []);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(switchObj.hasClass("center_open")){\n\t\t\t\t\t\tswitchObj.css("margin","12px 0 -2px 1px");\n\t\t\t\t\t\twindow.setTimeout(function(){\n\t\t\t\t\t\t\tswitchObj.removeAttr("style");\n\t\t\t\t\t\t},100);\n\t\t\t\t\t}\n\t\t\t\t\tview.replaceSwitchClass(node, switchObj, consts.folder.CLOSE);\n\t\t\t\t\tview.replaceIcoClass(node, icoObj, consts.folder.CLOSE);\n\t\t\t\t\tif (animateFlag == false || setting.view.expandSpeed == "" || !(node[childKey] && node[childKey].length > 0)) {\n\t\t\t\t\t\tulObj.hide();\n\t\t\t\t\t\ttools.apply(callback, []);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tulObj.slideUp(setting.view.expandSpeed, callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttools.apply(callback, []);\n\t\t\t}\n\t\t},\n\t\texpandCollapseParentNode: function(setting, node, expandFlag, animateFlag, callback) {\n\t\t\tif (!node) return;\n\t\t\tif (!node.parentTId) {\n\t\t\t\tview.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tview.expandCollapseNode(setting, node, expandFlag, animateFlag);\n\t\t\t}\n\t\t\tif (node.parentTId) {\n\t\t\t\tview.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, animateFlag, callback);\n\t\t\t}\n\t\t},\n\t\texpandCollapseSonNode: function(setting, node, expandFlag, animateFlag, callback) {\n\t\t\tvar root = data.getRoot(setting),\n\t\t\tchildKey = setting.data.key.children,\n\t\t\ttreeNodes = (node) ? node[childKey]: root[childKey],\n\t\t\tselfAnimateSign = (node) ? false : animateFlag,\n\t\t\texpandTriggerFlag = data.getRoot(setting).expandTriggerFlag;\n\t\t\tdata.getRoot(setting).expandTriggerFlag = false;\n\t\t\tif (treeNodes) {\n\t\t\t\tfor (var i = 0, l = treeNodes.length; i < l; i++) {\n\t\t\t\t\tif (treeNodes[i]) view.expandCollapseSonNode(setting, treeNodes[i], expandFlag, selfAnimateSign);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata.getRoot(setting).expandTriggerFlag = expandTriggerFlag;\n\t\t\tview.expandCollapseNode(setting, node, expandFlag, animateFlag, callback );\n\t\t},\n\t\tmakeDOMNodeIcon: function(html, setting, node) {\n\t\t\tvar nameStr = data.getNodeName(setting, node),\n\t\t\tname = setting.view.nameIsHTML ? nameStr : nameStr.replace(/&/g,\'&amp;\').replace(/</g,\'&lt;\').replace(/>/g,\'&gt;\');\n\t\t\thtml.push("<span id=\'", node.tId, consts.id.ICON,\n\t\t\t\t"\' title=\'\' treeNode", consts.id.ICON," class=\'", view.makeNodeIcoClass(setting, node),\n\t\t\t\t"\' style=\'", view.makeNodeIcoStyle(setting, node), "\'></span><span id=\'", node.tId, consts.id.SPAN,\n\t\t\t\t"\'>",name,"</span>");\n\t\t},\n\t\tmakeDOMNodeLine: function(html, setting, node) {\n\t\t\thtml.push("<span id=\'", node.tId, consts.id.SWITCH,\t"\' title=\'\' class=\'", view.makeNodeLineClass(setting, node), "\' treeNode", consts.id.SWITCH,"></span>");\n\t\t},\n\t\tmakeDOMNodeMainAfter: function(html, setting, node) {\n\t\t\thtml.push("</li>");\n\t\t},\n\t\tmakeDOMNodeMainBefore: function(html, setting, node) {\n\t\t\thtml.push("<li id=\'", node.tId, "\' class=\'", consts.className.LEVEL, node.level,"\' tabindex=\'0\' hidefocus=\'true\' treenode>");\n\t\t},\n\t\tmakeDOMNodeNameAfter: function(html, setting, node) {\n\t\t\thtml.push("</a>");\n\t\t},\n\t\tmakeDOMNodeNameBefore: function(html, setting, node) {\n\t\t\tvar title = data.getNodeTitle(setting, node),\n\t\t\turl = view.makeNodeUrl(setting, node),\n\t\t\tfontcss = view.makeNodeFontCss(setting, node),\n\t\t\tfontStyle = [];\n\t\t\tfor (var f in fontcss) {\n\t\t\t\tfontStyle.push(f, ":", fontcss[f], ";");\n\t\t\t}\n\t\t\thtml.push("<a id=\'", node.tId, consts.id.A, "\' class=\'", consts.className.LEVEL, node.level,"\' treeNode", consts.id.A," onclick=\\"", (node.click || \'\'),\n\t\t\t\t"\\" ", ((url != null && url.length > 0) ? "href=\'" + url + "\'" : ""), " target=\'",view.makeNodeTarget(node),"\' style=\'", fontStyle.join(\'\'),\n\t\t\t\t"\'");\n\t\t\tif (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle) && title) {html.push("title=\'", title.replace(/\'/g,"&#39;").replace(/</g,\'&lt;\').replace(/>/g,\'&gt;\'),"\'");}\n\t\t\thtml.push(">");\n\t\t},\n\t\tmakeNodeFontCss: function(setting, node) {\n\t\t\tvar fontCss = tools.apply(setting.view.fontCss, [setting.treeId, node], setting.view.fontCss);\n\t\t\treturn (fontCss && ((typeof fontCss) != "function")) ? fontCss : {};\n\t\t},\n\t\tmakeNodeIcoClass: function(setting, node) {\n\t\t\tvar icoCss = ["ico"],iconFont= [],iconJustify=\'\',showIconFont=setting.view.showIconFont?true:false ;\n\t\t\t//zxh add\n\t\t\tif (!node.isAjaxing) {\n\t\t\t\tif (node.isParent)\n\t\t\t\t\ticonJustify = node.open ? consts.folder.OPEN : consts.folder.CLOSE;\n\t\t\t\telse\n\t\t\t\t\ticonJustify =  consts.folder.DOCU;\n\t\t\t\t\n\t\t\t\tif(showIconFont){\n\t\t\t\t\ticoCss = [];\n\t\t\t\t\t//增加字体\n\t\t\t\t\tvar icon = (node.isParent && node.iconOpen && node.iconClose) ? (node.open ? node.iconOpen : node.iconClose) : node.icon;\n\t\t\t\t\tif(icon)\n\t\t\t\t\t\ticonFont.push(icon);\n\t\t\t\t\telse\n\t\t\t\t\t\ticonFont[0] = (node.iconSkin ? node.iconSkin + "_" : "ico_") + iconJustify;\n\t\t\t\t\ticonFont.push(\'fa_justify_\'+iconJustify);\n\t\t\t\t\tif (setting.view.showIcon == false || !tools.apply(setting.view.showIcon, [setting.treeId, node], true)) \n\t\t\t\t\t\ticonFont =[];\n\t\t\t\t}else{\n\t\t\t\t\ticoCss[0] = (node.iconSkin ? node.iconSkin + "_" : "") + icoCss[0];\n\t\t\t\t\ticoCss.push(iconJustify);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn consts.className.BUTTON + " " + icoCss.join(\'_\')+" "+ iconFont.join(\' \') ;\n\t\t},\n\t\tmakeNodeIcoStyle: function(setting, node) {\n\t\t\tvar icoStyle = [],showIconFont=setting.view.showIconFont?true:false;\n\t\t\tif (!node.isAjaxing) {\n\t\t\t\tvar icon = (node.isParent && node.iconOpen && node.iconClose) ? (node.open ? node.iconOpen : node.iconClose) : node.icon;\n\t\t\t\tif (icon && !showIconFont) icoStyle.push("background:url(", icon, ") 0 0 no-repeat;");\n\t\t\t\t\n\t\t\t\tif (setting.view.showIcon == false || !tools.apply(setting.view.showIcon, [setting.treeId, node], true)) {\n\t\t\t\t\ticoStyle.push("width:0px;height:0px;");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn icoStyle.join(\'\');\n\t\t},\n\t\tmakeNodeLineClass: function(setting, node) {\n\t\t\tvar lineClass = [];\n\t\t\tif (setting.view.showLine) {\n\t\t\t\tif (node.level == 0 && node.isFirstNode && node.isLastNode) {\n\t\t\t\t\tlineClass.push(consts.line.ROOT);\n\t\t\t\t} else if (node.level == 0 && node.isFirstNode) {\n\t\t\t\t\tlineClass.push(consts.line.ROOTS);\n\t\t\t\t} else if (node.isLastNode) {\n\t\t\t\t\tlineClass.push(consts.line.BOTTOM);\n\t\t\t\t} else {\n\t\t\t\t\tlineClass.push(consts.line.CENTER);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineClass.push(consts.line.NOLINE);\n\t\t\t}\n\t\t\tif (node.isParent) {\n\t\t\t\tlineClass.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);\n\t\t\t} else {\n\t\t\t\tlineClass.push(consts.folder.DOCU);\n\t\t\t}\n\t\t\treturn view.makeNodeLineClassEx(node) + lineClass.join(\'_\');\n\t\t},\n\t\tmakeNodeLineClassEx: function(node) {\n\t\t\treturn consts.className.BUTTON + " " + consts.className.LEVEL + node.level + " " + consts.className.SWITCH + " ";\n\t\t},\n\t\tmakeNodeTarget: function(node) {\n\t\t\treturn (node.target || "_blank");\n\t\t},\n\t\tmakeNodeUrl: function(setting, node) {\n\t\t\tvar urlKey = setting.data.key.url;\n\t\t\treturn node[urlKey] ? node[urlKey] : null;\n\t\t},\n\t\tmakeUlHtml: function(setting, node, html, content) {\n\t\t\thtml.push("<ul id=\'", node.tId, consts.id.UL, "\' class=\'", consts.className.LEVEL, node.level, " ", view.makeUlLineClass(setting, node), "\' style=\'display:", (node.open ? "block": "none"),"\'>");\n\t\t\thtml.push(content);\n\t\t\thtml.push("</ul>");\n\t\t},\n\t\tmakeUlLineClass: function(setting, node) {\n\t\t\treturn ((setting.view.showLine && !node.isLastNode) ? consts.line.LINE : "");\n\t\t},\n\t\tremoveChildNodes: function(setting, node) {\n\t\t\tif (!node) return;\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tnodes = node[childKey];\n\t\t\tif (!nodes) return;\n\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tdata.removeNodeCache(setting, nodes[i]);\n\t\t\t}\n\t\t\tdata.removeSelectedNode(setting);\n\t\t\tdelete node[childKey];\n\n\t\t\tif (!setting.data.keep.parent) {\n\t\t\t\tnode.isParent = false;\n\t\t\t\tnode.open = false;\n\t\t\t\tvar tmp_switchObj = $$(node, consts.id.SWITCH, setting),\n\t\t\t\ttmp_icoObj = $$(node, consts.id.ICON, setting);\n\t\t\t\tview.replaceSwitchClass(node, tmp_switchObj, consts.folder.DOCU);\n\t\t\t\tview.replaceIcoClass(node, tmp_icoObj, consts.folder.DOCU);\n\t\t\t\t$$(node, consts.id.UL, setting).remove();\n\t\t\t} else {\n\t\t\t\t$$(node, consts.id.UL, setting).empty();\n\t\t\t}\n\t\t},\n\t\tsetFirstNode: function(setting, parentNode) {\n\t\t\tvar childKey = setting.data.key.children, childLength = parentNode[childKey].length;\n\t\t\tif ( childLength > 0) {\n\t\t\t\tparentNode[childKey][0].isFirstNode = true;\n\t\t\t}\n\t\t},\n\t\tsetLastNode: function(setting, parentNode) {\n\t\t\tvar childKey = setting.data.key.children, childLength = parentNode[childKey].length;\n\t\t\tif ( childLength > 0) {\n\t\t\t\tparentNode[childKey][childLength - 1].isLastNode = true;\n\t\t\t}\n\t\t},\n\t\tremoveNode: function(setting, node) {\n\t\t\tvar root = data.getRoot(setting),\n\t\t\tchildKey = setting.data.key.children,\n\t\t\tparentNode = (node.parentTId) ? node.getParentNode() : root;\n\n\t\t\tnode.isFirstNode = false;\n\t\t\tnode.isLastNode = false;\n\t\t\tnode.getPreNode = function() {return null;};\n\t\t\tnode.getNextNode = function() {return null;};\n\n\t\t\tif (!data.getNodeCache(setting, node.tId)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$$(node, setting).remove();\n\t\t\tdata.removeNodeCache(setting, node);\n\t\t\tdata.removeSelectedNode(setting, node);\n\n\t\t\tfor (var i = 0, l = parentNode[childKey].length; i < l; i++) {\n\t\t\t\tif (parentNode[childKey][i].tId == node.tId) {\n\t\t\t\t\tparentNode[childKey].splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tview.setFirstNode(setting, parentNode);\n\t\t\tview.setLastNode(setting, parentNode);\n\n\t\t\tvar tmp_ulObj,tmp_switchObj,tmp_icoObj,\n\t\t\tchildLength = parentNode[childKey].length;\n\n\t\t\t//repair nodes old parent\n\t\t\tif (!setting.data.keep.parent && childLength == 0) {\n\t\t\t\t//old parentNode has no child nodes\n\t\t\t\tparentNode.isParent = false;\n\t\t\t\tparentNode.open = false;\n\t\t\t\ttmp_ulObj = $$(parentNode, consts.id.UL, setting);\n\t\t\t\ttmp_switchObj = $$(parentNode, consts.id.SWITCH, setting);\n\t\t\t\ttmp_icoObj = $$(parentNode, consts.id.ICON, setting);\n\t\t\t\tview.replaceSwitchClass(parentNode, tmp_switchObj, consts.folder.DOCU);\n\t\t\t\tview.replaceIcoClass(parentNode, tmp_icoObj, consts.folder.DOCU);\n\t\t\t\ttmp_ulObj.css("display", "none");\n\n\t\t\t} else if (setting.view.showLine && childLength > 0) {\n\t\t\t\t//old parentNode has child nodes\n\t\t\t\tvar newLast = parentNode[childKey][childLength - 1];\n\t\t\t\ttmp_ulObj = $$(newLast, consts.id.UL, setting);\n\t\t\t\ttmp_switchObj = $$(newLast, consts.id.SWITCH, setting);\n\t\t\t\ttmp_icoObj = $$(newLast, consts.id.ICON, setting);\n\t\t\t\tif (parentNode == root) {\n\t\t\t\t\tif (parentNode[childKey].length == 1) {\n\t\t\t\t\t\t//node was root, and ztree has only one root after move node\n\t\t\t\t\t\tview.replaceSwitchClass(newLast, tmp_switchObj, consts.line.ROOT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar tmp_first_switchObj = $$(parentNode[childKey][0], consts.id.SWITCH, setting);\n\t\t\t\t\t\tview.replaceSwitchClass(parentNode[childKey][0], tmp_first_switchObj, consts.line.ROOTS);\n\t\t\t\t\t\tview.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tview.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);\n\t\t\t\t}\n\t\t\t\ttmp_ulObj.removeClass(consts.line.LINE);\n\t\t\t}\n\t\t},\n\t\treplaceIcoClass: function(node, obj, newName) {\n\t\t\tif (!obj || node.isAjaxing) return;\n\t\t\tvar tmpName = obj.attr("class");\n\t\t\tif (tmpName == undefined) return;\n\t\t\tvar tmpList = tmpName.split("_");\n\t\t\tswitch (newName) {\n\t\t\t\tcase consts.folder.OPEN:\n\t\t\t\tcase consts.folder.CLOSE:\n\t\t\t\tcase consts.folder.DOCU:\n\t\t\t\t\ttmpList[tmpList.length-1] = newName;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tobj.attr("class", tmpList.join("_"));\n\t\t},\n\t\treplaceSwitchClass: function(node, obj, newName) {\n\t\t\tif (!obj) return;\n\t\t\tvar tmpName = obj.attr("class");\n\t\t\tif (tmpName == undefined) return;\n\t\t\tvar tmpList = tmpName.split("_");\n\t\t\tswitch (newName) {\n\t\t\t\tcase consts.line.ROOT:\n\t\t\t\tcase consts.line.ROOTS:\n\t\t\t\tcase consts.line.CENTER:\n\t\t\t\tcase consts.line.BOTTOM:\n\t\t\t\tcase consts.line.NOLINE:\n\t\t\t\t\ttmpList[0] = view.makeNodeLineClassEx(node) + newName;\n\t\t\t\t\tbreak;\n\t\t\t\tcase consts.folder.OPEN:\n\t\t\t\tcase consts.folder.CLOSE:\n\t\t\t\tcase consts.folder.DOCU:\n\t\t\t\t\ttmpList[1] = newName;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tobj.attr("class", tmpList.join("_"));\n\t\t\tif (newName !== consts.folder.DOCU) {\n\t\t\t\tobj.removeAttr("disabled");\n\t\t\t} else {\n\t\t\t\tobj.attr("disabled", "disabled");\n\t\t\t}\n\t\t},\n\t\tselectNode: function(setting, node, addFlag) {\n\t\t\tif (!addFlag) {\n\t\t\t\tview.cancelPreSelectedNode(setting);\n\t\t\t}\n\t\t\tvar currentSelectA = $$(node, consts.id.A, setting);\n\t\t\tcurrentSelectA.addClass(consts.node.CURSELECTED);\n\t\t\tif(currentSelectA.prev("span").hasClass("center_close")){\n\t\t\t\t$("."+consts.node.SELECTLI).removeClass(consts.node.SELECTLI);\n\t\t\t\tcurrentSelectA.parent().addClass(consts.node.SELECTLI);\n\t\t\t}\n\t\t\tdata.addSelectedNode(setting, node);\n\t\t},\n\t\tsetNodeFontCss: function(setting, treeNode) {\n\t\t\tvar aObj = $$(treeNode, consts.id.A, setting),\n\t\t\tfontCss = view.makeNodeFontCss(setting, treeNode);\n\t\t\tif (fontCss) {\n\t\t\t\taObj.css(fontCss);\n\t\t\t}\n\t\t},\n\t\tsetNodeLineIcos: function(setting, node) {\n\t\t\tif (!node) return;\n\t\t\tvar switchObj = $$(node, consts.id.SWITCH, setting),\n\t\t\tulObj = $$(node, consts.id.UL, setting),\n\t\t\ticoObj = $$(node, consts.id.ICON, setting),\n\t\t\tulLine = view.makeUlLineClass(setting, node);\n\t\t\tif (ulLine.length==0) {\n\t\t\t\tulObj.removeClass(consts.line.LINE);\n\t\t\t} else {\n\t\t\t\tulObj.addClass(ulLine);\n\t\t\t}\n\t\t\tswitchObj.attr("class", view.makeNodeLineClass(setting, node));\n\t\t\tif (node.isParent) {\n\t\t\t\tswitchObj.removeAttr("disabled");\n\t\t\t} else {\n\t\t\t\tswitchObj.attr("disabled", "disabled");\n\t\t\t}\n\t\t\ticoObj.removeAttr("style");\n\t\t\ticoObj.attr("style", view.makeNodeIcoStyle(setting, node));\n\t\t\ticoObj.attr("class", view.makeNodeIcoClass(setting, node));\n\t\t},\n\t\tsetNodeName: function(setting, node) {\n\t\t\tvar title = data.getNodeTitle(setting, node),\n\t\t\tnObj = $$(node, consts.id.SPAN, setting);\n\t\t\tnObj.empty();\n\t\t\tif (setting.view.nameIsHTML) {\n\t\t\t\tnObj.html(data.getNodeName(setting, node));\n\t\t\t} else {\n\t\t\t\tnObj.text(data.getNodeName(setting, node));\n\t\t\t}\n\t\t\tif (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle)) {\n\t\t\t\tvar aObj = $$(node, consts.id.A, setting);\n\t\t\t\taObj.attr("title", !title ? "" : title);\n\t\t\t}\n\t\t},\n\t\tsetNodeTarget: function(setting, node) {\n\t\t\tvar aObj = $$(node, consts.id.A, setting);\n\t\t\taObj.attr("target", view.makeNodeTarget(node));\n\t\t},\n\t\tsetNodeUrl: function(setting, node) {\n\t\t\tvar aObj = $$(node, consts.id.A, setting),\n\t\t\turl = view.makeNodeUrl(setting, node);\n\t\t\tif (url == null || url.length == 0) {\n\t\t\t\taObj.removeAttr("href");\n\t\t\t} else {\n\t\t\t\taObj.attr("href", url);\n\t\t\t}\n\t\t},\n\t\tswitchNode: function(setting, node) {\n\t\t\tif (node.open || !tools.canAsync(setting, node)) {\n\t\t\t\tview.expandCollapseNode(setting, node, !node.open);\n\t\t\t} else if (setting.async.enable) {\n\t\t\t\tif (!view.asyncNode(setting, node)) {\n\t\t\t\t\tview.expandCollapseNode(setting, node, !node.open);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (node) {\n\t\t\t\tview.expandCollapseNode(setting, node, !node.open);\n\t\t\t}\n\t\t}\n\t};\n\t// zTree defind\n\t$.fn.zTree = {\n\t\tconsts : _consts,\n\t\t_z : {\n\t\t\ttools: tools,\n\t\t\tview: view,\n\t\t\tevent: event,\n\t\t\tdata: data\n\t\t},\n\t\tgetZTreeObj: function(treeId) {\n\t\t\tvar o = data.getZTreeTools(treeId);\n\t\t\treturn o ? o : null;\n\t\t},\n\t\tdestroy: function(treeId) {\n\t\t\tif (!!treeId && treeId.length > 0) {\n\t\t\t\tview.destroy(data.getSetting(treeId));\n\t\t\t} else {\n\t\t\t\tfor(var s in settings) {\n\t\t\t\t\tview.destroy(settings[s]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tinit: function(obj, zSetting, zNodes) {\n\t\t\tvar setting = tools.clone(_setting);\n\t\t\t$.extend(true, setting, zSetting);\n\t\t\tsetting.treeId = obj.attr("id");\n\t\t\tsetting.treeObj = obj;\n\t\t\tsetting.treeObj.empty();\n\t\t\tsettings[setting.treeId] = setting;\n\t\t\t//For some older browser,(e.g., ie6)\n\t\t\tif(typeof document.body.style.maxHeight === "undefined") {\n\t\t\t\tsetting.view.expandSpeed = "";\n\t\t\t}\n\t\t\tdata.initRoot(setting);\n\t\t\tvar root = data.getRoot(setting),\n\t\t\tchildKey = setting.data.key.children;\n\t\t\tzNodes = zNodes ? tools.clone(tools.isArray(zNodes)? zNodes : [zNodes]) : [];\n\t\t\tif (setting.data.simpleData.enable) {\n\t\t\t\troot[childKey] = data.transformTozTreeFormat(setting, zNodes);\n\t\t\t} else {\n\t\t\t\troot[childKey] = zNodes;\n\t\t\t}\n\n\t\t\tdata.initCache(setting);\n\t\t\tevent.unbindTree(setting);\n\t\t\tevent.bindTree(setting);\n\t\t\tevent.unbindEvent(setting);\n\t\t\tevent.bindEvent(setting);\n\n\t\t\tvar zTreeTools = {\n\t\t\t\tsetting : setting,\n\t\t\t\taddNodes : function(parentNode, newNodes, isSilent) {\n\t\t\t\t\tif (!newNodes) return null;\n\t\t\t\t\tif (!parentNode) parentNode = null;\n\t\t\t\t\tif (parentNode && !parentNode.isParent && setting.data.keep.leaf) return null;\n\t\t\t\t\tvar xNewNodes = tools.clone(tools.isArray(newNodes)? newNodes: [newNodes]);\n\t\t\t\t\tfunction addCallback() {\n\t\t\t\t\t\tview.addNodes(setting, parentNode, xNewNodes, (isSilent==true));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tools.canAsync(setting, parentNode)) {\n\t\t\t\t\t\tview.asyncNode(setting, parentNode, isSilent, addCallback);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddCallback();\n\t\t\t\t\t}\n\t\t\t\t\treturn xNewNodes;\n\t\t\t\t},\n\t\t\t\tcancelSelectedNode : function(node) {\n\t\t\t\t\tview.cancelPreSelectedNode(setting, node);\n\t\t\t\t},\n\t\t\t\tdestroy : function() {\n\t\t\t\t\tview.destroy(setting);\n\t\t\t\t},\n\t\t\t\texpandAll : function(expandFlag) {\n\t\t\t\t\texpandFlag = !!expandFlag;\n\t\t\t\t\tview.expandCollapseSonNode(setting, null, expandFlag, true);\n\t\t\t\t\treturn expandFlag;\n\t\t\t\t},\n\t\t\t\texpandNode : function(node, expandFlag, sonSign, focus, callbackFlag) {\n\t\t\t\t\tif (!node || !node.isParent) return null;\n\t\t\t\t\tif (expandFlag !== true && expandFlag !== false) {\n\t\t\t\t\t\texpandFlag = !node.open;\n\t\t\t\t\t}\n\t\t\t\t\tcallbackFlag = !!callbackFlag;\n\n\t\t\t\t\tif (callbackFlag && expandFlag && (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else if (callbackFlag && !expandFlag && (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tif (expandFlag && node.parentTId) {\n\t\t\t\t\t\tview.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (expandFlag === node.open && !sonSign) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.getRoot(setting).expandTriggerFlag = callbackFlag;\n\t\t\t\t\tif (!tools.canAsync(setting, node) && sonSign) {\n\t\t\t\t\t\tview.expandCollapseSonNode(setting, node, expandFlag, true, function() {\n\t\t\t\t\t\t\tif (focus !== false) {try{$$(node, setting).focus().blur();}catch(e){}}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.open = !expandFlag;\n\t\t\t\t\t\tview.switchNode(this.setting, node);\n\t\t\t\t\t\tif (focus !== false) {try{$$(node, setting).focus().blur();}catch(e){}}\n\t\t\t\t\t}\n\t\t\t\t\treturn expandFlag;\n\t\t\t\t},\n\t\t\t\tgetNodes : function() {\n\t\t\t\t\treturn data.getNodes(setting);\n\t\t\t\t},\n\t\t\t\tgetNodeByParam : function(key, value, parentNode) {\n\t\t\t\t\tif (!key) return null;\n\t\t\t\t\treturn data.getNodeByParam(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), key, value);\n\t\t\t\t},\n\t\t\t\tgetNodeByTId : function(tId) {\n\t\t\t\t\treturn data.getNodeCache(setting, tId);\n\t\t\t\t},\n\t\t\t\tgetNodesByParam : function(key, value, parentNode) {\n\t\t\t\t\tif (!key) return null;\n\t\t\t\t\treturn data.getNodesByParam(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), key, value);\n\t\t\t\t},\n\t\t\t\tgetNodesByParamFuzzy : function(key, value, parentNode) {\n\t\t\t\t\tif (!key) return null;\n\t\t\t\t\treturn data.getNodesByParamFuzzy(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), key, value);\n\t\t\t\t},\n\t\t\t\tgetNodesByFilter: function(filter, isSingle, parentNode, invokeParam) {\n\t\t\t\t\tisSingle = !!isSingle;\n\t\t\t\t\tif (!filter || (typeof filter != "function")) return (isSingle ? null : []);\n\t\t\t\t\treturn data.getNodesByFilter(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), filter, isSingle, invokeParam);\n\t\t\t\t},\n\t\t\t\tgetNodeIndex : function(node) {\n\t\t\t\t\tif (!node) return null;\n\t\t\t\t\tvar childKey = setting.data.key.children,\n\t\t\t\t\tparentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);\n\t\t\t\t\tfor (var i=0, l = parentNode[childKey].length; i < l; i++) {\n\t\t\t\t\t\tif (parentNode[childKey][i] == node) return i;\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t},\n\t\t\t\tgetSelectedNodes : function() {\n\t\t\t\t\tvar r = [], list = data.getRoot(setting).curSelectedList;\n\t\t\t\t\tfor (var i=0, l=list.length; i<l; i++) {\n\t\t\t\t\t\tr.push(list[i]);\n\t\t\t\t\t}\n\t\t\t\t\treturn r;\n\t\t\t\t},\n\t\t\t\tisSelectedNode : function(node) {\n\t\t\t\t\treturn data.isSelectedNode(setting, node);\n\t\t\t\t},\n\t\t\t\treAsyncChildNodes : function(parentNode, reloadType, isSilent) {\n\t\t\t\t\tif (!this.setting.async.enable) return;\n\t\t\t\t\tvar isRoot = !parentNode;\n\t\t\t\t\tif (isRoot) {\n\t\t\t\t\t\tparentNode = data.getRoot(setting);\n\t\t\t\t\t}\n\t\t\t\t\tif (reloadType=="refresh") {\n\t\t\t\t\t\tvar childKey = this.setting.data.key.children;\n\t\t\t\t\t\tfor (var i = 0, l = parentNode[childKey] ? parentNode[childKey].length : 0; i < l; i++) {\n\t\t\t\t\t\t\tdata.removeNodeCache(setting, parentNode[childKey][i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata.removeSelectedNode(setting);\n\t\t\t\t\t\tparentNode[childKey] = [];\n\t\t\t\t\t\tif (isRoot) {\n\t\t\t\t\t\t\tthis.setting.treeObj.empty();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar ulObj = $$(parentNode, consts.id.UL, setting);\n\t\t\t\t\t\t\tulObj.empty();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tview.asyncNode(this.setting, isRoot? null:parentNode, !!isSilent);\n\t\t\t\t},\n\t\t\t\trefresh : function() {\n\t\t\t\t\tthis.setting.treeObj.empty();\n\t\t\t\t\tvar root = data.getRoot(setting),\n\t\t\t\t\tnodes = root[setting.data.key.children]\n\t\t\t\t\tdata.initRoot(setting);\n\t\t\t\t\troot[setting.data.key.children] = nodes\n\t\t\t\t\tdata.initCache(setting);\n\t\t\t\t\tview.createNodes(setting, 0, root[setting.data.key.children]);\n\t\t\t\t},\n\t\t\t\tremoveChildNodes : function(node) {\n\t\t\t\t\tif (!node) return null;\n\t\t\t\t\tvar childKey = setting.data.key.children,\n\t\t\t\t\tnodes = node[childKey];\n\t\t\t\t\tview.removeChildNodes(setting, node);\n\t\t\t\t\treturn nodes ? nodes : null;\n\t\t\t\t},\n\t\t\t\tremoveNode : function(node, callbackFlag) {\n\t\t\t\t\tif (!node) return;\n\t\t\t\t\tcallbackFlag = !!callbackFlag;\n\t\t\t\t\tif (callbackFlag && tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return;\n\t\t\t\t\tview.removeNode(setting, node);\n\t\t\t\t\tif (callbackFlag) {\n\t\t\t\t\t\tthis.setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tselectNode : function(node, addFlag) {\n\t\t\t\t\tif (!node) return;\n\t\t\t\t\tif (tools.uCanDo(setting)) {\n\t\t\t\t\t\taddFlag = setting.view.selectedMulti && addFlag;\n\t\t\t\t\t\tif (node.parentTId) {\n\t\t\t\t\t\t\tview.expandCollapseParentNode(setting, node.getParentNode(), true, false, function() {\n\t\t\t\t\t\t\t\ttry{$$(node, setting).focus().blur();}catch(e){}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry{$$(node, setting).focus().blur();}catch(e){}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tview.selectNode(setting, node, addFlag);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\ttransformTozTreeNodes : function(simpleNodes) {\n\t\t\t\t\treturn data.transformTozTreeFormat(setting, simpleNodes);\n\t\t\t\t},\n\t\t\t\ttransformToArray : function(nodes) {\n\t\t\t\t\treturn data.transformToArrayFormat(setting, nodes);\n\t\t\t\t},\n\t\t\t\tupdateNode : function(node, checkTypeFlag) {\n\t\t\t\t\tif (!node) return;\n\t\t\t\t\tvar nObj = $$(node, setting);\n\t\t\t\t\tif (nObj.get(0) && tools.uCanDo(setting)) {\n\t\t\t\t\t\tview.setNodeName(setting, node);\n\t\t\t\t\t\tview.setNodeTarget(setting, node);\n\t\t\t\t\t\tview.setNodeUrl(setting, node);\n\t\t\t\t\t\tview.setNodeLineIcos(setting, node);\n\t\t\t\t\t\tview.setNodeFontCss(setting, node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\troot.treeTools = zTreeTools;\n\t\t\tdata.setZTreeTools(setting, zTreeTools);\n\n\t\t\tif (root[childKey] && root[childKey].length > 0) {\n\t\t\t\tview.createNodes(setting, 0, root[childKey]);\n\t\t\t} else if (setting.async.enable && setting.async.url && setting.async.url !== \'\') {\n\t\t\t\tview.asyncNode(setting);\n\t\t\t}\n\t\t\treturn zTreeTools;\n\t\t}\n\t};\n\n\tvar zt = $.fn.zTree,\n\t$$ = tools.$,\n\tconsts = zt.consts;\n})(jQuery);\n/*\n * JQuery zTree excheck v3.5.17-beta.2\n * http://zTree.me/\n *\n * Copyright (c) 2010 Hunter.z\n *\n * Licensed same as jquery - MIT License\n * http://www.opensource.org/licenses/mit-license.php\n *\n * email: hunter.z@263.net\n * Date: 2014-05-08\n */\n(function($){\n\t//default consts of excheck\n\tvar _consts = {\n\t\tevent: {\n\t\t\tCHECK: "ztree_check"\n\t\t},\n\t\tid: {\n\t\t\tCHECK: "_check"\n\t\t},\n\t\tcheckbox: {\n\t\t\tSTYLE: "checkbox",\n\t\t\tDEFAULT: "chk",\n\t\t\tDISABLED: "disable",\n\t\t\tFALSE: "false",\n\t\t\tTRUE: "true",\n\t\t\tFULL: "full",\n\t\t\tPART: "part",\n\t\t\tFOCUS: "focus"\n\t\t},\n\t\tradio: {\n\t\t\tSTYLE: "radio",\n\t\t\tTYPE_ALL: "all",\n\t\t\tTYPE_LEVEL: "level"\n\t\t}\n\t},\n\t//default setting of excheck\n\t_setting = {\n\t\tcheck: {\n\t\t\tenable: false,\n\t\t\tautoCheckTrigger: false,\n\t\t\tchkStyle: _consts.checkbox.STYLE,\n\t\t\tnocheckInherit: false,\n\t\t\tchkDisabledInherit: false,\n\t\t\tradioType: _consts.radio.TYPE_LEVEL,\n\t\t\tchkboxType: {\n\t\t\t\t"Y": "ps",\n\t\t\t\t"N": "ps"\n\t\t\t}\n\t\t},\n\t\tdata: {\n\t\t\tkey: {\n\t\t\t\tchecked: "checked"\n\t\t\t}\n\t\t},\n\t\tcallback: {\n\t\t\tbeforeCheck:null,\n\t\t\tonCheck:null\n\t\t}\n\t},\n\t//default root of excheck\n\t_initRoot = function (setting) {\n\t\tvar r = data.getRoot(setting);\n\t\tr.radioCheckedList = [];\n\t},\n\t//default cache of excheck\n\t_initCache = function(treeId) {},\n\t//default bind event of excheck\n\t_bindEvent = function(setting) {\n\t\tvar o = setting.treeObj,\n\t\tc = consts.event;\n\t\to.bind(c.CHECK, function (event, srcEvent, treeId, node) {\n\t\t\tevent.srcEvent = srcEvent;\n\t\t\ttools.apply(setting.callback.onCheck, [event, treeId, node]);\n\t\t});\n\t},\n\t_unbindEvent = function(setting) {\n\t\tvar o = setting.treeObj,\n\t\tc = consts.event;\n\t\to.unbind(c.CHECK);\n\t},\n\t//default event proxy of excheck\n\t_eventProxy = function(e) {\n\t\tvar target = e.target,\n\t\tsetting = data.getSetting(e.data.treeId),\n\t\ttId = "", node = null,\n\t\tnodeEventType = "", treeEventType = "",\n\t\tnodeEventCallback = null, treeEventCallback = null;\n\n\t\tif (tools.eqs(e.type, "mouseover")) {\n\t\t\tif (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {\n\t\t\t\ttId = tools.getNodeMainDom(target).id;\n\t\t\t\tnodeEventType = "mouseoverCheck";\n\t\t\t}\n\t\t} else if (tools.eqs(e.type, "mouseout")) {\n\t\t\tif (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {\n\t\t\t\ttId = tools.getNodeMainDom(target).id;\n\t\t\t\tnodeEventType = "mouseoutCheck";\n\t\t\t}\n\t\t} else if (tools.eqs(e.type, "click")) {\n\t\t\tif (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {\n\t\t\t\ttId = tools.getNodeMainDom(target).id;\n\t\t\t\tnodeEventType = "checkNode";\n\t\t\t}\n\t\t}\n\t\tif (tId.length>0) {\n\t\t\tnode = data.getNodeCache(setting, tId);\n\t\t\tswitch (nodeEventType) {\n\t\t\t\tcase "checkNode" :\n\t\t\t\t\tnodeEventCallback = _handler.onCheckNode;\n\t\t\t\t\tbreak;\n\t\t\t\tcase "mouseoverCheck" :\n\t\t\t\t\tnodeEventCallback = _handler.onMouseoverCheck;\n\t\t\t\t\tbreak;\n\t\t\t\tcase "mouseoutCheck" :\n\t\t\t\t\tnodeEventCallback = _handler.onMouseoutCheck;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar proxyResult = {\n\t\t\tstop: nodeEventType === "checkNode",\n\t\t\tnode: node,\n\t\t\tnodeEventType: nodeEventType,\n\t\t\tnodeEventCallback: nodeEventCallback,\n\t\t\ttreeEventType: treeEventType,\n\t\t\ttreeEventCallback: treeEventCallback\n\t\t};\n\t\treturn proxyResult\n\t},\n\t//default init node of excheck\n\t_initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {\n\t\tif (!n) return;\n\t\tvar checkedKey = setting.data.key.checked;\n\t\tif (typeof n[checkedKey] == "string") n[checkedKey] = tools.eqs(n[checkedKey], "true");\n\t\tn[checkedKey] = !!n[checkedKey];\n\t\tn.checkedOld = n[checkedKey];\n\t\tif (typeof n.nocheck == "string") n.nocheck = tools.eqs(n.nocheck, "true");\n\t\tn.nocheck = !!n.nocheck || (setting.check.nocheckInherit && parentNode && !!parentNode.nocheck);\n\t\tif (typeof n.chkDisabled == "string") n.chkDisabled = tools.eqs(n.chkDisabled, "true");\n\t\tn.chkDisabled = !!n.chkDisabled || (setting.check.chkDisabledInherit && parentNode && !!parentNode.chkDisabled);\n\t\tif (typeof n.halfCheck == "string") n.halfCheck = tools.eqs(n.halfCheck, "true");\n\t\tn.halfCheck = !!n.halfCheck;\n\t\tn.check_Child_State = -1;\n\t\tn.check_Focus = false;\n\t\tn.getCheckStatus = function() {return data.getCheckStatus(setting, n);};\n\n\t\tif (setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL && n[checkedKey] ) {\n\t\t\tvar r = data.getRoot(setting);\n\t\t\tr.radioCheckedList.push(n);\n\t\t}\n\t},\n\t//add dom for check\n\t_beforeA = function(setting, node, html) {\n\t\tvar checkedKey = setting.data.key.checked;\n\t\tif (setting.check.enable) {\n\t\t\tdata.makeChkFlag(setting, node);\n\t\t\thtml.push("<span ID=\'", node.tId, consts.id.CHECK, "\' class=\'", view.makeChkClass(setting, node), "\' treeNode", consts.id.CHECK, (node.nocheck === true?" style=\'display:none;\'":""),"></span>");\n\t\t}\n\t},\n\t//update zTreeObj, add method of check\n\t_zTreeTools = function(setting, zTreeTools) {\n\t\tzTreeTools.checkNode = function(node, checked, checkTypeFlag, callbackFlag) {\n\t\t\tvar checkedKey = this.setting.data.key.checked;\n\t\t\tif (node.chkDisabled === true) return;\n\t\t\tif (checked !== true && checked !== false) {\n\t\t\t\tchecked = !node[checkedKey];\n\t\t\t}\n\t\t\tcallbackFlag = !!callbackFlag;\n\n\t\t\tif (node[checkedKey] === checked && !checkTypeFlag) {\n\t\t\t\treturn;\n\t\t\t} else if (callbackFlag && tools.apply(this.setting.callback.beforeCheck, [this.setting.treeId, node], true) == false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (tools.uCanDo(this.setting) && this.setting.check.enable && node.nocheck !== true) {\n\t\t\t\tnode[checkedKey] = checked;\n\t\t\t\tvar checkObj = $$(node, consts.id.CHECK, this.setting);\n\t\t\t\tif (checkTypeFlag || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);\n\t\t\t\tview.setChkClass(this.setting, checkObj, node);\n\t\t\t\tview.repairParentChkClassWithSelf(this.setting, node);\n\t\t\t\tif (callbackFlag) {\n\t\t\t\t\tthis.setting.treeObj.trigger(consts.event.CHECK, [null, this.setting.treeId, node]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tzTreeTools.checkAllNodes = function(checked) {\n\t\t\tview.repairAllChk(this.setting, !!checked);\n\t\t}\n\n\t\tzTreeTools.getCheckedNodes = function(checked) {\n\t\t\tvar childKey = this.setting.data.key.children;\n\t\t\tchecked = (checked !== false);\n\t\t\treturn data.getTreeCheckedNodes(this.setting, data.getRoot(this.setting)[childKey], checked);\n\t\t}\n\n\t\tzTreeTools.getChangeCheckedNodes = function() {\n\t\t\tvar childKey = this.setting.data.key.children;\n\t\t\treturn data.getTreeChangeCheckedNodes(this.setting, data.getRoot(this.setting)[childKey]);\n\t\t}\n\n\t\tzTreeTools.setChkDisabled = function(node, disabled, inheritParent, inheritChildren) {\n\t\t\tdisabled = !!disabled;\n\t\t\tinheritParent = !!inheritParent;\n\t\t\tinheritChildren = !!inheritChildren;\n\t\t\tview.repairSonChkDisabled(this.setting, node, disabled, inheritChildren);\n\t\t\tview.repairParentChkDisabled(this.setting, node.getParentNode(), disabled, inheritParent);\n\t\t}\n\n\t\tvar _updateNode = zTreeTools.updateNode;\n\t\tzTreeTools.updateNode = function(node, checkTypeFlag) {\n\t\t\tif (_updateNode) _updateNode.apply(zTreeTools, arguments);\n\t\t\tif (!node || !this.setting.check.enable) return;\n\t\t\tvar nObj = $$(node, this.setting);\n\t\t\tif (nObj.get(0) && tools.uCanDo(this.setting)) {\n\t\t\t\tvar checkObj = $$(node, consts.id.CHECK, this.setting);\n\t\t\t\tif (checkTypeFlag == true || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);\n\t\t\t\tview.setChkClass(this.setting, checkObj, node);\n\t\t\t\tview.repairParentChkClassWithSelf(this.setting, node);\n\t\t\t}\n\t\t}\n\t},\n\t//method of operate data\n\t_data = {\n\t\tgetRadioCheckedList: function(setting) {\n\t\t\tvar checkedList = data.getRoot(setting).radioCheckedList;\n\t\t\tfor (var i=0, j=checkedList.length; i<j; i++) {\n\t\t\t\tif(!data.getNodeCache(setting, checkedList[i].tId)) {\n\t\t\t\t\tcheckedList.splice(i, 1);\n\t\t\t\t\ti--; j--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn checkedList;\n\t\t},\n\t\tgetCheckStatus: function(setting, node) {\n\t\t\tif (!setting.check.enable || node.nocheck || node.chkDisabled) return null;\n\t\t\tvar checkedKey = setting.data.key.checked,\n\t\t\tr = {\n\t\t\t\tchecked: node[checkedKey],\n\t\t\t\thalf: node.halfCheck ? node.halfCheck : (setting.check.chkStyle == consts.radio.STYLE ? (node.check_Child_State === 2) : (node[checkedKey] ? (node.check_Child_State > -1 && node.check_Child_State < 2) : (node.check_Child_State > 0)))\n\t\t\t};\n\t\t\treturn r;\n\t\t},\n\t\tgetTreeCheckedNodes: function(setting, nodes, checked, results) {\n\t\t\tif (!nodes) return [];\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tcheckedKey = setting.data.key.checked,\n\t\t\tonlyOne = (checked && setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL);\n\t\t\tresults = !results ? [] : results;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tif (nodes[i].nocheck !== true && nodes[i].chkDisabled !== true && nodes[i][checkedKey] == checked) {\n\t\t\t\t\tresults.push(nodes[i]);\n\t\t\t\t\tif(onlyOne) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata.getTreeCheckedNodes(setting, nodes[i][childKey], checked, results);\n\t\t\t\tif(onlyOne && results.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t},\n\t\tgetTreeChangeCheckedNodes: function(setting, nodes, results) {\n\t\t\tif (!nodes) return [];\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tcheckedKey = setting.data.key.checked;\n\t\t\tresults = !results ? [] : results;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tif (nodes[i].nocheck !== true && nodes[i].chkDisabled !== true && nodes[i][checkedKey] != nodes[i].checkedOld) {\n\t\t\t\t\tresults.push(nodes[i]);\n\t\t\t\t}\n\t\t\t\tdata.getTreeChangeCheckedNodes(setting, nodes[i][childKey], results);\n\t\t\t}\n\t\t\treturn results;\n\t\t},\n\t\tmakeChkFlag: function(setting, node) {\n\t\t\tif (!node) return;\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tcheckedKey = setting.data.key.checked,\n\t\t\tchkFlag = -1;\n\t\t\tif (node[childKey]) {\n\t\t\t\tfor (var i = 0, l = node[childKey].length; i < l; i++) {\n\t\t\t\t\tvar cNode = node[childKey][i];\n\t\t\t\t\tvar tmp = -1;\n\t\t\t\t\tif (setting.check.chkStyle == consts.radio.STYLE) {\n\t\t\t\t\t\tif (cNode.nocheck === true || cNode.chkDisabled === true) {\n\t\t\t\t\t\t\ttmp = cNode.check_Child_State;\n\t\t\t\t\t\t} else if (cNode.halfCheck === true) {\n\t\t\t\t\t\t\ttmp = 2;\n\t\t\t\t\t\t} else if (cNode[checkedKey]) {\n\t\t\t\t\t\t\ttmp = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = cNode.check_Child_State > 0 ? 2:0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tmp == 2) {\n\t\t\t\t\t\t\tchkFlag = 2; break;\n\t\t\t\t\t\t} else if (tmp == 0){\n\t\t\t\t\t\t\tchkFlag = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (setting.check.chkStyle == consts.checkbox.STYLE) {\n\t\t\t\t\t\tif (cNode.nocheck === true || cNode.chkDisabled === true) {\n\t\t\t\t\t\t\ttmp = cNode.check_Child_State;\n\t\t\t\t\t\t} else if (cNode.halfCheck === true) {\n\t\t\t\t\t\t\ttmp = 1;\n\t\t\t\t\t\t} else if (cNode[checkedKey] ) {\n\t\t\t\t\t\t\ttmp = (cNode.check_Child_State === -1 || cNode.check_Child_State === 2) ? 2 : 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = (cNode.check_Child_State > 0) ? 1 : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tmp === 1) {\n\t\t\t\t\t\t\tchkFlag = 1; break;\n\t\t\t\t\t\t} else if (tmp === 2 && chkFlag > -1 && i > 0 && tmp !== chkFlag) {\n\t\t\t\t\t\t\tchkFlag = 1; break;\n\t\t\t\t\t\t} else if (chkFlag === 2 && tmp > -1 && tmp < 2) {\n\t\t\t\t\t\t\tchkFlag = 1; break;\n\t\t\t\t\t\t} else if (tmp > -1) {\n\t\t\t\t\t\t\tchkFlag = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode.check_Child_State = chkFlag;\n\t\t}\n\t},\n\t//method of event proxy\n\t_event = {\n\n\t},\n\t//method of event handler\n\t_handler = {\n\t\tonCheckNode: function (event, node) {\n\t\t\tif (node.chkDisabled === true) return false;\n\t\t\tvar setting = data.getSetting(event.data.treeId),\n\t\t\tcheckedKey = setting.data.key.checked;\n\t\t\tif (tools.apply(setting.callback.beforeCheck, [setting.treeId, node], true) == false) return true;\n\t\t\tnode[checkedKey] = !node[checkedKey];\n\t\t\tview.checkNodeRelation(setting, node);\n\t\t\tvar checkObj = $$(node, consts.id.CHECK, setting);\n\t\t\tview.setChkClass(setting, checkObj, node);\n\t\t\tview.repairParentChkClassWithSelf(setting, node);\n\t\t\tsetting.treeObj.trigger(consts.event.CHECK, [event, setting.treeId, node]);\n\t\t\treturn true;\n\t\t},\n\t\tonMouseoverCheck: function(event, node) {\n\t\t\tif (node.chkDisabled === true) return false;\n\t\t\tvar setting = data.getSetting(event.data.treeId),\n\t\t\tcheckObj = $$(node, consts.id.CHECK, setting);\n\t\t\tnode.check_Focus = true;\n\t\t\tview.setChkClass(setting, checkObj, node);\n\t\t\treturn true;\n\t\t},\n\t\tonMouseoutCheck: function(event, node) {\n\t\t\tif (node.chkDisabled === true) return false;\n\t\t\tvar setting = data.getSetting(event.data.treeId),\n\t\t\tcheckObj = $$(node, consts.id.CHECK, setting);\n\t\t\tnode.check_Focus = false;\n\t\t\tview.setChkClass(setting, checkObj, node);\n\t\t\treturn true;\n\t\t}\n\t},\n\t//method of tools for zTree\n\t_tools = {\n\n\t},\n\t//method of operate ztree dom\n\t_view = {\n\t\tcheckNodeRelation: function(setting, node) {\n\t\t\tvar pNode, i, l,\n\t\t\tchildKey = setting.data.key.children,\n\t\t\tcheckedKey = setting.data.key.checked,\n\t\t\tr = consts.radio;\n\t\t\tif (setting.check.chkStyle == r.STYLE) {\n\t\t\t\tvar checkedList = data.getRadioCheckedList(setting);\n\t\t\t\tif (node[checkedKey]) {\n\t\t\t\t\tif (setting.check.radioType == r.TYPE_ALL) {\n\t\t\t\t\t\tfor (i = checkedList.length-1; i >= 0; i--) {\n\t\t\t\t\t\t\tpNode = checkedList[i];\n\t\t\t\t\t\t\tif (pNode[checkedKey] && pNode != node) {\n\t\t\t\t\t\t\t\tpNode[checkedKey] = false;\n\t\t\t\t\t\t\t\tcheckedList.splice(i, 1);\n\n\t\t\t\t\t\t\t\tview.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);\n\t\t\t\t\t\t\t\tif (pNode.parentTId != node.parentTId) {\n\t\t\t\t\t\t\t\t\tview.repairParentChkClassWithSelf(setting, pNode);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcheckedList.push(node);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);\n\t\t\t\t\t\tfor (i = 0, l = parentNode[childKey].length; i < l; i++) {\n\t\t\t\t\t\t\tpNode = parentNode[childKey][i];\n\t\t\t\t\t\t\tif (pNode[checkedKey] && pNode != node) {\n\t\t\t\t\t\t\t\tpNode[checkedKey] = false;\n\t\t\t\t\t\t\t\tview.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (setting.check.radioType == r.TYPE_ALL) {\n\t\t\t\t\tfor (i = 0, l = checkedList.length; i < l; i++) {\n\t\t\t\t\t\tif (node == checkedList[i]) {\n\t\t\t\t\t\t\tcheckedList.splice(i, 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.Y.indexOf("s") > -1)) {\n\t\t\t\t\tview.setSonNodeCheckBox(setting, node, true);\n\t\t\t\t}\n\t\t\t\tif (!node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.N.indexOf("s") > -1)) {\n\t\t\t\t\tview.setSonNodeCheckBox(setting, node, false);\n\t\t\t\t}\n\t\t\t\tif (node[checkedKey] && setting.check.chkboxType.Y.indexOf("p") > -1) {\n\t\t\t\t\tview.setParentNodeCheckBox(setting, node, true);\n\t\t\t\t}\n\t\t\t\tif (!node[checkedKey] && setting.check.chkboxType.N.indexOf("p") > -1) {\n\t\t\t\t\tview.setParentNodeCheckBox(setting, node, false);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmakeChkClass: function(setting, node) {\n\t\t\tvar checkedKey = setting.data.key.checked,\n\t\t\tc = consts.checkbox, r = consts.radio,\n\t\t\tfullStyle = "";\n\t\t\tif (node.chkDisabled === true) {\n\t\t\t\tfullStyle = c.DISABLED;\n\t\t\t} else if (node.halfCheck) {\n\t\t\t\tfullStyle = c.PART;\n\t\t\t} else if (setting.check.chkStyle == r.STYLE) {\n\t\t\t\tfullStyle = (node.check_Child_State < 1)? c.FULL:c.PART;\n\t\t\t} else {\n\t\t\t\tfullStyle = node[checkedKey] ? ((node.check_Child_State === 2 || node.check_Child_State === -1) ? c.FULL:c.PART) : ((node.check_Child_State < 1)? c.FULL:c.PART);\n\t\t\t}\n\t\t\tvar chkName = setting.check.chkStyle + "_" + (node[checkedKey] ? c.TRUE : c.FALSE) + "_" + fullStyle;\n\t\t\tchkName = (node.check_Focus && node.chkDisabled !== true) ? chkName + "_" + c.FOCUS : chkName;\n\t\t\treturn consts.className.BUTTON + " " + c.DEFAULT + " " + chkName;\n\t\t},\n\t\trepairAllChk: function(setting, checked) {\n\t\t\tif (setting.check.enable && setting.check.chkStyle === consts.checkbox.STYLE) {\n\t\t\t\tvar checkedKey = setting.data.key.checked,\n\t\t\t\tchildKey = setting.data.key.children,\n\t\t\t\troot = data.getRoot(setting);\n\t\t\t\tfor (var i = 0, l = root[childKey].length; i<l ; i++) {\n\t\t\t\t\tvar node = root[childKey][i];\n\t\t\t\t\tif (node.nocheck !== true && node.chkDisabled !== true) {\n\t\t\t\t\t\tnode[checkedKey] = checked;\n\t\t\t\t\t}\n\t\t\t\t\tview.setSonNodeCheckBox(setting, node, checked);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\trepairChkClass: function(setting, node) {\n\t\t\tif (!node) return;\n\t\t\tdata.makeChkFlag(setting, node);\n\t\t\tif (node.nocheck !== true) {\n\t\t\t\tvar checkObj = $$(node, consts.id.CHECK, setting);\n\t\t\t\tview.setChkClass(setting, checkObj, node);\n\t\t\t}\n\t\t},\n\t\trepairParentChkClass: function(setting, node) {\n\t\t\tif (!node || !node.parentTId) return;\n\t\t\tvar pNode = node.getParentNode();\n\t\t\tview.repairChkClass(setting, pNode);\n\t\t\tview.repairParentChkClass(setting, pNode);\n\t\t},\n\t\trepairParentChkClassWithSelf: function(setting, node) {\n\t\t\tif (!node) return;\n\t\t\tvar childKey = setting.data.key.children;\n\t\t\tif (node[childKey] && node[childKey].length > 0) {\n\t\t\t\tview.repairParentChkClass(setting, node[childKey][0]);\n\t\t\t} else {\n\t\t\t\tview.repairParentChkClass(setting, node);\n\t\t\t}\n\t\t},\n\t\trepairSonChkDisabled: function(setting, node, chkDisabled, inherit) {\n\t\t\tif (!node) return;\n\t\t\tvar childKey = setting.data.key.children;\n\t\t\tif (node.chkDisabled != chkDisabled) {\n\t\t\t\tnode.chkDisabled = chkDisabled;\n\t\t\t}\n\t\t\tview.repairChkClass(setting, node);\n\t\t\tif (node[childKey] && inherit) {\n\t\t\t\tfor (var i = 0, l = node[childKey].length; i < l; i++) {\n\t\t\t\t\tvar sNode = node[childKey][i];\n\t\t\t\t\tview.repairSonChkDisabled(setting, sNode, chkDisabled, inherit);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\trepairParentChkDisabled: function(setting, node, chkDisabled, inherit) {\n\t\t\tif (!node) return;\n\t\t\tif (node.chkDisabled != chkDisabled && inherit) {\n\t\t\t\tnode.chkDisabled = chkDisabled;\n\t\t\t}\n\t\t\tview.repairChkClass(setting, node);\n\t\t\tview.repairParentChkDisabled(setting, node.getParentNode(), chkDisabled, inherit);\n\t\t},\n\t\tsetChkClass: function(setting, obj, node) {\n\t\t\tif (!obj) return;\n\t\t\tif (node.nocheck === true) {\n\t\t\t\tobj.hide();\n\t\t\t} else {\n\t\t\t\tobj.show();\n\t\t\t}\n            obj.attr(\'class\', view.makeChkClass(setting, node));\n\t\t},\n\t\tsetParentNodeCheckBox: function(setting, node, value, srcNode) {\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tcheckedKey = setting.data.key.checked,\n\t\t\tcheckObj = $$(node, consts.id.CHECK, setting);\n\t\t\tif (!srcNode) srcNode = node;\n\t\t\tdata.makeChkFlag(setting, node);\n\t\t\tif (node.nocheck !== true && node.chkDisabled !== true) {\n\t\t\t\tnode[checkedKey] = value;\n\t\t\t\tview.setChkClass(setting, checkObj, node);\n\t\t\t\tif (setting.check.autoCheckTrigger && node != srcNode) {\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parentTId) {\n\t\t\t\tvar pSign = true;\n\t\t\t\tif (!value) {\n\t\t\t\t\tvar pNodes = node.getParentNode()[childKey];\n\t\t\t\t\tfor (var i = 0, l = pNodes.length; i < l; i++) {\n\t\t\t\t\t\tif ((pNodes[i].nocheck !== true && pNodes[i].chkDisabled !== true && pNodes[i][checkedKey])\n\t\t\t\t\t\t|| ((pNodes[i].nocheck === true || pNodes[i].chkDisabled === true) && pNodes[i].check_Child_State > 0)) {\n\t\t\t\t\t\t\tpSign = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pSign) {\n\t\t\t\t\tview.setParentNodeCheckBox(setting, node.getParentNode(), value, srcNode);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsetSonNodeCheckBox: function(setting, node, value, srcNode) {\n\t\t\tif (!node) return;\n\t\t\tvar childKey = setting.data.key.children,\n\t\t\tcheckedKey = setting.data.key.checked,\n\t\t\tcheckObj = $$(node, consts.id.CHECK, setting);\n\t\t\tif (!srcNode) srcNode = node;\n\n\t\t\tvar hasDisable = false;\n\t\t\tif (node[childKey]) {\n\t\t\t\tfor (var i = 0, l = node[childKey].length; i < l && node.chkDisabled !== true; i++) {\n\t\t\t\t\tvar sNode = node[childKey][i];\n\t\t\t\t\tview.setSonNodeCheckBox(setting, sNode, value, srcNode);\n\t\t\t\t\tif (sNode.chkDisabled === true) hasDisable = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node != data.getRoot(setting) && node.chkDisabled !== true) {\n\t\t\t\tif (hasDisable && node.nocheck !== true) {\n\t\t\t\t\tdata.makeChkFlag(setting, node);\n\t\t\t\t}\n\t\t\t\tif (node.nocheck !== true && node.chkDisabled !== true) {\n\t\t\t\t\tnode[checkedKey] = value;\n\t\t\t\t\tif (!hasDisable) node.check_Child_State = (node[childKey] && node[childKey].length > 0) ? (value ? 2 : 0) : -1;\n\t\t\t\t} else {\n\t\t\t\t\tnode.check_Child_State = -1;\n\t\t\t\t}\n\t\t\t\tview.setChkClass(setting, checkObj, node);\n\t\t\t\tif (setting.check.autoCheckTrigger && node != srcNode && node.nocheck !== true && node.chkDisabled !== true) {\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\n\t_z = {\n\t\ttools: _tools,\n\t\tview: _view,\n\t\tevent: _event,\n\t\tdata: _data\n\t};\n\t$.extend(true, $.fn.zTree.consts, _consts);\n\t$.extend(true, $.fn.zTree._z, _z);\n\n\tvar zt = $.fn.zTree,\n\ttools = zt._z.tools,\n\tconsts = zt.consts,\n\tview = zt._z.view,\n\tdata = zt._z.data,\n\tevent = zt._z.event,\n\t$$ = tools.$;\n\n\tdata.exSetting(_setting);\n\tdata.addInitBind(_bindEvent);\n\tdata.addInitUnBind(_unbindEvent);\n\tdata.addInitCache(_initCache);\n\tdata.addInitNode(_initNode);\n\tdata.addInitProxy(_eventProxy, true);\n\tdata.addInitRoot(_initRoot);\n\tdata.addBeforeA(_beforeA);\n\tdata.addZTreeTools(_zTreeTools);\n\n\tvar _createNodes = view.createNodes;\n\tview.createNodes = function(setting, level, nodes, parentNode) {\n\t\tif (_createNodes) _createNodes.apply(view, arguments);\n\t\tif (!nodes) return;\n\t\tview.repairParentChkClassWithSelf(setting, parentNode);\n\t}\n\tvar _removeNode = view.removeNode;\n\tview.removeNode = function(setting, node) {\n\t\tvar parentNode = node.getParentNode();\n\t\tif (_removeNode) _removeNode.apply(view, arguments);\n\t\tif (!node || !parentNode) return;\n\t\tview.repairChkClass(setting, parentNode);\n\t\tview.repairParentChkClass(setting, parentNode);\n\t}\n\n\tvar _appendNodes = view.appendNodes;\n\tview.appendNodes = function(setting, level, nodes, parentNode, initFlag, openFlag) {\n\t\tvar html = "";\n\t\tif (_appendNodes) {\n\t\t\thtml = _appendNodes.apply(view, arguments);\n\t\t}\n\t\tif (parentNode) {\n\t\t\tdata.makeChkFlag(setting, parentNode);\n\t\t}\n\t\treturn html;\n\t}\n})(jQuery);\n/*\n * JQuery zTree exedit v3.5.17-beta.2\n * http://zTree.me/\n *\n * Copyright (c) 2010 Hunter.z\n *\n * Licensed same as jquery - MIT License\n * http://www.opensource.org/licenses/mit-license.php\n *\n * email: hunter.z@263.net\n * Date: 2014-05-08\n */\n(function($){\n\t//default consts of exedit\n\tvar _consts = {\n\t\tevent: {\n\t\t\tDRAG: "ztree_drag",\n\t\t\tDROP: "ztree_drop",\n\t\t\tRENAME: "ztree_rename",\n\t\t\tDRAGMOVE:"ztree_dragmove"\n\t\t},\n\t\tid: {\n\t\t\tEDIT: "_edit",\n\t\t\tINPUT: "_input",\n\t\t\tREMOVE: "_remove"\n\t\t},\n\t\tmove: {\n\t\t\tTYPE_INNER: "inner",\n\t\t\tTYPE_PREV: "prev",\n\t\t\tTYPE_NEXT: "next"\n\t\t},\n\t\tnode: {\n\t\t\tCURSELECTED_EDIT: "curSelectedNode_Edit",\n\t\t\tTMPTARGET_TREE: "tmpTargetzTree",\n\t\t\tTMPTARGET_NODE: "tmpTargetNode"\n\t\t}\n\t},\n\t//default setting of exedit\n\t_setting = {\n\t\tedit: {\n\t\t\tenable: false,\n\t\t\teditNameSelectAll: false,\n\t\t\tshowRemoveBtn: true,\n\t\t\tshowRenameBtn: true,\n\t\t\tremoveTitle: "remove",\n\t\t\trenameTitle: "rename",\n\t\t\tdrag: {\n\t\t\t\tautoExpandTrigger: false,\n\t\t\t\tisCopy: true,\n\t\t\t\tisMove: true,\n\t\t\t\tprev: true,\n\t\t\t\tnext: true,\n\t\t\t\tinner: true,\n\t\t\t\tminMoveSize: 5,\n\t\t\t\tborderMax: 10,\n\t\t\t\tborderMin: -5,\n\t\t\t\tmaxShowNodeNum: 5,\n\t\t\t\tautoOpenTime: 500\n\t\t\t}\n\t\t},\n\t\tview: {\n\t\t\taddHoverDom: null,\n\t\t\tremoveHoverDom: null\n\t\t},\n\t\tcallback: {\n\t\t\tbeforeDrag:null,\n\t\t\tbeforeDragOpen:null,\n\t\t\tbeforeDrop:null,\n\t\t\tbeforeEditName:null,\n\t\t\tbeforeRename:null,\n\t\t\tonDrag:null,\n\t\t\tonDragMove:null,\n\t\t\tonDrop:null,\n\t\t\tonRename:null\n\t\t}\n\t},\n\t//default root of exedit\n\t_initRoot = function (setting) {\n\t\tvar r = data.getRoot(setting), rs = data.getRoots();\n\t\tr.curEditNode = null;\n\t\tr.curEditInput = null;\n\t\tr.curHoverNode = null;\n\t\tr.dragFlag = 0;\n\t\tr.dragNodeShowBefore = [];\n\t\tr.dragMaskList = new Array();\n\t\trs.showHoverDom = true;\n\t},\n\t//default cache of exedit\n\t_initCache = function(treeId) {},\n\t//default bind event of exedit\n\t_bindEvent = function(setting) {\n\t\tvar o = setting.treeObj;\n\t\tvar c = consts.event;\n\t\to.bind(c.RENAME, function (event, treeId, treeNode, isCancel) {\n\t\t\ttools.apply(setting.callback.onRename, [event, treeId, treeNode, isCancel]);\n\t\t});\n\n\t\to.bind(c.DRAG, function (event, srcEvent, treeId, treeNodes) {\n\t\t\ttools.apply(setting.callback.onDrag, [srcEvent, treeId, treeNodes]);\n\t\t});\n\n\t\to.bind(c.DRAGMOVE,function(event, srcEvent, treeId, treeNodes){\n\t\t\ttools.apply(setting.callback.onDragMove,[srcEvent, treeId, treeNodes]);\n\t\t});\n\n\t\to.bind(c.DROP, function (event, srcEvent, treeId, treeNodes, targetNode, moveType, isCopy) {\n\t\t\ttools.apply(setting.callback.onDrop, [srcEvent, treeId, treeNodes, targetNode, moveType, isCopy]);\n\t\t});\n\t},\n\t_unbindEvent = function(setting) {\n\t\tvar o = setting.treeObj;\n\t\tvar c = consts.event;\n\t\to.unbind(c.RENAME);\n\t\to.unbind(c.DRAG);\n\t\to.unbind(c.DRAGMOVE);\n\t\to.unbind(c.DROP);\n\t},\n\t//default event proxy of exedit\n\t_eventProxy = function(e) {\n\t\tvar target = e.target,\n\t\tsetting = data.getSetting(e.data.treeId),\n\t\trelatedTarget = e.relatedTarget,\n\t\ttId = "", node = null,\n\t\tnodeEventType = "", treeEventType = "",\n\t\tnodeEventCallback = null, treeEventCallback = null,\n\t\ttmp = null;\n\n\t\tif (tools.eqs(e.type, "mouseover")) {\n\t\t\ttmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);\n\t\t\tif (tmp) {\n\t\t\t\ttId = tools.getNodeMainDom(tmp).id;\n\t\t\t\tnodeEventType = "hoverOverNode";\n\t\t\t}\n\t\t} else if (tools.eqs(e.type, "mouseout")) {\n\t\t\ttmp = tools.getMDom(setting, relatedTarget, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);\n\t\t\tif (!tmp) {\n\t\t\t\ttId = "remove";\n\t\t\t\tnodeEventType = "hoverOutNode";\n\t\t\t}\n\t\t} else if (tools.eqs(e.type, "mousedown")) {\n\t\t\ttmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);\n\t\t\tif (tmp) {\n\t\t\t\ttId = tools.getNodeMainDom(tmp).id;\n\t\t\t\tnodeEventType = "mousedownNode";\n\t\t\t}\n\t\t}\n\t\tif (tId.length>0) {\n\t\t\tnode = data.getNodeCache(setting, tId);\n\t\t\tswitch (nodeEventType) {\n\t\t\t\tcase "mousedownNode" :\n\t\t\t\t\tnodeEventCallback = _handler.onMousedownNode;\n\t\t\t\t\tbreak;\n\t\t\t\tcase "hoverOverNode" :\n\t\t\t\t\tnodeEventCallback = _handler.onHoverOverNode;\n\t\t\t\t\tbreak;\n\t\t\t\tcase "hoverOutNode" :\n\t\t\t\t\tnodeEventCallback = _handler.onHoverOutNode;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar proxyResult = {\n\t\t\tstop: false,\n\t\t\tnode: node,\n\t\t\tnodeEventType: nodeEventType,\n\t\t\tnodeEventCallback: nodeEventCallback,\n\t\t\ttreeEventType: treeEventType,\n\t\t\ttreeEventCallback: treeEventCallback\n\t\t};\n\t\treturn proxyResult\n\t},\n\t//default init node of exedit\n\t_initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {\n\t\tif (!n) return;\n\t\tn.isHover = false;\n\t\tn.editNameFlag = false;\n\t},\n\t//update zTreeObj, add method of edit\n\t_zTreeTools = function(setting, zTreeTools) {\n\t\tzTreeTools.cancelEditName = function(newName) {\n\t\t\tvar root = data.getRoot(this.setting);\n\t\t\tif (!root.curEditNode) return;\n\t\t\tview.cancelCurEditNode(this.setting, newName?newName:null, true);\n\t\t}\n\t\tzTreeTools.copyNode = function(targetNode, node, moveType, isSilent) {\n\t\t\tif (!node) return null;\n\t\t\tif (targetNode && !targetNode.isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) return null;\n\t\t\tvar _this = this,\n\t\t\t\tnewNode = tools.clone(node);\n\t\t\tif (!targetNode) {\n\t\t\t\ttargetNode = null;\n\t\t\t\tmoveType = consts.move.TYPE_INNER;\n\t\t\t}\n\t\t\tif (moveType == consts.move.TYPE_INNER) {\n\t\t\t\tfunction copyCallback() {\n\t\t\t\t\tview.addNodes(_this.setting, targetNode, [newNode], isSilent);\n\t\t\t\t}\n\n\t\t\t\tif (tools.canAsync(this.setting, targetNode)) {\n\t\t\t\t\tview.asyncNode(this.setting, targetNode, isSilent, copyCallback);\n\t\t\t\t} else {\n\t\t\t\t\tcopyCallback();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tview.addNodes(this.setting, targetNode.parentNode, [newNode], isSilent);\n\t\t\t\tview.moveNode(this.setting, targetNode, newNode, moveType, false, isSilent);\n\t\t\t}\n\t\t\treturn newNode;\n\t\t}\n\t\tzTreeTools.editName = function(node) {\n\t\t\tif (!node || !node.tId || node !== data.getNodeCache(this.setting, node.tId)) return;\n\t\t\tif (node.parentTId) view.expandCollapseParentNode(this.setting, node.getParentNode(), true);\n\t\t\tview.editNode(this.setting, node)\n\t\t}\n\t\tzTreeTools.moveNode = function(targetNode, node, moveType, isSilent) {\n\t\t\tif (!node) return node;\n\t\t\tif (targetNode && !targetNode.isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) {\n\t\t\t\treturn null;\n\t\t\t} else if (targetNode && ((node.parentTId == targetNode.tId && moveType == consts.move.TYPE_INNER) || $$(node, this.setting).find("#" + targetNode.tId).length > 0)) {\n\t\t\t\treturn null;\n\t\t\t} else if (!targetNode) {\n\t\t\t\ttargetNode = null;\n\t\t\t}\n\t\t\tvar _this = this;\n\t\t\tfunction moveCallback() {\n\t\t\t\tview.moveNode(_this.setting, targetNode, node, moveType, false, isSilent);\n\t\t\t}\n\t\t\tif (tools.canAsync(this.setting, targetNode) && moveType === consts.move.TYPE_INNER) {\n\t\t\t\tview.asyncNode(this.setting, targetNode, isSilent, moveCallback);\n\t\t\t} else {\n\t\t\t\tmoveCallback();\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t\tzTreeTools.setEditable = function(editable) {\n\t\t\tthis.setting.edit.enable = editable;\n\t\t\treturn this.refresh();\n\t\t}\n\t},\n\t//method of operate data\n\t_data = {\n\t\tsetSonNodeLevel: function(setting, parentNode, node) {\n\t\t\tif (!node) return;\n\t\t\tvar childKey = setting.data.key.children;\n\t\t\tnode.level = (parentNode)? parentNode.level + 1 : 0;\n\t\t\tif (!node[childKey]) return;\n\t\t\tfor (var i = 0, l = node[childKey].length; i < l; i++) {\n\t\t\t\tif (node[childKey][i]) data.setSonNodeLevel(setting, node, node[childKey][i]);\n\t\t\t}\n\t\t}\n\t},\n\t//method of event proxy\n\t_event = {\n\n\t},\n\t//method of event handler\n\t_handler = {\n\t\tonHoverOverNode: function(event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId),\n\t\t\troot = data.getRoot(setting);\n\t\t\tif (root.curHoverNode != node) {\n\t\t\t\t_handler.onHoverOutNode(event);\n\t\t\t}\n\t\t\troot.curHoverNode = node;\n\t\t\tview.addHoverDom(setting, node);\n\t\t},\n\t\tonHoverOutNode: function(event, node) {\n\t\t\tvar setting = data.getSetting(event.data.treeId),\n\t\t\troot = data.getRoot(setting);\n\t\t\tif (root.curHoverNode && !data.isSelectedNode(setting, root.curHoverNode)) {\n\t\t\t\tview.removeTreeDom(setting, root.curHoverNode);\n\t\t\t\troot.curHoverNode = null;\n\t\t\t}\n\t\t},\n\t\tonMousedownNode: function(eventMouseDown, _node) {\n\t\t\tvar i,l,\n\t\t\tsetting = data.getSetting(eventMouseDown.data.treeId),\n\t\t\troot = data.getRoot(setting), roots = data.getRoots();\n\t\t\t//right click can\'t drag & drop\n\t\t\tif (eventMouseDown.button == 2 || !setting.edit.enable || (!setting.edit.drag.isCopy && !setting.edit.drag.isMove)) return true;\n\n\t\t\t//input of edit node name can\'t drag & drop\n\t\t\tvar target = eventMouseDown.target,\n\t\t\t_nodes = data.getRoot(setting).curSelectedList,\n\t\t\tnodes = [];\n\t\t\tif (!data.isSelectedNode(setting, _node)) {\n\t\t\t\tnodes = [_node];\n\t\t\t} else {\n\t\t\t\tfor (i=0, l=_nodes.length; i<l; i++) {\n\t\t\t\t\tif (_nodes[i].editNameFlag && tools.eqs(target.tagName, "input") && target.getAttribute("treeNode"+consts.id.INPUT) !== null) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tnodes.push(_nodes[i]);\n\t\t\t\t\tif (nodes[0].parentTId !== _nodes[i].parentTId) {\n\t\t\t\t\t\tnodes = [_node];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tview.editNodeBlur = true;\n\t\t\tview.cancelCurEditNode(setting);\n\n\t\t\tvar doc = $(setting.treeObj.get(0).ownerDocument),\n\t\t\tbody = $(setting.treeObj.get(0).ownerDocument.body), curNode, tmpArrow, tmpTarget,\n\t\t\tisOtherTree = false,\n\t\t\ttargetSetting = setting,\n\t\t\tsourceSetting = setting,\n\t\t\tpreNode, nextNode,\n\t\t\tpreTmpTargetNodeId = null,\n\t\t\tpreTmpMoveType = null,\n\t\t\ttmpTargetNodeId = null,\n\t\t\tmoveType = consts.move.TYPE_INNER,\n\t\t\tmouseDownX = eventMouseDown.clientX,\n\t\t\tmouseDownY = eventMouseDown.clientY,\n\t\t\tstartTime = (new Date()).getTime();\n\n\t\t\tif (tools.uCanDo(setting)) {\n\t\t\t\tdoc.bind("mousemove", _docMouseMove);\n\t\t\t}\n\t\t\tfunction _docMouseMove(event) {\n\t\t\t\t//avoid start drag after click node\n\t\t\t\tif (root.dragFlag == 0 && Math.abs(mouseDownX - event.clientX) < setting.edit.drag.minMoveSize\n\t\t\t\t\t&& Math.abs(mouseDownY - event.clientY) < setting.edit.drag.minMoveSize) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar i, l, tmpNode, tmpDom, tmpNodes,\n\t\t\t\tchildKey = setting.data.key.children;\n\t\t\t\tbody.css("cursor", "pointer");\n\n\t\t\t\tif (root.dragFlag == 0) {\n\t\t\t\t\tif (tools.apply(setting.callback.beforeDrag, [setting.treeId, nodes], true) == false) {\n\t\t\t\t\t\t_docMouseUp(event);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i=0, l=nodes.length; i<l; i++) {\n\t\t\t\t\t\tif (i==0) {\n\t\t\t\t\t\t\troot.dragNodeShowBefore = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpNode = nodes[i];\n\t\t\t\t\t\tif (tmpNode.isParent && tmpNode.open) {\n\t\t\t\t\t\t\tview.expandCollapseNode(setting, tmpNode, !tmpNode.open);\n\t\t\t\t\t\t\troot.dragNodeShowBefore[tmpNode.tId] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\troot.dragNodeShowBefore[tmpNode.tId] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\troot.dragFlag = 1;\n\t\t\t\t\troots.showHoverDom = false;\n\t\t\t\t\ttools.showIfameMask(setting, true);\n\n\t\t\t\t\t//sort\n\t\t\t\t\tvar isOrder = true, lastIndex = -1;\n\t\t\t\t\tif (nodes.length>1) {\n\t\t\t\t\t\tvar pNodes = nodes[0].parentTId ? nodes[0].getParentNode()[childKey] : data.getNodes(setting);\n\t\t\t\t\t\ttmpNodes = [];\n\t\t\t\t\t\tfor (i=0, l=pNodes.length; i<l; i++) {\n\t\t\t\t\t\t\tif (root.dragNodeShowBefore[pNodes[i].tId] !== undefined) {\n\t\t\t\t\t\t\t\tif (isOrder && lastIndex > -1 && (lastIndex+1) !== i) {\n\t\t\t\t\t\t\t\t\tisOrder = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpNodes.push(pNodes[i]);\n\t\t\t\t\t\t\t\tlastIndex = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (nodes.length === tmpNodes.length) {\n\t\t\t\t\t\t\t\tnodes = tmpNodes;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isOrder) {\n\t\t\t\t\t\tpreNode = nodes[0].getPreNode();\n\t\t\t\t\t\tnextNode = nodes[nodes.length-1].getNextNode();\n\t\t\t\t\t}\n\n\t\t\t\t\t//set node in selected\n\t\t\t\t\tcurNode = $$("<ul class=\'zTreeDragUL\'></ul>", setting);\n\t\t\t\t\tfor (i=0, l=nodes.length; i<l; i++) {\n\t\t\t\t\t\ttmpNode = nodes[i];\n\t\t\t\t\t\ttmpNode.editNameFlag = false;\n\t\t\t\t\t\tview.selectNode(setting, tmpNode, i>0);\n\t\t\t\t\t\tview.removeTreeDom(setting, tmpNode);\n\n\t\t\t\t\t\tif (i > setting.edit.drag.maxShowNodeNum-1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmpDom = $$("<li id=\'"+ tmpNode.tId +"_tmp\'></li>", setting);\n\t\t\t\t\t\ttmpDom.append($$(tmpNode, consts.id.A, setting).clone());\n\t\t\t\t\t\ttmpDom.css("padding", "0");\n\t\t\t\t\t\ttmpDom.children("#" + tmpNode.tId + consts.id.A).removeClass(consts.node.CURSELECTED);\n\t\t\t\t\t\tcurNode.append(tmpDom);\n\t\t\t\t\t\tif (i == setting.edit.drag.maxShowNodeNum-1) {\n\t\t\t\t\t\t\ttmpDom = $$("<li id=\'"+ tmpNode.tId +"_moretmp\'><a>  ...  </a></li>", setting);\n\t\t\t\t\t\t\tcurNode.append(tmpDom);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcurNode.attr("id", nodes[0].tId + consts.id.UL + "_tmp");\n\t\t\t\t\tcurNode.addClass(setting.treeObj.attr("class"));\n\t\t\t\t\tcurNode.appendTo(body);\n\n\t\t\t\t\ttmpArrow = $$("<span class=\'tmpzTreeMove_arrow\'></span>", setting);\n\t\t\t\t\ttmpArrow.attr("id", "zTreeMove_arrow_tmp");\n\t\t\t\t\ttmpArrow.appendTo(body);\n\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.DRAG, [event, setting.treeId, nodes]);\n\t\t\t\t}\n\n\t\t\t\tif (root.dragFlag == 1) {\n\t\t\t\t\tif (tmpTarget && tmpArrow.attr("id") == event.target.id && tmpTargetNodeId && (event.clientX + doc.scrollLeft()+2) > ($("#" + tmpTargetNodeId + consts.id.A, tmpTarget).offset().left)) {\n\t\t\t\t\t\tvar xT = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget);\n\t\t\t\t\t\tevent.target = (xT.length > 0) ? xT.get(0) : event.target;\n\t\t\t\t\t} else if (tmpTarget) {\n\t\t\t\t\t\ttmpTarget.removeClass(consts.node.TMPTARGET_TREE);\n\t\t\t\t\t\tif (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)\n\t\t\t\t\t\t\t.removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);\n\t\t\t\t\t}\n\t\t\t\t\ttmpTarget = null;\n\t\t\t\t\ttmpTargetNodeId = null;\n\n\t\t\t\t\t//judge drag & drop in multi ztree\n\t\t\t\t\tisOtherTree = false;\n\t\t\t\t\ttargetSetting = setting;\n\t\t\t\t\tvar settings = data.getSettings();\n\t\t\t\t\tfor (var s in settings) {\n\t\t\t\t\t\tif (settings[s].treeId && settings[s].edit.enable && settings[s].treeId != setting.treeId\n\t\t\t\t\t\t\t&& (event.target.id == settings[s].treeId || $(event.target).parents("#" + settings[s].treeId).length>0)) {\n\t\t\t\t\t\t\tisOtherTree = true;\n\t\t\t\t\t\t\ttargetSetting = settings[s];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar docScrollTop = doc.scrollTop(),\n\t\t\t\t\tdocScrollLeft = doc.scrollLeft(),\n\t\t\t\t\ttreeOffset = targetSetting.treeObj.offset(),\n\t\t\t\t\tscrollHeight = targetSetting.treeObj.get(0).scrollHeight,\n\t\t\t\t\tscrollWidth = targetSetting.treeObj.get(0).scrollWidth,\n\t\t\t\t\tdTop = (event.clientY + docScrollTop - treeOffset.top),\n\t\t\t\t\tdBottom = (targetSetting.treeObj.height() + treeOffset.top - event.clientY - docScrollTop),\n\t\t\t\t\tdLeft = (event.clientX + docScrollLeft - treeOffset.left),\n\t\t\t\t\tdRight = (targetSetting.treeObj.width() + treeOffset.left - event.clientX - docScrollLeft),\n\t\t\t\t\tisTop = (dTop < setting.edit.drag.borderMax && dTop > setting.edit.drag.borderMin),\n\t\t\t\t\tisBottom = (dBottom < setting.edit.drag.borderMax && dBottom > setting.edit.drag.borderMin),\n\t\t\t\t\tisLeft = (dLeft < setting.edit.drag.borderMax && dLeft > setting.edit.drag.borderMin),\n\t\t\t\t\tisRight = (dRight < setting.edit.drag.borderMax && dRight > setting.edit.drag.borderMin),\n\t\t\t\t\tisTreeInner = dTop > setting.edit.drag.borderMin && dBottom > setting.edit.drag.borderMin && dLeft > setting.edit.drag.borderMin && dRight > setting.edit.drag.borderMin,\n\t\t\t\t\tisTreeTop = (isTop && targetSetting.treeObj.scrollTop() <= 0),\n\t\t\t\t\tisTreeBottom = (isBottom && (targetSetting.treeObj.scrollTop() + targetSetting.treeObj.height()+10) >= scrollHeight),\n\t\t\t\t\tisTreeLeft = (isLeft && targetSetting.treeObj.scrollLeft() <= 0),\n\t\t\t\t\tisTreeRight = (isRight && (targetSetting.treeObj.scrollLeft() + targetSetting.treeObj.width()+10) >= scrollWidth);\n\n\t\t\t\t\tif (event.target && tools.isChildOrSelf(event.target, targetSetting.treeId)) {\n\t\t\t\t\t\t//get node <li> dom\n\t\t\t\t\t\tvar targetObj = event.target;\n\t\t\t\t\t\twhile (targetObj && targetObj.tagName && !tools.eqs(targetObj.tagName, "li") && targetObj.id != targetSetting.treeId) {\n\t\t\t\t\t\t\ttargetObj = targetObj.parentNode;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar canMove = true;\n\t\t\t\t\t\t//don\'t move to self or children of self\n\t\t\t\t\t\tfor (i=0, l=nodes.length; i<l; i++) {\n\t\t\t\t\t\t\ttmpNode = nodes[i];\n\t\t\t\t\t\t\tif (targetObj.id === tmpNode.tId) {\n\t\t\t\t\t\t\t\tcanMove = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if ($$(tmpNode, setting).find("#" + targetObj.id).length > 0) {\n\t\t\t\t\t\t\t\tcanMove = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (canMove && event.target && tools.isChildOrSelf(event.target, targetObj.id + consts.id.A)) {\n\t\t\t\t\t\t\ttmpTarget = $(targetObj);\n\t\t\t\t\t\t\ttmpTargetNodeId = targetObj.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//the mouse must be in zTree\n\t\t\t\t\ttmpNode = nodes[0];\n\t\t\t\t\tif (isTreeInner && tools.isChildOrSelf(event.target, targetSetting.treeId)) {\n\t\t\t\t\t\t//judge mouse move in root of ztree\n\t\t\t\t\t\tif (!tmpTarget && (event.target.id == targetSetting.treeId || isTreeTop || isTreeBottom || isTreeLeft || isTreeRight) && (isOtherTree || (!isOtherTree && tmpNode.parentTId))) {\n\t\t\t\t\t\t\ttmpTarget = targetSetting.treeObj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//auto scroll top\n\t\t\t\t\t\tif (isTop) {\n\t\t\t\t\t\t\ttargetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()-10);\n\t\t\t\t\t\t} else if (isBottom)  {\n\t\t\t\t\t\t\ttargetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()+10);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isLeft) {\n\t\t\t\t\t\t\ttargetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()-10);\n\t\t\t\t\t\t} else if (isRight) {\n\t\t\t\t\t\t\ttargetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+10);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//auto scroll left\n\t\t\t\t\t\tif (tmpTarget && tmpTarget != targetSetting.treeObj && tmpTarget.offset().left < targetSetting.treeObj.offset().left) {\n\t\t\t\t\t\t\ttargetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+ tmpTarget.offset().left - targetSetting.treeObj.offset().left);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurNode.css({\n\t\t\t\t\t\t"top": (event.clientY + docScrollTop + 3) + "px",\n\t\t\t\t\t\t"left": (event.clientX + docScrollLeft + 3) + "px"\n\t\t\t\t\t});\n\n\t\t\t\t\tvar dX = 0;\n\t\t\t\t\tvar dY = 0;\n\t\t\t\t\tif (tmpTarget && tmpTarget.attr("id")!=targetSetting.treeId) {\n\t\t\t\t\t\tvar tmpTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId),\n\t\t\t\t\t\tisCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy),\n\t\t\t\t\t\tisPrev = !!(preNode && tmpTargetNodeId === preNode.tId),\n\t\t\t\t\t\tisNext = !!(nextNode && tmpTargetNodeId === nextNode.tId),\n\t\t\t\t\t\tisInner = (tmpNode.parentTId && tmpNode.parentTId == tmpTargetNodeId),\n\t\t\t\t\t\tcanPrev = (isCopy || !isNext) && tools.apply(targetSetting.edit.drag.prev, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.prev),\n\t\t\t\t\t\tcanNext = (isCopy || !isPrev) && tools.apply(targetSetting.edit.drag.next, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.next),\n\t\t\t\t\t\tcanInner = (isCopy || !isInner) && !(targetSetting.data.keep.leaf && !tmpTargetNode.isParent) && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.inner);\n\t\t\t\t\t\tif (!canPrev && !canNext && !canInner) {\n\t\t\t\t\t\t\ttmpTarget = null;\n\t\t\t\t\t\t\ttmpTargetNodeId = "";\n\t\t\t\t\t\t\tmoveType = consts.move.TYPE_INNER;\n\t\t\t\t\t\t\ttmpArrow.css({\n\t\t\t\t\t\t\t\t"display":"none"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (window.zTreeMoveTimer) {\n\t\t\t\t\t\t\t\tclearTimeout(window.zTreeMoveTimer);\n\t\t\t\t\t\t\t\twindow.zTreeMoveTargetNodeTId = null\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar tmpTargetA = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget),\n\t\t\t\t\t\t\ttmpNextA = tmpTargetNode.isLastNode ? null : $("#" + tmpTargetNode.getNextNode().tId + consts.id.A, tmpTarget.next()),\n\t\t\t\t\t\t\ttmpTop = tmpTargetA.offset().top,\n\t\t\t\t\t\t\ttmpLeft = tmpTargetA.offset().left,\n\t\t\t\t\t\t\tprevPercent = canPrev ? (canInner ? 0.25 : (canNext ? 0.5 : 1) ) : -1,\n\t\t\t\t\t\t\tnextPercent = canNext ? (canInner ? 0.75 : (canPrev ? 0.5 : 0) ) : -1,\n\t\t\t\t\t\t\tdY_percent = (event.clientY + docScrollTop - tmpTop)/tmpTargetA.height();\n\t\t\t\t\t\t\tif ((prevPercent==1 ||dY_percent<=prevPercent && dY_percent>=-.2) && canPrev) {\n\t\t\t\t\t\t\t\tdX = 1 - tmpArrow.width();\n\t\t\t\t\t\t\t\tdY = tmpTop - tmpArrow.height()/2;\n\t\t\t\t\t\t\t\tmoveType = consts.move.TYPE_PREV;\n\t\t\t\t\t\t\t} else if ((nextPercent==0 || dY_percent>=nextPercent && dY_percent<=1.2) && canNext) {\n\t\t\t\t\t\t\t\tdX = 1 - tmpArrow.width();\n\t\t\t\t\t\t\t\tdY = (tmpNextA == null || (tmpTargetNode.isParent && tmpTargetNode.open)) ? (tmpTop + tmpTargetA.height() - tmpArrow.height()/2) : (tmpNextA.offset().top - tmpArrow.height()/2);\n\t\t\t\t\t\t\t\tmoveType = consts.move.TYPE_NEXT;\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tdX = 5 - tmpArrow.width();\n\t\t\t\t\t\t\t\tdY = tmpTop;\n\t\t\t\t\t\t\t\tmoveType = consts.move.TYPE_INNER;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmpArrow.css({\n\t\t\t\t\t\t\t\t"display":"block",\n\t\t\t\t\t\t\t\t"top": dY + "px",\n\t\t\t\t\t\t\t\t"left": (tmpLeft + dX) + "px"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\ttmpTargetA.addClass(consts.node.TMPTARGET_NODE + "_" + moveType);\n\n\t\t\t\t\t\t\tif (preTmpTargetNodeId != tmpTargetNodeId || preTmpMoveType != moveType) {\n\t\t\t\t\t\t\t\tstartTime = (new Date()).getTime();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tmpTargetNode && tmpTargetNode.isParent && moveType == consts.move.TYPE_INNER) {\n\t\t\t\t\t\t\t\tvar startTimer = true;\n\t\t\t\t\t\t\t\tif (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId !== tmpTargetNode.tId) {\n\t\t\t\t\t\t\t\t\tclearTimeout(window.zTreeMoveTimer);\n\t\t\t\t\t\t\t\t\twindow.zTreeMoveTargetNodeTId = null;\n\t\t\t\t\t\t\t\t}else if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId === tmpTargetNode.tId) {\n\t\t\t\t\t\t\t\t\tstartTimer = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (startTimer) {\n\t\t\t\t\t\t\t\t\twindow.zTreeMoveTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\t\t\tif (moveType != consts.move.TYPE_INNER) return;\n\t\t\t\t\t\t\t\t\t\tif (tmpTargetNode && tmpTargetNode.isParent && !tmpTargetNode.open && (new Date()).getTime() - startTime > targetSetting.edit.drag.autoOpenTime\n\t\t\t\t\t\t\t\t\t\t\t&& tools.apply(targetSetting.callback.beforeDragOpen, [targetSetting.treeId, tmpTargetNode], true)) {\n\t\t\t\t\t\t\t\t\t\t\tview.switchNode(targetSetting, tmpTargetNode);\n\t\t\t\t\t\t\t\t\t\t\tif (targetSetting.edit.drag.autoExpandTrigger) {\n\t\t\t\t\t\t\t\t\t\t\t\ttargetSetting.treeObj.trigger(consts.event.EXPAND, [targetSetting.treeId, tmpTargetNode]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, targetSetting.edit.drag.autoOpenTime+50);\n\t\t\t\t\t\t\t\t\twindow.zTreeMoveTargetNodeTId = tmpTargetNode.tId;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmoveType = consts.move.TYPE_INNER;\n\t\t\t\t\t\tif (tmpTarget && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, null], !!targetSetting.edit.drag.inner)) {\n\t\t\t\t\t\t\ttmpTarget.addClass(consts.node.TMPTARGET_TREE);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmpTarget = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpArrow.css({\n\t\t\t\t\t\t\t"display":"none"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (window.zTreeMoveTimer) {\n\t\t\t\t\t\t\tclearTimeout(window.zTreeMoveTimer);\n\t\t\t\t\t\t\twindow.zTreeMoveTargetNodeTId = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreTmpTargetNodeId = tmpTargetNodeId;\n\t\t\t\t\tpreTmpMoveType = moveType;\n\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.DRAGMOVE, [event, setting.treeId, nodes]);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tdoc.bind("mouseup", _docMouseUp);\n\t\t\tfunction _docMouseUp(event) {\n\t\t\t\tif (window.zTreeMoveTimer) {\n\t\t\t\t\tclearTimeout(window.zTreeMoveTimer);\n\t\t\t\t\twindow.zTreeMoveTargetNodeTId = null;\n\t\t\t\t}\n\t\t\t\tpreTmpTargetNodeId = null;\n\t\t\t\tpreTmpMoveType = null;\n\t\t\t\tdoc.unbind("mousemove", _docMouseMove);\n\t\t\t\tdoc.unbind("mouseup", _docMouseUp);\n\t\t\t\tdoc.unbind("selectstart", _docSelect);\n\t\t\t\tbody.css("cursor", "auto");\n\t\t\t\tif (tmpTarget) {\n\t\t\t\t\ttmpTarget.removeClass(consts.node.TMPTARGET_TREE);\n\t\t\t\t\tif (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)\n\t\t\t\t\t\t\t.removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);\n\t\t\t\t}\n\t\t\t\ttools.showIfameMask(setting, false);\n\n\t\t\t\troots.showHoverDom = true;\n\t\t\t\tif (root.dragFlag == 0) return;\n\t\t\t\troot.dragFlag = 0;\n\n\t\t\t\tvar i, l, tmpNode;\n\t\t\t\tfor (i=0, l=nodes.length; i<l; i++) {\n\t\t\t\t\ttmpNode = nodes[i];\n\t\t\t\t\tif (tmpNode.isParent && root.dragNodeShowBefore[tmpNode.tId] && !tmpNode.open) {\n\t\t\t\t\t\tview.expandCollapseNode(setting, tmpNode, !tmpNode.open);\n\t\t\t\t\t\tdelete root.dragNodeShowBefore[tmpNode.tId];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (curNode) curNode.remove();\n\t\t\t\tif (tmpArrow) tmpArrow.remove();\n\n\t\t\t\tvar isCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy);\n\t\t\t\tif (!isCopy && tmpTarget && tmpTargetNodeId && nodes[0].parentTId && tmpTargetNodeId==nodes[0].parentTId && moveType == consts.move.TYPE_INNER) {\n\t\t\t\t\ttmpTarget = null;\n\t\t\t\t}\n\t\t\t\tif (tmpTarget) {\n\t\t\t\t\tvar dragTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId);\n\t\t\t\t\tif (tools.apply(setting.callback.beforeDrop, [targetSetting.treeId, nodes, dragTargetNode, moveType, isCopy], true) == false) {\n\t\t\t\t\t\tview.selectNodes(sourceSetting, nodes);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar newNodes = isCopy ? tools.clone(nodes) : nodes;\n\n\t\t\t\t\tfunction dropCallback() {\n\t\t\t\t\t\tif (isOtherTree) {\n\t\t\t\t\t\t\tif (!isCopy) {\n\t\t\t\t\t\t\t\tfor(var i=0, l=nodes.length; i<l; i++) {\n\t\t\t\t\t\t\t\t\tview.removeNode(setting, nodes[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (moveType == consts.move.TYPE_INNER) {\n\t\t\t\t\t\t\t\tview.addNodes(targetSetting, dragTargetNode, newNodes);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tview.addNodes(targetSetting, dragTargetNode.getParentNode(), newNodes);\n\t\t\t\t\t\t\t\tif (moveType == consts.move.TYPE_PREV) {\n\t\t\t\t\t\t\t\t\tfor (i=0, l=newNodes.length; i<l; i++) {\n\t\t\t\t\t\t\t\t\t\tview.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (i=-1, l=newNodes.length-1; i<l; l--) {\n\t\t\t\t\t\t\t\t\t\tview.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (isCopy && moveType == consts.move.TYPE_INNER) {\n\t\t\t\t\t\t\t\tview.addNodes(targetSetting, dragTargetNode, newNodes);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (isCopy) {\n\t\t\t\t\t\t\t\t\tview.addNodes(targetSetting, dragTargetNode.getParentNode(), newNodes);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (moveType != consts.move.TYPE_NEXT) {\n\t\t\t\t\t\t\t\t\tfor (i=0, l=newNodes.length; i<l; i++) {\n\t\t\t\t\t\t\t\t\t\tview.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (i=-1, l=newNodes.length-1; i<l; l--) {\n\t\t\t\t\t\t\t\t\t\tview.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tview.selectNodes(targetSetting, newNodes);\n\t\t\t\t\t\t$$(newNodes[0], setting).focus().blur();\n\n\t\t\t\t\t\tsetting.treeObj.trigger(consts.event.DROP, [event, targetSetting.treeId, newNodes, dragTargetNode, moveType, isCopy]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (moveType == consts.move.TYPE_INNER && tools.canAsync(targetSetting, dragTargetNode)) {\n\t\t\t\t\t\tview.asyncNode(targetSetting, dragTargetNode, false, dropCallback);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdropCallback();\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tview.selectNodes(sourceSetting, nodes);\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.DROP, [event, setting.treeId, nodes, null, null, null]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdoc.bind("selectstart", _docSelect);\n\t\t\tfunction _docSelect() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//Avoid FireFox\'s Bug\n\t\t\t//If zTree Div CSS set \'overflow\', so drag node outside of zTree, and event.target is error.\n\t\t\tif(eventMouseDown.preventDefault) {\n\t\t\t\teventMouseDown.preventDefault();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\t//method of tools for zTree\n\t_tools = {\n\t\tgetAbs: function (obj) {\n\t\t\tvar oRect = obj.getBoundingClientRect(),\n\t\t\tscrollTop = document.body.scrollTop+document.documentElement.scrollTop,\n\t\t\tscrollLeft = document.body.scrollLeft+document.documentElement.scrollLeft;\n\t\t\treturn [oRect.left+scrollLeft,oRect.top+scrollTop];\n\t\t},\n\t\tinputFocus: function(inputObj) {\n\t\t\tif (inputObj.get(0)) {\n\t\t\t\tinputObj.focus();\n\t\t\t\ttools.setCursorPosition(inputObj.get(0), inputObj.val().length);\n\t\t\t}\n\t\t},\n\t\tinputSelect: function(inputObj) {\n\t\t\tif (inputObj.get(0)) {\n\t\t\t\tinputObj.focus();\n\t\t\t\tinputObj.select();\n\t\t\t}\n\t\t},\n\t\tsetCursorPosition: function(obj, pos){\n\t\t\tif(obj.setSelectionRange) {\n\t\t\t\tobj.focus();\n\t\t\t\tobj.setSelectionRange(pos,pos);\n\t\t\t} else if (obj.createTextRange) {\n\t\t\t\tvar range = obj.createTextRange();\n\t\t\t\trange.collapse(true);\n\t\t\t\trange.moveEnd(\'character\', pos);\n\t\t\t\trange.moveStart(\'character\', pos);\n\t\t\t\trange.select();\n\t\t\t}\n\t\t},\n\t\tshowIfameMask: function(setting, showSign) {\n\t\t\tvar root = data.getRoot(setting);\n\t\t\t//clear full mask\n\t\t\twhile (root.dragMaskList.length > 0) {\n\t\t\t\troot.dragMaskList[0].remove();\n\t\t\t\troot.dragMaskList.shift();\n\t\t\t}\n\t\t\tif (showSign) {\n\t\t\t\t//show mask\n\t\t\t\tvar iframeList = $$("iframe", setting);\n\t\t\t\tfor (var i = 0, l = iframeList.length; i < l; i++) {\n\t\t\t\t\tvar obj = iframeList.get(i),\n\t\t\t\t\tr = tools.getAbs(obj),\n\t\t\t\t\tdragMask = $$("<div id=\'zTreeMask_" + i + "\' class=\'zTreeMask\' style=\'top:" + r[1] + "px; left:" + r[0] + "px; width:" + obj.offsetWidth + "px; height:" + obj.offsetHeight + "px;\'></div>", setting);\n\t\t\t\t\tdragMask.appendTo($$("body", setting));\n\t\t\t\t\troot.dragMaskList.push(dragMask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t//method of operate ztree dom\n\t_view = {\n\t\taddEditBtn: function(setting, node) {\n\t\t\tif (node.editNameFlag || $$(node, consts.id.EDIT, setting).length > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!tools.apply(setting.edit.showRenameBtn, [setting.treeId, node], setting.edit.showRenameBtn)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar aObj = $$(node, consts.id.A, setting),\n\t\t\teditStr = "<span class=\'" + consts.className.BUTTON + " edit\' id=\'" + node.tId + consts.id.EDIT + "\' title=\'"+tools.apply(setting.edit.renameTitle, [setting.treeId, node], setting.edit.renameTitle)+"\' treeNode"+consts.id.EDIT+" style=\'display:none;\'></span>";\n\t\t\taObj.append(editStr);\n\n\t\t\t$$(node, consts.id.EDIT, setting).bind(\'click\',\n\t\t\t\tfunction() {\n\t\t\t\t\tif (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeEditName, [setting.treeId, node], true) == false) return false;\n\t\t\t\t\tview.editNode(setting, node);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t).show();\n\t\t},\n\t\taddRemoveBtn: function(setting, node) {\n\t\t\tif (node.editNameFlag || $$(node, consts.id.REMOVE, setting).length > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!tools.apply(setting.edit.showRemoveBtn, [setting.treeId, node], setting.edit.showRemoveBtn)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar aObj = $$(node, consts.id.A, setting),\n\t\t\tremoveStr = "<span class=\'" + consts.className.BUTTON + " remove\' id=\'" + node.tId + consts.id.REMOVE + "\' title=\'"+tools.apply(setting.edit.removeTitle, [setting.treeId, node], setting.edit.removeTitle)+"\' treeNode"+consts.id.REMOVE+" style=\'display:none;\'></span>";\n\t\t\taObj.append(removeStr);\n\n\t\t\t$$(node, consts.id.REMOVE, setting).bind(\'click\',\n\t\t\t\tfunction() {\n\t\t\t\t\tif (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return false;\n\t\t\t\t\tview.removeNode(setting, node);\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t).bind(\'mousedown\',\n\t\t\t\tfunction(eventMouseDown) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t).show();\n\t\t},\n\t\taddHoverDom: function(setting, node) {\n\t\t\tif (data.getRoots().showHoverDom) {\n\t\t\t\tnode.isHover = true;\n\t\t\t\tif (setting.edit.enable) {\n\t\t\t\t\tview.addEditBtn(setting, node);\n\t\t\t\t\tview.addRemoveBtn(setting, node);\n\t\t\t\t}\n\t\t\t\ttools.apply(setting.view.addHoverDom, [setting.treeId, node]);\n\t\t\t}\n\t\t},\n\t\tcancelCurEditNode: function (setting, forceName, isCancel) {\n\t\t\tvar root = data.getRoot(setting),\n\t\t\tnameKey = setting.data.key.name,\n\t\t\tnode = root.curEditNode;\n\n\t\t\tif (node) {\n\t\t\t\tvar inputObj = root.curEditInput,\n\t\t\t\tnewName = forceName ? forceName:(isCancel ? node[nameKey]: inputObj.val());\n\t\t\t\tif (tools.apply(setting.callback.beforeRename, [setting.treeId, node, newName, isCancel], true) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tnode[nameKey] = newName;\n\t\t\t\t\tsetting.treeObj.trigger(consts.event.RENAME, [setting.treeId, node, isCancel]);\n\t\t\t\t}\n\t\t\t\tvar aObj = $$(node, consts.id.A, setting);\n\t\t\t\taObj.removeClass(consts.node.CURSELECTED_EDIT);\n\t\t\t\tinputObj.unbind();\n\t\t\t\tview.setNodeName(setting, node);\n\t\t\t\tnode.editNameFlag = false;\n\t\t\t\troot.curEditNode = null;\n\t\t\t\troot.curEditInput = null;\n\t\t\t\tview.selectNode(setting, node, false);\n\t\t\t}\n\t\t\troot.noSelection = true;\n\t\t\treturn true;\n\t\t},\n\t\teditNode: function(setting, node) {\n\t\t\tvar root = data.getRoot(setting);\n\t\t\tview.editNodeBlur = false;\n\t\t\tif (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {\n\t\t\t\tsetTimeout(function() {tools.inputFocus(root.curEditInput);}, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar nameKey = setting.data.key.name;\n\t\t\tnode.editNameFlag = true;\n\t\t\tview.removeTreeDom(setting, node);\n\t\t\tview.cancelCurEditNode(setting);\n\t\t\tview.selectNode(setting, node, false);\n\t\t\t$$(node, consts.id.SPAN, setting).html("<input type=text class=\'rename\' id=\'" + node.tId + consts.id.INPUT + "\' treeNode" + consts.id.INPUT + " >");\n\t\t\tvar inputObj = $$(node, consts.id.INPUT, setting);\n\t\t\tinputObj.attr("value", node[nameKey]);\n\t\t\tif (setting.edit.editNameSelectAll) {\n\t\t\t\ttools.inputSelect(inputObj);\n\t\t\t} else {\n\t\t\t\ttools.inputFocus(inputObj);\n\t\t\t}\n\n\t\t\tinputObj.bind(\'blur\', function(event) {\n\t\t\t\tif (!view.editNodeBlur) {\n\t\t\t\t\tview.cancelCurEditNode(setting);\n\t\t\t\t}\n\t\t\t}).bind(\'keydown\', function(event) {\n\t\t\t\tif (event.keyCode=="13") {\n\t\t\t\t\tview.editNodeBlur = true;\n\t\t\t\t\tview.cancelCurEditNode(setting);\n\t\t\t\t} else if (event.keyCode=="27") {\n\t\t\t\t\tview.cancelCurEditNode(setting, null, true);\n\t\t\t\t}\n\t\t\t}).bind(\'click\', function(event) {\n\t\t\t\treturn false;\n\t\t\t}).bind(\'dblclick\', function(event) {\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\t$$(node, consts.id.A, setting).addClass(consts.node.CURSELECTED_EDIT);\n\t\t\troot.curEditInput = inputObj;\n\t\t\troot.noSelection = false;\n\t\t\troot.curEditNode = node;\n\t\t},\n\t\tmoveNode: function(setting, targetNode, node, moveType, animateFlag, isSilent) {\n\t\t\tvar root = data.getRoot(setting),\n\t\t\tchildKey = setting.data.key.children;\n\t\t\tif (targetNode == node) return;\n\t\t\tif (setting.data.keep.leaf && targetNode && !targetNode.isParent && moveType == consts.move.TYPE_INNER) return;\n\t\t\tvar oldParentNode = (node.parentTId ? node.getParentNode(): root),\n\t\t\ttargetNodeIsRoot = (targetNode === null || targetNode == root);\n\t\t\tif (targetNodeIsRoot && targetNode === null) targetNode = root;\n\t\t\tif (targetNodeIsRoot) moveType = consts.move.TYPE_INNER;\n\t\t\tvar targetParentNode = (targetNode.parentTId ? targetNode.getParentNode() : root);\n\n\t\t\tif (moveType != consts.move.TYPE_PREV && moveType != consts.move.TYPE_NEXT) {\n\t\t\t\tmoveType = consts.move.TYPE_INNER;\n\t\t\t}\n\n\t\t\tif (moveType == consts.move.TYPE_INNER) {\n\t\t\t\tif (targetNodeIsRoot) {\n\t\t\t\t\t//parentTId of root node is null\n\t\t\t\t\tnode.parentTId = null;\n\t\t\t\t} else {\n\t\t\t\t\tif (!targetNode.isParent) {\n\t\t\t\t\t\ttargetNode.isParent = true;\n\t\t\t\t\t\ttargetNode.open = !!targetNode.open;\n\t\t\t\t\t\tview.setNodeLineIcos(setting, targetNode);\n\t\t\t\t\t}\n\t\t\t\t\tnode.parentTId = targetNode.tId;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//move node Dom\n\t\t\tvar targetObj, target_ulObj;\n\t\t\tif (targetNodeIsRoot) {\n\t\t\t\ttargetObj = setting.treeObj;\n\t\t\t\ttarget_ulObj = targetObj;\n\t\t\t} else {\n\t\t\t\tif (!isSilent && moveType == consts.move.TYPE_INNER) {\n\t\t\t\t\tview.expandCollapseNode(setting, targetNode, true, false);\n\t\t\t\t} else if (!isSilent) {\n\t\t\t\t\tview.expandCollapseNode(setting, targetNode.getParentNode(), true, false);\n\t\t\t\t}\n\t\t\t\ttargetObj = $$(targetNode, setting);\n\t\t\t\ttarget_ulObj = $$(targetNode, consts.id.UL, setting);\n\t\t\t\tif (!!targetObj.get(0) && !target_ulObj.get(0)) {\n\t\t\t\t\tvar ulstr = [];\n\t\t\t\t\tview.makeUlHtml(setting, targetNode, ulstr, \'\');\n\t\t\t\t\ttargetObj.append(ulstr.join(\'\'));\n\t\t\t\t}\n\t\t\t\ttarget_ulObj = $$(targetNode, consts.id.UL, setting);\n\t\t\t}\n\t\t\tvar nodeDom = $$(node, setting);\n\t\t\tif (!nodeDom.get(0)) {\n\t\t\t\tnodeDom = view.appendNodes(setting, node.level, [node], null, false, true).join(\'\');\n\t\t\t} else if (!targetObj.get(0)) {\n\t\t\t\tnodeDom.remove();\n\t\t\t}\n\t\t\tif (target_ulObj.get(0) && moveType == consts.move.TYPE_INNER) {\n\t\t\t\ttarget_ulObj.append(nodeDom);\n\t\t\t} else if (targetObj.get(0) && moveType == consts.move.TYPE_PREV) {\n\t\t\t\ttargetObj.before(nodeDom);\n\t\t\t} else if (targetObj.get(0) && moveType == consts.move.TYPE_NEXT) {\n\t\t\t\ttargetObj.after(nodeDom);\n\t\t\t}\n\n\t\t\t//repair the data after move\n\t\t\tvar i,l,\n\t\t\ttmpSrcIndex = -1,\n\t\t\ttmpTargetIndex = 0,\n\t\t\toldNeighbor = null,\n\t\t\tnewNeighbor = null,\n\t\t\toldLevel = node.level;\n\t\t\tif (node.isFirstNode) {\n\t\t\t\ttmpSrcIndex = 0;\n\t\t\t\tif (oldParentNode[childKey].length > 1 ) {\n\t\t\t\t\toldNeighbor = oldParentNode[childKey][1];\n\t\t\t\t\toldNeighbor.isFirstNode = true;\n\t\t\t\t}\n\t\t\t} else if (node.isLastNode) {\n\t\t\t\ttmpSrcIndex = oldParentNode[childKey].length -1;\n\t\t\t\toldNeighbor = oldParentNode[childKey][tmpSrcIndex - 1];\n\t\t\t\toldNeighbor.isLastNode = true;\n\t\t\t} else {\n\t\t\t\tfor (i = 0, l = oldParentNode[childKey].length; i < l; i++) {\n\t\t\t\t\tif (oldParentNode[childKey][i].tId == node.tId) {\n\t\t\t\t\t\ttmpSrcIndex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmpSrcIndex >= 0) {\n\t\t\t\toldParentNode[childKey].splice(tmpSrcIndex, 1);\n\t\t\t}\n\t\t\tif (moveType != consts.move.TYPE_INNER) {\n\t\t\t\tfor (i = 0, l = targetParentNode[childKey].length; i < l; i++) {\n\t\t\t\t\tif (targetParentNode[childKey][i].tId == targetNode.tId) tmpTargetIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (moveType == consts.move.TYPE_INNER) {\n\t\t\t\tif (!targetNode[childKey]) targetNode[childKey] = new Array();\n\t\t\t\tif (targetNode[childKey].length > 0) {\n\t\t\t\t\tnewNeighbor = targetNode[childKey][targetNode[childKey].length - 1];\n\t\t\t\t\tnewNeighbor.isLastNode = false;\n\t\t\t\t}\n\t\t\t\ttargetNode[childKey].splice(targetNode[childKey].length, 0, node);\n\t\t\t\tnode.isLastNode = true;\n\t\t\t\tnode.isFirstNode = (targetNode[childKey].length == 1);\n\t\t\t} else if (targetNode.isFirstNode && moveType == consts.move.TYPE_PREV) {\n\t\t\t\ttargetParentNode[childKey].splice(tmpTargetIndex, 0, node);\n\t\t\t\tnewNeighbor = targetNode;\n\t\t\t\tnewNeighbor.isFirstNode = false;\n\t\t\t\tnode.parentTId = targetNode.parentTId;\n\t\t\t\tnode.isFirstNode = true;\n\t\t\t\tnode.isLastNode = false;\n\n\t\t\t} else if (targetNode.isLastNode && moveType == consts.move.TYPE_NEXT) {\n\t\t\t\ttargetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);\n\t\t\t\tnewNeighbor = targetNode;\n\t\t\t\tnewNeighbor.isLastNode = false;\n\t\t\t\tnode.parentTId = targetNode.parentTId;\n\t\t\t\tnode.isFirstNode = false;\n\t\t\t\tnode.isLastNode = true;\n\n\t\t\t} else {\n\t\t\t\tif (moveType == consts.move.TYPE_PREV) {\n\t\t\t\t\ttargetParentNode[childKey].splice(tmpTargetIndex, 0, node);\n\t\t\t\t} else {\n\t\t\t\t\ttargetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);\n\t\t\t\t}\n\t\t\t\tnode.parentTId = targetNode.parentTId;\n\t\t\t\tnode.isFirstNode = false;\n\t\t\t\tnode.isLastNode = false;\n\t\t\t}\n\t\t\tdata.fixPIdKeyValue(setting, node);\n\t\t\tdata.setSonNodeLevel(setting, node.getParentNode(), node);\n\n\t\t\t//repair node what been moved\n\t\t\tview.setNodeLineIcos(setting, node);\n\t\t\tview.repairNodeLevelClass(setting, node, oldLevel)\n\n\t\t\t//repair node\'s old parentNode dom\n\t\t\tif (!setting.data.keep.parent && oldParentNode[childKey].length < 1) {\n\t\t\t\t//old parentNode has no child nodes\n\t\t\t\toldParentNode.isParent = false;\n\t\t\t\toldParentNode.open = false;\n\t\t\t\tvar tmp_ulObj = $$(oldParentNode, consts.id.UL, setting),\n\t\t\t\ttmp_switchObj = $$(oldParentNode, consts.id.SWITCH, setting),\n\t\t\t\ttmp_icoObj = $$(oldParentNode, consts.id.ICON, setting);\n\t\t\t\tview.replaceSwitchClass(oldParentNode, tmp_switchObj, consts.folder.DOCU);\n\t\t\t\tview.replaceIcoClass(oldParentNode, tmp_icoObj, consts.folder.DOCU);\n\t\t\t\ttmp_ulObj.css("display", "none");\n\n\t\t\t} else if (oldNeighbor) {\n\t\t\t\t//old neigbor node\n\t\t\t\tview.setNodeLineIcos(setting, oldNeighbor);\n\t\t\t}\n\n\t\t\t//new neigbor node\n\t\t\tif (newNeighbor) {\n\t\t\t\tview.setNodeLineIcos(setting, newNeighbor);\n\t\t\t}\n\n\t\t\t//repair checkbox / radio\n\t\t\tif (!!setting.check && setting.check.enable && view.repairChkClass) {\n\t\t\t\tview.repairChkClass(setting, oldParentNode);\n\t\t\t\tview.repairParentChkClassWithSelf(setting, oldParentNode);\n\t\t\t\tif (oldParentNode != node.parent)\n\t\t\t\t\tview.repairParentChkClassWithSelf(setting, node);\n\t\t\t}\n\n\t\t\t//expand parents after move\n\t\t\tif (!isSilent) {\n\t\t\t\tview.expandCollapseParentNode(setting, node.getParentNode(), true, animateFlag);\n\t\t\t}\n\t\t},\n\t\tremoveEditBtn: function(setting, node) {\n\t\t\t$$(node, consts.id.EDIT, setting).unbind().remove();\n\t\t},\n\t\tremoveRemoveBtn: function(setting, node) {\n\t\t\t$$(node, consts.id.REMOVE, setting).unbind().remove();\n\t\t},\n\t\tremoveTreeDom: function(setting, node) {\n\t\t\tnode.isHover = false;\n\t\t\tview.removeEditBtn(setting, node);\n\t\t\tview.removeRemoveBtn(setting, node);\n\t\t\ttools.apply(setting.view.removeHoverDom, [setting.treeId, node]);\n\t\t},\n\t\trepairNodeLevelClass: function(setting, node, oldLevel) {\n\t\t\tif (oldLevel === node.level) return;\n\t\t\tvar liObj = $$(node, setting),\n\t\t\taObj = $$(node, consts.id.A, setting),\n\t\t\tulObj = $$(node, consts.id.UL, setting),\n\t\t\toldClass = consts.className.LEVEL + oldLevel,\n\t\t\tnewClass = consts.className.LEVEL + node.level;\n\t\t\tliObj.removeClass(oldClass);\n\t\t\tliObj.addClass(newClass);\n\t\t\taObj.removeClass(oldClass);\n\t\t\taObj.addClass(newClass);\n\t\t\tulObj.removeClass(oldClass);\n\t\t\tulObj.addClass(newClass);\n\t\t},\n\t\tselectNodes : function(setting, nodes) {\n\t\t\tfor (var i=0, l=nodes.length; i<l; i++) {\n\t\t\t\tview.selectNode(setting, nodes[i], i>0);\n\t\t\t}\n\t\t}\n\t},\n\n\t_z = {\n\t\ttools: _tools,\n\t\tview: _view,\n\t\tevent: _event,\n\t\tdata: _data\n\t};\n\t$.extend(true, $.fn.zTree.consts, _consts);\n\t$.extend(true, $.fn.zTree._z, _z);\n\n\tvar zt = $.fn.zTree,\n\ttools = zt._z.tools,\n\tconsts = zt.consts,\n\tview = zt._z.view,\n\tdata = zt._z.data,\n\tevent = zt._z.event,\n\t$$ = tools.$;\n\n\tdata.exSetting(_setting);\n\tdata.addInitBind(_bindEvent);\n\tdata.addInitUnBind(_unbindEvent);\n\tdata.addInitCache(_initCache);\n\tdata.addInitNode(_initNode);\n\tdata.addInitProxy(_eventProxy);\n\tdata.addInitRoot(_initRoot);\n\tdata.addZTreeTools(_zTreeTools);\n\n\tvar _cancelPreSelectedNode = view.cancelPreSelectedNode;\n\tview.cancelPreSelectedNode = function (setting, node) {\n\t\tvar list = data.getRoot(setting).curSelectedList;\n\t\tfor (var i=0, j=list.length; i<j; i++) {\n\t\t\tif (!node || node === list[i]) {\n\t\t\t\tview.removeTreeDom(setting, list[i]);\n\t\t\t\tif (node) break;\n\t\t\t}\n\t\t}\n\t\tif (_cancelPreSelectedNode) _cancelPreSelectedNode.apply(view, arguments);\n\t}\n\n\tvar _createNodes = view.createNodes;\n\tview.createNodes = function(setting, level, nodes, parentNode) {\n\t\tif (_createNodes) {\n\t\t\t_createNodes.apply(view, arguments);\n\t\t}\n\t\tif (!nodes) return;\n\t\tif (view.repairParentChkClassWithSelf) {\n\t\t\tview.repairParentChkClassWithSelf(setting, parentNode);\n\t\t}\n\t}\n\n\tvar _makeNodeUrl = view.makeNodeUrl;\n\tview.makeNodeUrl = function(setting, node) {\n\t\treturn setting.edit.enable ? null : (_makeNodeUrl.apply(view, arguments));\n\t}\n\n\tvar _removeNode = view.removeNode;\n\tview.removeNode = function(setting, node) {\n\t\tvar root = data.getRoot(setting);\n\t\tif (root.curEditNode === node) root.curEditNode = null;\n\t\tif (_removeNode) {\n\t\t\t_removeNode.apply(view, arguments);\n\t\t}\n\t}\n\n\tvar _selectNode = view.selectNode;\n\tview.selectNode = function(setting, node, addFlag) {\n\t\tvar root = data.getRoot(setting);\n\t\tif (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {\n\t\t\treturn false;\n\t\t}\n\t\tif (_selectNode) _selectNode.apply(view, arguments);\n\t\tview.addHoverDom(setting, node);\n\t\treturn true;\n\t}\n\n\tvar _uCanDo = tools.uCanDo;\n\ttools.uCanDo = function(setting, e) {\n\t\tvar root = data.getRoot(setting);\n\t\tif (e && (tools.eqs(e.type, "mouseover") || tools.eqs(e.type, "mouseout") || tools.eqs(e.type, "mousedown") || tools.eqs(e.type, "mouseup"))) {\n\t\t\treturn true;\n\t\t}\n\t\tif (root.curEditNode) {\n\t\t\tview.editNodeBlur = false;\n\t\t\troot.curEditInput.focus();\n\t\t}\n\t\treturn (!root.curEditNode) && (_uCanDo ? _uCanDo.apply(view, arguments) : true);\n\t}\n})(jQuery);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy96dHJlZS9qcXVlcnkuenRyZWUuYWxsLm1pbi5qcz9lNjY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDJDQUEyQyw2Q0FBNkM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDBDQUEwQyw2Q0FBNkM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZDQUE2QztBQUN2RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlGQUFpRjtBQUNsRzs7QUFFQTtBQUNBLGtEQUFrRCxlQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUVBQXlFLHFCQUFxQixxQkFBcUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csOENBQThDLHFCQUFxQixxQkFBcUI7QUFDOUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Rjs7QUFFdkY7QUFDQSw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxrQ0FBa0M7QUFDbkUsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsNEJBQTRCLElBQUksa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLE9BQU87QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QyxRQUFRO0FBQ1IsT0FBTztBQUNQLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTEFBaUw7QUFDakw7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixPQUFPO0FBQ1AsbUJBQW1CO0FBQ25CLE9BQU87QUFDUCxtQkFBbUI7QUFDbkIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLG9DQUFvQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDZDQUE2QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpREFBaUQsNkNBQTZDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBDQUEwQyw2Q0FBNkM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVCx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVCx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQSw4RkFBOEYscUJBQXFCLGlDQUFpQyxtQ0FBbUM7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJQQUEyUDtBQUMzUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbVFBQW1RO0FBQ25ROztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuICogSlF1ZXJ5IHpUcmVlIGNvcmUgdjMuNS4xNy1iZXRhLjJcbiAqIGh0dHA6Ly96VHJlZS5tZS9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgSHVudGVyLnpcbiAqXG4gKiBMaWNlbnNlZCBzYW1lIGFzIGpxdWVyeSAtIE1JVCBMaWNlbnNlXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIGVtYWlsOiBodW50ZXIuekAyNjMubmV0XG4gKiBEYXRlOiAyMDE0LTA1LTA4XG4gKi9cbihmdW5jdGlvbigkKXtcblx0dmFyIHNldHRpbmdzID0ge30sIHJvb3RzID0ge30sIGNhY2hlcyA9IHt9LFxuXHQvL2RlZmF1bHQgY29uc3RzIG9mIGNvcmVcblx0X2NvbnN0cyA9IHtcblx0XHRjbGFzc05hbWU6IHtcblx0XHRcdEJVVFRPTjogXCJidXR0b25cIixcblx0XHRcdExFVkVMOiBcImxldmVsXCIsXG5cdFx0XHRJQ09fTE9BRElORzogXCJpY29fbG9hZGluZ1wiLFxuXHRcdFx0U1dJVENIOiBcInN3aXRjaFwiXG5cdFx0fSxcblx0XHRldmVudDoge1xuXHRcdFx0Tk9ERUNSRUFURUQ6IFwienRyZWVfbm9kZUNyZWF0ZWRcIixcblx0XHRcdENMSUNLOiBcInp0cmVlX2NsaWNrXCIsXG5cdFx0XHRFWFBBTkQ6IFwienRyZWVfZXhwYW5kXCIsXG5cdFx0XHRDT0xMQVBTRTogXCJ6dHJlZV9jb2xsYXBzZVwiLFxuXHRcdFx0QVNZTkNfU1VDQ0VTUzogXCJ6dHJlZV9hc3luY19zdWNjZXNzXCIsXG5cdFx0XHRBU1lOQ19FUlJPUjogXCJ6dHJlZV9hc3luY19lcnJvclwiLFxuXHRcdFx0UkVNT1ZFOiBcInp0cmVlX3JlbW92ZVwiXG5cdFx0fSxcblx0XHRpZDoge1xuXHRcdFx0QTogXCJfYVwiLFxuXHRcdFx0SUNPTjogXCJfaWNvXCIsXG5cdFx0XHRTUEFOOiBcIl9zcGFuXCIsXG5cdFx0XHRTV0lUQ0g6IFwiX3N3aXRjaFwiLFxuXHRcdFx0VUw6IFwiX3VsXCJcblx0XHR9LFxuXHRcdGxpbmU6IHtcblx0XHRcdFJPT1Q6IFwicm9vdFwiLFxuXHRcdFx0Uk9PVFM6IFwicm9vdHNcIixcblx0XHRcdENFTlRFUjogXCJjZW50ZXJcIixcblx0XHRcdEJPVFRPTTogXCJib3R0b21cIixcblx0XHRcdE5PTElORTogXCJub2xpbmVcIixcblx0XHRcdExJTkU6IFwibGluZVwiXG5cdFx0fSxcblx0XHRmb2xkZXI6IHtcblx0XHRcdE9QRU46IFwib3BlblwiLFxuXHRcdFx0Q0xPU0U6IFwiY2xvc2VcIixcblx0XHRcdERPQ1U6IFwiZG9jdVwiXG5cdFx0fSxcblx0XHRub2RlOiB7XG5cdFx0XHRDVVJTRUxFQ1RFRDogXCJjdXJTZWxlY3RlZE5vZGVcIixcblx0XHRcdFNFTEVDVExJOlwiU0VMRUNUX0xJXCJcblx0XHR9XG5cdH0sXG5cdC8vZGVmYXVsdCBzZXR0aW5nIG9mIGNvcmVcblx0X3NldHRpbmcgPSB7XG5cdFx0dHJlZUlkOiBcIlwiLFxuXHRcdHRyZWVPYmo6IG51bGwsXG5cdFx0dmlldzoge1xuXHRcdFx0YWRkRGl5RG9tOiBudWxsLFxuXHRcdFx0YXV0b0NhbmNlbFNlbGVjdGVkOiB0cnVlLFxuXHRcdFx0ZGJsQ2xpY2tFeHBhbmQ6IHRydWUsXG5cdFx0XHRleHBhbmRTcGVlZDogXCJmYXN0XCIsXG5cdFx0XHRmb250Q3NzOiB7fSxcblx0XHRcdG5hbWVJc0hUTUw6IGZhbHNlLFxuXHRcdFx0c2VsZWN0ZWRNdWx0aTogdHJ1ZSxcblx0XHRcdHNob3dJY29uOiB0cnVlLFxuXHRcdFx0c2hvd0xpbmU6IHRydWUsXG5cdFx0XHRzaG93VGl0bGU6IHRydWUsXG5cdFx0XHR0eHRTZWxlY3RlZEVuYWJsZTogZmFsc2Vcblx0XHR9LFxuXHRcdGRhdGE6IHtcblx0XHRcdGtleToge1xuXHRcdFx0XHRjaGlsZHJlbjogXCJjaGlsZHJlblwiLFxuXHRcdFx0XHRuYW1lOiBcIm5hbWVcIixcblx0XHRcdFx0dGl0bGU6IFwiXCIsXG5cdFx0XHRcdHVybDogXCJ1cmxcIlxuXHRcdFx0fSxcblx0XHRcdHNpbXBsZURhdGE6IHtcblx0XHRcdFx0ZW5hYmxlOiBmYWxzZSxcblx0XHRcdFx0aWRLZXk6IFwiaWRcIixcblx0XHRcdFx0cElkS2V5OiBcInBJZFwiLFxuXHRcdFx0XHRyb290UElkOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0a2VlcDoge1xuXHRcdFx0XHRwYXJlbnQ6IGZhbHNlLFxuXHRcdFx0XHRsZWFmOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXN5bmM6IHtcblx0XHRcdGVuYWJsZTogZmFsc2UsXG5cdFx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcblx0XHRcdHR5cGU6IFwicG9zdFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwidGV4dFwiLFxuXHRcdFx0dXJsOiBcIlwiLFxuXHRcdFx0YXV0b1BhcmFtOiBbXSxcblx0XHRcdG90aGVyUGFyYW06IFtdLFxuXHRcdFx0ZGF0YUZpbHRlcjogbnVsbFxuXHRcdH0sXG5cdFx0Y2FsbGJhY2s6IHtcblx0XHRcdGJlZm9yZUFzeW5jOm51bGwsXG5cdFx0XHRiZWZvcmVDbGljazpudWxsLFxuXHRcdFx0YmVmb3JlRGJsQ2xpY2s6bnVsbCxcblx0XHRcdGJlZm9yZVJpZ2h0Q2xpY2s6bnVsbCxcblx0XHRcdGJlZm9yZU1vdXNlRG93bjpudWxsLFxuXHRcdFx0YmVmb3JlTW91c2VVcDpudWxsLFxuXHRcdFx0YmVmb3JlRXhwYW5kOm51bGwsXG5cdFx0XHRiZWZvcmVDb2xsYXBzZTpudWxsLFxuXHRcdFx0YmVmb3JlUmVtb3ZlOm51bGwsXG5cblx0XHRcdG9uQXN5bmNFcnJvcjpudWxsLFxuXHRcdFx0b25Bc3luY1N1Y2Nlc3M6bnVsbCxcblx0XHRcdG9uTm9kZUNyZWF0ZWQ6bnVsbCxcblx0XHRcdG9uQ2xpY2s6bnVsbCxcblx0XHRcdG9uRGJsQ2xpY2s6bnVsbCxcblx0XHRcdG9uUmlnaHRDbGljazpudWxsLFxuXHRcdFx0b25Nb3VzZURvd246bnVsbCxcblx0XHRcdG9uTW91c2VVcDpudWxsLFxuXHRcdFx0b25FeHBhbmQ6bnVsbCxcblx0XHRcdG9uQ29sbGFwc2U6bnVsbCxcblx0XHRcdG9uUmVtb3ZlOm51bGxcblx0XHR9XG5cdH0sXG5cdC8vZGVmYXVsdCByb290IG9mIGNvcmVcblx0Ly96VHJlZSB1c2Ugcm9vdCB0byBzYXZlIGZ1bGwgZGF0YVxuXHRfaW5pdFJvb3QgPSBmdW5jdGlvbiAoc2V0dGluZykge1xuXHRcdHZhciByID0gZGF0YS5nZXRSb290KHNldHRpbmcpO1xuXHRcdGlmICghcikge1xuXHRcdFx0ciA9IHt9O1xuXHRcdFx0ZGF0YS5zZXRSb290KHNldHRpbmcsIHIpO1xuXHRcdH1cblx0XHRyW3NldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW5dID0gW107XG5cdFx0ci5leHBhbmRUcmlnZ2VyRmxhZyA9IGZhbHNlO1xuXHRcdHIuY3VyU2VsZWN0ZWRMaXN0ID0gW107XG5cdFx0ci5ub1NlbGVjdGlvbiA9IHRydWU7XG5cdFx0ci5jcmVhdGVkTm9kZXMgPSBbXTtcblx0XHRyLnpJZCA9IDA7XG5cdFx0ci5fdmVyID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0fSxcblx0Ly9kZWZhdWx0IGNhY2hlIG9mIGNvcmVcblx0X2luaXRDYWNoZSA9IGZ1bmN0aW9uKHNldHRpbmcpIHtcblx0XHR2YXIgYyA9IGRhdGEuZ2V0Q2FjaGUoc2V0dGluZyk7XG5cdFx0aWYgKCFjKSB7XG5cdFx0XHRjID0ge307XG5cdFx0XHRkYXRhLnNldENhY2hlKHNldHRpbmcsIGMpO1xuXHRcdH1cblx0XHRjLm5vZGVzID0gW107XG5cdFx0Yy5kb21zID0gW107XG5cdH0sXG5cdC8vZGVmYXVsdCBiaW5kRXZlbnQgb2YgY29yZVxuXHRfYmluZEV2ZW50ID0gZnVuY3Rpb24oc2V0dGluZykge1xuXHRcdHZhciBvID0gc2V0dGluZy50cmVlT2JqLFxuXHRcdGMgPSBjb25zdHMuZXZlbnQ7XG5cdFx0by5iaW5kKGMuTk9ERUNSRUFURUQsIGZ1bmN0aW9uIChldmVudCwgdHJlZUlkLCBub2RlKSB7XG5cdFx0XHR0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLm9uTm9kZUNyZWF0ZWQsIFtldmVudCwgdHJlZUlkLCBub2RlXSk7XG5cdFx0fSk7XG5cblx0XHRvLmJpbmQoYy5DTElDSywgZnVuY3Rpb24gKGV2ZW50LCBzcmNFdmVudCwgdHJlZUlkLCBub2RlLCBjbGlja0ZsYWcpIHtcblx0XHRcdHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2sub25DbGljaywgW3NyY0V2ZW50LCB0cmVlSWQsIG5vZGUsIGNsaWNrRmxhZ10pO1xuXHRcdH0pO1xuXG5cdFx0by5iaW5kKGMuRVhQQU5ELCBmdW5jdGlvbiAoZXZlbnQsIHRyZWVJZCwgbm9kZSkge1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vbkV4cGFuZCwgW2V2ZW50LCB0cmVlSWQsIG5vZGVdKTtcblx0XHR9KTtcblxuXHRcdG8uYmluZChjLkNPTExBUFNFLCBmdW5jdGlvbiAoZXZlbnQsIHRyZWVJZCwgbm9kZSkge1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vbkNvbGxhcHNlLCBbZXZlbnQsIHRyZWVJZCwgbm9kZV0pO1xuXHRcdH0pO1xuXG5cdFx0by5iaW5kKGMuQVNZTkNfU1VDQ0VTUywgZnVuY3Rpb24gKGV2ZW50LCB0cmVlSWQsIG5vZGUsIG1zZykge1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vbkFzeW5jU3VjY2VzcywgW2V2ZW50LCB0cmVlSWQsIG5vZGUsIG1zZ10pO1xuXHRcdH0pO1xuXG5cdFx0by5iaW5kKGMuQVNZTkNfRVJST1IsIGZ1bmN0aW9uIChldmVudCwgdHJlZUlkLCBub2RlLCBYTUxIdHRwUmVxdWVzdCwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcblx0XHRcdHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2sub25Bc3luY0Vycm9yLCBbZXZlbnQsIHRyZWVJZCwgbm9kZSwgWE1MSHR0cFJlcXVlc3QsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duXSk7XG5cdFx0fSk7XG5cblx0XHRvLmJpbmQoYy5SRU1PVkUsIGZ1bmN0aW9uIChldmVudCwgdHJlZUlkLCB0cmVlTm9kZSkge1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vblJlbW92ZSwgW2V2ZW50LCB0cmVlSWQsIHRyZWVOb2RlXSk7XG5cdFx0fSk7XG5cdH0sXG5cdF91bmJpbmRFdmVudCA9IGZ1bmN0aW9uKHNldHRpbmcpIHtcblx0XHR2YXIgbyA9IHNldHRpbmcudHJlZU9iaixcblx0XHRjID0gY29uc3RzLmV2ZW50O1xuXHRcdG8udW5iaW5kKGMuTk9ERUNSRUFURUQpXG5cdFx0LnVuYmluZChjLkNMSUNLKVxuXHRcdC51bmJpbmQoYy5FWFBBTkQpXG5cdFx0LnVuYmluZChjLkNPTExBUFNFKVxuXHRcdC51bmJpbmQoYy5BU1lOQ19TVUNDRVNTKVxuXHRcdC51bmJpbmQoYy5BU1lOQ19FUlJPUilcblx0XHQudW5iaW5kKGMuUkVNT1ZFKTtcblx0fSxcblx0Ly9kZWZhdWx0IGV2ZW50IHByb3h5IG9mIGNvcmVcblx0X2V2ZW50UHJveHkgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG5cdFx0c2V0dGluZyA9IGRhdGEuZ2V0U2V0dGluZyhldmVudC5kYXRhLnRyZWVJZCksXG5cdFx0dElkID0gXCJcIiwgbm9kZSA9IG51bGwsXG5cdFx0bm9kZUV2ZW50VHlwZSA9IFwiXCIsIHRyZWVFdmVudFR5cGUgPSBcIlwiLFxuXHRcdG5vZGVFdmVudENhbGxiYWNrID0gbnVsbCwgdHJlZUV2ZW50Q2FsbGJhY2sgPSBudWxsLFxuXHRcdHRtcCA9IG51bGw7XG5cblx0XHRpZiAodG9vbHMuZXFzKGV2ZW50LnR5cGUsIFwibW91c2Vkb3duXCIpKSB7XG5cdFx0XHR0cmVlRXZlbnRUeXBlID0gXCJtb3VzZWRvd25cIjtcblx0XHR9IGVsc2UgaWYgKHRvb2xzLmVxcyhldmVudC50eXBlLCBcIm1vdXNldXBcIikpIHtcblx0XHRcdHRyZWVFdmVudFR5cGUgPSBcIm1vdXNldXBcIjtcblx0XHR9IGVsc2UgaWYgKHRvb2xzLmVxcyhldmVudC50eXBlLCBcImNvbnRleHRtZW51XCIpKSB7XG5cdFx0XHR0cmVlRXZlbnRUeXBlID0gXCJjb250ZXh0bWVudVwiO1xuXHRcdH0gZWxzZSBpZiAodG9vbHMuZXFzKGV2ZW50LnR5cGUsIFwiY2xpY2tcIikpIHtcblx0XHRcdGlmICh0b29scy5lcXModGFyZ2V0LnRhZ05hbWUsIFwic3BhblwiKSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJlZU5vZGVcIisgY29uc3RzLmlkLlNXSVRDSCkgIT09IG51bGwpIHtcblx0XHRcdFx0dElkID0gdG9vbHMuZ2V0Tm9kZU1haW5Eb20odGFyZ2V0KS5pZDtcblx0XHRcdFx0bm9kZUV2ZW50VHlwZSA9IFwic3dpdGNoTm9kZVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG9vbHMuZ2V0TURvbShzZXR0aW5nLCB0YXJnZXQsIFt7dGFnTmFtZTpcImFcIiwgYXR0ck5hbWU6XCJ0cmVlTm9kZVwiK2NvbnN0cy5pZC5BfV0pO1xuXHRcdFx0XHRpZiAodG1wKSB7XG5cdFx0XHRcdFx0dElkID0gdG9vbHMuZ2V0Tm9kZU1haW5Eb20odG1wKS5pZDtcblx0XHRcdFx0XHRub2RlRXZlbnRUeXBlID0gXCJjbGlja05vZGVcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodG9vbHMuZXFzKGV2ZW50LnR5cGUsIFwiZGJsY2xpY2tcIikpIHtcblx0XHRcdHRyZWVFdmVudFR5cGUgPSBcImRibGNsaWNrXCI7XG5cdFx0XHR0bXAgPSB0b29scy5nZXRNRG9tKHNldHRpbmcsIHRhcmdldCwgW3t0YWdOYW1lOlwiYVwiLCBhdHRyTmFtZTpcInRyZWVOb2RlXCIrY29uc3RzLmlkLkF9XSk7XG5cdFx0XHRpZiAodG1wKSB7XG5cdFx0XHRcdHRJZCA9IHRvb2xzLmdldE5vZGVNYWluRG9tKHRtcCkuaWQ7XG5cdFx0XHRcdG5vZGVFdmVudFR5cGUgPSBcInN3aXRjaE5vZGVcIjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRyZWVFdmVudFR5cGUubGVuZ3RoID4gMCAmJiB0SWQubGVuZ3RoID09IDApIHtcblx0XHRcdHRtcCA9IHRvb2xzLmdldE1Eb20oc2V0dGluZywgdGFyZ2V0LCBbe3RhZ05hbWU6XCJhXCIsIGF0dHJOYW1lOlwidHJlZU5vZGVcIitjb25zdHMuaWQuQX1dKTtcblx0XHRcdGlmICh0bXApIHt0SWQgPSB0b29scy5nZXROb2RlTWFpbkRvbSh0bXApLmlkO31cblx0XHR9XG5cdFx0Ly8gZXZlbnQgdG8gbm9kZVxuXHRcdGlmICh0SWQubGVuZ3RoPjApIHtcblx0XHRcdG5vZGUgPSBkYXRhLmdldE5vZGVDYWNoZShzZXR0aW5nLCB0SWQpO1xuXHRcdFx0c3dpdGNoIChub2RlRXZlbnRUeXBlKSB7XG5cdFx0XHRcdGNhc2UgXCJzd2l0Y2hOb2RlXCIgOlxuXHRcdFx0XHRcdGlmICghbm9kZS5pc1BhcmVudCkge1xuXHRcdFx0XHRcdFx0bm9kZUV2ZW50VHlwZSA9IFwiXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0b29scy5lcXMoZXZlbnQudHlwZSwgXCJjbGlja1wiKVxuXHRcdFx0XHRcdFx0fHwgKHRvb2xzLmVxcyhldmVudC50eXBlLCBcImRibGNsaWNrXCIpICYmIHRvb2xzLmFwcGx5KHNldHRpbmcudmlldy5kYmxDbGlja0V4cGFuZCwgW3NldHRpbmcudHJlZUlkLCBub2RlXSwgc2V0dGluZy52aWV3LmRibENsaWNrRXhwYW5kKSkpIHtcblx0XHRcdFx0XHRcdG5vZGVFdmVudENhbGxiYWNrID0gaGFuZGxlci5vblN3aXRjaE5vZGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGVFdmVudFR5cGUgPSBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImNsaWNrTm9kZVwiIDpcblx0XHRcdFx0XHRub2RlRXZlbnRDYWxsYmFjayA9IGhhbmRsZXIub25DbGlja05vZGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGV2ZW50IHRvIHpUcmVlXG5cdFx0c3dpdGNoICh0cmVlRXZlbnRUeXBlKSB7XG5cdFx0XHRjYXNlIFwibW91c2Vkb3duXCIgOlxuXHRcdFx0XHR0cmVlRXZlbnRDYWxsYmFjayA9IGhhbmRsZXIub25aVHJlZU1vdXNlZG93bjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibW91c2V1cFwiIDpcblx0XHRcdFx0dHJlZUV2ZW50Q2FsbGJhY2sgPSBoYW5kbGVyLm9uWlRyZWVNb3VzZXVwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJkYmxjbGlja1wiIDpcblx0XHRcdFx0dHJlZUV2ZW50Q2FsbGJhY2sgPSBoYW5kbGVyLm9uWlRyZWVEYmxjbGljaztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiY29udGV4dG1lbnVcIiA6XG5cdFx0XHRcdHRyZWVFdmVudENhbGxiYWNrID0gaGFuZGxlci5vblpUcmVlQ29udGV4dG1lbnU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR2YXIgcHJveHlSZXN1bHQgPSB7XG5cdFx0XHRzdG9wOiBmYWxzZSxcblx0XHRcdG5vZGU6IG5vZGUsXG5cdFx0XHRub2RlRXZlbnRUeXBlOiBub2RlRXZlbnRUeXBlLFxuXHRcdFx0bm9kZUV2ZW50Q2FsbGJhY2s6IG5vZGVFdmVudENhbGxiYWNrLFxuXHRcdFx0dHJlZUV2ZW50VHlwZTogdHJlZUV2ZW50VHlwZSxcblx0XHRcdHRyZWVFdmVudENhbGxiYWNrOiB0cmVlRXZlbnRDYWxsYmFja1xuXHRcdH07XG5cdFx0cmV0dXJuIHByb3h5UmVzdWx0XG5cdH0sXG5cdC8vZGVmYXVsdCBpbml0IG5vZGUgb2YgY29yZVxuXHRfaW5pdE5vZGUgPSBmdW5jdGlvbihzZXR0aW5nLCBsZXZlbCwgbiwgcGFyZW50Tm9kZSwgaXNGaXJzdE5vZGUsIGlzTGFzdE5vZGUsIG9wZW5GbGFnKSB7XG5cdFx0aWYgKCFuKSByZXR1cm47XG5cdFx0dmFyIHIgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyksXG5cdFx0Y2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuO1xuXHRcdG4ubGV2ZWwgPSBsZXZlbDtcblx0XHRuLnRJZCA9IHNldHRpbmcudHJlZUlkICsgXCJfXCIgKyAoKytyLnpJZCk7XG5cdFx0bi5wYXJlbnRUSWQgPSBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS50SWQgOiBudWxsO1xuXHRcdG4ub3BlbiA9ICh0eXBlb2Ygbi5vcGVuID09IFwic3RyaW5nXCIpID8gdG9vbHMuZXFzKG4ub3BlbiwgXCJ0cnVlXCIpIDogISFuLm9wZW47XG5cdFx0aWYgKG5bY2hpbGRLZXldICYmIG5bY2hpbGRLZXldLmxlbmd0aCA+IDApIHtcblx0XHRcdG4uaXNQYXJlbnQgPSB0cnVlO1xuXHRcdFx0bi56QXN5bmMgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuLmlzUGFyZW50ID0gKHR5cGVvZiBuLmlzUGFyZW50ID09IFwic3RyaW5nXCIpID8gdG9vbHMuZXFzKG4uaXNQYXJlbnQsIFwidHJ1ZVwiKSA6ICEhbi5pc1BhcmVudDtcblx0XHRcdG4ub3BlbiA9IChuLmlzUGFyZW50ICYmICFzZXR0aW5nLmFzeW5jLmVuYWJsZSkgPyBuLm9wZW4gOiBmYWxzZTtcblx0XHRcdG4uekFzeW5jID0gIW4uaXNQYXJlbnQ7XG5cdFx0fVxuXHRcdG4uaXNGaXJzdE5vZGUgPSBpc0ZpcnN0Tm9kZTtcblx0XHRuLmlzTGFzdE5vZGUgPSBpc0xhc3ROb2RlO1xuXHRcdG4uZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uKCkge3JldHVybiBkYXRhLmdldE5vZGVDYWNoZShzZXR0aW5nLCBuLnBhcmVudFRJZCk7fTtcblx0XHRuLmdldFByZU5vZGUgPSBmdW5jdGlvbigpIHtyZXR1cm4gZGF0YS5nZXRQcmVOb2RlKHNldHRpbmcsIG4pO307XG5cdFx0bi5nZXROZXh0Tm9kZSA9IGZ1bmN0aW9uKCkge3JldHVybiBkYXRhLmdldE5leHROb2RlKHNldHRpbmcsIG4pO307XG5cdFx0bi5pc0FqYXhpbmcgPSBmYWxzZTtcblx0XHRkYXRhLmZpeFBJZEtleVZhbHVlKHNldHRpbmcsIG4pO1xuXHR9LFxuXHRfaW5pdCA9IHtcblx0XHRiaW5kOiBbX2JpbmRFdmVudF0sXG5cdFx0dW5iaW5kOiBbX3VuYmluZEV2ZW50XSxcblx0XHRjYWNoZXM6IFtfaW5pdENhY2hlXSxcblx0XHRub2RlczogW19pbml0Tm9kZV0sXG5cdFx0cHJveHlzOiBbX2V2ZW50UHJveHldLFxuXHRcdHJvb3RzOiBbX2luaXRSb290XSxcblx0XHRiZWZvcmVBOiBbXSxcblx0XHRhZnRlckE6IFtdLFxuXHRcdGlubmVyQmVmb3JlQTogW10sXG5cdFx0aW5uZXJBZnRlckE6IFtdLFxuXHRcdHpUcmVlVG9vbHM6IFtdXG5cdH0sXG5cdC8vbWV0aG9kIG9mIG9wZXJhdGUgZGF0YVxuXHRkYXRhID0ge1xuXHRcdGFkZE5vZGVDYWNoZTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0ZGF0YS5nZXRDYWNoZShzZXR0aW5nKS5ub2Rlc1tkYXRhLmdldE5vZGVDYWNoZUlkKG5vZGUudElkKV0gPSBub2RlO1xuXHRcdH0sXG5cdFx0Z2V0Tm9kZUNhY2hlSWQ6IGZ1bmN0aW9uKHRJZCkge1xuXHRcdFx0cmV0dXJuIHRJZC5zdWJzdHJpbmcodElkLmxhc3RJbmRleE9mKFwiX1wiKSsxKTtcblx0XHR9LFxuXHRcdGFkZEFmdGVyQTogZnVuY3Rpb24oYWZ0ZXJBKSB7XG5cdFx0XHRfaW5pdC5hZnRlckEucHVzaChhZnRlckEpO1xuXHRcdH0sXG5cdFx0YWRkQmVmb3JlQTogZnVuY3Rpb24oYmVmb3JlQSkge1xuXHRcdFx0X2luaXQuYmVmb3JlQS5wdXNoKGJlZm9yZUEpO1xuXHRcdH0sXG5cdFx0YWRkSW5uZXJBZnRlckE6IGZ1bmN0aW9uKGlubmVyQWZ0ZXJBKSB7XG5cdFx0XHRfaW5pdC5pbm5lckFmdGVyQS5wdXNoKGlubmVyQWZ0ZXJBKTtcblx0XHR9LFxuXHRcdGFkZElubmVyQmVmb3JlQTogZnVuY3Rpb24oaW5uZXJCZWZvcmVBKSB7XG5cdFx0XHRfaW5pdC5pbm5lckJlZm9yZUEucHVzaChpbm5lckJlZm9yZUEpO1xuXHRcdH0sXG5cdFx0YWRkSW5pdEJpbmQ6IGZ1bmN0aW9uKGJpbmRFdmVudCkge1xuXHRcdFx0X2luaXQuYmluZC5wdXNoKGJpbmRFdmVudCk7XG5cdFx0fSxcblx0XHRhZGRJbml0VW5CaW5kOiBmdW5jdGlvbih1bmJpbmRFdmVudCkge1xuXHRcdFx0X2luaXQudW5iaW5kLnB1c2godW5iaW5kRXZlbnQpO1xuXHRcdH0sXG5cdFx0YWRkSW5pdENhY2hlOiBmdW5jdGlvbihpbml0Q2FjaGUpIHtcblx0XHRcdF9pbml0LmNhY2hlcy5wdXNoKGluaXRDYWNoZSk7XG5cdFx0fSxcblx0XHRhZGRJbml0Tm9kZTogZnVuY3Rpb24oaW5pdE5vZGUpIHtcblx0XHRcdF9pbml0Lm5vZGVzLnB1c2goaW5pdE5vZGUpO1xuXHRcdH0sXG5cdFx0YWRkSW5pdFByb3h5OiBmdW5jdGlvbihpbml0UHJveHksIGlzRmlyc3QpIHtcblx0XHRcdGlmICghIWlzRmlyc3QpIHtcblx0XHRcdFx0X2luaXQucHJveHlzLnNwbGljZSgwLDAsaW5pdFByb3h5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9pbml0LnByb3h5cy5wdXNoKGluaXRQcm94eSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhZGRJbml0Um9vdDogZnVuY3Rpb24oaW5pdFJvb3QpIHtcblx0XHRcdF9pbml0LnJvb3RzLnB1c2goaW5pdFJvb3QpO1xuXHRcdH0sXG5cdFx0YWRkTm9kZXNEYXRhOiBmdW5jdGlvbihzZXR0aW5nLCBwYXJlbnROb2RlLCBub2Rlcykge1xuXHRcdFx0dmFyIGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbjtcblx0XHRcdGlmICghcGFyZW50Tm9kZVtjaGlsZEtleV0pIHBhcmVudE5vZGVbY2hpbGRLZXldID0gW107XG5cdFx0XHRpZiAocGFyZW50Tm9kZVtjaGlsZEtleV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRwYXJlbnROb2RlW2NoaWxkS2V5XVtwYXJlbnROb2RlW2NoaWxkS2V5XS5sZW5ndGggLSAxXS5pc0xhc3ROb2RlID0gZmFsc2U7XG5cdFx0XHRcdHZpZXcuc2V0Tm9kZUxpbmVJY29zKHNldHRpbmcsIHBhcmVudE5vZGVbY2hpbGRLZXldW3BhcmVudE5vZGVbY2hpbGRLZXldLmxlbmd0aCAtIDFdKTtcblx0XHRcdH1cblx0XHRcdHBhcmVudE5vZGUuaXNQYXJlbnQgPSB0cnVlO1xuXHRcdFx0cGFyZW50Tm9kZVtjaGlsZEtleV0gPSBwYXJlbnROb2RlW2NoaWxkS2V5XS5jb25jYXQobm9kZXMpO1xuXHRcdH0sXG5cdFx0YWRkU2VsZWN0ZWROb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgcm9vdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRcdGlmICghZGF0YS5pc1NlbGVjdGVkTm9kZShzZXR0aW5nLCBub2RlKSkge1xuXHRcdFx0XHRyb290LmN1clNlbGVjdGVkTGlzdC5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWRkQ3JlYXRlZE5vZGU6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdGlmICghIXNldHRpbmcuY2FsbGJhY2sub25Ob2RlQ3JlYXRlZCB8fCAhIXNldHRpbmcudmlldy5hZGREaXlEb20pIHtcblx0XHRcdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyk7XG5cdFx0XHRcdHJvb3QuY3JlYXRlZE5vZGVzLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhZGRaVHJlZVRvb2xzOiBmdW5jdGlvbih6VHJlZVRvb2xzKSB7XG5cdFx0XHRfaW5pdC56VHJlZVRvb2xzLnB1c2goelRyZWVUb29scyk7XG5cdFx0fSxcblx0XHRleFNldHRpbmc6IGZ1bmN0aW9uKHMpIHtcblx0XHRcdCQuZXh0ZW5kKHRydWUsIF9zZXR0aW5nLCBzKTtcblx0XHR9LFxuXHRcdGZpeFBJZEtleVZhbHVlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHRpZiAoc2V0dGluZy5kYXRhLnNpbXBsZURhdGEuZW5hYmxlKSB7XG5cdFx0XHRcdG5vZGVbc2V0dGluZy5kYXRhLnNpbXBsZURhdGEucElkS2V5XSA9IG5vZGUucGFyZW50VElkID8gbm9kZS5nZXRQYXJlbnROb2RlKClbc2V0dGluZy5kYXRhLnNpbXBsZURhdGEuaWRLZXldIDogc2V0dGluZy5kYXRhLnNpbXBsZURhdGEucm9vdFBJZDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldEFmdGVyQTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSwgYXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGk9MCwgaj1faW5pdC5hZnRlckEubGVuZ3RoOyBpPGo7IGkrKykge1xuXHRcdFx0XHRfaW5pdC5hZnRlckFbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldEJlZm9yZUE6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUsIGFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGo9X2luaXQuYmVmb3JlQS5sZW5ndGg7IGk8ajsgaSsrKSB7XG5cdFx0XHRcdF9pbml0LmJlZm9yZUFbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldElubmVyQWZ0ZXJBOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlLCBhcnJheSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBqPV9pbml0LmlubmVyQWZ0ZXJBLmxlbmd0aDsgaTxqOyBpKyspIHtcblx0XHRcdFx0X2luaXQuaW5uZXJBZnRlckFbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldElubmVyQmVmb3JlQTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSwgYXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGk9MCwgaj1faW5pdC5pbm5lckJlZm9yZUEubGVuZ3RoOyBpPGo7IGkrKykge1xuXHRcdFx0XHRfaW5pdC5pbm5lckJlZm9yZUFbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldENhY2hlOiBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGVzW3NldHRpbmcudHJlZUlkXTtcblx0XHR9LFxuXHRcdGdldE5leHROb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHRpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXHRcdFx0dmFyIGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbixcblx0XHRcdHAgPSBub2RlLnBhcmVudFRJZCA/IG5vZGUuZ2V0UGFyZW50Tm9kZSgpIDogZGF0YS5nZXRSb290KHNldHRpbmcpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBsPXBbY2hpbGRLZXldLmxlbmd0aC0xOyBpPD1sOyBpKyspIHtcblx0XHRcdFx0aWYgKHBbY2hpbGRLZXldW2ldID09PSBub2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChpPT1sID8gbnVsbCA6IHBbY2hpbGRLZXldW2krMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdGdldE5vZGVCeVBhcmFtOiBmdW5jdGlvbihzZXR0aW5nLCBub2Rlcywga2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCFub2RlcyB8fCAha2V5KSByZXR1cm4gbnVsbDtcblx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAobm9kZXNbaV1ba2V5XSA9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdHJldHVybiBub2Rlc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdG1wID0gZGF0YS5nZXROb2RlQnlQYXJhbShzZXR0aW5nLCBub2Rlc1tpXVtjaGlsZEtleV0sIGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAodG1wKSByZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRnZXROb2RlQ2FjaGU6IGZ1bmN0aW9uKHNldHRpbmcsIHRJZCkge1xuXHRcdFx0aWYgKCF0SWQpIHJldHVybiBudWxsO1xuXHRcdFx0dmFyIG4gPSBjYWNoZXNbc2V0dGluZy50cmVlSWRdLm5vZGVzW2RhdGEuZ2V0Tm9kZUNhY2hlSWQodElkKV07XG5cdFx0XHRyZXR1cm4gbiA/IG4gOiBudWxsO1xuXHRcdH0sXG5cdFx0Z2V0Tm9kZU5hbWU6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciBuYW1lS2V5ID0gc2V0dGluZy5kYXRhLmtleS5uYW1lO1xuXHRcdFx0cmV0dXJuIFwiXCIgKyBub2RlW25hbWVLZXldO1xuXHRcdH0sXG5cdFx0Z2V0Tm9kZVRpdGxlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgdCA9IHNldHRpbmcuZGF0YS5rZXkudGl0bGUgPT09IFwiXCIgPyBzZXR0aW5nLmRhdGEua2V5Lm5hbWUgOiBzZXR0aW5nLmRhdGEua2V5LnRpdGxlO1xuXHRcdFx0cmV0dXJuIFwiXCIgKyBub2RlW3RdO1xuXHRcdH0sXG5cdFx0Z2V0Tm9kZXM6IGZ1bmN0aW9uKHNldHRpbmcpIHtcblx0XHRcdHJldHVybiBkYXRhLmdldFJvb3Qoc2V0dGluZylbc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbl07XG5cdFx0fSxcblx0XHRnZXROb2Rlc0J5UGFyYW06IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGVzLCBrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoIW5vZGVzIHx8ICFrZXkpIHJldHVybiBbXTtcblx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChub2Rlc1tpXVtrZXldID09IHZhbHVlKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZGF0YS5nZXROb2Rlc0J5UGFyYW0oc2V0dGluZywgbm9kZXNbaV1bY2hpbGRLZXldLCBrZXksIHZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0Z2V0Tm9kZXNCeVBhcmFtRnV6enk6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGVzLCBrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoIW5vZGVzIHx8ICFrZXkpIHJldHVybiBbXTtcblx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygbm9kZXNbaV1ba2V5XSA9PSBcInN0cmluZ1wiICYmIG5vZGVzW2ldW2tleV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbHVlKT4tMSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGVzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQuY29uY2F0KGRhdGEuZ2V0Tm9kZXNCeVBhcmFtRnV6enkoc2V0dGluZywgbm9kZXNbaV1bY2hpbGRLZXldLCBrZXksIHZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0Z2V0Tm9kZXNCeUZpbHRlcjogZnVuY3Rpb24oc2V0dGluZywgbm9kZXMsIGZpbHRlciwgaXNTaW5nbGUsIGludm9rZVBhcmFtKSB7XG5cdFx0XHRpZiAoIW5vZGVzKSByZXR1cm4gKGlzU2luZ2xlID8gbnVsbCA6IFtdKTtcblx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRyZXN1bHQgPSBpc1NpbmdsZSA/IG51bGwgOiBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0b29scy5hcHBseShmaWx0ZXIsIFtub2Rlc1tpXSwgaW52b2tlUGFyYW1dLCBmYWxzZSkpIHtcblx0XHRcdFx0XHRpZiAoaXNTaW5nbGUpIHtyZXR1cm4gbm9kZXNbaV07fVxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGVzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdG1wUmVzdWx0ID0gZGF0YS5nZXROb2Rlc0J5RmlsdGVyKHNldHRpbmcsIG5vZGVzW2ldW2NoaWxkS2V5XSwgZmlsdGVyLCBpc1NpbmdsZSwgaW52b2tlUGFyYW0pO1xuXHRcdFx0XHRpZiAoaXNTaW5nbGUgJiYgISF0bXBSZXN1bHQpIHtyZXR1cm4gdG1wUmVzdWx0O31cblx0XHRcdFx0cmVzdWx0ID0gaXNTaW5nbGUgPyB0bXBSZXN1bHQgOiByZXN1bHQuY29uY2F0KHRtcFJlc3VsdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0Z2V0UHJlTm9kZTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0aWYgKCFub2RlKSByZXR1cm4gbnVsbDtcblx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRwID0gbm9kZS5wYXJlbnRUSWQgPyBub2RlLmdldFBhcmVudE5vZGUoKSA6IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRcdGZvciAodmFyIGk9MCwgbD1wW2NoaWxkS2V5XS5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwW2NoaWxkS2V5XVtpXSA9PT0gbm9kZSkge1xuXHRcdFx0XHRcdHJldHVybiAoaT09MCA/IG51bGwgOiBwW2NoaWxkS2V5XVtpLTFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRnZXRSb290OiBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZyA/IHJvb3RzW3NldHRpbmcudHJlZUlkXSA6IG51bGw7XG5cdFx0fSxcblx0XHRnZXRSb290czogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcm9vdHM7XG5cdFx0fSxcblx0XHRnZXRTZXR0aW5nOiBmdW5jdGlvbih0cmVlSWQpIHtcblx0XHRcdHJldHVybiBzZXR0aW5nc1t0cmVlSWRdO1xuXHRcdH0sXG5cdFx0Z2V0U2V0dGluZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzO1xuXHRcdH0sXG5cdFx0Z2V0WlRyZWVUb29sczogZnVuY3Rpb24odHJlZUlkKSB7XG5cdFx0XHR2YXIgciA9IHRoaXMuZ2V0Um9vdCh0aGlzLmdldFNldHRpbmcodHJlZUlkKSk7XG5cdFx0XHRyZXR1cm4gciA/IHIudHJlZVRvb2xzIDogbnVsbDtcblx0XHR9LFxuXHRcdGluaXRDYWNoZTogZnVuY3Rpb24oc2V0dGluZykge1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBqPV9pbml0LmNhY2hlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG5cdFx0XHRcdF9pbml0LmNhY2hlc1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW5pdE5vZGU6IGZ1bmN0aW9uKHNldHRpbmcsIGxldmVsLCBub2RlLCBwYXJlbnROb2RlLCBwcmVOb2RlLCBuZXh0Tm9kZSkge1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBqPV9pbml0Lm5vZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcblx0XHRcdFx0X2luaXQubm9kZXNbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGluaXRSb290OiBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGo9X2luaXQucm9vdHMubGVuZ3RoOyBpPGo7IGkrKykge1xuXHRcdFx0XHRfaW5pdC5yb290c1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aXNTZWxlY3RlZE5vZGU6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciByb290ID0gZGF0YS5nZXRSb290KHNldHRpbmcpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBqPXJvb3QuY3VyU2VsZWN0ZWRMaXN0Lmxlbmd0aDsgaTxqOyBpKyspIHtcblx0XHRcdFx0aWYobm9kZSA9PT0gcm9vdC5jdXJTZWxlY3RlZExpc3RbaV0pIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0cmVtb3ZlTm9kZUNhY2hlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuO1xuXHRcdFx0aWYgKG5vZGVbY2hpbGRLZXldKSB7XG5cdFx0XHRcdGZvciAodmFyIGk9MCwgbD1ub2RlW2NoaWxkS2V5XS5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0YXJndW1lbnRzLmNhbGxlZShzZXR0aW5nLCBub2RlW2NoaWxkS2V5XVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRhdGEuZ2V0Q2FjaGUoc2V0dGluZykubm9kZXNbZGF0YS5nZXROb2RlQ2FjaGVJZChub2RlLnRJZCldID0gbnVsbDtcblx0XHR9LFxuXHRcdHJlbW92ZVNlbGVjdGVkTm9kZTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyk7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGo9cm9vdC5jdXJTZWxlY3RlZExpc3QubGVuZ3RoOyBpPGo7IGkrKykge1xuXHRcdFx0XHRpZihub2RlID09PSByb290LmN1clNlbGVjdGVkTGlzdFtpXSB8fCAhZGF0YS5nZXROb2RlQ2FjaGUoc2V0dGluZywgcm9vdC5jdXJTZWxlY3RlZExpc3RbaV0udElkKSkge1xuXHRcdFx0XHRcdHJvb3QuY3VyU2VsZWN0ZWRMaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRpLS07ai0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZXRDYWNoZTogZnVuY3Rpb24oc2V0dGluZywgY2FjaGUpIHtcblx0XHRcdGNhY2hlc1tzZXR0aW5nLnRyZWVJZF0gPSBjYWNoZTtcblx0XHR9LFxuXHRcdHNldFJvb3Q6IGZ1bmN0aW9uKHNldHRpbmcsIHJvb3QpIHtcblx0XHRcdHJvb3RzW3NldHRpbmcudHJlZUlkXSA9IHJvb3Q7XG5cdFx0fSxcblx0XHRzZXRaVHJlZVRvb2xzOiBmdW5jdGlvbihzZXR0aW5nLCB6VHJlZVRvb2xzKSB7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGo9X2luaXQuelRyZWVUb29scy5sZW5ndGg7IGk8ajsgaSsrKSB7XG5cdFx0XHRcdF9pbml0LnpUcmVlVG9vbHNbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRyYW5zZm9ybVRvQXJyYXlGb3JtYXQ6IGZ1bmN0aW9uIChzZXR0aW5nLCBub2Rlcykge1xuXHRcdFx0aWYgKCFub2RlcykgcmV0dXJuIFtdO1xuXHRcdFx0dmFyIGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbixcblx0XHRcdHIgPSBbXTtcblx0XHRcdGlmICh0b29scy5pc0FycmF5KG5vZGVzKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpPTAsIGw9bm9kZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHRcdHIucHVzaChub2Rlc1tpXSk7XG5cdFx0XHRcdFx0aWYgKG5vZGVzW2ldW2NoaWxkS2V5XSlcblx0XHRcdFx0XHRcdHIgPSByLmNvbmNhdChkYXRhLnRyYW5zZm9ybVRvQXJyYXlGb3JtYXQoc2V0dGluZywgbm9kZXNbaV1bY2hpbGRLZXldKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHIucHVzaChub2Rlcyk7XG5cdFx0XHRcdGlmIChub2Rlc1tjaGlsZEtleV0pXG5cdFx0XHRcdFx0ciA9IHIuY29uY2F0KGRhdGEudHJhbnNmb3JtVG9BcnJheUZvcm1hdChzZXR0aW5nLCBub2Rlc1tjaGlsZEtleV0pKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByO1xuXHRcdH0sXG5cdFx0dHJhbnNmb3JtVG96VHJlZUZvcm1hdDogZnVuY3Rpb24oc2V0dGluZywgc05vZGVzKSB7XG5cdFx0XHR2YXIgaSxsLFxuXHRcdFx0a2V5ID0gc2V0dGluZy5kYXRhLnNpbXBsZURhdGEuaWRLZXksXG5cdFx0XHRwYXJlbnRLZXkgPSBzZXR0aW5nLmRhdGEuc2ltcGxlRGF0YS5wSWRLZXksXG5cdFx0XHRjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW47XG5cdFx0XHRpZiAoIWtleSB8fCBrZXk9PVwiXCIgfHwgIXNOb2RlcykgcmV0dXJuIFtdO1xuXG5cdFx0XHRpZiAodG9vbHMuaXNBcnJheShzTm9kZXMpKSB7XG5cdFx0XHRcdHZhciByID0gW107XG5cdFx0XHRcdHZhciB0bXBNYXAgPSBbXTtcblx0XHRcdFx0Zm9yIChpPTAsIGw9c05vZGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0XHR0bXBNYXBbc05vZGVzW2ldW2tleV1dID0gc05vZGVzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaT0wLCBsPXNOb2Rlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRtcE1hcFtzTm9kZXNbaV1bcGFyZW50S2V5XV0gJiYgc05vZGVzW2ldW2tleV0gIT0gc05vZGVzW2ldW3BhcmVudEtleV0pIHtcblx0XHRcdFx0XHRcdGlmICghdG1wTWFwW3NOb2Rlc1tpXVtwYXJlbnRLZXldXVtjaGlsZEtleV0pXG5cdFx0XHRcdFx0XHRcdHRtcE1hcFtzTm9kZXNbaV1bcGFyZW50S2V5XV1bY2hpbGRLZXldID0gW107XG5cdFx0XHRcdFx0XHR0bXBNYXBbc05vZGVzW2ldW3BhcmVudEtleV1dW2NoaWxkS2V5XS5wdXNoKHNOb2Rlc1tpXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHIucHVzaChzTm9kZXNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcjtcblx0XHRcdH1lbHNlIHtcblx0XHRcdFx0cmV0dXJuIFtzTm9kZXNdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0Ly9tZXRob2Qgb2YgZXZlbnQgcHJveHlcblx0ZXZlbnQgPSB7XG5cdFx0YmluZEV2ZW50OiBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGo9X2luaXQuYmluZC5sZW5ndGg7IGk8ajsgaSsrKSB7XG5cdFx0XHRcdF9pbml0LmJpbmRbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHVuYmluZEV2ZW50OiBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGo9X2luaXQudW5iaW5kLmxlbmd0aDsgaTxqOyBpKyspIHtcblx0XHRcdFx0X2luaXQudW5iaW5kW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRiaW5kVHJlZTogZnVuY3Rpb24oc2V0dGluZykge1xuXHRcdFx0dmFyIGV2ZW50UGFyYW0gPSB7XG5cdFx0XHRcdHRyZWVJZDogc2V0dGluZy50cmVlSWRcblx0XHRcdH0sXG5cdFx0XHRvID0gc2V0dGluZy50cmVlT2JqO1xuXHRcdFx0aWYgKCFzZXR0aW5nLnZpZXcudHh0U2VsZWN0ZWRFbmFibGUpIHtcblx0XHRcdFx0Ly8gZm9yIGNhbid0IHNlbGVjdCB0ZXh0XG5cdFx0XHRcdG8uYmluZCgnc2VsZWN0c3RhcnQnLCBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHR2YXIgbm9kZVxuXHRcdFx0XHRcdHZhciBuID0gZS5vcmlnaW5hbEV2ZW50LnNyY0VsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRyZXR1cm4gKG4gPT09IFwiaW5wdXRcIiB8fCBuID09PSBcInRleHRhcmVhXCIgKTtcblx0XHRcdFx0fSkuY3NzKHtcblx0XHRcdFx0XHRcIi1tb3otdXNlci1zZWxlY3RcIjpcIi1tb3otbm9uZVwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0by5iaW5kKCdjbGljaycsIGV2ZW50UGFyYW0sIGV2ZW50LnByb3h5KTtcblx0XHRcdG8uYmluZCgnZGJsY2xpY2snLCBldmVudFBhcmFtLCBldmVudC5wcm94eSk7XG5cdFx0XHRvLmJpbmQoJ21vdXNlb3ZlcicsIGV2ZW50UGFyYW0sIGV2ZW50LnByb3h5KTtcblx0XHRcdG8uYmluZCgnbW91c2VvdXQnLCBldmVudFBhcmFtLCBldmVudC5wcm94eSk7XG5cdFx0XHRvLmJpbmQoJ21vdXNlZG93bicsIGV2ZW50UGFyYW0sIGV2ZW50LnByb3h5KTtcblx0XHRcdG8uYmluZCgnbW91c2V1cCcsIGV2ZW50UGFyYW0sIGV2ZW50LnByb3h5KTtcblx0XHRcdG8uYmluZCgnY29udGV4dG1lbnUnLCBldmVudFBhcmFtLCBldmVudC5wcm94eSk7XG5cdFx0fSxcblx0XHR1bmJpbmRUcmVlOiBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0XHR2YXIgbyA9IHNldHRpbmcudHJlZU9iajtcblx0XHRcdG8udW5iaW5kKCdjbGljaycsIGV2ZW50LnByb3h5KVxuXHRcdFx0LnVuYmluZCgnZGJsY2xpY2snLCBldmVudC5wcm94eSlcblx0XHRcdC51bmJpbmQoJ21vdXNlb3ZlcicsIGV2ZW50LnByb3h5KVxuXHRcdFx0LnVuYmluZCgnbW91c2VvdXQnLCBldmVudC5wcm94eSlcblx0XHRcdC51bmJpbmQoJ21vdXNlZG93bicsIGV2ZW50LnByb3h5KVxuXHRcdFx0LnVuYmluZCgnbW91c2V1cCcsIGV2ZW50LnByb3h5KVxuXHRcdFx0LnVuYmluZCgnY29udGV4dG1lbnUnLCBldmVudC5wcm94eSk7XG5cdFx0fSxcblx0XHRkb1Byb3h5OiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBqPV9pbml0LnByb3h5cy5sZW5ndGg7IGk8ajsgaSsrKSB7XG5cdFx0XHRcdHZhciBwcm94eVJlc3VsdCA9IF9pbml0LnByb3h5c1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRyZXN1bHRzLnB1c2gocHJveHlSZXN1bHQpO1xuXHRcdFx0XHRpZiAocHJveHlSZXN1bHQuc3RvcCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9LFxuXHRcdHByb3h5OiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgc2V0dGluZyA9IGRhdGEuZ2V0U2V0dGluZyhlLmRhdGEudHJlZUlkKTtcblx0XHRcdGlmICghdG9vbHMudUNhbkRvKHNldHRpbmcsIGUpKSByZXR1cm4gdHJ1ZTtcblx0XHRcdHZhciByZXN1bHRzID0gZXZlbnQuZG9Qcm94eShlKSxcblx0XHRcdHIgPSB0cnVlLCB4ID0gZmFsc2U7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGw9cmVzdWx0cy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwcm94eVJlc3VsdCA9IHJlc3VsdHNbaV07XG5cdFx0XHRcdGlmIChwcm94eVJlc3VsdC5ub2RlRXZlbnRDYWxsYmFjaykge1xuXHRcdFx0XHRcdHggPSB0cnVlO1xuXHRcdFx0XHRcdHIgPSBwcm94eVJlc3VsdC5ub2RlRXZlbnRDYWxsYmFjay5hcHBseShwcm94eVJlc3VsdCwgW2UsIHByb3h5UmVzdWx0Lm5vZGVdKSAmJiByO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcm94eVJlc3VsdC50cmVlRXZlbnRDYWxsYmFjaykge1xuXHRcdFx0XHRcdHggPSB0cnVlO1xuXHRcdFx0XHRcdHIgPSBwcm94eVJlc3VsdC50cmVlRXZlbnRDYWxsYmFjay5hcHBseShwcm94eVJlc3VsdCwgW2UsIHByb3h5UmVzdWx0Lm5vZGVdKSAmJiByO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9XG5cdH0sXG5cdC8vbWV0aG9kIG9mIGV2ZW50IGhhbmRsZXJcblx0aGFuZGxlciA9IHtcblx0XHRvblN3aXRjaE5vZGU6IGZ1bmN0aW9uIChldmVudCwgbm9kZSkge1xuXHRcdFx0dmFyIHNldHRpbmcgPSBkYXRhLmdldFNldHRpbmcoZXZlbnQuZGF0YS50cmVlSWQpO1xuXHRcdFx0aWYgKG5vZGUub3Blbikge1xuXHRcdFx0XHRpZiAodG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5iZWZvcmVDb2xsYXBzZSwgW3NldHRpbmcudHJlZUlkLCBub2RlXSwgdHJ1ZSkgPT0gZmFsc2UpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRkYXRhLmdldFJvb3Qoc2V0dGluZykuZXhwYW5kVHJpZ2dlckZsYWcgPSB0cnVlO1xuXHRcdFx0XHR2aWV3LnN3aXRjaE5vZGUoc2V0dGluZywgbm9kZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5iZWZvcmVFeHBhbmQsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0sIHRydWUpID09IGZhbHNlKSByZXR1cm4gdHJ1ZTtcblx0XHRcdFx0ZGF0YS5nZXRSb290KHNldHRpbmcpLmV4cGFuZFRyaWdnZXJGbGFnID0gdHJ1ZTtcblx0XHRcdFx0dmlldy5zd2l0Y2hOb2RlKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRvbkNsaWNrTm9kZTogZnVuY3Rpb24gKGV2ZW50LCBub2RlKSB7XG5cdFx0XHR2YXIgc2V0dGluZyA9IGRhdGEuZ2V0U2V0dGluZyhldmVudC5kYXRhLnRyZWVJZCksXG5cdFx0XHRjbGlja0ZsYWcgPSAoIChzZXR0aW5nLnZpZXcuYXV0b0NhbmNlbFNlbGVjdGVkICYmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpKSAmJiBkYXRhLmlzU2VsZWN0ZWROb2RlKHNldHRpbmcsIG5vZGUpKSA/IDAgOiAoc2V0dGluZy52aWV3LmF1dG9DYW5jZWxTZWxlY3RlZCAmJiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJiBzZXR0aW5nLnZpZXcuc2VsZWN0ZWRNdWx0aSkgPyAyIDogMTtcblx0XHRcdGlmICh0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZUNsaWNrLCBbc2V0dGluZy50cmVlSWQsIG5vZGUsIGNsaWNrRmxhZ10sIHRydWUpID09IGZhbHNlKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChjbGlja0ZsYWcgPT09IDApIHtcblx0XHRcdFx0dmlldy5jYW5jZWxQcmVTZWxlY3RlZE5vZGUoc2V0dGluZywgbm9kZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2aWV3LnNlbGVjdE5vZGUoc2V0dGluZywgbm9kZSwgY2xpY2tGbGFnID09PSAyKTtcblx0XHRcdH1cblx0XHRcdHNldHRpbmcudHJlZU9iai50cmlnZ2VyKGNvbnN0cy5ldmVudC5DTElDSywgW2V2ZW50LCBzZXR0aW5nLnRyZWVJZCwgbm9kZSwgY2xpY2tGbGFnXSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdG9uWlRyZWVNb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG5cdFx0XHR2YXIgc2V0dGluZyA9IGRhdGEuZ2V0U2V0dGluZyhldmVudC5kYXRhLnRyZWVJZCk7XG5cdFx0XHRpZiAodG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5iZWZvcmVNb3VzZURvd24sIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0sIHRydWUpKSB7XG5cdFx0XHRcdHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2sub25Nb3VzZURvd24sIFtldmVudCwgc2V0dGluZy50cmVlSWQsIG5vZGVdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0b25aVHJlZU1vdXNldXA6IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG5cdFx0XHR2YXIgc2V0dGluZyA9IGRhdGEuZ2V0U2V0dGluZyhldmVudC5kYXRhLnRyZWVJZCk7XG5cdFx0XHRpZiAodG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5iZWZvcmVNb3VzZVVwLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSkge1xuXHRcdFx0XHR0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLm9uTW91c2VVcCwgW2V2ZW50LCBzZXR0aW5nLnRyZWVJZCwgbm9kZV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRvblpUcmVlRGJsY2xpY2s6IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG5cdFx0XHR2YXIgc2V0dGluZyA9IGRhdGEuZ2V0U2V0dGluZyhldmVudC5kYXRhLnRyZWVJZCk7XG5cdFx0XHRpZiAodG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5iZWZvcmVEYmxDbGljaywgW3NldHRpbmcudHJlZUlkLCBub2RlXSwgdHJ1ZSkpIHtcblx0XHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vbkRibENsaWNrLCBbZXZlbnQsIHNldHRpbmcudHJlZUlkLCBub2RlXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdG9uWlRyZWVDb250ZXh0bWVudTogZnVuY3Rpb24oZXZlbnQsIG5vZGUpIHtcblx0XHRcdHZhciBzZXR0aW5nID0gZGF0YS5nZXRTZXR0aW5nKGV2ZW50LmRhdGEudHJlZUlkKTtcblx0XHRcdGlmICh0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZVJpZ2h0Q2xpY2ssIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0sIHRydWUpKSB7XG5cdFx0XHRcdHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2sub25SaWdodENsaWNrLCBbZXZlbnQsIHNldHRpbmcudHJlZUlkLCBub2RlXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHR5cGVvZiBzZXR0aW5nLmNhbGxiYWNrLm9uUmlnaHRDbGljaykgIT0gXCJmdW5jdGlvblwiO1xuXHRcdH1cblx0fSxcblx0Ly9tZXRob2Qgb2YgdG9vbHMgZm9yIHpUcmVlXG5cdHRvb2xzID0ge1xuXHRcdGFwcGx5OiBmdW5jdGlvbihmdW4sIHBhcmFtLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRcdGlmICgodHlwZW9mIGZ1bikgPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHJldHVybiBmdW4uYXBwbHkoenQsIHBhcmFtP3BhcmFtOltdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdFx0fSxcblx0XHRjYW5Bc3luYzogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0dmFyIGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbjtcblx0XHRcdHJldHVybiAoc2V0dGluZy5hc3luYy5lbmFibGUgJiYgbm9kZSAmJiBub2RlLmlzUGFyZW50ICYmICEobm9kZS56QXN5bmMgfHwgKG5vZGVbY2hpbGRLZXldICYmIG5vZGVbY2hpbGRLZXldLmxlbmd0aCA+IDApKSk7XG5cdFx0fSxcblx0XHRjbG9uZTogZnVuY3Rpb24gKG9iail7XG5cdFx0XHRpZiAob2JqID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0XHRcdHZhciBvID0gdG9vbHMuaXNBcnJheShvYmopID8gW10gOiB7fTtcblx0XHRcdGZvcih2YXIgaSBpbiBvYmope1xuXHRcdFx0XHRvW2ldID0gKG9ialtpXSBpbnN0YW5jZW9mIERhdGUpID8gbmV3IERhdGUob2JqW2ldLmdldFRpbWUoKSkgOiAodHlwZW9mIG9ialtpXSA9PT0gXCJvYmplY3RcIiA/IGFyZ3VtZW50cy5jYWxsZWUob2JqW2ldKSA6IG9ialtpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbztcblx0XHR9LFxuXHRcdGVxczogZnVuY3Rpb24oc3RyMSwgc3RyMikge1xuXHRcdFx0cmV0dXJuIHN0cjEudG9Mb3dlckNhc2UoKSA9PT0gc3RyMi50b0xvd2VyQ2FzZSgpO1xuXHRcdH0sXG5cdFx0aXNBcnJheTogZnVuY3Rpb24oYXJyKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShhcnIpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cdFx0fSxcblx0XHQkOiBmdW5jdGlvbihub2RlLCBleHAsIHNldHRpbmcpIHtcblx0XHRcdGlmICghIWV4cCAmJiB0eXBlb2YgZXhwICE9IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0c2V0dGluZyA9IGV4cDtcblx0XHRcdFx0ZXhwID0gXCJcIjtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Ygbm9kZSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHJldHVybiAkKG5vZGUsIHNldHRpbmcgPyBzZXR0aW5nLnRyZWVPYmouZ2V0KDApLm93bmVyRG9jdW1lbnQgOiBudWxsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAkKFwiI1wiICsgbm9kZS50SWQgKyBleHAsIHNldHRpbmcgPyBzZXR0aW5nLnRyZWVPYmogOiBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdldE1Eb206IGZ1bmN0aW9uIChzZXR0aW5nLCBjdXJEb20sIHRhcmdldEV4cHIpIHtcblx0XHRcdGlmICghY3VyRG9tKSByZXR1cm4gbnVsbDtcblx0XHRcdHdoaWxlIChjdXJEb20gJiYgY3VyRG9tLmlkICE9PSBzZXR0aW5nLnRyZWVJZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpPTAsIGw9dGFyZ2V0RXhwci5sZW5ndGg7IGN1ckRvbS50YWdOYW1lICYmIGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRvb2xzLmVxcyhjdXJEb20udGFnTmFtZSwgdGFyZ2V0RXhwcltpXS50YWdOYW1lKSAmJiBjdXJEb20uZ2V0QXR0cmlidXRlKHRhcmdldEV4cHJbaV0uYXR0ck5hbWUpICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY3VyRG9tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJEb20gPSBjdXJEb20ucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0Z2V0Tm9kZU1haW5Eb206ZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gKCQodGFyZ2V0KS5wYXJlbnQoXCJsaVwiKS5nZXQoMCkgfHwgJCh0YXJnZXQpLnBhcmVudHNVbnRpbChcImxpXCIpLnBhcmVudCgpLmdldCgwKSk7XG5cdFx0fSxcblx0XHRpc0NoaWxkT3JTZWxmOiBmdW5jdGlvbihkb20sIHBhcmVudElkKSB7XG5cdFx0XHRyZXR1cm4gKCAkKGRvbSkuY2xvc2VzdChcIiNcIiArIHBhcmVudElkKS5sZW5ndGg+IDAgKTtcblx0XHR9LFxuXHRcdHVDYW5EbzogZnVuY3Rpb24oc2V0dGluZywgZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXHQvL21ldGhvZCBvZiBvcGVyYXRlIHp0cmVlIGRvbVxuXHR2aWV3ID0ge1xuXHRcdGFkZE5vZGVzOiBmdW5jdGlvbihzZXR0aW5nLCBwYXJlbnROb2RlLCBuZXdOb2RlcywgaXNTaWxlbnQpIHtcblx0XHRcdGlmIChzZXR0aW5nLmRhdGEua2VlcC5sZWFmICYmIHBhcmVudE5vZGUgJiYgIXBhcmVudE5vZGUuaXNQYXJlbnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF0b29scy5pc0FycmF5KG5ld05vZGVzKSkge1xuXHRcdFx0XHRuZXdOb2RlcyA9IFtuZXdOb2Rlc107XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2V0dGluZy5kYXRhLnNpbXBsZURhdGEuZW5hYmxlKSB7XG5cdFx0XHRcdG5ld05vZGVzID0gZGF0YS50cmFuc2Zvcm1Ub3pUcmVlRm9ybWF0KHNldHRpbmcsIG5ld05vZGVzKTtcblx0XHRcdH1cblx0XHRcdGlmIChwYXJlbnROb2RlKSB7XG5cdFx0XHRcdHZhciB0YXJnZXRfc3dpdGNoT2JqID0gJCQocGFyZW50Tm9kZSwgY29uc3RzLmlkLlNXSVRDSCwgc2V0dGluZyksXG5cdFx0XHRcdHRhcmdldF9pY29PYmogPSAkJChwYXJlbnROb2RlLCBjb25zdHMuaWQuSUNPTiwgc2V0dGluZyksXG5cdFx0XHRcdHRhcmdldF91bE9iaiA9ICQkKHBhcmVudE5vZGUsIGNvbnN0cy5pZC5VTCwgc2V0dGluZyk7XG5cblx0XHRcdFx0aWYgKCFwYXJlbnROb2RlLm9wZW4pIHtcblx0XHRcdFx0XHR2aWV3LnJlcGxhY2VTd2l0Y2hDbGFzcyhwYXJlbnROb2RlLCB0YXJnZXRfc3dpdGNoT2JqLCBjb25zdHMuZm9sZGVyLkNMT1NFKTtcblx0XHRcdFx0XHR2aWV3LnJlcGxhY2VJY29DbGFzcyhwYXJlbnROb2RlLCB0YXJnZXRfaWNvT2JqLCBjb25zdHMuZm9sZGVyLkNMT1NFKTtcblx0XHRcdFx0XHRwYXJlbnROb2RlLm9wZW4gPSBmYWxzZTtcblx0XHRcdFx0XHR0YXJnZXRfdWxPYmouY3NzKHtcblx0XHRcdFx0XHRcdFwiZGlzcGxheVwiOiBcIm5vbmVcIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGF0YS5hZGROb2Rlc0RhdGEoc2V0dGluZywgcGFyZW50Tm9kZSwgbmV3Tm9kZXMpO1xuXHRcdFx0XHR2aWV3LmNyZWF0ZU5vZGVzKHNldHRpbmcsIHBhcmVudE5vZGUubGV2ZWwgKyAxLCBuZXdOb2RlcywgcGFyZW50Tm9kZSk7XG5cdFx0XHRcdGlmICghaXNTaWxlbnQpIHtcblx0XHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlUGFyZW50Tm9kZShzZXR0aW5nLCBwYXJlbnROb2RlLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YS5hZGROb2Rlc0RhdGEoc2V0dGluZywgZGF0YS5nZXRSb290KHNldHRpbmcpLCBuZXdOb2Rlcyk7XG5cdFx0XHRcdHZpZXcuY3JlYXRlTm9kZXMoc2V0dGluZywgMCwgbmV3Tm9kZXMsIG51bGwpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXBwZW5kTm9kZXM6IGZ1bmN0aW9uKHNldHRpbmcsIGxldmVsLCBub2RlcywgcGFyZW50Tm9kZSwgaW5pdEZsYWcsIG9wZW5GbGFnKSB7XG5cdFx0XHRpZiAoIW5vZGVzKSByZXR1cm4gW107XG5cdFx0XHR2YXIgaHRtbCA9IFtdLFxuXHRcdFx0Y2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdFx0aWYgKGluaXRGbGFnKSB7XG5cdFx0XHRcdFx0dmFyIHRtcFBOb2RlID0gKHBhcmVudE5vZGUpID8gcGFyZW50Tm9kZTogZGF0YS5nZXRSb290KHNldHRpbmcpLFxuXHRcdFx0XHRcdHRtcFBDaGlsZCA9IHRtcFBOb2RlW2NoaWxkS2V5XSxcblx0XHRcdFx0XHRpc0ZpcnN0Tm9kZSA9ICgodG1wUENoaWxkLmxlbmd0aCA9PSBub2Rlcy5sZW5ndGgpICYmIChpID09IDApKSxcblx0XHRcdFx0XHRpc0xhc3ROb2RlID0gKGkgPT0gKG5vZGVzLmxlbmd0aCAtIDEpKTtcblx0XHRcdFx0XHRkYXRhLmluaXROb2RlKHNldHRpbmcsIGxldmVsLCBub2RlLCBwYXJlbnROb2RlLCBpc0ZpcnN0Tm9kZSwgaXNMYXN0Tm9kZSwgb3BlbkZsYWcpO1xuXHRcdFx0XHRcdGRhdGEuYWRkTm9kZUNhY2hlKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNoaWxkSHRtbCA9IFtdO1xuXHRcdFx0XHRpZiAobm9kZVtjaGlsZEtleV0gJiYgbm9kZVtjaGlsZEtleV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdC8vbWFrZSBjaGlsZCBodG1sIGZpcnN0LCBiZWNhdXNlIGNoZWNrVHlwZVxuXHRcdFx0XHRcdGNoaWxkSHRtbCA9IHZpZXcuYXBwZW5kTm9kZXMoc2V0dGluZywgbGV2ZWwgKyAxLCBub2RlW2NoaWxkS2V5XSwgbm9kZSwgaW5pdEZsYWcsIG9wZW5GbGFnICYmIG5vZGUub3Blbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wZW5GbGFnKSB7XG5cblx0XHRcdFx0XHR2aWV3Lm1ha2VET01Ob2RlTWFpbkJlZm9yZShodG1sLCBzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0XHR2aWV3Lm1ha2VET01Ob2RlTGluZShodG1sLCBzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0XHRkYXRhLmdldEJlZm9yZUEoc2V0dGluZywgbm9kZSwgaHRtbCk7XG5cdFx0XHRcdFx0dmlldy5tYWtlRE9NTm9kZU5hbWVCZWZvcmUoaHRtbCwgc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdFx0ZGF0YS5nZXRJbm5lckJlZm9yZUEoc2V0dGluZywgbm9kZSwgaHRtbCk7XG5cdFx0XHRcdFx0dmlldy5tYWtlRE9NTm9kZUljb24oaHRtbCwgc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdFx0ZGF0YS5nZXRJbm5lckFmdGVyQShzZXR0aW5nLCBub2RlLCBodG1sKTtcblx0XHRcdFx0XHR2aWV3Lm1ha2VET01Ob2RlTmFtZUFmdGVyKGh0bWwsIHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRcdGRhdGEuZ2V0QWZ0ZXJBKHNldHRpbmcsIG5vZGUsIGh0bWwpO1xuXHRcdFx0XHRcdGlmIChub2RlLmlzUGFyZW50ICYmIG5vZGUub3Blbikge1xuXHRcdFx0XHRcdFx0dmlldy5tYWtlVWxIdG1sKHNldHRpbmcsIG5vZGUsIGh0bWwsIGNoaWxkSHRtbC5qb2luKCcnKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZpZXcubWFrZURPTU5vZGVNYWluQWZ0ZXIoaHRtbCwgc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdFx0ZGF0YS5hZGRDcmVhdGVkTm9kZShzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGh0bWw7XG5cdFx0fSxcblx0XHRhcHBlbmRQYXJlbnRVTERvbTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0dmFyIGh0bWwgPSBbXSxcblx0XHRcdG5PYmogPSAkJChub2RlLCBzZXR0aW5nKTtcblx0XHRcdGlmICghbk9iai5nZXQoMCkgJiYgISFub2RlLnBhcmVudFRJZCkge1xuXHRcdFx0XHR2aWV3LmFwcGVuZFBhcmVudFVMRG9tKHNldHRpbmcsIG5vZGUuZ2V0UGFyZW50Tm9kZSgpKTtcblx0XHRcdFx0bk9iaiA9ICQkKG5vZGUsIHNldHRpbmcpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHVsT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLlVMLCBzZXR0aW5nKTtcblx0XHRcdGlmICh1bE9iai5nZXQoMCkpIHtcblx0XHRcdFx0dWxPYmoucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuLFxuXHRcdFx0Y2hpbGRIdG1sID0gdmlldy5hcHBlbmROb2RlcyhzZXR0aW5nLCBub2RlLmxldmVsKzEsIG5vZGVbY2hpbGRLZXldLCBub2RlLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR2aWV3Lm1ha2VVbEh0bWwoc2V0dGluZywgbm9kZSwgaHRtbCwgY2hpbGRIdG1sLmpvaW4oJycpKTtcblx0XHRcdG5PYmouYXBwZW5kKGh0bWwuam9pbignJykpO1xuXHRcdH0sXG5cdFx0YXN5bmNOb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlLCBpc1NpbGVudCwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBpLCBsO1xuXHRcdFx0aWYgKG5vZGUgJiYgIW5vZGUuaXNQYXJlbnQpIHtcblx0XHRcdFx0dG9vbHMuYXBwbHkoY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKG5vZGUgJiYgbm9kZS5pc0FqYXhpbmcpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICh0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZUFzeW5jLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkge1xuXHRcdFx0XHR0b29scy5hcHBseShjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdG5vZGUuaXNBamF4aW5nID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGljb09iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5JQ09OLCBzZXR0aW5nKTtcblx0XHRcdFx0aWNvT2JqLmF0dHIoe1wic3R5bGVcIjpcIlwiLCBcImNsYXNzXCI6Y29uc3RzLmNsYXNzTmFtZS5CVVRUT04gKyBcIiBcIiArIGNvbnN0cy5jbGFzc05hbWUuSUNPX0xPQURJTkd9KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRtcFBhcmFtID0ge307XG5cdFx0XHRmb3IgKGkgPSAwLCBsID0gc2V0dGluZy5hc3luYy5hdXRvUGFyYW0ubGVuZ3RoOyBub2RlICYmIGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHBLZXkgPSBzZXR0aW5nLmFzeW5jLmF1dG9QYXJhbVtpXS5zcGxpdChcIj1cIiksIHNwS2V5ID0gcEtleTtcblx0XHRcdFx0aWYgKHBLZXkubGVuZ3RoPjEpIHtcblx0XHRcdFx0XHRzcEtleSA9IHBLZXlbMV07XG5cdFx0XHRcdFx0cEtleSA9IHBLZXlbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0dG1wUGFyYW1bc3BLZXldID0gbm9kZVtwS2V5XTtcblx0XHRcdH1cblx0XHRcdGlmICh0b29scy5pc0FycmF5KHNldHRpbmcuYXN5bmMub3RoZXJQYXJhbSkpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IHNldHRpbmcuYXN5bmMub3RoZXJQYXJhbS5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcblx0XHRcdFx0XHR0bXBQYXJhbVtzZXR0aW5nLmFzeW5jLm90aGVyUGFyYW1baV1dID0gc2V0dGluZy5hc3luYy5vdGhlclBhcmFtW2kgKyAxXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgcCBpbiBzZXR0aW5nLmFzeW5jLm90aGVyUGFyYW0pIHtcblx0XHRcdFx0XHR0bXBQYXJhbVtwXSA9IHNldHRpbmcuYXN5bmMub3RoZXJQYXJhbVtwXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX3RtcFYgPSBkYXRhLmdldFJvb3Qoc2V0dGluZykuX3Zlcjtcblx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdGNvbnRlbnRUeXBlOiBzZXR0aW5nLmFzeW5jLmNvbnRlbnRUeXBlLFxuXHRcdFx0XHR0eXBlOiBzZXR0aW5nLmFzeW5jLnR5cGUsXG5cdFx0XHRcdHVybDogdG9vbHMuYXBwbHkoc2V0dGluZy5hc3luYy51cmwsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0sIHNldHRpbmcuYXN5bmMudXJsKSxcblx0XHRcdFx0ZGF0YTogdG1wUGFyYW0sXG5cdFx0XHRcdGRhdGFUeXBlOiBzZXR0aW5nLmFzeW5jLmRhdGFUeXBlLFxuXHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbihtc2cpIHtcblx0XHRcdFx0XHRpZiAoX3RtcFYgIT0gZGF0YS5nZXRSb290KHNldHRpbmcpLl92ZXIpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIG5ld05vZGVzID0gW107XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmICghbXNnIHx8IG1zZy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRuZXdOb2RlcyA9IFtdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgbXNnID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMgPSBldmFsKFwiKFwiICsgbXNnICsgXCIpXCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bmV3Tm9kZXMgPSBtc2c7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaChlcnIpIHtcblx0XHRcdFx0XHRcdG5ld05vZGVzID0gbXNnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0XHRub2RlLmlzQWpheGluZyA9IG51bGw7XG5cdFx0XHRcdFx0XHRub2RlLnpBc3luYyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZpZXcuc2V0Tm9kZUxpbmVJY29zKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRcdGlmIChuZXdOb2RlcyAmJiBuZXdOb2RlcyAhPT0gXCJcIikge1xuXHRcdFx0XHRcdFx0bmV3Tm9kZXMgPSB0b29scy5hcHBseShzZXR0aW5nLmFzeW5jLmRhdGFGaWx0ZXIsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZSwgbmV3Tm9kZXNdLCBuZXdOb2Rlcyk7XG5cdFx0XHRcdFx0XHR2aWV3LmFkZE5vZGVzKHNldHRpbmcsIG5vZGUsICEhbmV3Tm9kZXMgPyB0b29scy5jbG9uZShuZXdOb2RlcykgOiBbXSwgISFpc1NpbGVudCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZpZXcuYWRkTm9kZXMoc2V0dGluZywgbm9kZSwgW10sICEhaXNTaWxlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZXR0aW5nLnRyZWVPYmoudHJpZ2dlcihjb25zdHMuZXZlbnQuQVNZTkNfU1VDQ0VTUywgW3NldHRpbmcudHJlZUlkLCBub2RlLCBtc2ddKTtcblx0XHRcdFx0XHR0b29scy5hcHBseShjYWxsYmFjayk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbihYTUxIdHRwUmVxdWVzdCwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcblx0XHRcdFx0XHRpZiAoX3RtcFYgIT0gZGF0YS5nZXRSb290KHNldHRpbmcpLl92ZXIpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG5vZGUpIG5vZGUuaXNBamF4aW5nID0gbnVsbDtcblx0XHRcdFx0XHR2aWV3LnNldE5vZGVMaW5lSWNvcyhzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0XHRzZXR0aW5nLnRyZWVPYmoudHJpZ2dlcihjb25zdHMuZXZlbnQuQVNZTkNfRVJST1IsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZSwgWE1MSHR0cFJlcXVlc3QsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRjYW5jZWxQcmVTZWxlY3RlZE5vZGU6IGZ1bmN0aW9uIChzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgbGlzdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKS5jdXJTZWxlY3RlZExpc3Q7XG5cdFx0XHRmb3IgKHZhciBpPTAsIGo9bGlzdC5sZW5ndGgtMTsgaj49aTsgai0tKSB7XG5cdFx0XHRcdGlmICghbm9kZSB8fCBub2RlID09PSBsaXN0W2pdKSB7XG5cdFx0XHRcdFx0JCQobGlzdFtqXSwgY29uc3RzLmlkLkEsIHNldHRpbmcpLnJlbW92ZUNsYXNzKGNvbnN0cy5ub2RlLkNVUlNFTEVDVEVEKTtcblx0XHRcdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRcdFx0ZGF0YS5yZW1vdmVTZWxlY3RlZE5vZGUoc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghbm9kZSkgZGF0YS5nZXRSb290KHNldHRpbmcpLmN1clNlbGVjdGVkTGlzdCA9IFtdO1xuXHRcdH0sXG5cdFx0Y3JlYXRlTm9kZUNhbGxiYWNrOiBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0XHRpZiAoISFzZXR0aW5nLmNhbGxiYWNrLm9uTm9kZUNyZWF0ZWQgfHwgISFzZXR0aW5nLnZpZXcuYWRkRGl5RG9tKSB7XG5cdFx0XHRcdHZhciByb290ID0gZGF0YS5nZXRSb290KHNldHRpbmcpO1xuXHRcdFx0XHR3aGlsZSAocm9vdC5jcmVhdGVkTm9kZXMubGVuZ3RoPjApIHtcblx0XHRcdFx0XHR2YXIgbm9kZSA9IHJvb3QuY3JlYXRlZE5vZGVzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy52aWV3LmFkZERpeURvbSwgW3NldHRpbmcudHJlZUlkLCBub2RlXSk7XG5cdFx0XHRcdFx0aWYgKCEhc2V0dGluZy5jYWxsYmFjay5vbk5vZGVDcmVhdGVkKSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5nLnRyZWVPYmoudHJpZ2dlcihjb25zdHMuZXZlbnQuTk9ERUNSRUFURUQsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y3JlYXRlTm9kZXM6IGZ1bmN0aW9uKHNldHRpbmcsIGxldmVsLCBub2RlcywgcGFyZW50Tm9kZSkge1xuXHRcdFx0aWYgKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCkgcmV0dXJuO1xuXHRcdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyksXG5cdFx0XHRjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRvcGVuRmxhZyA9ICFwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUub3BlbiB8fCAhISQkKHBhcmVudE5vZGVbY2hpbGRLZXldWzBdLCBzZXR0aW5nKS5nZXQoMCk7XG5cdFx0XHRyb290LmNyZWF0ZWROb2RlcyA9IFtdO1xuXHRcdFx0dmFyIHpUcmVlSHRtbCA9IHZpZXcuYXBwZW5kTm9kZXMoc2V0dGluZywgbGV2ZWwsIG5vZGVzLCBwYXJlbnROb2RlLCB0cnVlLCBvcGVuRmxhZyk7XG5cdFx0XHRpZiAoIXBhcmVudE5vZGUpIHtcblx0XHRcdFx0c2V0dGluZy50cmVlT2JqLmFwcGVuZCh6VHJlZUh0bWwuam9pbignJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHVsT2JqID0gJCQocGFyZW50Tm9kZSwgY29uc3RzLmlkLlVMLCBzZXR0aW5nKTtcblx0XHRcdFx0aWYgKHVsT2JqLmdldCgwKSkge1xuXHRcdFx0XHRcdHVsT2JqLmFwcGVuZCh6VHJlZUh0bWwuam9pbignJykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2aWV3LmNyZWF0ZU5vZGVDYWxsYmFjayhzZXR0aW5nKTtcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKHNldHRpbmcpIHtcblx0XHRcdGlmICghc2V0dGluZykgcmV0dXJuO1xuXHRcdFx0ZGF0YS5pbml0Q2FjaGUoc2V0dGluZyk7XG5cdFx0XHRkYXRhLmluaXRSb290KHNldHRpbmcpO1xuXHRcdFx0ZXZlbnQudW5iaW5kVHJlZShzZXR0aW5nKTtcblx0XHRcdGV2ZW50LnVuYmluZEV2ZW50KHNldHRpbmcpO1xuXHRcdFx0c2V0dGluZy50cmVlT2JqLmVtcHR5KCk7XG5cdFx0XHRkZWxldGUgc2V0dGluZ3Nbc2V0dGluZy50cmVlSWRdO1xuXHRcdH0sXG5cdFx0ZXhwYW5kQ29sbGFwc2VOb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlLCBleHBhbmRGbGFnLCBhbmltYXRlRmxhZywgY2FsbGJhY2spIHtcblx0XHRcdHZhciByb290ID0gZGF0YS5nZXRSb290KHNldHRpbmcpLFxuXHRcdFx0Y2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuO1xuXHRcdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRcdHRvb2xzLmFwcGx5KGNhbGxiYWNrLCBbXSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChyb290LmV4cGFuZFRyaWdnZXJGbGFnKSB7XG5cdFx0XHRcdHZhciBfY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmIChfY2FsbGJhY2spIF9jYWxsYmFjaygpO1xuXHRcdFx0XHRcdGlmIChub2RlLm9wZW4pIHtcblx0XHRcdFx0XHRcdHNldHRpbmcudHJlZU9iai50cmlnZ2VyKGNvbnN0cy5ldmVudC5FWFBBTkQsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZXR0aW5nLnRyZWVPYmoudHJpZ2dlcihjb25zdHMuZXZlbnQuQ09MTEFQU0UsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0cm9vdC5leHBhbmRUcmlnZ2VyRmxhZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFub2RlLm9wZW4gJiYgbm9kZS5pc1BhcmVudCAmJiAoKCEkJChub2RlLCBjb25zdHMuaWQuVUwsIHNldHRpbmcpLmdldCgwKSkgfHwgKG5vZGVbY2hpbGRLZXldICYmIG5vZGVbY2hpbGRLZXldLmxlbmd0aD4wICYmICEkJChub2RlW2NoaWxkS2V5XVswXSwgc2V0dGluZykuZ2V0KDApKSkpIHtcblx0XHRcdFx0dmlldy5hcHBlbmRQYXJlbnRVTERvbShzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0dmlldy5jcmVhdGVOb2RlQ2FsbGJhY2soc2V0dGluZyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobm9kZS5vcGVuID09IGV4cGFuZEZsYWcpIHtcblx0XHRcdFx0dG9vbHMuYXBwbHkoY2FsbGJhY2ssIFtdKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHVsT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLlVMLCBzZXR0aW5nKSxcblx0XHRcdHN3aXRjaE9iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5TV0lUQ0gsIHNldHRpbmcpLFxuXHRcdFx0aWNvT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLklDT04sIHNldHRpbmcpO1xuXG5cdFx0XHRpZiAobm9kZS5pc1BhcmVudCkge1xuXHRcdFx0XHRub2RlLm9wZW4gPSAhbm9kZS5vcGVuO1xuXHRcdFx0XHRpZiAobm9kZS5pY29uT3BlbiAmJiBub2RlLmljb25DbG9zZSkge1xuXHRcdFx0XHRcdGljb09iai5hdHRyKFwic3R5bGVcIiwgdmlldy5tYWtlTm9kZUljb1N0eWxlKHNldHRpbmcsIG5vZGUpKTtcblx0XHRcdFx0XHQvL3p4aCBhZGRcblx0XHRcdFx0XHQvL2ljb09iai5hdHRyKFwiY2xhc3NcIiwgdmlldy5tYWtlTm9kZUljb0NsYXNzKHNldHRpbmcsIG5vZGUpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChub2RlLm9wZW4pIHtcblx0XHRcdFx0XHR2aWV3LnJlcGxhY2VTd2l0Y2hDbGFzcyhub2RlLCBzd2l0Y2hPYmosIGNvbnN0cy5mb2xkZXIuT1BFTik7XG5cdFx0XHRcdFx0dmlldy5yZXBsYWNlSWNvQ2xhc3Mobm9kZSwgaWNvT2JqLCBjb25zdHMuZm9sZGVyLk9QRU4pO1xuXHRcdFx0XHRcdGlmIChhbmltYXRlRmxhZyA9PSBmYWxzZSB8fCBzZXR0aW5nLnZpZXcuZXhwYW5kU3BlZWQgPT0gXCJcIikge1xuXHRcdFx0XHRcdFx0dWxPYmouc2hvdygpO1xuXHRcdFx0XHRcdFx0dG9vbHMuYXBwbHkoY2FsbGJhY2ssIFtdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG5vZGVbY2hpbGRLZXldICYmIG5vZGVbY2hpbGRLZXldLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0dWxPYmouc2xpZGVEb3duKHNldHRpbmcudmlldy5leHBhbmRTcGVlZCwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dWxPYmouc2hvdygpO1xuXHRcdFx0XHRcdFx0XHR0b29scy5hcHBseShjYWxsYmFjaywgW10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZihzd2l0Y2hPYmouaGFzQ2xhc3MoXCJjZW50ZXJfb3BlblwiKSl7XG5cdFx0XHRcdFx0XHRzd2l0Y2hPYmouY3NzKFwibWFyZ2luXCIsXCIxMnB4IDAgLTJweCAxcHhcIik7XG5cdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2hPYmoucmVtb3ZlQXR0cihcInN0eWxlXCIpO1xuXHRcdFx0XHRcdFx0fSwxMDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2aWV3LnJlcGxhY2VTd2l0Y2hDbGFzcyhub2RlLCBzd2l0Y2hPYmosIGNvbnN0cy5mb2xkZXIuQ0xPU0UpO1xuXHRcdFx0XHRcdHZpZXcucmVwbGFjZUljb0NsYXNzKG5vZGUsIGljb09iaiwgY29uc3RzLmZvbGRlci5DTE9TRSk7XG5cdFx0XHRcdFx0aWYgKGFuaW1hdGVGbGFnID09IGZhbHNlIHx8IHNldHRpbmcudmlldy5leHBhbmRTcGVlZCA9PSBcIlwiIHx8ICEobm9kZVtjaGlsZEtleV0gJiYgbm9kZVtjaGlsZEtleV0ubGVuZ3RoID4gMCkpIHtcblx0XHRcdFx0XHRcdHVsT2JqLmhpZGUoKTtcblx0XHRcdFx0XHRcdHRvb2xzLmFwcGx5KGNhbGxiYWNrLCBbXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHVsT2JqLnNsaWRlVXAoc2V0dGluZy52aWV3LmV4cGFuZFNwZWVkLCBjYWxsYmFjayk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b29scy5hcHBseShjYWxsYmFjaywgW10pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhwYW5kQ29sbGFwc2VQYXJlbnROb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlLCBleHBhbmRGbGFnLCBhbmltYXRlRmxhZywgY2FsbGJhY2spIHtcblx0XHRcdGlmICghbm9kZSkgcmV0dXJuO1xuXHRcdFx0aWYgKCFub2RlLnBhcmVudFRJZCkge1xuXHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlTm9kZShzZXR0aW5nLCBub2RlLCBleHBhbmRGbGFnLCBhbmltYXRlRmxhZywgY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlTm9kZShzZXR0aW5nLCBub2RlLCBleHBhbmRGbGFnLCBhbmltYXRlRmxhZyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobm9kZS5wYXJlbnRUSWQpIHtcblx0XHRcdFx0dmlldy5leHBhbmRDb2xsYXBzZVBhcmVudE5vZGUoc2V0dGluZywgbm9kZS5nZXRQYXJlbnROb2RlKCksIGV4cGFuZEZsYWcsIGFuaW1hdGVGbGFnLCBjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRleHBhbmRDb2xsYXBzZVNvbk5vZGU6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUsIGV4cGFuZEZsYWcsIGFuaW1hdGVGbGFnLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyksXG5cdFx0XHRjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHR0cmVlTm9kZXMgPSAobm9kZSkgPyBub2RlW2NoaWxkS2V5XTogcm9vdFtjaGlsZEtleV0sXG5cdFx0XHRzZWxmQW5pbWF0ZVNpZ24gPSAobm9kZSkgPyBmYWxzZSA6IGFuaW1hdGVGbGFnLFxuXHRcdFx0ZXhwYW5kVHJpZ2dlckZsYWcgPSBkYXRhLmdldFJvb3Qoc2V0dGluZykuZXhwYW5kVHJpZ2dlckZsYWc7XG5cdFx0XHRkYXRhLmdldFJvb3Qoc2V0dGluZykuZXhwYW5kVHJpZ2dlckZsYWcgPSBmYWxzZTtcblx0XHRcdGlmICh0cmVlTm9kZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0cmVlTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRyZWVOb2Rlc1tpXSkgdmlldy5leHBhbmRDb2xsYXBzZVNvbk5vZGUoc2V0dGluZywgdHJlZU5vZGVzW2ldLCBleHBhbmRGbGFnLCBzZWxmQW5pbWF0ZVNpZ24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkYXRhLmdldFJvb3Qoc2V0dGluZykuZXhwYW5kVHJpZ2dlckZsYWcgPSBleHBhbmRUcmlnZ2VyRmxhZztcblx0XHRcdHZpZXcuZXhwYW5kQ29sbGFwc2VOb2RlKHNldHRpbmcsIG5vZGUsIGV4cGFuZEZsYWcsIGFuaW1hdGVGbGFnLCBjYWxsYmFjayApO1xuXHRcdH0sXG5cdFx0bWFrZURPTU5vZGVJY29uOiBmdW5jdGlvbihodG1sLCBzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgbmFtZVN0ciA9IGRhdGEuZ2V0Tm9kZU5hbWUoc2V0dGluZywgbm9kZSksXG5cdFx0XHRuYW1lID0gc2V0dGluZy52aWV3Lm5hbWVJc0hUTUwgPyBuYW1lU3RyIDogbmFtZVN0ci5yZXBsYWNlKC8mL2csJyZhbXA7JykucmVwbGFjZSgvPC9nLCcmbHQ7JykucmVwbGFjZSgvPi9nLCcmZ3Q7Jyk7XG5cdFx0XHRodG1sLnB1c2goXCI8c3BhbiBpZD0nXCIsIG5vZGUudElkLCBjb25zdHMuaWQuSUNPTixcblx0XHRcdFx0XCInIHRpdGxlPScnIHRyZWVOb2RlXCIsIGNvbnN0cy5pZC5JQ09OLFwiIGNsYXNzPSdcIiwgdmlldy5tYWtlTm9kZUljb0NsYXNzKHNldHRpbmcsIG5vZGUpLFxuXHRcdFx0XHRcIicgc3R5bGU9J1wiLCB2aWV3Lm1ha2VOb2RlSWNvU3R5bGUoc2V0dGluZywgbm9kZSksIFwiJz48L3NwYW4+PHNwYW4gaWQ9J1wiLCBub2RlLnRJZCwgY29uc3RzLmlkLlNQQU4sXG5cdFx0XHRcdFwiJz5cIixuYW1lLFwiPC9zcGFuPlwiKTtcblx0XHR9LFxuXHRcdG1ha2VET01Ob2RlTGluZTogZnVuY3Rpb24oaHRtbCwgc2V0dGluZywgbm9kZSkge1xuXHRcdFx0aHRtbC5wdXNoKFwiPHNwYW4gaWQ9J1wiLCBub2RlLnRJZCwgY29uc3RzLmlkLlNXSVRDSCxcdFwiJyB0aXRsZT0nJyBjbGFzcz0nXCIsIHZpZXcubWFrZU5vZGVMaW5lQ2xhc3Moc2V0dGluZywgbm9kZSksIFwiJyB0cmVlTm9kZVwiLCBjb25zdHMuaWQuU1dJVENILFwiPjwvc3Bhbj5cIik7XG5cdFx0fSxcblx0XHRtYWtlRE9NTm9kZU1haW5BZnRlcjogZnVuY3Rpb24oaHRtbCwgc2V0dGluZywgbm9kZSkge1xuXHRcdFx0aHRtbC5wdXNoKFwiPC9saT5cIik7XG5cdFx0fSxcblx0XHRtYWtlRE9NTm9kZU1haW5CZWZvcmU6IGZ1bmN0aW9uKGh0bWwsIHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdGh0bWwucHVzaChcIjxsaSBpZD0nXCIsIG5vZGUudElkLCBcIicgY2xhc3M9J1wiLCBjb25zdHMuY2xhc3NOYW1lLkxFVkVMLCBub2RlLmxldmVsLFwiJyB0YWJpbmRleD0nMCcgaGlkZWZvY3VzPSd0cnVlJyB0cmVlbm9kZT5cIik7XG5cdFx0fSxcblx0XHRtYWtlRE9NTm9kZU5hbWVBZnRlcjogZnVuY3Rpb24oaHRtbCwgc2V0dGluZywgbm9kZSkge1xuXHRcdFx0aHRtbC5wdXNoKFwiPC9hPlwiKTtcblx0XHR9LFxuXHRcdG1ha2VET01Ob2RlTmFtZUJlZm9yZTogZnVuY3Rpb24oaHRtbCwgc2V0dGluZywgbm9kZSkge1xuXHRcdFx0dmFyIHRpdGxlID0gZGF0YS5nZXROb2RlVGl0bGUoc2V0dGluZywgbm9kZSksXG5cdFx0XHR1cmwgPSB2aWV3Lm1ha2VOb2RlVXJsKHNldHRpbmcsIG5vZGUpLFxuXHRcdFx0Zm9udGNzcyA9IHZpZXcubWFrZU5vZGVGb250Q3NzKHNldHRpbmcsIG5vZGUpLFxuXHRcdFx0Zm9udFN0eWxlID0gW107XG5cdFx0XHRmb3IgKHZhciBmIGluIGZvbnRjc3MpIHtcblx0XHRcdFx0Zm9udFN0eWxlLnB1c2goZiwgXCI6XCIsIGZvbnRjc3NbZl0sIFwiO1wiKTtcblx0XHRcdH1cblx0XHRcdGh0bWwucHVzaChcIjxhIGlkPSdcIiwgbm9kZS50SWQsIGNvbnN0cy5pZC5BLCBcIicgY2xhc3M9J1wiLCBjb25zdHMuY2xhc3NOYW1lLkxFVkVMLCBub2RlLmxldmVsLFwiJyB0cmVlTm9kZVwiLCBjb25zdHMuaWQuQSxcIiBvbmNsaWNrPVxcXCJcIiwgKG5vZGUuY2xpY2sgfHwgJycpLFxuXHRcdFx0XHRcIlxcXCIgXCIsICgodXJsICE9IG51bGwgJiYgdXJsLmxlbmd0aCA+IDApID8gXCJocmVmPSdcIiArIHVybCArIFwiJ1wiIDogXCJcIiksIFwiIHRhcmdldD0nXCIsdmlldy5tYWtlTm9kZVRhcmdldChub2RlKSxcIicgc3R5bGU9J1wiLCBmb250U3R5bGUuam9pbignJyksXG5cdFx0XHRcdFwiJ1wiKTtcblx0XHRcdGlmICh0b29scy5hcHBseShzZXR0aW5nLnZpZXcuc2hvd1RpdGxlLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCBzZXR0aW5nLnZpZXcuc2hvd1RpdGxlKSAmJiB0aXRsZSkge2h0bWwucHVzaChcInRpdGxlPSdcIiwgdGl0bGUucmVwbGFjZSgvJy9nLFwiJiMzOTtcIikucmVwbGFjZSgvPC9nLCcmbHQ7JykucmVwbGFjZSgvPi9nLCcmZ3Q7JyksXCInXCIpO31cblx0XHRcdGh0bWwucHVzaChcIj5cIik7XG5cdFx0fSxcblx0XHRtYWtlTm9kZUZvbnRDc3M6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciBmb250Q3NzID0gdG9vbHMuYXBwbHkoc2V0dGluZy52aWV3LmZvbnRDc3MsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0sIHNldHRpbmcudmlldy5mb250Q3NzKTtcblx0XHRcdHJldHVybiAoZm9udENzcyAmJiAoKHR5cGVvZiBmb250Q3NzKSAhPSBcImZ1bmN0aW9uXCIpKSA/IGZvbnRDc3MgOiB7fTtcblx0XHR9LFxuXHRcdG1ha2VOb2RlSWNvQ2xhc3M6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciBpY29Dc3MgPSBbXCJpY29cIl0saWNvbkZvbnQ9IFtdLGljb25KdXN0aWZ5PScnLHNob3dJY29uRm9udD1zZXR0aW5nLnZpZXcuc2hvd0ljb25Gb250P3RydWU6ZmFsc2UgO1xuXHRcdFx0Ly96eGggYWRkXG5cdFx0XHRpZiAoIW5vZGUuaXNBamF4aW5nKSB7XG5cdFx0XHRcdGlmIChub2RlLmlzUGFyZW50KVxuXHRcdFx0XHRcdGljb25KdXN0aWZ5ID0gbm9kZS5vcGVuID8gY29uc3RzLmZvbGRlci5PUEVOIDogY29uc3RzLmZvbGRlci5DTE9TRTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGljb25KdXN0aWZ5ID0gIGNvbnN0cy5mb2xkZXIuRE9DVTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmKHNob3dJY29uRm9udCl7XG5cdFx0XHRcdFx0aWNvQ3NzID0gW107XG5cdFx0XHRcdFx0Ly/lop7liqDlrZfkvZNcblx0XHRcdFx0XHR2YXIgaWNvbiA9IChub2RlLmlzUGFyZW50ICYmIG5vZGUuaWNvbk9wZW4gJiYgbm9kZS5pY29uQ2xvc2UpID8gKG5vZGUub3BlbiA/IG5vZGUuaWNvbk9wZW4gOiBub2RlLmljb25DbG9zZSkgOiBub2RlLmljb247XG5cdFx0XHRcdFx0aWYoaWNvbilcblx0XHRcdFx0XHRcdGljb25Gb250LnB1c2goaWNvbik7XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0aWNvbkZvbnRbMF0gPSAobm9kZS5pY29uU2tpbiA/IG5vZGUuaWNvblNraW4gKyBcIl9cIiA6IFwiaWNvX1wiKSArIGljb25KdXN0aWZ5O1xuXHRcdFx0XHRcdGljb25Gb250LnB1c2goJ2ZhX2p1c3RpZnlfJytpY29uSnVzdGlmeSk7XG5cdFx0XHRcdFx0aWYgKHNldHRpbmcudmlldy5zaG93SWNvbiA9PSBmYWxzZSB8fCAhdG9vbHMuYXBwbHkoc2V0dGluZy52aWV3LnNob3dJY29uLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSkgXG5cdFx0XHRcdFx0XHRpY29uRm9udCA9W107XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGljb0Nzc1swXSA9IChub2RlLmljb25Ta2luID8gbm9kZS5pY29uU2tpbiArIFwiX1wiIDogXCJcIikgKyBpY29Dc3NbMF07XG5cdFx0XHRcdFx0aWNvQ3NzLnB1c2goaWNvbkp1c3RpZnkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb25zdHMuY2xhc3NOYW1lLkJVVFRPTiArIFwiIFwiICsgaWNvQ3NzLmpvaW4oJ18nKStcIiBcIisgaWNvbkZvbnQuam9pbignICcpIDtcblx0XHR9LFxuXHRcdG1ha2VOb2RlSWNvU3R5bGU6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciBpY29TdHlsZSA9IFtdLHNob3dJY29uRm9udD1zZXR0aW5nLnZpZXcuc2hvd0ljb25Gb250P3RydWU6ZmFsc2U7XG5cdFx0XHRpZiAoIW5vZGUuaXNBamF4aW5nKSB7XG5cdFx0XHRcdHZhciBpY29uID0gKG5vZGUuaXNQYXJlbnQgJiYgbm9kZS5pY29uT3BlbiAmJiBub2RlLmljb25DbG9zZSkgPyAobm9kZS5vcGVuID8gbm9kZS5pY29uT3BlbiA6IG5vZGUuaWNvbkNsb3NlKSA6IG5vZGUuaWNvbjtcblx0XHRcdFx0aWYgKGljb24gJiYgIXNob3dJY29uRm9udCkgaWNvU3R5bGUucHVzaChcImJhY2tncm91bmQ6dXJsKFwiLCBpY29uLCBcIikgMCAwIG5vLXJlcGVhdDtcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoc2V0dGluZy52aWV3LnNob3dJY29uID09IGZhbHNlIHx8ICF0b29scy5hcHBseShzZXR0aW5nLnZpZXcuc2hvd0ljb24sIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0sIHRydWUpKSB7XG5cdFx0XHRcdFx0aWNvU3R5bGUucHVzaChcIndpZHRoOjBweDtoZWlnaHQ6MHB4O1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGljb1N0eWxlLmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0bWFrZU5vZGVMaW5lQ2xhc3M6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciBsaW5lQ2xhc3MgPSBbXTtcblx0XHRcdGlmIChzZXR0aW5nLnZpZXcuc2hvd0xpbmUpIHtcblx0XHRcdFx0aWYgKG5vZGUubGV2ZWwgPT0gMCAmJiBub2RlLmlzRmlyc3ROb2RlICYmIG5vZGUuaXNMYXN0Tm9kZSkge1xuXHRcdFx0XHRcdGxpbmVDbGFzcy5wdXNoKGNvbnN0cy5saW5lLlJPT1QpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5vZGUubGV2ZWwgPT0gMCAmJiBub2RlLmlzRmlyc3ROb2RlKSB7XG5cdFx0XHRcdFx0bGluZUNsYXNzLnB1c2goY29uc3RzLmxpbmUuUk9PVFMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5vZGUuaXNMYXN0Tm9kZSkge1xuXHRcdFx0XHRcdGxpbmVDbGFzcy5wdXNoKGNvbnN0cy5saW5lLkJPVFRPTSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGluZUNsYXNzLnB1c2goY29uc3RzLmxpbmUuQ0VOVEVSKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGluZUNsYXNzLnB1c2goY29uc3RzLmxpbmUuTk9MSU5FKTtcblx0XHRcdH1cblx0XHRcdGlmIChub2RlLmlzUGFyZW50KSB7XG5cdFx0XHRcdGxpbmVDbGFzcy5wdXNoKG5vZGUub3BlbiA/IGNvbnN0cy5mb2xkZXIuT1BFTiA6IGNvbnN0cy5mb2xkZXIuQ0xPU0UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGluZUNsYXNzLnB1c2goY29uc3RzLmZvbGRlci5ET0NVKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2aWV3Lm1ha2VOb2RlTGluZUNsYXNzRXgobm9kZSkgKyBsaW5lQ2xhc3Muam9pbignXycpO1xuXHRcdH0sXG5cdFx0bWFrZU5vZGVMaW5lQ2xhc3NFeDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIGNvbnN0cy5jbGFzc05hbWUuQlVUVE9OICsgXCIgXCIgKyBjb25zdHMuY2xhc3NOYW1lLkxFVkVMICsgbm9kZS5sZXZlbCArIFwiIFwiICsgY29uc3RzLmNsYXNzTmFtZS5TV0lUQ0ggKyBcIiBcIjtcblx0XHR9LFxuXHRcdG1ha2VOb2RlVGFyZ2V0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gKG5vZGUudGFyZ2V0IHx8IFwiX2JsYW5rXCIpO1xuXHRcdH0sXG5cdFx0bWFrZU5vZGVVcmw6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciB1cmxLZXkgPSBzZXR0aW5nLmRhdGEua2V5LnVybDtcblx0XHRcdHJldHVybiBub2RlW3VybEtleV0gPyBub2RlW3VybEtleV0gOiBudWxsO1xuXHRcdH0sXG5cdFx0bWFrZVVsSHRtbDogZnVuY3Rpb24oc2V0dGluZywgbm9kZSwgaHRtbCwgY29udGVudCkge1xuXHRcdFx0aHRtbC5wdXNoKFwiPHVsIGlkPSdcIiwgbm9kZS50SWQsIGNvbnN0cy5pZC5VTCwgXCInIGNsYXNzPSdcIiwgY29uc3RzLmNsYXNzTmFtZS5MRVZFTCwgbm9kZS5sZXZlbCwgXCIgXCIsIHZpZXcubWFrZVVsTGluZUNsYXNzKHNldHRpbmcsIG5vZGUpLCBcIicgc3R5bGU9J2Rpc3BsYXk6XCIsIChub2RlLm9wZW4gPyBcImJsb2NrXCI6IFwibm9uZVwiKSxcIic+XCIpO1xuXHRcdFx0aHRtbC5wdXNoKGNvbnRlbnQpO1xuXHRcdFx0aHRtbC5wdXNoKFwiPC91bD5cIik7XG5cdFx0fSxcblx0XHRtYWtlVWxMaW5lQ2xhc3M6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHJldHVybiAoKHNldHRpbmcudmlldy5zaG93TGluZSAmJiAhbm9kZS5pc0xhc3ROb2RlKSA/IGNvbnN0cy5saW5lLkxJTkUgOiBcIlwiKTtcblx0XHR9LFxuXHRcdHJlbW92ZUNoaWxkTm9kZXM6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdGlmICghbm9kZSkgcmV0dXJuO1xuXHRcdFx0dmFyIGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbixcblx0XHRcdG5vZGVzID0gbm9kZVtjaGlsZEtleV07XG5cdFx0XHRpZiAoIW5vZGVzKSByZXR1cm47XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGRhdGEucmVtb3ZlTm9kZUNhY2hlKHNldHRpbmcsIG5vZGVzW2ldKTtcblx0XHRcdH1cblx0XHRcdGRhdGEucmVtb3ZlU2VsZWN0ZWROb2RlKHNldHRpbmcpO1xuXHRcdFx0ZGVsZXRlIG5vZGVbY2hpbGRLZXldO1xuXG5cdFx0XHRpZiAoIXNldHRpbmcuZGF0YS5rZWVwLnBhcmVudCkge1xuXHRcdFx0XHRub2RlLmlzUGFyZW50ID0gZmFsc2U7XG5cdFx0XHRcdG5vZGUub3BlbiA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgdG1wX3N3aXRjaE9iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5TV0lUQ0gsIHNldHRpbmcpLFxuXHRcdFx0XHR0bXBfaWNvT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLklDT04sIHNldHRpbmcpO1xuXHRcdFx0XHR2aWV3LnJlcGxhY2VTd2l0Y2hDbGFzcyhub2RlLCB0bXBfc3dpdGNoT2JqLCBjb25zdHMuZm9sZGVyLkRPQ1UpO1xuXHRcdFx0XHR2aWV3LnJlcGxhY2VJY29DbGFzcyhub2RlLCB0bXBfaWNvT2JqLCBjb25zdHMuZm9sZGVyLkRPQ1UpO1xuXHRcdFx0XHQkJChub2RlLCBjb25zdHMuaWQuVUwsIHNldHRpbmcpLnJlbW92ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCQobm9kZSwgY29uc3RzLmlkLlVMLCBzZXR0aW5nKS5lbXB0eSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2V0Rmlyc3ROb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBwYXJlbnROb2RlKSB7XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuLCBjaGlsZExlbmd0aCA9IHBhcmVudE5vZGVbY2hpbGRLZXldLmxlbmd0aDtcblx0XHRcdGlmICggY2hpbGRMZW5ndGggPiAwKSB7XG5cdFx0XHRcdHBhcmVudE5vZGVbY2hpbGRLZXldWzBdLmlzRmlyc3ROb2RlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNldExhc3ROb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBwYXJlbnROb2RlKSB7XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuLCBjaGlsZExlbmd0aCA9IHBhcmVudE5vZGVbY2hpbGRLZXldLmxlbmd0aDtcblx0XHRcdGlmICggY2hpbGRMZW5ndGggPiAwKSB7XG5cdFx0XHRcdHBhcmVudE5vZGVbY2hpbGRLZXldW2NoaWxkTGVuZ3RoIC0gMV0uaXNMYXN0Tm9kZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW1vdmVOb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgcm9vdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKSxcblx0XHRcdGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbixcblx0XHRcdHBhcmVudE5vZGUgPSAobm9kZS5wYXJlbnRUSWQpID8gbm9kZS5nZXRQYXJlbnROb2RlKCkgOiByb290O1xuXG5cdFx0XHRub2RlLmlzRmlyc3ROb2RlID0gZmFsc2U7XG5cdFx0XHRub2RlLmlzTGFzdE5vZGUgPSBmYWxzZTtcblx0XHRcdG5vZGUuZ2V0UHJlTm9kZSA9IGZ1bmN0aW9uKCkge3JldHVybiBudWxsO307XG5cdFx0XHRub2RlLmdldE5leHROb2RlID0gZnVuY3Rpb24oKSB7cmV0dXJuIG51bGw7fTtcblxuXHRcdFx0aWYgKCFkYXRhLmdldE5vZGVDYWNoZShzZXR0aW5nLCBub2RlLnRJZCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQkJChub2RlLCBzZXR0aW5nKS5yZW1vdmUoKTtcblx0XHRcdGRhdGEucmVtb3ZlTm9kZUNhY2hlKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0ZGF0YS5yZW1vdmVTZWxlY3RlZE5vZGUoc2V0dGluZywgbm9kZSk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyZW50Tm9kZVtjaGlsZEtleV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwYXJlbnROb2RlW2NoaWxkS2V5XVtpXS50SWQgPT0gbm9kZS50SWQpIHtcblx0XHRcdFx0XHRwYXJlbnROb2RlW2NoaWxkS2V5XS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZpZXcuc2V0Rmlyc3ROb2RlKHNldHRpbmcsIHBhcmVudE5vZGUpO1xuXHRcdFx0dmlldy5zZXRMYXN0Tm9kZShzZXR0aW5nLCBwYXJlbnROb2RlKTtcblxuXHRcdFx0dmFyIHRtcF91bE9iaix0bXBfc3dpdGNoT2JqLHRtcF9pY29PYmosXG5cdFx0XHRjaGlsZExlbmd0aCA9IHBhcmVudE5vZGVbY2hpbGRLZXldLmxlbmd0aDtcblxuXHRcdFx0Ly9yZXBhaXIgbm9kZXMgb2xkIHBhcmVudFxuXHRcdFx0aWYgKCFzZXR0aW5nLmRhdGEua2VlcC5wYXJlbnQgJiYgY2hpbGRMZW5ndGggPT0gMCkge1xuXHRcdFx0XHQvL29sZCBwYXJlbnROb2RlIGhhcyBubyBjaGlsZCBub2Rlc1xuXHRcdFx0XHRwYXJlbnROb2RlLmlzUGFyZW50ID0gZmFsc2U7XG5cdFx0XHRcdHBhcmVudE5vZGUub3BlbiA9IGZhbHNlO1xuXHRcdFx0XHR0bXBfdWxPYmogPSAkJChwYXJlbnROb2RlLCBjb25zdHMuaWQuVUwsIHNldHRpbmcpO1xuXHRcdFx0XHR0bXBfc3dpdGNoT2JqID0gJCQocGFyZW50Tm9kZSwgY29uc3RzLmlkLlNXSVRDSCwgc2V0dGluZyk7XG5cdFx0XHRcdHRtcF9pY29PYmogPSAkJChwYXJlbnROb2RlLCBjb25zdHMuaWQuSUNPTiwgc2V0dGluZyk7XG5cdFx0XHRcdHZpZXcucmVwbGFjZVN3aXRjaENsYXNzKHBhcmVudE5vZGUsIHRtcF9zd2l0Y2hPYmosIGNvbnN0cy5mb2xkZXIuRE9DVSk7XG5cdFx0XHRcdHZpZXcucmVwbGFjZUljb0NsYXNzKHBhcmVudE5vZGUsIHRtcF9pY29PYmosIGNvbnN0cy5mb2xkZXIuRE9DVSk7XG5cdFx0XHRcdHRtcF91bE9iai5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblxuXHRcdFx0fSBlbHNlIGlmIChzZXR0aW5nLnZpZXcuc2hvd0xpbmUgJiYgY2hpbGRMZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vb2xkIHBhcmVudE5vZGUgaGFzIGNoaWxkIG5vZGVzXG5cdFx0XHRcdHZhciBuZXdMYXN0ID0gcGFyZW50Tm9kZVtjaGlsZEtleV1bY2hpbGRMZW5ndGggLSAxXTtcblx0XHRcdFx0dG1wX3VsT2JqID0gJCQobmV3TGFzdCwgY29uc3RzLmlkLlVMLCBzZXR0aW5nKTtcblx0XHRcdFx0dG1wX3N3aXRjaE9iaiA9ICQkKG5ld0xhc3QsIGNvbnN0cy5pZC5TV0lUQ0gsIHNldHRpbmcpO1xuXHRcdFx0XHR0bXBfaWNvT2JqID0gJCQobmV3TGFzdCwgY29uc3RzLmlkLklDT04sIHNldHRpbmcpO1xuXHRcdFx0XHRpZiAocGFyZW50Tm9kZSA9PSByb290KSB7XG5cdFx0XHRcdFx0aWYgKHBhcmVudE5vZGVbY2hpbGRLZXldLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdFx0XHQvL25vZGUgd2FzIHJvb3QsIGFuZCB6dHJlZSBoYXMgb25seSBvbmUgcm9vdCBhZnRlciBtb3ZlIG5vZGVcblx0XHRcdFx0XHRcdHZpZXcucmVwbGFjZVN3aXRjaENsYXNzKG5ld0xhc3QsIHRtcF9zd2l0Y2hPYmosIGNvbnN0cy5saW5lLlJPT1QpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgdG1wX2ZpcnN0X3N3aXRjaE9iaiA9ICQkKHBhcmVudE5vZGVbY2hpbGRLZXldWzBdLCBjb25zdHMuaWQuU1dJVENILCBzZXR0aW5nKTtcblx0XHRcdFx0XHRcdHZpZXcucmVwbGFjZVN3aXRjaENsYXNzKHBhcmVudE5vZGVbY2hpbGRLZXldWzBdLCB0bXBfZmlyc3Rfc3dpdGNoT2JqLCBjb25zdHMubGluZS5ST09UUyk7XG5cdFx0XHRcdFx0XHR2aWV3LnJlcGxhY2VTd2l0Y2hDbGFzcyhuZXdMYXN0LCB0bXBfc3dpdGNoT2JqLCBjb25zdHMubGluZS5CT1RUT00pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2aWV3LnJlcGxhY2VTd2l0Y2hDbGFzcyhuZXdMYXN0LCB0bXBfc3dpdGNoT2JqLCBjb25zdHMubGluZS5CT1RUT00pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRtcF91bE9iai5yZW1vdmVDbGFzcyhjb25zdHMubGluZS5MSU5FKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcGxhY2VJY29DbGFzczogZnVuY3Rpb24obm9kZSwgb2JqLCBuZXdOYW1lKSB7XG5cdFx0XHRpZiAoIW9iaiB8fCBub2RlLmlzQWpheGluZykgcmV0dXJuO1xuXHRcdFx0dmFyIHRtcE5hbWUgPSBvYmouYXR0cihcImNsYXNzXCIpO1xuXHRcdFx0aWYgKHRtcE5hbWUgPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFx0XHR2YXIgdG1wTGlzdCA9IHRtcE5hbWUuc3BsaXQoXCJfXCIpO1xuXHRcdFx0c3dpdGNoIChuZXdOYW1lKSB7XG5cdFx0XHRcdGNhc2UgY29uc3RzLmZvbGRlci5PUEVOOlxuXHRcdFx0XHRjYXNlIGNvbnN0cy5mb2xkZXIuQ0xPU0U6XG5cdFx0XHRcdGNhc2UgY29uc3RzLmZvbGRlci5ET0NVOlxuXHRcdFx0XHRcdHRtcExpc3RbdG1wTGlzdC5sZW5ndGgtMV0gPSBuZXdOYW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0b2JqLmF0dHIoXCJjbGFzc1wiLCB0bXBMaXN0LmpvaW4oXCJfXCIpKTtcblx0XHR9LFxuXHRcdHJlcGxhY2VTd2l0Y2hDbGFzczogZnVuY3Rpb24obm9kZSwgb2JqLCBuZXdOYW1lKSB7XG5cdFx0XHRpZiAoIW9iaikgcmV0dXJuO1xuXHRcdFx0dmFyIHRtcE5hbWUgPSBvYmouYXR0cihcImNsYXNzXCIpO1xuXHRcdFx0aWYgKHRtcE5hbWUgPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFx0XHR2YXIgdG1wTGlzdCA9IHRtcE5hbWUuc3BsaXQoXCJfXCIpO1xuXHRcdFx0c3dpdGNoIChuZXdOYW1lKSB7XG5cdFx0XHRcdGNhc2UgY29uc3RzLmxpbmUuUk9PVDpcblx0XHRcdFx0Y2FzZSBjb25zdHMubGluZS5ST09UUzpcblx0XHRcdFx0Y2FzZSBjb25zdHMubGluZS5DRU5URVI6XG5cdFx0XHRcdGNhc2UgY29uc3RzLmxpbmUuQk9UVE9NOlxuXHRcdFx0XHRjYXNlIGNvbnN0cy5saW5lLk5PTElORTpcblx0XHRcdFx0XHR0bXBMaXN0WzBdID0gdmlldy5tYWtlTm9kZUxpbmVDbGFzc0V4KG5vZGUpICsgbmV3TmFtZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBjb25zdHMuZm9sZGVyLk9QRU46XG5cdFx0XHRcdGNhc2UgY29uc3RzLmZvbGRlci5DTE9TRTpcblx0XHRcdFx0Y2FzZSBjb25zdHMuZm9sZGVyLkRPQ1U6XG5cdFx0XHRcdFx0dG1wTGlzdFsxXSA9IG5ld05hbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRvYmouYXR0cihcImNsYXNzXCIsIHRtcExpc3Quam9pbihcIl9cIikpO1xuXHRcdFx0aWYgKG5ld05hbWUgIT09IGNvbnN0cy5mb2xkZXIuRE9DVSkge1xuXHRcdFx0XHRvYmoucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JqLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0Tm9kZTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSwgYWRkRmxhZykge1xuXHRcdFx0aWYgKCFhZGRGbGFnKSB7XG5cdFx0XHRcdHZpZXcuY2FuY2VsUHJlU2VsZWN0ZWROb2RlKHNldHRpbmcpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRTZWxlY3RBID0gJCQobm9kZSwgY29uc3RzLmlkLkEsIHNldHRpbmcpO1xuXHRcdFx0Y3VycmVudFNlbGVjdEEuYWRkQ2xhc3MoY29uc3RzLm5vZGUuQ1VSU0VMRUNURUQpO1xuXHRcdFx0aWYoY3VycmVudFNlbGVjdEEucHJldihcInNwYW5cIikuaGFzQ2xhc3MoXCJjZW50ZXJfY2xvc2VcIikpe1xuXHRcdFx0XHQkKFwiLlwiK2NvbnN0cy5ub2RlLlNFTEVDVExJKS5yZW1vdmVDbGFzcyhjb25zdHMubm9kZS5TRUxFQ1RMSSk7XG5cdFx0XHRcdGN1cnJlbnRTZWxlY3RBLnBhcmVudCgpLmFkZENsYXNzKGNvbnN0cy5ub2RlLlNFTEVDVExJKTtcblx0XHRcdH1cblx0XHRcdGRhdGEuYWRkU2VsZWN0ZWROb2RlKHNldHRpbmcsIG5vZGUpO1xuXHRcdH0sXG5cdFx0c2V0Tm9kZUZvbnRDc3M6IGZ1bmN0aW9uKHNldHRpbmcsIHRyZWVOb2RlKSB7XG5cdFx0XHR2YXIgYU9iaiA9ICQkKHRyZWVOb2RlLCBjb25zdHMuaWQuQSwgc2V0dGluZyksXG5cdFx0XHRmb250Q3NzID0gdmlldy5tYWtlTm9kZUZvbnRDc3Moc2V0dGluZywgdHJlZU5vZGUpO1xuXHRcdFx0aWYgKGZvbnRDc3MpIHtcblx0XHRcdFx0YU9iai5jc3MoZm9udENzcyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZXROb2RlTGluZUljb3M6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdGlmICghbm9kZSkgcmV0dXJuO1xuXHRcdFx0dmFyIHN3aXRjaE9iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5TV0lUQ0gsIHNldHRpbmcpLFxuXHRcdFx0dWxPYmogPSAkJChub2RlLCBjb25zdHMuaWQuVUwsIHNldHRpbmcpLFxuXHRcdFx0aWNvT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLklDT04sIHNldHRpbmcpLFxuXHRcdFx0dWxMaW5lID0gdmlldy5tYWtlVWxMaW5lQ2xhc3Moc2V0dGluZywgbm9kZSk7XG5cdFx0XHRpZiAodWxMaW5lLmxlbmd0aD09MCkge1xuXHRcdFx0XHR1bE9iai5yZW1vdmVDbGFzcyhjb25zdHMubGluZS5MSU5FKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVsT2JqLmFkZENsYXNzKHVsTGluZSk7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2hPYmouYXR0cihcImNsYXNzXCIsIHZpZXcubWFrZU5vZGVMaW5lQ2xhc3Moc2V0dGluZywgbm9kZSkpO1xuXHRcdFx0aWYgKG5vZGUuaXNQYXJlbnQpIHtcblx0XHRcdFx0c3dpdGNoT2JqLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaE9iai5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcblx0XHRcdH1cblx0XHRcdGljb09iai5yZW1vdmVBdHRyKFwic3R5bGVcIik7XG5cdFx0XHRpY29PYmouYXR0cihcInN0eWxlXCIsIHZpZXcubWFrZU5vZGVJY29TdHlsZShzZXR0aW5nLCBub2RlKSk7XG5cdFx0XHRpY29PYmouYXR0cihcImNsYXNzXCIsIHZpZXcubWFrZU5vZGVJY29DbGFzcyhzZXR0aW5nLCBub2RlKSk7XG5cdFx0fSxcblx0XHRzZXROb2RlTmFtZTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0dmFyIHRpdGxlID0gZGF0YS5nZXROb2RlVGl0bGUoc2V0dGluZywgbm9kZSksXG5cdFx0XHRuT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLlNQQU4sIHNldHRpbmcpO1xuXHRcdFx0bk9iai5lbXB0eSgpO1xuXHRcdFx0aWYgKHNldHRpbmcudmlldy5uYW1lSXNIVE1MKSB7XG5cdFx0XHRcdG5PYmouaHRtbChkYXRhLmdldE5vZGVOYW1lKHNldHRpbmcsIG5vZGUpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5PYmoudGV4dChkYXRhLmdldE5vZGVOYW1lKHNldHRpbmcsIG5vZGUpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0b29scy5hcHBseShzZXR0aW5nLnZpZXcuc2hvd1RpdGxlLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCBzZXR0aW5nLnZpZXcuc2hvd1RpdGxlKSkge1xuXHRcdFx0XHR2YXIgYU9iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5BLCBzZXR0aW5nKTtcblx0XHRcdFx0YU9iai5hdHRyKFwidGl0bGVcIiwgIXRpdGxlID8gXCJcIiA6IHRpdGxlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNldE5vZGVUYXJnZXQ6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdHZhciBhT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLkEsIHNldHRpbmcpO1xuXHRcdFx0YU9iai5hdHRyKFwidGFyZ2V0XCIsIHZpZXcubWFrZU5vZGVUYXJnZXQobm9kZSkpO1xuXHRcdH0sXG5cdFx0c2V0Tm9kZVVybDogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0dmFyIGFPYmogPSAkJChub2RlLCBjb25zdHMuaWQuQSwgc2V0dGluZyksXG5cdFx0XHR1cmwgPSB2aWV3Lm1ha2VOb2RlVXJsKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0aWYgKHVybCA9PSBudWxsIHx8IHVybC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRhT2JqLnJlbW92ZUF0dHIoXCJocmVmXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YU9iai5hdHRyKFwiaHJlZlwiLCB1cmwpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3dpdGNoTm9kZTogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0aWYgKG5vZGUub3BlbiB8fCAhdG9vbHMuY2FuQXN5bmMoc2V0dGluZywgbm9kZSkpIHtcblx0XHRcdFx0dmlldy5leHBhbmRDb2xsYXBzZU5vZGUoc2V0dGluZywgbm9kZSwgIW5vZGUub3Blbik7XG5cdFx0XHR9IGVsc2UgaWYgKHNldHRpbmcuYXN5bmMuZW5hYmxlKSB7XG5cdFx0XHRcdGlmICghdmlldy5hc3luY05vZGUoc2V0dGluZywgbm9kZSkpIHtcblx0XHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlTm9kZShzZXR0aW5nLCBub2RlLCAhbm9kZS5vcGVuKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobm9kZSkge1xuXHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlTm9kZShzZXR0aW5nLCBub2RlLCAhbm9kZS5vcGVuKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdC8vIHpUcmVlIGRlZmluZFxuXHQkLmZuLnpUcmVlID0ge1xuXHRcdGNvbnN0cyA6IF9jb25zdHMsXG5cdFx0X3ogOiB7XG5cdFx0XHR0b29sczogdG9vbHMsXG5cdFx0XHR2aWV3OiB2aWV3LFxuXHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0ZGF0YTogZGF0YVxuXHRcdH0sXG5cdFx0Z2V0WlRyZWVPYmo6IGZ1bmN0aW9uKHRyZWVJZCkge1xuXHRcdFx0dmFyIG8gPSBkYXRhLmdldFpUcmVlVG9vbHModHJlZUlkKTtcblx0XHRcdHJldHVybiBvID8gbyA6IG51bGw7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbih0cmVlSWQpIHtcblx0XHRcdGlmICghIXRyZWVJZCAmJiB0cmVlSWQubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2aWV3LmRlc3Ryb3koZGF0YS5nZXRTZXR0aW5nKHRyZWVJZCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yKHZhciBzIGluIHNldHRpbmdzKSB7XG5cdFx0XHRcdFx0dmlldy5kZXN0cm95KHNldHRpbmdzW3NdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24ob2JqLCB6U2V0dGluZywgek5vZGVzKSB7XG5cdFx0XHR2YXIgc2V0dGluZyA9IHRvb2xzLmNsb25lKF9zZXR0aW5nKTtcblx0XHRcdCQuZXh0ZW5kKHRydWUsIHNldHRpbmcsIHpTZXR0aW5nKTtcblx0XHRcdHNldHRpbmcudHJlZUlkID0gb2JqLmF0dHIoXCJpZFwiKTtcblx0XHRcdHNldHRpbmcudHJlZU9iaiA9IG9iajtcblx0XHRcdHNldHRpbmcudHJlZU9iai5lbXB0eSgpO1xuXHRcdFx0c2V0dGluZ3Nbc2V0dGluZy50cmVlSWRdID0gc2V0dGluZztcblx0XHRcdC8vRm9yIHNvbWUgb2xkZXIgYnJvd3NlciwoZS5nLiwgaWU2KVxuXHRcdFx0aWYodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGUubWF4SGVpZ2h0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdHNldHRpbmcudmlldy5leHBhbmRTcGVlZCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0XHRkYXRhLmluaXRSb290KHNldHRpbmcpO1xuXHRcdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyksXG5cdFx0XHRjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW47XG5cdFx0XHR6Tm9kZXMgPSB6Tm9kZXMgPyB0b29scy5jbG9uZSh0b29scy5pc0FycmF5KHpOb2Rlcyk/IHpOb2RlcyA6IFt6Tm9kZXNdKSA6IFtdO1xuXHRcdFx0aWYgKHNldHRpbmcuZGF0YS5zaW1wbGVEYXRhLmVuYWJsZSkge1xuXHRcdFx0XHRyb290W2NoaWxkS2V5XSA9IGRhdGEudHJhbnNmb3JtVG96VHJlZUZvcm1hdChzZXR0aW5nLCB6Tm9kZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cm9vdFtjaGlsZEtleV0gPSB6Tm9kZXM7XG5cdFx0XHR9XG5cblx0XHRcdGRhdGEuaW5pdENhY2hlKHNldHRpbmcpO1xuXHRcdFx0ZXZlbnQudW5iaW5kVHJlZShzZXR0aW5nKTtcblx0XHRcdGV2ZW50LmJpbmRUcmVlKHNldHRpbmcpO1xuXHRcdFx0ZXZlbnQudW5iaW5kRXZlbnQoc2V0dGluZyk7XG5cdFx0XHRldmVudC5iaW5kRXZlbnQoc2V0dGluZyk7XG5cblx0XHRcdHZhciB6VHJlZVRvb2xzID0ge1xuXHRcdFx0XHRzZXR0aW5nIDogc2V0dGluZyxcblx0XHRcdFx0YWRkTm9kZXMgOiBmdW5jdGlvbihwYXJlbnROb2RlLCBuZXdOb2RlcywgaXNTaWxlbnQpIHtcblx0XHRcdFx0XHRpZiAoIW5ld05vZGVzKSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRpZiAoIXBhcmVudE5vZGUpIHBhcmVudE5vZGUgPSBudWxsO1xuXHRcdFx0XHRcdGlmIChwYXJlbnROb2RlICYmICFwYXJlbnROb2RlLmlzUGFyZW50ICYmIHNldHRpbmcuZGF0YS5rZWVwLmxlYWYpIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdHZhciB4TmV3Tm9kZXMgPSB0b29scy5jbG9uZSh0b29scy5pc0FycmF5KG5ld05vZGVzKT8gbmV3Tm9kZXM6IFtuZXdOb2Rlc10pO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIGFkZENhbGxiYWNrKCkge1xuXHRcdFx0XHRcdFx0dmlldy5hZGROb2RlcyhzZXR0aW5nLCBwYXJlbnROb2RlLCB4TmV3Tm9kZXMsIChpc1NpbGVudD09dHJ1ZSkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0b29scy5jYW5Bc3luYyhzZXR0aW5nLCBwYXJlbnROb2RlKSkge1xuXHRcdFx0XHRcdFx0dmlldy5hc3luY05vZGUoc2V0dGluZywgcGFyZW50Tm9kZSwgaXNTaWxlbnQsIGFkZENhbGxiYWNrKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWRkQ2FsbGJhY2soKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHhOZXdOb2Rlcztcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2FuY2VsU2VsZWN0ZWROb2RlIDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRcdHZpZXcuY2FuY2VsUHJlU2VsZWN0ZWROb2RlKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRkZXN0cm95IDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmlldy5kZXN0cm95KHNldHRpbmcpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRleHBhbmRBbGwgOiBmdW5jdGlvbihleHBhbmRGbGFnKSB7XG5cdFx0XHRcdFx0ZXhwYW5kRmxhZyA9ICEhZXhwYW5kRmxhZztcblx0XHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlU29uTm9kZShzZXR0aW5nLCBudWxsLCBleHBhbmRGbGFnLCB0cnVlKTtcblx0XHRcdFx0XHRyZXR1cm4gZXhwYW5kRmxhZztcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXhwYW5kTm9kZSA6IGZ1bmN0aW9uKG5vZGUsIGV4cGFuZEZsYWcsIHNvblNpZ24sIGZvY3VzLCBjYWxsYmFja0ZsYWcpIHtcblx0XHRcdFx0XHRpZiAoIW5vZGUgfHwgIW5vZGUuaXNQYXJlbnQpIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdGlmIChleHBhbmRGbGFnICE9PSB0cnVlICYmIGV4cGFuZEZsYWcgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRleHBhbmRGbGFnID0gIW5vZGUub3Blbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsbGJhY2tGbGFnID0gISFjYWxsYmFja0ZsYWc7XG5cblx0XHRcdFx0XHRpZiAoY2FsbGJhY2tGbGFnICYmIGV4cGFuZEZsYWcgJiYgKHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2suYmVmb3JlRXhwYW5kLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2FsbGJhY2tGbGFnICYmICFleHBhbmRGbGFnICYmICh0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZUNvbGxhcHNlLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZXhwYW5kRmxhZyAmJiBub2RlLnBhcmVudFRJZCkge1xuXHRcdFx0XHRcdFx0dmlldy5leHBhbmRDb2xsYXBzZVBhcmVudE5vZGUoc2V0dGluZywgbm9kZS5nZXRQYXJlbnROb2RlKCksIGV4cGFuZEZsYWcsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGV4cGFuZEZsYWcgPT09IG5vZGUub3BlbiAmJiAhc29uU2lnbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGF0YS5nZXRSb290KHNldHRpbmcpLmV4cGFuZFRyaWdnZXJGbGFnID0gY2FsbGJhY2tGbGFnO1xuXHRcdFx0XHRcdGlmICghdG9vbHMuY2FuQXN5bmMoc2V0dGluZywgbm9kZSkgJiYgc29uU2lnbikge1xuXHRcdFx0XHRcdFx0dmlldy5leHBhbmRDb2xsYXBzZVNvbk5vZGUoc2V0dGluZywgbm9kZSwgZXhwYW5kRmxhZywgdHJ1ZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChmb2N1cyAhPT0gZmFsc2UpIHt0cnl7JCQobm9kZSwgc2V0dGluZykuZm9jdXMoKS5ibHVyKCk7fWNhdGNoKGUpe319XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS5vcGVuID0gIWV4cGFuZEZsYWc7XG5cdFx0XHRcdFx0XHR2aWV3LnN3aXRjaE5vZGUodGhpcy5zZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0XHRcdGlmIChmb2N1cyAhPT0gZmFsc2UpIHt0cnl7JCQobm9kZSwgc2V0dGluZykuZm9jdXMoKS5ibHVyKCk7fWNhdGNoKGUpe319XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBleHBhbmRGbGFnO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXROb2RlcyA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmdldE5vZGVzKHNldHRpbmcpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXROb2RlQnlQYXJhbSA6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIHBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRpZiAoIWtleSkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEuZ2V0Tm9kZUJ5UGFyYW0oc2V0dGluZywgcGFyZW50Tm9kZT9wYXJlbnROb2RlW3NldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW5dOmRhdGEuZ2V0Tm9kZXMoc2V0dGluZyksIGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXROb2RlQnlUSWQgOiBmdW5jdGlvbih0SWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5nZXROb2RlQ2FjaGUoc2V0dGluZywgdElkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0Tm9kZXNCeVBhcmFtIDogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgcGFyZW50Tm9kZSkge1xuXHRcdFx0XHRcdGlmICgha2V5KSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5nZXROb2Rlc0J5UGFyYW0oc2V0dGluZywgcGFyZW50Tm9kZT9wYXJlbnROb2RlW3NldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW5dOmRhdGEuZ2V0Tm9kZXMoc2V0dGluZyksIGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXROb2Rlc0J5UGFyYW1GdXp6eSA6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIHBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRpZiAoIWtleSkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEuZ2V0Tm9kZXNCeVBhcmFtRnV6enkoc2V0dGluZywgcGFyZW50Tm9kZT9wYXJlbnROb2RlW3NldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW5dOmRhdGEuZ2V0Tm9kZXMoc2V0dGluZyksIGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXROb2Rlc0J5RmlsdGVyOiBmdW5jdGlvbihmaWx0ZXIsIGlzU2luZ2xlLCBwYXJlbnROb2RlLCBpbnZva2VQYXJhbSkge1xuXHRcdFx0XHRcdGlzU2luZ2xlID0gISFpc1NpbmdsZTtcblx0XHRcdFx0XHRpZiAoIWZpbHRlciB8fCAodHlwZW9mIGZpbHRlciAhPSBcImZ1bmN0aW9uXCIpKSByZXR1cm4gKGlzU2luZ2xlID8gbnVsbCA6IFtdKTtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5nZXROb2Rlc0J5RmlsdGVyKHNldHRpbmcsIHBhcmVudE5vZGU/cGFyZW50Tm9kZVtzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuXTpkYXRhLmdldE5vZGVzKHNldHRpbmcpLCBmaWx0ZXIsIGlzU2luZ2xlLCBpbnZva2VQYXJhbSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldE5vZGVJbmRleCA6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRcdFx0cGFyZW50Tm9kZSA9IChub2RlLnBhcmVudFRJZCkgPyBub2RlLmdldFBhcmVudE5vZGUoKSA6IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpPTAsIGwgPSBwYXJlbnROb2RlW2NoaWxkS2V5XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChwYXJlbnROb2RlW2NoaWxkS2V5XVtpXSA9PSBub2RlKSByZXR1cm4gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRTZWxlY3RlZE5vZGVzIDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHIgPSBbXSwgbGlzdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKS5jdXJTZWxlY3RlZExpc3Q7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wLCBsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHRcdFx0ci5wdXNoKGxpc3RbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcjtcblx0XHRcdFx0fSxcblx0XHRcdFx0aXNTZWxlY3RlZE5vZGUgOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEuaXNTZWxlY3RlZE5vZGUoc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlQXN5bmNDaGlsZE5vZGVzIDogZnVuY3Rpb24ocGFyZW50Tm9kZSwgcmVsb2FkVHlwZSwgaXNTaWxlbnQpIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuc2V0dGluZy5hc3luYy5lbmFibGUpIHJldHVybjtcblx0XHRcdFx0XHR2YXIgaXNSb290ID0gIXBhcmVudE5vZGU7XG5cdFx0XHRcdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHJlbG9hZFR5cGU9PVwicmVmcmVzaFwiKSB7XG5cdFx0XHRcdFx0XHR2YXIgY2hpbGRLZXkgPSB0aGlzLnNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcmVudE5vZGVbY2hpbGRLZXldID8gcGFyZW50Tm9kZVtjaGlsZEtleV0ubGVuZ3RoIDogMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRkYXRhLnJlbW92ZU5vZGVDYWNoZShzZXR0aW5nLCBwYXJlbnROb2RlW2NoaWxkS2V5XVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkYXRhLnJlbW92ZVNlbGVjdGVkTm9kZShzZXR0aW5nKTtcblx0XHRcdFx0XHRcdHBhcmVudE5vZGVbY2hpbGRLZXldID0gW107XG5cdFx0XHRcdFx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZy50cmVlT2JqLmVtcHR5KCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgdWxPYmogPSAkJChwYXJlbnROb2RlLCBjb25zdHMuaWQuVUwsIHNldHRpbmcpO1xuXHRcdFx0XHRcdFx0XHR1bE9iai5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2aWV3LmFzeW5jTm9kZSh0aGlzLnNldHRpbmcsIGlzUm9vdD8gbnVsbDpwYXJlbnROb2RlLCAhIWlzU2lsZW50KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVmcmVzaCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZy50cmVlT2JqLmVtcHR5KCk7XG5cdFx0XHRcdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyksXG5cdFx0XHRcdFx0bm9kZXMgPSByb290W3NldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW5dXG5cdFx0XHRcdFx0ZGF0YS5pbml0Um9vdChzZXR0aW5nKTtcblx0XHRcdFx0XHRyb290W3NldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW5dID0gbm9kZXNcblx0XHRcdFx0XHRkYXRhLmluaXRDYWNoZShzZXR0aW5nKTtcblx0XHRcdFx0XHR2aWV3LmNyZWF0ZU5vZGVzKHNldHRpbmcsIDAsIHJvb3Rbc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbl0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDaGlsZE5vZGVzIDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRcdGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0dmFyIGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbixcblx0XHRcdFx0XHRub2RlcyA9IG5vZGVbY2hpbGRLZXldO1xuXHRcdFx0XHRcdHZpZXcucmVtb3ZlQ2hpbGROb2RlcyhzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZXMgPyBub2RlcyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZU5vZGUgOiBmdW5jdGlvbihub2RlLCBjYWxsYmFja0ZsYWcpIHtcblx0XHRcdFx0XHRpZiAoIW5vZGUpIHJldHVybjtcblx0XHRcdFx0XHRjYWxsYmFja0ZsYWcgPSAhIWNhbGxiYWNrRmxhZztcblx0XHRcdFx0XHRpZiAoY2FsbGJhY2tGbGFnICYmIHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2suYmVmb3JlUmVtb3ZlLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0XHRcdHZpZXcucmVtb3ZlTm9kZShzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0XHRpZiAoY2FsbGJhY2tGbGFnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldHRpbmcudHJlZU9iai50cmlnZ2VyKGNvbnN0cy5ldmVudC5SRU1PVkUsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0Tm9kZSA6IGZ1bmN0aW9uKG5vZGUsIGFkZEZsYWcpIHtcblx0XHRcdFx0XHRpZiAoIW5vZGUpIHJldHVybjtcblx0XHRcdFx0XHRpZiAodG9vbHMudUNhbkRvKHNldHRpbmcpKSB7XG5cdFx0XHRcdFx0XHRhZGRGbGFnID0gc2V0dGluZy52aWV3LnNlbGVjdGVkTXVsdGkgJiYgYWRkRmxhZztcblx0XHRcdFx0XHRcdGlmIChub2RlLnBhcmVudFRJZCkge1xuXHRcdFx0XHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlUGFyZW50Tm9kZShzZXR0aW5nLCBub2RlLmdldFBhcmVudE5vZGUoKSwgdHJ1ZSwgZmFsc2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHRyeXskJChub2RlLCBzZXR0aW5nKS5mb2N1cygpLmJsdXIoKTt9Y2F0Y2goZSl7fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRyeXskJChub2RlLCBzZXR0aW5nKS5mb2N1cygpLmJsdXIoKTt9Y2F0Y2goZSl7fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmlldy5zZWxlY3ROb2RlKHNldHRpbmcsIG5vZGUsIGFkZEZsYWcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0dHJhbnNmb3JtVG96VHJlZU5vZGVzIDogZnVuY3Rpb24oc2ltcGxlTm9kZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS50cmFuc2Zvcm1Ub3pUcmVlRm9ybWF0KHNldHRpbmcsIHNpbXBsZU5vZGVzKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dHJhbnNmb3JtVG9BcnJheSA6IGZ1bmN0aW9uKG5vZGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEudHJhbnNmb3JtVG9BcnJheUZvcm1hdChzZXR0aW5nLCBub2Rlcyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVwZGF0ZU5vZGUgOiBmdW5jdGlvbihub2RlLCBjaGVja1R5cGVGbGFnKSB7XG5cdFx0XHRcdFx0aWYgKCFub2RlKSByZXR1cm47XG5cdFx0XHRcdFx0dmFyIG5PYmogPSAkJChub2RlLCBzZXR0aW5nKTtcblx0XHRcdFx0XHRpZiAobk9iai5nZXQoMCkgJiYgdG9vbHMudUNhbkRvKHNldHRpbmcpKSB7XG5cdFx0XHRcdFx0XHR2aWV3LnNldE5vZGVOYW1lKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRcdFx0dmlldy5zZXROb2RlVGFyZ2V0KHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRcdFx0dmlldy5zZXROb2RlVXJsKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRcdFx0dmlldy5zZXROb2RlTGluZUljb3Moc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdFx0XHR2aWV3LnNldE5vZGVGb250Q3NzKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cm9vdC50cmVlVG9vbHMgPSB6VHJlZVRvb2xzO1xuXHRcdFx0ZGF0YS5zZXRaVHJlZVRvb2xzKHNldHRpbmcsIHpUcmVlVG9vbHMpO1xuXG5cdFx0XHRpZiAocm9vdFtjaGlsZEtleV0gJiYgcm9vdFtjaGlsZEtleV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2aWV3LmNyZWF0ZU5vZGVzKHNldHRpbmcsIDAsIHJvb3RbY2hpbGRLZXldKTtcblx0XHRcdH0gZWxzZSBpZiAoc2V0dGluZy5hc3luYy5lbmFibGUgJiYgc2V0dGluZy5hc3luYy51cmwgJiYgc2V0dGluZy5hc3luYy51cmwgIT09ICcnKSB7XG5cdFx0XHRcdHZpZXcuYXN5bmNOb2RlKHNldHRpbmcpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHpUcmVlVG9vbHM7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciB6dCA9ICQuZm4uelRyZWUsXG5cdCQkID0gdG9vbHMuJCxcblx0Y29uc3RzID0genQuY29uc3RzO1xufSkoalF1ZXJ5KTtcbi8qXG4gKiBKUXVlcnkgelRyZWUgZXhjaGVjayB2My41LjE3LWJldGEuMlxuICogaHR0cDovL3pUcmVlLm1lL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCBIdW50ZXIuelxuICpcbiAqIExpY2Vuc2VkIHNhbWUgYXMganF1ZXJ5IC0gTUlUIExpY2Vuc2VcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogZW1haWw6IGh1bnRlci56QDI2My5uZXRcbiAqIERhdGU6IDIwMTQtMDUtMDhcbiAqL1xuKGZ1bmN0aW9uKCQpe1xuXHQvL2RlZmF1bHQgY29uc3RzIG9mIGV4Y2hlY2tcblx0dmFyIF9jb25zdHMgPSB7XG5cdFx0ZXZlbnQ6IHtcblx0XHRcdENIRUNLOiBcInp0cmVlX2NoZWNrXCJcblx0XHR9LFxuXHRcdGlkOiB7XG5cdFx0XHRDSEVDSzogXCJfY2hlY2tcIlxuXHRcdH0sXG5cdFx0Y2hlY2tib3g6IHtcblx0XHRcdFNUWUxFOiBcImNoZWNrYm94XCIsXG5cdFx0XHRERUZBVUxUOiBcImNoa1wiLFxuXHRcdFx0RElTQUJMRUQ6IFwiZGlzYWJsZVwiLFxuXHRcdFx0RkFMU0U6IFwiZmFsc2VcIixcblx0XHRcdFRSVUU6IFwidHJ1ZVwiLFxuXHRcdFx0RlVMTDogXCJmdWxsXCIsXG5cdFx0XHRQQVJUOiBcInBhcnRcIixcblx0XHRcdEZPQ1VTOiBcImZvY3VzXCJcblx0XHR9LFxuXHRcdHJhZGlvOiB7XG5cdFx0XHRTVFlMRTogXCJyYWRpb1wiLFxuXHRcdFx0VFlQRV9BTEw6IFwiYWxsXCIsXG5cdFx0XHRUWVBFX0xFVkVMOiBcImxldmVsXCJcblx0XHR9XG5cdH0sXG5cdC8vZGVmYXVsdCBzZXR0aW5nIG9mIGV4Y2hlY2tcblx0X3NldHRpbmcgPSB7XG5cdFx0Y2hlY2s6IHtcblx0XHRcdGVuYWJsZTogZmFsc2UsXG5cdFx0XHRhdXRvQ2hlY2tUcmlnZ2VyOiBmYWxzZSxcblx0XHRcdGNoa1N0eWxlOiBfY29uc3RzLmNoZWNrYm94LlNUWUxFLFxuXHRcdFx0bm9jaGVja0luaGVyaXQ6IGZhbHNlLFxuXHRcdFx0Y2hrRGlzYWJsZWRJbmhlcml0OiBmYWxzZSxcblx0XHRcdHJhZGlvVHlwZTogX2NvbnN0cy5yYWRpby5UWVBFX0xFVkVMLFxuXHRcdFx0Y2hrYm94VHlwZToge1xuXHRcdFx0XHRcIllcIjogXCJwc1wiLFxuXHRcdFx0XHRcIk5cIjogXCJwc1wiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkYXRhOiB7XG5cdFx0XHRrZXk6IHtcblx0XHRcdFx0Y2hlY2tlZDogXCJjaGVja2VkXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdGNhbGxiYWNrOiB7XG5cdFx0XHRiZWZvcmVDaGVjazpudWxsLFxuXHRcdFx0b25DaGVjazpudWxsXG5cdFx0fVxuXHR9LFxuXHQvL2RlZmF1bHQgcm9vdCBvZiBleGNoZWNrXG5cdF9pbml0Um9vdCA9IGZ1bmN0aW9uIChzZXR0aW5nKSB7XG5cdFx0dmFyIHIgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyk7XG5cdFx0ci5yYWRpb0NoZWNrZWRMaXN0ID0gW107XG5cdH0sXG5cdC8vZGVmYXVsdCBjYWNoZSBvZiBleGNoZWNrXG5cdF9pbml0Q2FjaGUgPSBmdW5jdGlvbih0cmVlSWQpIHt9LFxuXHQvL2RlZmF1bHQgYmluZCBldmVudCBvZiBleGNoZWNrXG5cdF9iaW5kRXZlbnQgPSBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0dmFyIG8gPSBzZXR0aW5nLnRyZWVPYmosXG5cdFx0YyA9IGNvbnN0cy5ldmVudDtcblx0XHRvLmJpbmQoYy5DSEVDSywgZnVuY3Rpb24gKGV2ZW50LCBzcmNFdmVudCwgdHJlZUlkLCBub2RlKSB7XG5cdFx0XHRldmVudC5zcmNFdmVudCA9IHNyY0V2ZW50O1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vbkNoZWNrLCBbZXZlbnQsIHRyZWVJZCwgbm9kZV0pO1xuXHRcdH0pO1xuXHR9LFxuXHRfdW5iaW5kRXZlbnQgPSBmdW5jdGlvbihzZXR0aW5nKSB7XG5cdFx0dmFyIG8gPSBzZXR0aW5nLnRyZWVPYmosXG5cdFx0YyA9IGNvbnN0cy5ldmVudDtcblx0XHRvLnVuYmluZChjLkNIRUNLKTtcblx0fSxcblx0Ly9kZWZhdWx0IGV2ZW50IHByb3h5IG9mIGV4Y2hlY2tcblx0X2V2ZW50UHJveHkgPSBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0LFxuXHRcdHNldHRpbmcgPSBkYXRhLmdldFNldHRpbmcoZS5kYXRhLnRyZWVJZCksXG5cdFx0dElkID0gXCJcIiwgbm9kZSA9IG51bGwsXG5cdFx0bm9kZUV2ZW50VHlwZSA9IFwiXCIsIHRyZWVFdmVudFR5cGUgPSBcIlwiLFxuXHRcdG5vZGVFdmVudENhbGxiYWNrID0gbnVsbCwgdHJlZUV2ZW50Q2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0aWYgKHRvb2xzLmVxcyhlLnR5cGUsIFwibW91c2VvdmVyXCIpKSB7XG5cdFx0XHRpZiAoc2V0dGluZy5jaGVjay5lbmFibGUgJiYgdG9vbHMuZXFzKHRhcmdldC50YWdOYW1lLCBcInNwYW5cIikgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyZWVOb2RlXCIrIGNvbnN0cy5pZC5DSEVDSykgIT09IG51bGwpIHtcblx0XHRcdFx0dElkID0gdG9vbHMuZ2V0Tm9kZU1haW5Eb20odGFyZ2V0KS5pZDtcblx0XHRcdFx0bm9kZUV2ZW50VHlwZSA9IFwibW91c2VvdmVyQ2hlY2tcIjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRvb2xzLmVxcyhlLnR5cGUsIFwibW91c2VvdXRcIikpIHtcblx0XHRcdGlmIChzZXR0aW5nLmNoZWNrLmVuYWJsZSAmJiB0b29scy5lcXModGFyZ2V0LnRhZ05hbWUsIFwic3BhblwiKSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJlZU5vZGVcIisgY29uc3RzLmlkLkNIRUNLKSAhPT0gbnVsbCkge1xuXHRcdFx0XHR0SWQgPSB0b29scy5nZXROb2RlTWFpbkRvbSh0YXJnZXQpLmlkO1xuXHRcdFx0XHRub2RlRXZlbnRUeXBlID0gXCJtb3VzZW91dENoZWNrXCI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0b29scy5lcXMoZS50eXBlLCBcImNsaWNrXCIpKSB7XG5cdFx0XHRpZiAoc2V0dGluZy5jaGVjay5lbmFibGUgJiYgdG9vbHMuZXFzKHRhcmdldC50YWdOYW1lLCBcInNwYW5cIikgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyZWVOb2RlXCIrIGNvbnN0cy5pZC5DSEVDSykgIT09IG51bGwpIHtcblx0XHRcdFx0dElkID0gdG9vbHMuZ2V0Tm9kZU1haW5Eb20odGFyZ2V0KS5pZDtcblx0XHRcdFx0bm9kZUV2ZW50VHlwZSA9IFwiY2hlY2tOb2RlXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0SWQubGVuZ3RoPjApIHtcblx0XHRcdG5vZGUgPSBkYXRhLmdldE5vZGVDYWNoZShzZXR0aW5nLCB0SWQpO1xuXHRcdFx0c3dpdGNoIChub2RlRXZlbnRUeXBlKSB7XG5cdFx0XHRcdGNhc2UgXCJjaGVja05vZGVcIiA6XG5cdFx0XHRcdFx0bm9kZUV2ZW50Q2FsbGJhY2sgPSBfaGFuZGxlci5vbkNoZWNrTm9kZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIm1vdXNlb3ZlckNoZWNrXCIgOlxuXHRcdFx0XHRcdG5vZGVFdmVudENhbGxiYWNrID0gX2hhbmRsZXIub25Nb3VzZW92ZXJDaGVjaztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIm1vdXNlb3V0Q2hlY2tcIiA6XG5cdFx0XHRcdFx0bm9kZUV2ZW50Q2FsbGJhY2sgPSBfaGFuZGxlci5vbk1vdXNlb3V0Q2hlY2s7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBwcm94eVJlc3VsdCA9IHtcblx0XHRcdHN0b3A6IG5vZGVFdmVudFR5cGUgPT09IFwiY2hlY2tOb2RlXCIsXG5cdFx0XHRub2RlOiBub2RlLFxuXHRcdFx0bm9kZUV2ZW50VHlwZTogbm9kZUV2ZW50VHlwZSxcblx0XHRcdG5vZGVFdmVudENhbGxiYWNrOiBub2RlRXZlbnRDYWxsYmFjayxcblx0XHRcdHRyZWVFdmVudFR5cGU6IHRyZWVFdmVudFR5cGUsXG5cdFx0XHR0cmVlRXZlbnRDYWxsYmFjazogdHJlZUV2ZW50Q2FsbGJhY2tcblx0XHR9O1xuXHRcdHJldHVybiBwcm94eVJlc3VsdFxuXHR9LFxuXHQvL2RlZmF1bHQgaW5pdCBub2RlIG9mIGV4Y2hlY2tcblx0X2luaXROb2RlID0gZnVuY3Rpb24oc2V0dGluZywgbGV2ZWwsIG4sIHBhcmVudE5vZGUsIGlzRmlyc3ROb2RlLCBpc0xhc3ROb2RlLCBvcGVuRmxhZykge1xuXHRcdGlmICghbikgcmV0dXJuO1xuXHRcdHZhciBjaGVja2VkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGVja2VkO1xuXHRcdGlmICh0eXBlb2YgbltjaGVja2VkS2V5XSA9PSBcInN0cmluZ1wiKSBuW2NoZWNrZWRLZXldID0gdG9vbHMuZXFzKG5bY2hlY2tlZEtleV0sIFwidHJ1ZVwiKTtcblx0XHRuW2NoZWNrZWRLZXldID0gISFuW2NoZWNrZWRLZXldO1xuXHRcdG4uY2hlY2tlZE9sZCA9IG5bY2hlY2tlZEtleV07XG5cdFx0aWYgKHR5cGVvZiBuLm5vY2hlY2sgPT0gXCJzdHJpbmdcIikgbi5ub2NoZWNrID0gdG9vbHMuZXFzKG4ubm9jaGVjaywgXCJ0cnVlXCIpO1xuXHRcdG4ubm9jaGVjayA9ICEhbi5ub2NoZWNrIHx8IChzZXR0aW5nLmNoZWNrLm5vY2hlY2tJbmhlcml0ICYmIHBhcmVudE5vZGUgJiYgISFwYXJlbnROb2RlLm5vY2hlY2spO1xuXHRcdGlmICh0eXBlb2Ygbi5jaGtEaXNhYmxlZCA9PSBcInN0cmluZ1wiKSBuLmNoa0Rpc2FibGVkID0gdG9vbHMuZXFzKG4uY2hrRGlzYWJsZWQsIFwidHJ1ZVwiKTtcblx0XHRuLmNoa0Rpc2FibGVkID0gISFuLmNoa0Rpc2FibGVkIHx8IChzZXR0aW5nLmNoZWNrLmNoa0Rpc2FibGVkSW5oZXJpdCAmJiBwYXJlbnROb2RlICYmICEhcGFyZW50Tm9kZS5jaGtEaXNhYmxlZCk7XG5cdFx0aWYgKHR5cGVvZiBuLmhhbGZDaGVjayA9PSBcInN0cmluZ1wiKSBuLmhhbGZDaGVjayA9IHRvb2xzLmVxcyhuLmhhbGZDaGVjaywgXCJ0cnVlXCIpO1xuXHRcdG4uaGFsZkNoZWNrID0gISFuLmhhbGZDaGVjaztcblx0XHRuLmNoZWNrX0NoaWxkX1N0YXRlID0gLTE7XG5cdFx0bi5jaGVja19Gb2N1cyA9IGZhbHNlO1xuXHRcdG4uZ2V0Q2hlY2tTdGF0dXMgPSBmdW5jdGlvbigpIHtyZXR1cm4gZGF0YS5nZXRDaGVja1N0YXR1cyhzZXR0aW5nLCBuKTt9O1xuXG5cdFx0aWYgKHNldHRpbmcuY2hlY2suY2hrU3R5bGUgPT0gY29uc3RzLnJhZGlvLlNUWUxFICYmIHNldHRpbmcuY2hlY2sucmFkaW9UeXBlID09IGNvbnN0cy5yYWRpby5UWVBFX0FMTCAmJiBuW2NoZWNrZWRLZXldICkge1xuXHRcdFx0dmFyIHIgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyk7XG5cdFx0XHRyLnJhZGlvQ2hlY2tlZExpc3QucHVzaChuKTtcblx0XHR9XG5cdH0sXG5cdC8vYWRkIGRvbSBmb3IgY2hlY2tcblx0X2JlZm9yZUEgPSBmdW5jdGlvbihzZXR0aW5nLCBub2RlLCBodG1sKSB7XG5cdFx0dmFyIGNoZWNrZWRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoZWNrZWQ7XG5cdFx0aWYgKHNldHRpbmcuY2hlY2suZW5hYmxlKSB7XG5cdFx0XHRkYXRhLm1ha2VDaGtGbGFnKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0aHRtbC5wdXNoKFwiPHNwYW4gSUQ9J1wiLCBub2RlLnRJZCwgY29uc3RzLmlkLkNIRUNLLCBcIicgY2xhc3M9J1wiLCB2aWV3Lm1ha2VDaGtDbGFzcyhzZXR0aW5nLCBub2RlKSwgXCInIHRyZWVOb2RlXCIsIGNvbnN0cy5pZC5DSEVDSywgKG5vZGUubm9jaGVjayA9PT0gdHJ1ZT9cIiBzdHlsZT0nZGlzcGxheTpub25lOydcIjpcIlwiKSxcIj48L3NwYW4+XCIpO1xuXHRcdH1cblx0fSxcblx0Ly91cGRhdGUgelRyZWVPYmosIGFkZCBtZXRob2Qgb2YgY2hlY2tcblx0X3pUcmVlVG9vbHMgPSBmdW5jdGlvbihzZXR0aW5nLCB6VHJlZVRvb2xzKSB7XG5cdFx0elRyZWVUb29scy5jaGVja05vZGUgPSBmdW5jdGlvbihub2RlLCBjaGVja2VkLCBjaGVja1R5cGVGbGFnLCBjYWxsYmFja0ZsYWcpIHtcblx0XHRcdHZhciBjaGVja2VkS2V5ID0gdGhpcy5zZXR0aW5nLmRhdGEua2V5LmNoZWNrZWQ7XG5cdFx0XHRpZiAobm9kZS5jaGtEaXNhYmxlZCA9PT0gdHJ1ZSkgcmV0dXJuO1xuXHRcdFx0aWYgKGNoZWNrZWQgIT09IHRydWUgJiYgY2hlY2tlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Y2hlY2tlZCA9ICFub2RlW2NoZWNrZWRLZXldO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2tGbGFnID0gISFjYWxsYmFja0ZsYWc7XG5cblx0XHRcdGlmIChub2RlW2NoZWNrZWRLZXldID09PSBjaGVja2VkICYmICFjaGVja1R5cGVGbGFnKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoY2FsbGJhY2tGbGFnICYmIHRvb2xzLmFwcGx5KHRoaXMuc2V0dGluZy5jYWxsYmFjay5iZWZvcmVDaGVjaywgW3RoaXMuc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAodG9vbHMudUNhbkRvKHRoaXMuc2V0dGluZykgJiYgdGhpcy5zZXR0aW5nLmNoZWNrLmVuYWJsZSAmJiBub2RlLm5vY2hlY2sgIT09IHRydWUpIHtcblx0XHRcdFx0bm9kZVtjaGVja2VkS2V5XSA9IGNoZWNrZWQ7XG5cdFx0XHRcdHZhciBjaGVja09iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5DSEVDSywgdGhpcy5zZXR0aW5nKTtcblx0XHRcdFx0aWYgKGNoZWNrVHlwZUZsYWcgfHwgdGhpcy5zZXR0aW5nLmNoZWNrLmNoa1N0eWxlID09PSBjb25zdHMucmFkaW8uU1RZTEUpIHZpZXcuY2hlY2tOb2RlUmVsYXRpb24odGhpcy5zZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0dmlldy5zZXRDaGtDbGFzcyh0aGlzLnNldHRpbmcsIGNoZWNrT2JqLCBub2RlKTtcblx0XHRcdFx0dmlldy5yZXBhaXJQYXJlbnRDaGtDbGFzc1dpdGhTZWxmKHRoaXMuc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdGlmIChjYWxsYmFja0ZsYWcpIHtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmcudHJlZU9iai50cmlnZ2VyKGNvbnN0cy5ldmVudC5DSEVDSywgW251bGwsIHRoaXMuc2V0dGluZy50cmVlSWQsIG5vZGVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHpUcmVlVG9vbHMuY2hlY2tBbGxOb2RlcyA9IGZ1bmN0aW9uKGNoZWNrZWQpIHtcblx0XHRcdHZpZXcucmVwYWlyQWxsQ2hrKHRoaXMuc2V0dGluZywgISFjaGVja2VkKTtcblx0XHR9XG5cblx0XHR6VHJlZVRvb2xzLmdldENoZWNrZWROb2RlcyA9IGZ1bmN0aW9uKGNoZWNrZWQpIHtcblx0XHRcdHZhciBjaGlsZEtleSA9IHRoaXMuc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbjtcblx0XHRcdGNoZWNrZWQgPSAoY2hlY2tlZCAhPT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIGRhdGEuZ2V0VHJlZUNoZWNrZWROb2Rlcyh0aGlzLnNldHRpbmcsIGRhdGEuZ2V0Um9vdCh0aGlzLnNldHRpbmcpW2NoaWxkS2V5XSwgY2hlY2tlZCk7XG5cdFx0fVxuXG5cdFx0elRyZWVUb29scy5nZXRDaGFuZ2VDaGVja2VkTm9kZXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjaGlsZEtleSA9IHRoaXMuc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbjtcblx0XHRcdHJldHVybiBkYXRhLmdldFRyZWVDaGFuZ2VDaGVja2VkTm9kZXModGhpcy5zZXR0aW5nLCBkYXRhLmdldFJvb3QodGhpcy5zZXR0aW5nKVtjaGlsZEtleV0pO1xuXHRcdH1cblxuXHRcdHpUcmVlVG9vbHMuc2V0Q2hrRGlzYWJsZWQgPSBmdW5jdGlvbihub2RlLCBkaXNhYmxlZCwgaW5oZXJpdFBhcmVudCwgaW5oZXJpdENoaWxkcmVuKSB7XG5cdFx0XHRkaXNhYmxlZCA9ICEhZGlzYWJsZWQ7XG5cdFx0XHRpbmhlcml0UGFyZW50ID0gISFpbmhlcml0UGFyZW50O1xuXHRcdFx0aW5oZXJpdENoaWxkcmVuID0gISFpbmhlcml0Q2hpbGRyZW47XG5cdFx0XHR2aWV3LnJlcGFpclNvbkNoa0Rpc2FibGVkKHRoaXMuc2V0dGluZywgbm9kZSwgZGlzYWJsZWQsIGluaGVyaXRDaGlsZHJlbik7XG5cdFx0XHR2aWV3LnJlcGFpclBhcmVudENoa0Rpc2FibGVkKHRoaXMuc2V0dGluZywgbm9kZS5nZXRQYXJlbnROb2RlKCksIGRpc2FibGVkLCBpbmhlcml0UGFyZW50KTtcblx0XHR9XG5cblx0XHR2YXIgX3VwZGF0ZU5vZGUgPSB6VHJlZVRvb2xzLnVwZGF0ZU5vZGU7XG5cdFx0elRyZWVUb29scy51cGRhdGVOb2RlID0gZnVuY3Rpb24obm9kZSwgY2hlY2tUeXBlRmxhZykge1xuXHRcdFx0aWYgKF91cGRhdGVOb2RlKSBfdXBkYXRlTm9kZS5hcHBseSh6VHJlZVRvb2xzLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYgKCFub2RlIHx8ICF0aGlzLnNldHRpbmcuY2hlY2suZW5hYmxlKSByZXR1cm47XG5cdFx0XHR2YXIgbk9iaiA9ICQkKG5vZGUsIHRoaXMuc2V0dGluZyk7XG5cdFx0XHRpZiAobk9iai5nZXQoMCkgJiYgdG9vbHMudUNhbkRvKHRoaXMuc2V0dGluZykpIHtcblx0XHRcdFx0dmFyIGNoZWNrT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLkNIRUNLLCB0aGlzLnNldHRpbmcpO1xuXHRcdFx0XHRpZiAoY2hlY2tUeXBlRmxhZyA9PSB0cnVlIHx8IHRoaXMuc2V0dGluZy5jaGVjay5jaGtTdHlsZSA9PT0gY29uc3RzLnJhZGlvLlNUWUxFKSB2aWV3LmNoZWNrTm9kZVJlbGF0aW9uKHRoaXMuc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdHZpZXcuc2V0Q2hrQ2xhc3ModGhpcy5zZXR0aW5nLCBjaGVja09iaiwgbm9kZSk7XG5cdFx0XHRcdHZpZXcucmVwYWlyUGFyZW50Q2hrQ2xhc3NXaXRoU2VsZih0aGlzLnNldHRpbmcsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0Ly9tZXRob2Qgb2Ygb3BlcmF0ZSBkYXRhXG5cdF9kYXRhID0ge1xuXHRcdGdldFJhZGlvQ2hlY2tlZExpc3Q6IGZ1bmN0aW9uKHNldHRpbmcpIHtcblx0XHRcdHZhciBjaGVja2VkTGlzdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKS5yYWRpb0NoZWNrZWRMaXN0O1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBqPWNoZWNrZWRMaXN0Lmxlbmd0aDsgaTxqOyBpKyspIHtcblx0XHRcdFx0aWYoIWRhdGEuZ2V0Tm9kZUNhY2hlKHNldHRpbmcsIGNoZWNrZWRMaXN0W2ldLnRJZCkpIHtcblx0XHRcdFx0XHRjaGVja2VkTGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0aS0tOyBqLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGVja2VkTGlzdDtcblx0XHR9LFxuXHRcdGdldENoZWNrU3RhdHVzOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHRpZiAoIXNldHRpbmcuY2hlY2suZW5hYmxlIHx8IG5vZGUubm9jaGVjayB8fCBub2RlLmNoa0Rpc2FibGVkKSByZXR1cm4gbnVsbDtcblx0XHRcdHZhciBjaGVja2VkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGVja2VkLFxuXHRcdFx0ciA9IHtcblx0XHRcdFx0Y2hlY2tlZDogbm9kZVtjaGVja2VkS2V5XSxcblx0XHRcdFx0aGFsZjogbm9kZS5oYWxmQ2hlY2sgPyBub2RlLmhhbGZDaGVjayA6IChzZXR0aW5nLmNoZWNrLmNoa1N0eWxlID09IGNvbnN0cy5yYWRpby5TVFlMRSA/IChub2RlLmNoZWNrX0NoaWxkX1N0YXRlID09PSAyKSA6IChub2RlW2NoZWNrZWRLZXldID8gKG5vZGUuY2hlY2tfQ2hpbGRfU3RhdGUgPiAtMSAmJiBub2RlLmNoZWNrX0NoaWxkX1N0YXRlIDwgMikgOiAobm9kZS5jaGVja19DaGlsZF9TdGF0ZSA+IDApKSlcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gcjtcblx0XHR9LFxuXHRcdGdldFRyZWVDaGVja2VkTm9kZXM6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGVzLCBjaGVja2VkLCByZXN1bHRzKSB7XG5cdFx0XHRpZiAoIW5vZGVzKSByZXR1cm4gW107XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuLFxuXHRcdFx0Y2hlY2tlZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hlY2tlZCxcblx0XHRcdG9ubHlPbmUgPSAoY2hlY2tlZCAmJiBzZXR0aW5nLmNoZWNrLmNoa1N0eWxlID09IGNvbnN0cy5yYWRpby5TVFlMRSAmJiBzZXR0aW5nLmNoZWNrLnJhZGlvVHlwZSA9PSBjb25zdHMucmFkaW8uVFlQRV9BTEwpO1xuXHRcdFx0cmVzdWx0cyA9ICFyZXN1bHRzID8gW10gOiByZXN1bHRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKG5vZGVzW2ldLm5vY2hlY2sgIT09IHRydWUgJiYgbm9kZXNbaV0uY2hrRGlzYWJsZWQgIT09IHRydWUgJiYgbm9kZXNbaV1bY2hlY2tlZEtleV0gPT0gY2hlY2tlZCkge1xuXHRcdFx0XHRcdHJlc3VsdHMucHVzaChub2Rlc1tpXSk7XG5cdFx0XHRcdFx0aWYob25seU9uZSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuZ2V0VHJlZUNoZWNrZWROb2RlcyhzZXR0aW5nLCBub2Rlc1tpXVtjaGlsZEtleV0sIGNoZWNrZWQsIHJlc3VsdHMpO1xuXHRcdFx0XHRpZihvbmx5T25lICYmIHJlc3VsdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9LFxuXHRcdGdldFRyZWVDaGFuZ2VDaGVja2VkTm9kZXM6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGVzLCByZXN1bHRzKSB7XG5cdFx0XHRpZiAoIW5vZGVzKSByZXR1cm4gW107XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuLFxuXHRcdFx0Y2hlY2tlZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hlY2tlZDtcblx0XHRcdHJlc3VsdHMgPSAhcmVzdWx0cyA/IFtdIDogcmVzdWx0cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChub2Rlc1tpXS5ub2NoZWNrICE9PSB0cnVlICYmIG5vZGVzW2ldLmNoa0Rpc2FibGVkICE9PSB0cnVlICYmIG5vZGVzW2ldW2NoZWNrZWRLZXldICE9IG5vZGVzW2ldLmNoZWNrZWRPbGQpIHtcblx0XHRcdFx0XHRyZXN1bHRzLnB1c2gobm9kZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuZ2V0VHJlZUNoYW5nZUNoZWNrZWROb2RlcyhzZXR0aW5nLCBub2Rlc1tpXVtjaGlsZEtleV0sIHJlc3VsdHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fSxcblx0XHRtYWtlQ2hrRmxhZzogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0aWYgKCFub2RlKSByZXR1cm47XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuLFxuXHRcdFx0Y2hlY2tlZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hlY2tlZCxcblx0XHRcdGNoa0ZsYWcgPSAtMTtcblx0XHRcdGlmIChub2RlW2NoaWxkS2V5XSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVbY2hpbGRLZXldLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjTm9kZSA9IG5vZGVbY2hpbGRLZXldW2ldO1xuXHRcdFx0XHRcdHZhciB0bXAgPSAtMTtcblx0XHRcdFx0XHRpZiAoc2V0dGluZy5jaGVjay5jaGtTdHlsZSA9PSBjb25zdHMucmFkaW8uU1RZTEUpIHtcblx0XHRcdFx0XHRcdGlmIChjTm9kZS5ub2NoZWNrID09PSB0cnVlIHx8IGNOb2RlLmNoa0Rpc2FibGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IGNOb2RlLmNoZWNrX0NoaWxkX1N0YXRlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjTm9kZS5oYWxmQ2hlY2sgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0dG1wID0gMjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoY05vZGVbY2hlY2tlZEtleV0pIHtcblx0XHRcdFx0XHRcdFx0dG1wID0gMjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IGNOb2RlLmNoZWNrX0NoaWxkX1N0YXRlID4gMCA/IDI6MDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0bXAgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRjaGtGbGFnID0gMjsgYnJlYWs7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRtcCA9PSAwKXtcblx0XHRcdFx0XHRcdFx0Y2hrRmxhZyA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzZXR0aW5nLmNoZWNrLmNoa1N0eWxlID09IGNvbnN0cy5jaGVja2JveC5TVFlMRSkge1xuXHRcdFx0XHRcdFx0aWYgKGNOb2RlLm5vY2hlY2sgPT09IHRydWUgfHwgY05vZGUuY2hrRGlzYWJsZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0dG1wID0gY05vZGUuY2hlY2tfQ2hpbGRfU3RhdGU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNOb2RlLmhhbGZDaGVjayA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHR0bXAgPSAxO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjTm9kZVtjaGVja2VkS2V5XSApIHtcblx0XHRcdFx0XHRcdFx0dG1wID0gKGNOb2RlLmNoZWNrX0NoaWxkX1N0YXRlID09PSAtMSB8fCBjTm9kZS5jaGVja19DaGlsZF9TdGF0ZSA9PT0gMikgPyAyIDogMTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IChjTm9kZS5jaGVja19DaGlsZF9TdGF0ZSA+IDApID8gMSA6IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodG1wID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGNoa0ZsYWcgPSAxOyBicmVhaztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodG1wID09PSAyICYmIGNoa0ZsYWcgPiAtMSAmJiBpID4gMCAmJiB0bXAgIT09IGNoa0ZsYWcpIHtcblx0XHRcdFx0XHRcdFx0Y2hrRmxhZyA9IDE7IGJyZWFrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjaGtGbGFnID09PSAyICYmIHRtcCA+IC0xICYmIHRtcCA8IDIpIHtcblx0XHRcdFx0XHRcdFx0Y2hrRmxhZyA9IDE7IGJyZWFrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0bXAgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRjaGtGbGFnID0gdG1wO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bm9kZS5jaGVja19DaGlsZF9TdGF0ZSA9IGNoa0ZsYWc7XG5cdFx0fVxuXHR9LFxuXHQvL21ldGhvZCBvZiBldmVudCBwcm94eVxuXHRfZXZlbnQgPSB7XG5cblx0fSxcblx0Ly9tZXRob2Qgb2YgZXZlbnQgaGFuZGxlclxuXHRfaGFuZGxlciA9IHtcblx0XHRvbkNoZWNrTm9kZTogZnVuY3Rpb24gKGV2ZW50LCBub2RlKSB7XG5cdFx0XHRpZiAobm9kZS5jaGtEaXNhYmxlZCA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0dmFyIHNldHRpbmcgPSBkYXRhLmdldFNldHRpbmcoZXZlbnQuZGF0YS50cmVlSWQpLFxuXHRcdFx0Y2hlY2tlZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hlY2tlZDtcblx0XHRcdGlmICh0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZUNoZWNrLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkgcmV0dXJuIHRydWU7XG5cdFx0XHRub2RlW2NoZWNrZWRLZXldID0gIW5vZGVbY2hlY2tlZEtleV07XG5cdFx0XHR2aWV3LmNoZWNrTm9kZVJlbGF0aW9uKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0dmFyIGNoZWNrT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLkNIRUNLLCBzZXR0aW5nKTtcblx0XHRcdHZpZXcuc2V0Q2hrQ2xhc3Moc2V0dGluZywgY2hlY2tPYmosIG5vZGUpO1xuXHRcdFx0dmlldy5yZXBhaXJQYXJlbnRDaGtDbGFzc1dpdGhTZWxmKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0c2V0dGluZy50cmVlT2JqLnRyaWdnZXIoY29uc3RzLmV2ZW50LkNIRUNLLCBbZXZlbnQsIHNldHRpbmcudHJlZUlkLCBub2RlXSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdG9uTW91c2VvdmVyQ2hlY2s6IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG5cdFx0XHRpZiAobm9kZS5jaGtEaXNhYmxlZCA9PT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0dmFyIHNldHRpbmcgPSBkYXRhLmdldFNldHRpbmcoZXZlbnQuZGF0YS50cmVlSWQpLFxuXHRcdFx0Y2hlY2tPYmogPSAkJChub2RlLCBjb25zdHMuaWQuQ0hFQ0ssIHNldHRpbmcpO1xuXHRcdFx0bm9kZS5jaGVja19Gb2N1cyA9IHRydWU7XG5cdFx0XHR2aWV3LnNldENoa0NsYXNzKHNldHRpbmcsIGNoZWNrT2JqLCBub2RlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0b25Nb3VzZW91dENoZWNrOiBmdW5jdGlvbihldmVudCwgbm9kZSkge1xuXHRcdFx0aWYgKG5vZGUuY2hrRGlzYWJsZWQgPT09IHRydWUpIHJldHVybiBmYWxzZTtcblx0XHRcdHZhciBzZXR0aW5nID0gZGF0YS5nZXRTZXR0aW5nKGV2ZW50LmRhdGEudHJlZUlkKSxcblx0XHRcdGNoZWNrT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLkNIRUNLLCBzZXR0aW5nKTtcblx0XHRcdG5vZGUuY2hlY2tfRm9jdXMgPSBmYWxzZTtcblx0XHRcdHZpZXcuc2V0Q2hrQ2xhc3Moc2V0dGluZywgY2hlY2tPYmosIG5vZGUpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXHQvL21ldGhvZCBvZiB0b29scyBmb3IgelRyZWVcblx0X3Rvb2xzID0ge1xuXG5cdH0sXG5cdC8vbWV0aG9kIG9mIG9wZXJhdGUgenRyZWUgZG9tXG5cdF92aWV3ID0ge1xuXHRcdGNoZWNrTm9kZVJlbGF0aW9uOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgcE5vZGUsIGksIGwsXG5cdFx0XHRjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRjaGVja2VkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGVja2VkLFxuXHRcdFx0ciA9IGNvbnN0cy5yYWRpbztcblx0XHRcdGlmIChzZXR0aW5nLmNoZWNrLmNoa1N0eWxlID09IHIuU1RZTEUpIHtcblx0XHRcdFx0dmFyIGNoZWNrZWRMaXN0ID0gZGF0YS5nZXRSYWRpb0NoZWNrZWRMaXN0KHNldHRpbmcpO1xuXHRcdFx0XHRpZiAobm9kZVtjaGVja2VkS2V5XSkge1xuXHRcdFx0XHRcdGlmIChzZXR0aW5nLmNoZWNrLnJhZGlvVHlwZSA9PSByLlRZUEVfQUxMKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSBjaGVja2VkTGlzdC5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdFx0cE5vZGUgPSBjaGVja2VkTGlzdFtpXTtcblx0XHRcdFx0XHRcdFx0aWYgKHBOb2RlW2NoZWNrZWRLZXldICYmIHBOb2RlICE9IG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRwTm9kZVtjaGVja2VkS2V5XSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGNoZWNrZWRMaXN0LnNwbGljZShpLCAxKTtcblxuXHRcdFx0XHRcdFx0XHRcdHZpZXcuc2V0Q2hrQ2xhc3Moc2V0dGluZywgJCQocE5vZGUsIGNvbnN0cy5pZC5DSEVDSywgc2V0dGluZyksIHBOb2RlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAocE5vZGUucGFyZW50VElkICE9IG5vZGUucGFyZW50VElkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2aWV3LnJlcGFpclBhcmVudENoa0NsYXNzV2l0aFNlbGYoc2V0dGluZywgcE5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2hlY2tlZExpc3QucHVzaChub2RlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHBhcmVudE5vZGUgPSAobm9kZS5wYXJlbnRUSWQpID8gbm9kZS5nZXRQYXJlbnROb2RlKCkgOiBkYXRhLmdldFJvb3Qoc2V0dGluZyk7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gcGFyZW50Tm9kZVtjaGlsZEtleV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHBOb2RlID0gcGFyZW50Tm9kZVtjaGlsZEtleV1baV07XG5cdFx0XHRcdFx0XHRcdGlmIChwTm9kZVtjaGVja2VkS2V5XSAmJiBwTm9kZSAhPSBub2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cE5vZGVbY2hlY2tlZEtleV0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR2aWV3LnNldENoa0NsYXNzKHNldHRpbmcsICQkKHBOb2RlLCBjb25zdHMuaWQuQ0hFQ0ssIHNldHRpbmcpLCBwTm9kZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2V0dGluZy5jaGVjay5yYWRpb1R5cGUgPT0gci5UWVBFX0FMTCkge1xuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBjaGVja2VkTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChub2RlID09IGNoZWNrZWRMaXN0W2ldKSB7XG5cdFx0XHRcdFx0XHRcdGNoZWNrZWRMaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChub2RlW2NoZWNrZWRLZXldICYmICghbm9kZVtjaGlsZEtleV0gfHwgbm9kZVtjaGlsZEtleV0ubGVuZ3RoPT0wIHx8IHNldHRpbmcuY2hlY2suY2hrYm94VHlwZS5ZLmluZGV4T2YoXCJzXCIpID4gLTEpKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRTb25Ob2RlQ2hlY2tCb3goc2V0dGluZywgbm9kZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFub2RlW2NoZWNrZWRLZXldICYmICghbm9kZVtjaGlsZEtleV0gfHwgbm9kZVtjaGlsZEtleV0ubGVuZ3RoPT0wIHx8IHNldHRpbmcuY2hlY2suY2hrYm94VHlwZS5OLmluZGV4T2YoXCJzXCIpID4gLTEpKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRTb25Ob2RlQ2hlY2tCb3goc2V0dGluZywgbm9kZSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub2RlW2NoZWNrZWRLZXldICYmIHNldHRpbmcuY2hlY2suY2hrYm94VHlwZS5ZLmluZGV4T2YoXCJwXCIpID4gLTEpIHtcblx0XHRcdFx0XHR2aWV3LnNldFBhcmVudE5vZGVDaGVja0JveChzZXR0aW5nLCBub2RlLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIW5vZGVbY2hlY2tlZEtleV0gJiYgc2V0dGluZy5jaGVjay5jaGtib3hUeXBlLk4uaW5kZXhPZihcInBcIikgPiAtMSkge1xuXHRcdFx0XHRcdHZpZXcuc2V0UGFyZW50Tm9kZUNoZWNrQm94KHNldHRpbmcsIG5vZGUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWFrZUNoa0NsYXNzOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgY2hlY2tlZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hlY2tlZCxcblx0XHRcdGMgPSBjb25zdHMuY2hlY2tib3gsIHIgPSBjb25zdHMucmFkaW8sXG5cdFx0XHRmdWxsU3R5bGUgPSBcIlwiO1xuXHRcdFx0aWYgKG5vZGUuY2hrRGlzYWJsZWQgPT09IHRydWUpIHtcblx0XHRcdFx0ZnVsbFN0eWxlID0gYy5ESVNBQkxFRDtcblx0XHRcdH0gZWxzZSBpZiAobm9kZS5oYWxmQ2hlY2spIHtcblx0XHRcdFx0ZnVsbFN0eWxlID0gYy5QQVJUO1xuXHRcdFx0fSBlbHNlIGlmIChzZXR0aW5nLmNoZWNrLmNoa1N0eWxlID09IHIuU1RZTEUpIHtcblx0XHRcdFx0ZnVsbFN0eWxlID0gKG5vZGUuY2hlY2tfQ2hpbGRfU3RhdGUgPCAxKT8gYy5GVUxMOmMuUEFSVDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGxTdHlsZSA9IG5vZGVbY2hlY2tlZEtleV0gPyAoKG5vZGUuY2hlY2tfQ2hpbGRfU3RhdGUgPT09IDIgfHwgbm9kZS5jaGVja19DaGlsZF9TdGF0ZSA9PT0gLTEpID8gYy5GVUxMOmMuUEFSVCkgOiAoKG5vZGUuY2hlY2tfQ2hpbGRfU3RhdGUgPCAxKT8gYy5GVUxMOmMuUEFSVCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2hrTmFtZSA9IHNldHRpbmcuY2hlY2suY2hrU3R5bGUgKyBcIl9cIiArIChub2RlW2NoZWNrZWRLZXldID8gYy5UUlVFIDogYy5GQUxTRSkgKyBcIl9cIiArIGZ1bGxTdHlsZTtcblx0XHRcdGNoa05hbWUgPSAobm9kZS5jaGVja19Gb2N1cyAmJiBub2RlLmNoa0Rpc2FibGVkICE9PSB0cnVlKSA/IGNoa05hbWUgKyBcIl9cIiArIGMuRk9DVVMgOiBjaGtOYW1lO1xuXHRcdFx0cmV0dXJuIGNvbnN0cy5jbGFzc05hbWUuQlVUVE9OICsgXCIgXCIgKyBjLkRFRkFVTFQgKyBcIiBcIiArIGNoa05hbWU7XG5cdFx0fSxcblx0XHRyZXBhaXJBbGxDaGs6IGZ1bmN0aW9uKHNldHRpbmcsIGNoZWNrZWQpIHtcblx0XHRcdGlmIChzZXR0aW5nLmNoZWNrLmVuYWJsZSAmJiBzZXR0aW5nLmNoZWNrLmNoa1N0eWxlID09PSBjb25zdHMuY2hlY2tib3guU1RZTEUpIHtcblx0XHRcdFx0dmFyIGNoZWNrZWRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoZWNrZWQsXG5cdFx0XHRcdGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbixcblx0XHRcdFx0cm9vdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSByb290W2NoaWxkS2V5XS5sZW5ndGg7IGk8bCA7IGkrKykge1xuXHRcdFx0XHRcdHZhciBub2RlID0gcm9vdFtjaGlsZEtleV1baV07XG5cdFx0XHRcdFx0aWYgKG5vZGUubm9jaGVjayAhPT0gdHJ1ZSAmJiBub2RlLmNoa0Rpc2FibGVkICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRub2RlW2NoZWNrZWRLZXldID0gY2hlY2tlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmlldy5zZXRTb25Ob2RlQ2hlY2tCb3goc2V0dGluZywgbm9kZSwgY2hlY2tlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcGFpckNoa0NsYXNzOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHRpZiAoIW5vZGUpIHJldHVybjtcblx0XHRcdGRhdGEubWFrZUNoa0ZsYWcoc2V0dGluZywgbm9kZSk7XG5cdFx0XHRpZiAobm9kZS5ub2NoZWNrICE9PSB0cnVlKSB7XG5cdFx0XHRcdHZhciBjaGVja09iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5DSEVDSywgc2V0dGluZyk7XG5cdFx0XHRcdHZpZXcuc2V0Q2hrQ2xhc3Moc2V0dGluZywgY2hlY2tPYmosIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmVwYWlyUGFyZW50Q2hrQ2xhc3M6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdGlmICghbm9kZSB8fCAhbm9kZS5wYXJlbnRUSWQpIHJldHVybjtcblx0XHRcdHZhciBwTm9kZSA9IG5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXHRcdFx0dmlldy5yZXBhaXJDaGtDbGFzcyhzZXR0aW5nLCBwTm9kZSk7XG5cdFx0XHR2aWV3LnJlcGFpclBhcmVudENoa0NsYXNzKHNldHRpbmcsIHBOb2RlKTtcblx0XHR9LFxuXHRcdHJlcGFpclBhcmVudENoa0NsYXNzV2l0aFNlbGY6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdGlmICghbm9kZSkgcmV0dXJuO1xuXHRcdFx0dmFyIGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbjtcblx0XHRcdGlmIChub2RlW2NoaWxkS2V5XSAmJiBub2RlW2NoaWxkS2V5XS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZpZXcucmVwYWlyUGFyZW50Q2hrQ2xhc3Moc2V0dGluZywgbm9kZVtjaGlsZEtleV1bMF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmlldy5yZXBhaXJQYXJlbnRDaGtDbGFzcyhzZXR0aW5nLCBub2RlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcGFpclNvbkNoa0Rpc2FibGVkOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlLCBjaGtEaXNhYmxlZCwgaW5oZXJpdCkge1xuXHRcdFx0aWYgKCFub2RlKSByZXR1cm47XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuO1xuXHRcdFx0aWYgKG5vZGUuY2hrRGlzYWJsZWQgIT0gY2hrRGlzYWJsZWQpIHtcblx0XHRcdFx0bm9kZS5jaGtEaXNhYmxlZCA9IGNoa0Rpc2FibGVkO1xuXHRcdFx0fVxuXHRcdFx0dmlldy5yZXBhaXJDaGtDbGFzcyhzZXR0aW5nLCBub2RlKTtcblx0XHRcdGlmIChub2RlW2NoaWxkS2V5XSAmJiBpbmhlcml0KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZVtjaGlsZEtleV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNOb2RlID0gbm9kZVtjaGlsZEtleV1baV07XG5cdFx0XHRcdFx0dmlldy5yZXBhaXJTb25DaGtEaXNhYmxlZChzZXR0aW5nLCBzTm9kZSwgY2hrRGlzYWJsZWQsIGluaGVyaXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXBhaXJQYXJlbnRDaGtEaXNhYmxlZDogZnVuY3Rpb24oc2V0dGluZywgbm9kZSwgY2hrRGlzYWJsZWQsIGluaGVyaXQpIHtcblx0XHRcdGlmICghbm9kZSkgcmV0dXJuO1xuXHRcdFx0aWYgKG5vZGUuY2hrRGlzYWJsZWQgIT0gY2hrRGlzYWJsZWQgJiYgaW5oZXJpdCkge1xuXHRcdFx0XHRub2RlLmNoa0Rpc2FibGVkID0gY2hrRGlzYWJsZWQ7XG5cdFx0XHR9XG5cdFx0XHR2aWV3LnJlcGFpckNoa0NsYXNzKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0dmlldy5yZXBhaXJQYXJlbnRDaGtEaXNhYmxlZChzZXR0aW5nLCBub2RlLmdldFBhcmVudE5vZGUoKSwgY2hrRGlzYWJsZWQsIGluaGVyaXQpO1xuXHRcdH0sXG5cdFx0c2V0Q2hrQ2xhc3M6IGZ1bmN0aW9uKHNldHRpbmcsIG9iaiwgbm9kZSkge1xuXHRcdFx0aWYgKCFvYmopIHJldHVybjtcblx0XHRcdGlmIChub2RlLm5vY2hlY2sgPT09IHRydWUpIHtcblx0XHRcdFx0b2JqLmhpZGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9iai5zaG93KCk7XG5cdFx0XHR9XG4gICAgICAgICAgICBvYmouYXR0cignY2xhc3MnLCB2aWV3Lm1ha2VDaGtDbGFzcyhzZXR0aW5nLCBub2RlKSk7XG5cdFx0fSxcblx0XHRzZXRQYXJlbnROb2RlQ2hlY2tCb3g6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUsIHZhbHVlLCBzcmNOb2RlKSB7XG5cdFx0XHR2YXIgY2hpbGRLZXkgPSBzZXR0aW5nLmRhdGEua2V5LmNoaWxkcmVuLFxuXHRcdFx0Y2hlY2tlZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hlY2tlZCxcblx0XHRcdGNoZWNrT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLkNIRUNLLCBzZXR0aW5nKTtcblx0XHRcdGlmICghc3JjTm9kZSkgc3JjTm9kZSA9IG5vZGU7XG5cdFx0XHRkYXRhLm1ha2VDaGtGbGFnKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0aWYgKG5vZGUubm9jaGVjayAhPT0gdHJ1ZSAmJiBub2RlLmNoa0Rpc2FibGVkICE9PSB0cnVlKSB7XG5cdFx0XHRcdG5vZGVbY2hlY2tlZEtleV0gPSB2YWx1ZTtcblx0XHRcdFx0dmlldy5zZXRDaGtDbGFzcyhzZXR0aW5nLCBjaGVja09iaiwgbm9kZSk7XG5cdFx0XHRcdGlmIChzZXR0aW5nLmNoZWNrLmF1dG9DaGVja1RyaWdnZXIgJiYgbm9kZSAhPSBzcmNOb2RlKSB7XG5cdFx0XHRcdFx0c2V0dGluZy50cmVlT2JqLnRyaWdnZXIoY29uc3RzLmV2ZW50LkNIRUNLLCBbbnVsbCwgc2V0dGluZy50cmVlSWQsIG5vZGVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5vZGUucGFyZW50VElkKSB7XG5cdFx0XHRcdHZhciBwU2lnbiA9IHRydWU7XG5cdFx0XHRcdGlmICghdmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgcE5vZGVzID0gbm9kZS5nZXRQYXJlbnROb2RlKClbY2hpbGRLZXldO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKChwTm9kZXNbaV0ubm9jaGVjayAhPT0gdHJ1ZSAmJiBwTm9kZXNbaV0uY2hrRGlzYWJsZWQgIT09IHRydWUgJiYgcE5vZGVzW2ldW2NoZWNrZWRLZXldKVxuXHRcdFx0XHRcdFx0fHwgKChwTm9kZXNbaV0ubm9jaGVjayA9PT0gdHJ1ZSB8fCBwTm9kZXNbaV0uY2hrRGlzYWJsZWQgPT09IHRydWUpICYmIHBOb2Rlc1tpXS5jaGVja19DaGlsZF9TdGF0ZSA+IDApKSB7XG5cdFx0XHRcdFx0XHRcdHBTaWduID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocFNpZ24pIHtcblx0XHRcdFx0XHR2aWV3LnNldFBhcmVudE5vZGVDaGVja0JveChzZXR0aW5nLCBub2RlLmdldFBhcmVudE5vZGUoKSwgdmFsdWUsIHNyY05vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZXRTb25Ob2RlQ2hlY2tCb3g6IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUsIHZhbHVlLCBzcmNOb2RlKSB7XG5cdFx0XHRpZiAoIW5vZGUpIHJldHVybjtcblx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4sXG5cdFx0XHRjaGVja2VkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGVja2VkLFxuXHRcdFx0Y2hlY2tPYmogPSAkJChub2RlLCBjb25zdHMuaWQuQ0hFQ0ssIHNldHRpbmcpO1xuXHRcdFx0aWYgKCFzcmNOb2RlKSBzcmNOb2RlID0gbm9kZTtcblxuXHRcdFx0dmFyIGhhc0Rpc2FibGUgPSBmYWxzZTtcblx0XHRcdGlmIChub2RlW2NoaWxkS2V5XSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVbY2hpbGRLZXldLmxlbmd0aDsgaSA8IGwgJiYgbm9kZS5jaGtEaXNhYmxlZCAhPT0gdHJ1ZTsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNOb2RlID0gbm9kZVtjaGlsZEtleV1baV07XG5cdFx0XHRcdFx0dmlldy5zZXRTb25Ob2RlQ2hlY2tCb3goc2V0dGluZywgc05vZGUsIHZhbHVlLCBzcmNOb2RlKTtcblx0XHRcdFx0XHRpZiAoc05vZGUuY2hrRGlzYWJsZWQgPT09IHRydWUpIGhhc0Rpc2FibGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChub2RlICE9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKSAmJiBub2RlLmNoa0Rpc2FibGVkICE9PSB0cnVlKSB7XG5cdFx0XHRcdGlmIChoYXNEaXNhYmxlICYmIG5vZGUubm9jaGVjayAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGRhdGEubWFrZUNoa0ZsYWcoc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vZGUubm9jaGVjayAhPT0gdHJ1ZSAmJiBub2RlLmNoa0Rpc2FibGVkICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0bm9kZVtjaGVja2VkS2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmICghaGFzRGlzYWJsZSkgbm9kZS5jaGVja19DaGlsZF9TdGF0ZSA9IChub2RlW2NoaWxkS2V5XSAmJiBub2RlW2NoaWxkS2V5XS5sZW5ndGggPiAwKSA/ICh2YWx1ZSA/IDIgOiAwKSA6IC0xO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuY2hlY2tfQ2hpbGRfU3RhdGUgPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2aWV3LnNldENoa0NsYXNzKHNldHRpbmcsIGNoZWNrT2JqLCBub2RlKTtcblx0XHRcdFx0aWYgKHNldHRpbmcuY2hlY2suYXV0b0NoZWNrVHJpZ2dlciAmJiBub2RlICE9IHNyY05vZGUgJiYgbm9kZS5ub2NoZWNrICE9PSB0cnVlICYmIG5vZGUuY2hrRGlzYWJsZWQgIT09IHRydWUpIHtcblx0XHRcdFx0XHRzZXR0aW5nLnRyZWVPYmoudHJpZ2dlcihjb25zdHMuZXZlbnQuQ0hFQ0ssIFtudWxsLCBzZXR0aW5nLnRyZWVJZCwgbm9kZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cblx0X3ogPSB7XG5cdFx0dG9vbHM6IF90b29scyxcblx0XHR2aWV3OiBfdmlldyxcblx0XHRldmVudDogX2V2ZW50LFxuXHRcdGRhdGE6IF9kYXRhXG5cdH07XG5cdCQuZXh0ZW5kKHRydWUsICQuZm4uelRyZWUuY29uc3RzLCBfY29uc3RzKTtcblx0JC5leHRlbmQodHJ1ZSwgJC5mbi56VHJlZS5feiwgX3opO1xuXG5cdHZhciB6dCA9ICQuZm4uelRyZWUsXG5cdHRvb2xzID0genQuX3oudG9vbHMsXG5cdGNvbnN0cyA9IHp0LmNvbnN0cyxcblx0dmlldyA9IHp0Ll96LnZpZXcsXG5cdGRhdGEgPSB6dC5fei5kYXRhLFxuXHRldmVudCA9IHp0Ll96LmV2ZW50LFxuXHQkJCA9IHRvb2xzLiQ7XG5cblx0ZGF0YS5leFNldHRpbmcoX3NldHRpbmcpO1xuXHRkYXRhLmFkZEluaXRCaW5kKF9iaW5kRXZlbnQpO1xuXHRkYXRhLmFkZEluaXRVbkJpbmQoX3VuYmluZEV2ZW50KTtcblx0ZGF0YS5hZGRJbml0Q2FjaGUoX2luaXRDYWNoZSk7XG5cdGRhdGEuYWRkSW5pdE5vZGUoX2luaXROb2RlKTtcblx0ZGF0YS5hZGRJbml0UHJveHkoX2V2ZW50UHJveHksIHRydWUpO1xuXHRkYXRhLmFkZEluaXRSb290KF9pbml0Um9vdCk7XG5cdGRhdGEuYWRkQmVmb3JlQShfYmVmb3JlQSk7XG5cdGRhdGEuYWRkWlRyZWVUb29scyhfelRyZWVUb29scyk7XG5cblx0dmFyIF9jcmVhdGVOb2RlcyA9IHZpZXcuY3JlYXRlTm9kZXM7XG5cdHZpZXcuY3JlYXRlTm9kZXMgPSBmdW5jdGlvbihzZXR0aW5nLCBsZXZlbCwgbm9kZXMsIHBhcmVudE5vZGUpIHtcblx0XHRpZiAoX2NyZWF0ZU5vZGVzKSBfY3JlYXRlTm9kZXMuYXBwbHkodmlldywgYXJndW1lbnRzKTtcblx0XHRpZiAoIW5vZGVzKSByZXR1cm47XG5cdFx0dmlldy5yZXBhaXJQYXJlbnRDaGtDbGFzc1dpdGhTZWxmKHNldHRpbmcsIHBhcmVudE5vZGUpO1xuXHR9XG5cdHZhciBfcmVtb3ZlTm9kZSA9IHZpZXcucmVtb3ZlTm9kZTtcblx0dmlldy5yZW1vdmVOb2RlID0gZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdHZhciBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnROb2RlKCk7XG5cdFx0aWYgKF9yZW1vdmVOb2RlKSBfcmVtb3ZlTm9kZS5hcHBseSh2aWV3LCBhcmd1bWVudHMpO1xuXHRcdGlmICghbm9kZSB8fCAhcGFyZW50Tm9kZSkgcmV0dXJuO1xuXHRcdHZpZXcucmVwYWlyQ2hrQ2xhc3Moc2V0dGluZywgcGFyZW50Tm9kZSk7XG5cdFx0dmlldy5yZXBhaXJQYXJlbnRDaGtDbGFzcyhzZXR0aW5nLCBwYXJlbnROb2RlKTtcblx0fVxuXG5cdHZhciBfYXBwZW5kTm9kZXMgPSB2aWV3LmFwcGVuZE5vZGVzO1xuXHR2aWV3LmFwcGVuZE5vZGVzID0gZnVuY3Rpb24oc2V0dGluZywgbGV2ZWwsIG5vZGVzLCBwYXJlbnROb2RlLCBpbml0RmxhZywgb3BlbkZsYWcpIHtcblx0XHR2YXIgaHRtbCA9IFwiXCI7XG5cdFx0aWYgKF9hcHBlbmROb2Rlcykge1xuXHRcdFx0aHRtbCA9IF9hcHBlbmROb2Rlcy5hcHBseSh2aWV3LCBhcmd1bWVudHMpO1xuXHRcdH1cblx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0ZGF0YS5tYWtlQ2hrRmxhZyhzZXR0aW5nLCBwYXJlbnROb2RlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH1cbn0pKGpRdWVyeSk7XG4vKlxuICogSlF1ZXJ5IHpUcmVlIGV4ZWRpdCB2My41LjE3LWJldGEuMlxuICogaHR0cDovL3pUcmVlLm1lL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCBIdW50ZXIuelxuICpcbiAqIExpY2Vuc2VkIHNhbWUgYXMganF1ZXJ5IC0gTUlUIExpY2Vuc2VcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogZW1haWw6IGh1bnRlci56QDI2My5uZXRcbiAqIERhdGU6IDIwMTQtMDUtMDhcbiAqL1xuKGZ1bmN0aW9uKCQpe1xuXHQvL2RlZmF1bHQgY29uc3RzIG9mIGV4ZWRpdFxuXHR2YXIgX2NvbnN0cyA9IHtcblx0XHRldmVudDoge1xuXHRcdFx0RFJBRzogXCJ6dHJlZV9kcmFnXCIsXG5cdFx0XHREUk9QOiBcInp0cmVlX2Ryb3BcIixcblx0XHRcdFJFTkFNRTogXCJ6dHJlZV9yZW5hbWVcIixcblx0XHRcdERSQUdNT1ZFOlwienRyZWVfZHJhZ21vdmVcIlxuXHRcdH0sXG5cdFx0aWQ6IHtcblx0XHRcdEVESVQ6IFwiX2VkaXRcIixcblx0XHRcdElOUFVUOiBcIl9pbnB1dFwiLFxuXHRcdFx0UkVNT1ZFOiBcIl9yZW1vdmVcIlxuXHRcdH0sXG5cdFx0bW92ZToge1xuXHRcdFx0VFlQRV9JTk5FUjogXCJpbm5lclwiLFxuXHRcdFx0VFlQRV9QUkVWOiBcInByZXZcIixcblx0XHRcdFRZUEVfTkVYVDogXCJuZXh0XCJcblx0XHR9LFxuXHRcdG5vZGU6IHtcblx0XHRcdENVUlNFTEVDVEVEX0VESVQ6IFwiY3VyU2VsZWN0ZWROb2RlX0VkaXRcIixcblx0XHRcdFRNUFRBUkdFVF9UUkVFOiBcInRtcFRhcmdldHpUcmVlXCIsXG5cdFx0XHRUTVBUQVJHRVRfTk9ERTogXCJ0bXBUYXJnZXROb2RlXCJcblx0XHR9XG5cdH0sXG5cdC8vZGVmYXVsdCBzZXR0aW5nIG9mIGV4ZWRpdFxuXHRfc2V0dGluZyA9IHtcblx0XHRlZGl0OiB7XG5cdFx0XHRlbmFibGU6IGZhbHNlLFxuXHRcdFx0ZWRpdE5hbWVTZWxlY3RBbGw6IGZhbHNlLFxuXHRcdFx0c2hvd1JlbW92ZUJ0bjogdHJ1ZSxcblx0XHRcdHNob3dSZW5hbWVCdG46IHRydWUsXG5cdFx0XHRyZW1vdmVUaXRsZTogXCJyZW1vdmVcIixcblx0XHRcdHJlbmFtZVRpdGxlOiBcInJlbmFtZVwiLFxuXHRcdFx0ZHJhZzoge1xuXHRcdFx0XHRhdXRvRXhwYW5kVHJpZ2dlcjogZmFsc2UsXG5cdFx0XHRcdGlzQ29weTogdHJ1ZSxcblx0XHRcdFx0aXNNb3ZlOiB0cnVlLFxuXHRcdFx0XHRwcmV2OiB0cnVlLFxuXHRcdFx0XHRuZXh0OiB0cnVlLFxuXHRcdFx0XHRpbm5lcjogdHJ1ZSxcblx0XHRcdFx0bWluTW92ZVNpemU6IDUsXG5cdFx0XHRcdGJvcmRlck1heDogMTAsXG5cdFx0XHRcdGJvcmRlck1pbjogLTUsXG5cdFx0XHRcdG1heFNob3dOb2RlTnVtOiA1LFxuXHRcdFx0XHRhdXRvT3BlblRpbWU6IDUwMFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dmlldzoge1xuXHRcdFx0YWRkSG92ZXJEb206IG51bGwsXG5cdFx0XHRyZW1vdmVIb3ZlckRvbTogbnVsbFxuXHRcdH0sXG5cdFx0Y2FsbGJhY2s6IHtcblx0XHRcdGJlZm9yZURyYWc6bnVsbCxcblx0XHRcdGJlZm9yZURyYWdPcGVuOm51bGwsXG5cdFx0XHRiZWZvcmVEcm9wOm51bGwsXG5cdFx0XHRiZWZvcmVFZGl0TmFtZTpudWxsLFxuXHRcdFx0YmVmb3JlUmVuYW1lOm51bGwsXG5cdFx0XHRvbkRyYWc6bnVsbCxcblx0XHRcdG9uRHJhZ01vdmU6bnVsbCxcblx0XHRcdG9uRHJvcDpudWxsLFxuXHRcdFx0b25SZW5hbWU6bnVsbFxuXHRcdH1cblx0fSxcblx0Ly9kZWZhdWx0IHJvb3Qgb2YgZXhlZGl0XG5cdF9pbml0Um9vdCA9IGZ1bmN0aW9uIChzZXR0aW5nKSB7XG5cdFx0dmFyIHIgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyksIHJzID0gZGF0YS5nZXRSb290cygpO1xuXHRcdHIuY3VyRWRpdE5vZGUgPSBudWxsO1xuXHRcdHIuY3VyRWRpdElucHV0ID0gbnVsbDtcblx0XHRyLmN1ckhvdmVyTm9kZSA9IG51bGw7XG5cdFx0ci5kcmFnRmxhZyA9IDA7XG5cdFx0ci5kcmFnTm9kZVNob3dCZWZvcmUgPSBbXTtcblx0XHRyLmRyYWdNYXNrTGlzdCA9IG5ldyBBcnJheSgpO1xuXHRcdHJzLnNob3dIb3ZlckRvbSA9IHRydWU7XG5cdH0sXG5cdC8vZGVmYXVsdCBjYWNoZSBvZiBleGVkaXRcblx0X2luaXRDYWNoZSA9IGZ1bmN0aW9uKHRyZWVJZCkge30sXG5cdC8vZGVmYXVsdCBiaW5kIGV2ZW50IG9mIGV4ZWRpdFxuXHRfYmluZEV2ZW50ID0gZnVuY3Rpb24oc2V0dGluZykge1xuXHRcdHZhciBvID0gc2V0dGluZy50cmVlT2JqO1xuXHRcdHZhciBjID0gY29uc3RzLmV2ZW50O1xuXHRcdG8uYmluZChjLlJFTkFNRSwgZnVuY3Rpb24gKGV2ZW50LCB0cmVlSWQsIHRyZWVOb2RlLCBpc0NhbmNlbCkge1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vblJlbmFtZSwgW2V2ZW50LCB0cmVlSWQsIHRyZWVOb2RlLCBpc0NhbmNlbF0pO1xuXHRcdH0pO1xuXG5cdFx0by5iaW5kKGMuRFJBRywgZnVuY3Rpb24gKGV2ZW50LCBzcmNFdmVudCwgdHJlZUlkLCB0cmVlTm9kZXMpIHtcblx0XHRcdHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2sub25EcmFnLCBbc3JjRXZlbnQsIHRyZWVJZCwgdHJlZU5vZGVzXSk7XG5cdFx0fSk7XG5cblx0XHRvLmJpbmQoYy5EUkFHTU9WRSxmdW5jdGlvbihldmVudCwgc3JjRXZlbnQsIHRyZWVJZCwgdHJlZU5vZGVzKXtcblx0XHRcdHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2sub25EcmFnTW92ZSxbc3JjRXZlbnQsIHRyZWVJZCwgdHJlZU5vZGVzXSk7XG5cdFx0fSk7XG5cblx0XHRvLmJpbmQoYy5EUk9QLCBmdW5jdGlvbiAoZXZlbnQsIHNyY0V2ZW50LCB0cmVlSWQsIHRyZWVOb2RlcywgdGFyZ2V0Tm9kZSwgbW92ZVR5cGUsIGlzQ29weSkge1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5vbkRyb3AsIFtzcmNFdmVudCwgdHJlZUlkLCB0cmVlTm9kZXMsIHRhcmdldE5vZGUsIG1vdmVUeXBlLCBpc0NvcHldKTtcblx0XHR9KTtcblx0fSxcblx0X3VuYmluZEV2ZW50ID0gZnVuY3Rpb24oc2V0dGluZykge1xuXHRcdHZhciBvID0gc2V0dGluZy50cmVlT2JqO1xuXHRcdHZhciBjID0gY29uc3RzLmV2ZW50O1xuXHRcdG8udW5iaW5kKGMuUkVOQU1FKTtcblx0XHRvLnVuYmluZChjLkRSQUcpO1xuXHRcdG8udW5iaW5kKGMuRFJBR01PVkUpO1xuXHRcdG8udW5iaW5kKGMuRFJPUCk7XG5cdH0sXG5cdC8vZGVmYXVsdCBldmVudCBwcm94eSBvZiBleGVkaXRcblx0X2V2ZW50UHJveHkgPSBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0LFxuXHRcdHNldHRpbmcgPSBkYXRhLmdldFNldHRpbmcoZS5kYXRhLnRyZWVJZCksXG5cdFx0cmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCxcblx0XHR0SWQgPSBcIlwiLCBub2RlID0gbnVsbCxcblx0XHRub2RlRXZlbnRUeXBlID0gXCJcIiwgdHJlZUV2ZW50VHlwZSA9IFwiXCIsXG5cdFx0bm9kZUV2ZW50Q2FsbGJhY2sgPSBudWxsLCB0cmVlRXZlbnRDYWxsYmFjayA9IG51bGwsXG5cdFx0dG1wID0gbnVsbDtcblxuXHRcdGlmICh0b29scy5lcXMoZS50eXBlLCBcIm1vdXNlb3ZlclwiKSkge1xuXHRcdFx0dG1wID0gdG9vbHMuZ2V0TURvbShzZXR0aW5nLCB0YXJnZXQsIFt7dGFnTmFtZTpcImFcIiwgYXR0ck5hbWU6XCJ0cmVlTm9kZVwiK2NvbnN0cy5pZC5BfV0pO1xuXHRcdFx0aWYgKHRtcCkge1xuXHRcdFx0XHR0SWQgPSB0b29scy5nZXROb2RlTWFpbkRvbSh0bXApLmlkO1xuXHRcdFx0XHRub2RlRXZlbnRUeXBlID0gXCJob3Zlck92ZXJOb2RlXCI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0b29scy5lcXMoZS50eXBlLCBcIm1vdXNlb3V0XCIpKSB7XG5cdFx0XHR0bXAgPSB0b29scy5nZXRNRG9tKHNldHRpbmcsIHJlbGF0ZWRUYXJnZXQsIFt7dGFnTmFtZTpcImFcIiwgYXR0ck5hbWU6XCJ0cmVlTm9kZVwiK2NvbnN0cy5pZC5BfV0pO1xuXHRcdFx0aWYgKCF0bXApIHtcblx0XHRcdFx0dElkID0gXCJyZW1vdmVcIjtcblx0XHRcdFx0bm9kZUV2ZW50VHlwZSA9IFwiaG92ZXJPdXROb2RlXCI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0b29scy5lcXMoZS50eXBlLCBcIm1vdXNlZG93blwiKSkge1xuXHRcdFx0dG1wID0gdG9vbHMuZ2V0TURvbShzZXR0aW5nLCB0YXJnZXQsIFt7dGFnTmFtZTpcImFcIiwgYXR0ck5hbWU6XCJ0cmVlTm9kZVwiK2NvbnN0cy5pZC5BfV0pO1xuXHRcdFx0aWYgKHRtcCkge1xuXHRcdFx0XHR0SWQgPSB0b29scy5nZXROb2RlTWFpbkRvbSh0bXApLmlkO1xuXHRcdFx0XHRub2RlRXZlbnRUeXBlID0gXCJtb3VzZWRvd25Ob2RlXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0SWQubGVuZ3RoPjApIHtcblx0XHRcdG5vZGUgPSBkYXRhLmdldE5vZGVDYWNoZShzZXR0aW5nLCB0SWQpO1xuXHRcdFx0c3dpdGNoIChub2RlRXZlbnRUeXBlKSB7XG5cdFx0XHRcdGNhc2UgXCJtb3VzZWRvd25Ob2RlXCIgOlxuXHRcdFx0XHRcdG5vZGVFdmVudENhbGxiYWNrID0gX2hhbmRsZXIub25Nb3VzZWRvd25Ob2RlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiaG92ZXJPdmVyTm9kZVwiIDpcblx0XHRcdFx0XHRub2RlRXZlbnRDYWxsYmFjayA9IF9oYW5kbGVyLm9uSG92ZXJPdmVyTm9kZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImhvdmVyT3V0Tm9kZVwiIDpcblx0XHRcdFx0XHRub2RlRXZlbnRDYWxsYmFjayA9IF9oYW5kbGVyLm9uSG92ZXJPdXROb2RlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcHJveHlSZXN1bHQgPSB7XG5cdFx0XHRzdG9wOiBmYWxzZSxcblx0XHRcdG5vZGU6IG5vZGUsXG5cdFx0XHRub2RlRXZlbnRUeXBlOiBub2RlRXZlbnRUeXBlLFxuXHRcdFx0bm9kZUV2ZW50Q2FsbGJhY2s6IG5vZGVFdmVudENhbGxiYWNrLFxuXHRcdFx0dHJlZUV2ZW50VHlwZTogdHJlZUV2ZW50VHlwZSxcblx0XHRcdHRyZWVFdmVudENhbGxiYWNrOiB0cmVlRXZlbnRDYWxsYmFja1xuXHRcdH07XG5cdFx0cmV0dXJuIHByb3h5UmVzdWx0XG5cdH0sXG5cdC8vZGVmYXVsdCBpbml0IG5vZGUgb2YgZXhlZGl0XG5cdF9pbml0Tm9kZSA9IGZ1bmN0aW9uKHNldHRpbmcsIGxldmVsLCBuLCBwYXJlbnROb2RlLCBpc0ZpcnN0Tm9kZSwgaXNMYXN0Tm9kZSwgb3BlbkZsYWcpIHtcblx0XHRpZiAoIW4pIHJldHVybjtcblx0XHRuLmlzSG92ZXIgPSBmYWxzZTtcblx0XHRuLmVkaXROYW1lRmxhZyA9IGZhbHNlO1xuXHR9LFxuXHQvL3VwZGF0ZSB6VHJlZU9iaiwgYWRkIG1ldGhvZCBvZiBlZGl0XG5cdF96VHJlZVRvb2xzID0gZnVuY3Rpb24oc2V0dGluZywgelRyZWVUb29scykge1xuXHRcdHpUcmVlVG9vbHMuY2FuY2VsRWRpdE5hbWUgPSBmdW5jdGlvbihuZXdOYW1lKSB7XG5cdFx0XHR2YXIgcm9vdCA9IGRhdGEuZ2V0Um9vdCh0aGlzLnNldHRpbmcpO1xuXHRcdFx0aWYgKCFyb290LmN1ckVkaXROb2RlKSByZXR1cm47XG5cdFx0XHR2aWV3LmNhbmNlbEN1ckVkaXROb2RlKHRoaXMuc2V0dGluZywgbmV3TmFtZT9uZXdOYW1lOm51bGwsIHRydWUpO1xuXHRcdH1cblx0XHR6VHJlZVRvb2xzLmNvcHlOb2RlID0gZnVuY3Rpb24odGFyZ2V0Tm9kZSwgbm9kZSwgbW92ZVR5cGUsIGlzU2lsZW50KSB7XG5cdFx0XHRpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXHRcdFx0aWYgKHRhcmdldE5vZGUgJiYgIXRhcmdldE5vZGUuaXNQYXJlbnQgJiYgdGhpcy5zZXR0aW5nLmRhdGEua2VlcC5sZWFmICYmIG1vdmVUeXBlID09PSBjb25zdHMubW92ZS5UWVBFX0lOTkVSKSByZXR1cm4gbnVsbDtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdG5ld05vZGUgPSB0b29scy5jbG9uZShub2RlKTtcblx0XHRcdGlmICghdGFyZ2V0Tm9kZSkge1xuXHRcdFx0XHR0YXJnZXROb2RlID0gbnVsbDtcblx0XHRcdFx0bW92ZVR5cGUgPSBjb25zdHMubW92ZS5UWVBFX0lOTkVSO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVIpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29weUNhbGxiYWNrKCkge1xuXHRcdFx0XHRcdHZpZXcuYWRkTm9kZXMoX3RoaXMuc2V0dGluZywgdGFyZ2V0Tm9kZSwgW25ld05vZGVdLCBpc1NpbGVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodG9vbHMuY2FuQXN5bmModGhpcy5zZXR0aW5nLCB0YXJnZXROb2RlKSkge1xuXHRcdFx0XHRcdHZpZXcuYXN5bmNOb2RlKHRoaXMuc2V0dGluZywgdGFyZ2V0Tm9kZSwgaXNTaWxlbnQsIGNvcHlDYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29weUNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZpZXcuYWRkTm9kZXModGhpcy5zZXR0aW5nLCB0YXJnZXROb2RlLnBhcmVudE5vZGUsIFtuZXdOb2RlXSwgaXNTaWxlbnQpO1xuXHRcdFx0XHR2aWV3Lm1vdmVOb2RlKHRoaXMuc2V0dGluZywgdGFyZ2V0Tm9kZSwgbmV3Tm9kZSwgbW92ZVR5cGUsIGZhbHNlLCBpc1NpbGVudCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3Tm9kZTtcblx0XHR9XG5cdFx0elRyZWVUb29scy5lZGl0TmFtZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdGlmICghbm9kZSB8fCAhbm9kZS50SWQgfHwgbm9kZSAhPT0gZGF0YS5nZXROb2RlQ2FjaGUodGhpcy5zZXR0aW5nLCBub2RlLnRJZCkpIHJldHVybjtcblx0XHRcdGlmIChub2RlLnBhcmVudFRJZCkgdmlldy5leHBhbmRDb2xsYXBzZVBhcmVudE5vZGUodGhpcy5zZXR0aW5nLCBub2RlLmdldFBhcmVudE5vZGUoKSwgdHJ1ZSk7XG5cdFx0XHR2aWV3LmVkaXROb2RlKHRoaXMuc2V0dGluZywgbm9kZSlcblx0XHR9XG5cdFx0elRyZWVUb29scy5tb3ZlTm9kZSA9IGZ1bmN0aW9uKHRhcmdldE5vZGUsIG5vZGUsIG1vdmVUeXBlLCBpc1NpbGVudCkge1xuXHRcdFx0aWYgKCFub2RlKSByZXR1cm4gbm9kZTtcblx0XHRcdGlmICh0YXJnZXROb2RlICYmICF0YXJnZXROb2RlLmlzUGFyZW50ICYmIHRoaXMuc2V0dGluZy5kYXRhLmtlZXAubGVhZiAmJiBtb3ZlVHlwZSA9PT0gY29uc3RzLm1vdmUuVFlQRV9JTk5FUikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Tm9kZSAmJiAoKG5vZGUucGFyZW50VElkID09IHRhcmdldE5vZGUudElkICYmIG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVIpIHx8ICQkKG5vZGUsIHRoaXMuc2V0dGluZykuZmluZChcIiNcIiArIHRhcmdldE5vZGUudElkKS5sZW5ndGggPiAwKSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAoIXRhcmdldE5vZGUpIHtcblx0XHRcdFx0dGFyZ2V0Tm9kZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0ZnVuY3Rpb24gbW92ZUNhbGxiYWNrKCkge1xuXHRcdFx0XHR2aWV3Lm1vdmVOb2RlKF90aGlzLnNldHRpbmcsIHRhcmdldE5vZGUsIG5vZGUsIG1vdmVUeXBlLCBmYWxzZSwgaXNTaWxlbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRvb2xzLmNhbkFzeW5jKHRoaXMuc2V0dGluZywgdGFyZ2V0Tm9kZSkgJiYgbW92ZVR5cGUgPT09IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVIpIHtcblx0XHRcdFx0dmlldy5hc3luY05vZGUodGhpcy5zZXR0aW5nLCB0YXJnZXROb2RlLCBpc1NpbGVudCwgbW92ZUNhbGxiYWNrKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vdmVDYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fVxuXHRcdHpUcmVlVG9vbHMuc2V0RWRpdGFibGUgPSBmdW5jdGlvbihlZGl0YWJsZSkge1xuXHRcdFx0dGhpcy5zZXR0aW5nLmVkaXQuZW5hYmxlID0gZWRpdGFibGU7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXHR9LFxuXHQvL21ldGhvZCBvZiBvcGVyYXRlIGRhdGFcblx0X2RhdGEgPSB7XG5cdFx0c2V0U29uTm9kZUxldmVsOiBmdW5jdGlvbihzZXR0aW5nLCBwYXJlbnROb2RlLCBub2RlKSB7XG5cdFx0XHRpZiAoIW5vZGUpIHJldHVybjtcblx0XHRcdHZhciBjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW47XG5cdFx0XHRub2RlLmxldmVsID0gKHBhcmVudE5vZGUpPyBwYXJlbnROb2RlLmxldmVsICsgMSA6IDA7XG5cdFx0XHRpZiAoIW5vZGVbY2hpbGRLZXldKSByZXR1cm47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVbY2hpbGRLZXldLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAobm9kZVtjaGlsZEtleV1baV0pIGRhdGEuc2V0U29uTm9kZUxldmVsKHNldHRpbmcsIG5vZGUsIG5vZGVbY2hpbGRLZXldW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdC8vbWV0aG9kIG9mIGV2ZW50IHByb3h5XG5cdF9ldmVudCA9IHtcblxuXHR9LFxuXHQvL21ldGhvZCBvZiBldmVudCBoYW5kbGVyXG5cdF9oYW5kbGVyID0ge1xuXHRcdG9uSG92ZXJPdmVyTm9kZTogZnVuY3Rpb24oZXZlbnQsIG5vZGUpIHtcblx0XHRcdHZhciBzZXR0aW5nID0gZGF0YS5nZXRTZXR0aW5nKGV2ZW50LmRhdGEudHJlZUlkKSxcblx0XHRcdHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyk7XG5cdFx0XHRpZiAocm9vdC5jdXJIb3Zlck5vZGUgIT0gbm9kZSkge1xuXHRcdFx0XHRfaGFuZGxlci5vbkhvdmVyT3V0Tm9kZShldmVudCk7XG5cdFx0XHR9XG5cdFx0XHRyb290LmN1ckhvdmVyTm9kZSA9IG5vZGU7XG5cdFx0XHR2aWV3LmFkZEhvdmVyRG9tKHNldHRpbmcsIG5vZGUpO1xuXHRcdH0sXG5cdFx0b25Ib3Zlck91dE5vZGU6IGZ1bmN0aW9uKGV2ZW50LCBub2RlKSB7XG5cdFx0XHR2YXIgc2V0dGluZyA9IGRhdGEuZ2V0U2V0dGluZyhldmVudC5kYXRhLnRyZWVJZCksXG5cdFx0XHRyb290ID0gZGF0YS5nZXRSb290KHNldHRpbmcpO1xuXHRcdFx0aWYgKHJvb3QuY3VySG92ZXJOb2RlICYmICFkYXRhLmlzU2VsZWN0ZWROb2RlKHNldHRpbmcsIHJvb3QuY3VySG92ZXJOb2RlKSkge1xuXHRcdFx0XHR2aWV3LnJlbW92ZVRyZWVEb20oc2V0dGluZywgcm9vdC5jdXJIb3Zlck5vZGUpO1xuXHRcdFx0XHRyb290LmN1ckhvdmVyTm9kZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbk1vdXNlZG93bk5vZGU6IGZ1bmN0aW9uKGV2ZW50TW91c2VEb3duLCBfbm9kZSkge1xuXHRcdFx0dmFyIGksbCxcblx0XHRcdHNldHRpbmcgPSBkYXRhLmdldFNldHRpbmcoZXZlbnRNb3VzZURvd24uZGF0YS50cmVlSWQpLFxuXHRcdFx0cm9vdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKSwgcm9vdHMgPSBkYXRhLmdldFJvb3RzKCk7XG5cdFx0XHQvL3JpZ2h0IGNsaWNrIGNhbid0IGRyYWcgJiBkcm9wXG5cdFx0XHRpZiAoZXZlbnRNb3VzZURvd24uYnV0dG9uID09IDIgfHwgIXNldHRpbmcuZWRpdC5lbmFibGUgfHwgKCFzZXR0aW5nLmVkaXQuZHJhZy5pc0NvcHkgJiYgIXNldHRpbmcuZWRpdC5kcmFnLmlzTW92ZSkpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvL2lucHV0IG9mIGVkaXQgbm9kZSBuYW1lIGNhbid0IGRyYWcgJiBkcm9wXG5cdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnRNb3VzZURvd24udGFyZ2V0LFxuXHRcdFx0X25vZGVzID0gZGF0YS5nZXRSb290KHNldHRpbmcpLmN1clNlbGVjdGVkTGlzdCxcblx0XHRcdG5vZGVzID0gW107XG5cdFx0XHRpZiAoIWRhdGEuaXNTZWxlY3RlZE5vZGUoc2V0dGluZywgX25vZGUpKSB7XG5cdFx0XHRcdG5vZGVzID0gW19ub2RlXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaT0wLCBsPV9ub2Rlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKF9ub2Rlc1tpXS5lZGl0TmFtZUZsYWcgJiYgdG9vbHMuZXFzKHRhcmdldC50YWdOYW1lLCBcImlucHV0XCIpICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmVlTm9kZVwiK2NvbnN0cy5pZC5JTlBVVCkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2Rlcy5wdXNoKF9ub2Rlc1tpXSk7XG5cdFx0XHRcdFx0aWYgKG5vZGVzWzBdLnBhcmVudFRJZCAhPT0gX25vZGVzW2ldLnBhcmVudFRJZCkge1xuXHRcdFx0XHRcdFx0bm9kZXMgPSBbX25vZGVdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZpZXcuZWRpdE5vZGVCbHVyID0gdHJ1ZTtcblx0XHRcdHZpZXcuY2FuY2VsQ3VyRWRpdE5vZGUoc2V0dGluZyk7XG5cblx0XHRcdHZhciBkb2MgPSAkKHNldHRpbmcudHJlZU9iai5nZXQoMCkub3duZXJEb2N1bWVudCksXG5cdFx0XHRib2R5ID0gJChzZXR0aW5nLnRyZWVPYmouZ2V0KDApLm93bmVyRG9jdW1lbnQuYm9keSksIGN1ck5vZGUsIHRtcEFycm93LCB0bXBUYXJnZXQsXG5cdFx0XHRpc090aGVyVHJlZSA9IGZhbHNlLFxuXHRcdFx0dGFyZ2V0U2V0dGluZyA9IHNldHRpbmcsXG5cdFx0XHRzb3VyY2VTZXR0aW5nID0gc2V0dGluZyxcblx0XHRcdHByZU5vZGUsIG5leHROb2RlLFxuXHRcdFx0cHJlVG1wVGFyZ2V0Tm9kZUlkID0gbnVsbCxcblx0XHRcdHByZVRtcE1vdmVUeXBlID0gbnVsbCxcblx0XHRcdHRtcFRhcmdldE5vZGVJZCA9IG51bGwsXG5cdFx0XHRtb3ZlVHlwZSA9IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVIsXG5cdFx0XHRtb3VzZURvd25YID0gZXZlbnRNb3VzZURvd24uY2xpZW50WCxcblx0XHRcdG1vdXNlRG93blkgPSBldmVudE1vdXNlRG93bi5jbGllbnRZLFxuXHRcdFx0c3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0aWYgKHRvb2xzLnVDYW5EbyhzZXR0aW5nKSkge1xuXHRcdFx0XHRkb2MuYmluZChcIm1vdXNlbW92ZVwiLCBfZG9jTW91c2VNb3ZlKTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIF9kb2NNb3VzZU1vdmUoZXZlbnQpIHtcblx0XHRcdFx0Ly9hdm9pZCBzdGFydCBkcmFnIGFmdGVyIGNsaWNrIG5vZGVcblx0XHRcdFx0aWYgKHJvb3QuZHJhZ0ZsYWcgPT0gMCAmJiBNYXRoLmFicyhtb3VzZURvd25YIC0gZXZlbnQuY2xpZW50WCkgPCBzZXR0aW5nLmVkaXQuZHJhZy5taW5Nb3ZlU2l6ZVxuXHRcdFx0XHRcdCYmIE1hdGguYWJzKG1vdXNlRG93blkgLSBldmVudC5jbGllbnRZKSA8IHNldHRpbmcuZWRpdC5kcmFnLm1pbk1vdmVTaXplKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGksIGwsIHRtcE5vZGUsIHRtcERvbSwgdG1wTm9kZXMsXG5cdFx0XHRcdGNoaWxkS2V5ID0gc2V0dGluZy5kYXRhLmtleS5jaGlsZHJlbjtcblx0XHRcdFx0Ym9keS5jc3MoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpO1xuXG5cdFx0XHRcdGlmIChyb290LmRyYWdGbGFnID09IDApIHtcblx0XHRcdFx0XHRpZiAodG9vbHMuYXBwbHkoc2V0dGluZy5jYWxsYmFjay5iZWZvcmVEcmFnLCBbc2V0dGluZy50cmVlSWQsIG5vZGVzXSwgdHJ1ZSkgPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdF9kb2NNb3VzZVVwKGV2ZW50KTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoaT0wLCBsPW5vZGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChpPT0wKSB7XG5cdFx0XHRcdFx0XHRcdHJvb3QuZHJhZ05vZGVTaG93QmVmb3JlID0gW107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0bXBOb2RlID0gbm9kZXNbaV07XG5cdFx0XHRcdFx0XHRpZiAodG1wTm9kZS5pc1BhcmVudCAmJiB0bXBOb2RlLm9wZW4pIHtcblx0XHRcdFx0XHRcdFx0dmlldy5leHBhbmRDb2xsYXBzZU5vZGUoc2V0dGluZywgdG1wTm9kZSwgIXRtcE5vZGUub3Blbik7XG5cdFx0XHRcdFx0XHRcdHJvb3QuZHJhZ05vZGVTaG93QmVmb3JlW3RtcE5vZGUudElkXSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyb290LmRyYWdOb2RlU2hvd0JlZm9yZVt0bXBOb2RlLnRJZF0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyb290LmRyYWdGbGFnID0gMTtcblx0XHRcdFx0XHRyb290cy5zaG93SG92ZXJEb20gPSBmYWxzZTtcblx0XHRcdFx0XHR0b29scy5zaG93SWZhbWVNYXNrKHNldHRpbmcsIHRydWUpO1xuXG5cdFx0XHRcdFx0Ly9zb3J0XG5cdFx0XHRcdFx0dmFyIGlzT3JkZXIgPSB0cnVlLCBsYXN0SW5kZXggPSAtMTtcblx0XHRcdFx0XHRpZiAobm9kZXMubGVuZ3RoPjEpIHtcblx0XHRcdFx0XHRcdHZhciBwTm9kZXMgPSBub2Rlc1swXS5wYXJlbnRUSWQgPyBub2Rlc1swXS5nZXRQYXJlbnROb2RlKClbY2hpbGRLZXldIDogZGF0YS5nZXROb2RlcyhzZXR0aW5nKTtcblx0XHRcdFx0XHRcdHRtcE5vZGVzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKGk9MCwgbD1wTm9kZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAocm9vdC5kcmFnTm9kZVNob3dCZWZvcmVbcE5vZGVzW2ldLnRJZF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpc09yZGVyICYmIGxhc3RJbmRleCA+IC0xICYmIChsYXN0SW5kZXgrMSkgIT09IGkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlzT3JkZXIgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dG1wTm9kZXMucHVzaChwTm9kZXNbaV0pO1xuXHRcdFx0XHRcdFx0XHRcdGxhc3RJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKG5vZGVzLmxlbmd0aCA9PT0gdG1wTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZXMgPSB0bXBOb2Rlcztcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaXNPcmRlcikge1xuXHRcdFx0XHRcdFx0cHJlTm9kZSA9IG5vZGVzWzBdLmdldFByZU5vZGUoKTtcblx0XHRcdFx0XHRcdG5leHROb2RlID0gbm9kZXNbbm9kZXMubGVuZ3RoLTFdLmdldE5leHROb2RlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9zZXQgbm9kZSBpbiBzZWxlY3RlZFxuXHRcdFx0XHRcdGN1ck5vZGUgPSAkJChcIjx1bCBjbGFzcz0nelRyZWVEcmFnVUwnPjwvdWw+XCIsIHNldHRpbmcpO1xuXHRcdFx0XHRcdGZvciAoaT0wLCBsPW5vZGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0XHRcdHRtcE5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdFx0XHRcdHRtcE5vZGUuZWRpdE5hbWVGbGFnID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR2aWV3LnNlbGVjdE5vZGUoc2V0dGluZywgdG1wTm9kZSwgaT4wKTtcblx0XHRcdFx0XHRcdHZpZXcucmVtb3ZlVHJlZURvbShzZXR0aW5nLCB0bXBOb2RlKTtcblxuXHRcdFx0XHRcdFx0aWYgKGkgPiBzZXR0aW5nLmVkaXQuZHJhZy5tYXhTaG93Tm9kZU51bS0xKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0bXBEb20gPSAkJChcIjxsaSBpZD0nXCIrIHRtcE5vZGUudElkICtcIl90bXAnPjwvbGk+XCIsIHNldHRpbmcpO1xuXHRcdFx0XHRcdFx0dG1wRG9tLmFwcGVuZCgkJCh0bXBOb2RlLCBjb25zdHMuaWQuQSwgc2V0dGluZykuY2xvbmUoKSk7XG5cdFx0XHRcdFx0XHR0bXBEb20uY3NzKFwicGFkZGluZ1wiLCBcIjBcIik7XG5cdFx0XHRcdFx0XHR0bXBEb20uY2hpbGRyZW4oXCIjXCIgKyB0bXBOb2RlLnRJZCArIGNvbnN0cy5pZC5BKS5yZW1vdmVDbGFzcyhjb25zdHMubm9kZS5DVVJTRUxFQ1RFRCk7XG5cdFx0XHRcdFx0XHRjdXJOb2RlLmFwcGVuZCh0bXBEb20pO1xuXHRcdFx0XHRcdFx0aWYgKGkgPT0gc2V0dGluZy5lZGl0LmRyYWcubWF4U2hvd05vZGVOdW0tMSkge1xuXHRcdFx0XHRcdFx0XHR0bXBEb20gPSAkJChcIjxsaSBpZD0nXCIrIHRtcE5vZGUudElkICtcIl9tb3JldG1wJz48YT4gIC4uLiAgPC9hPjwvbGk+XCIsIHNldHRpbmcpO1xuXHRcdFx0XHRcdFx0XHRjdXJOb2RlLmFwcGVuZCh0bXBEb20pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJOb2RlLmF0dHIoXCJpZFwiLCBub2Rlc1swXS50SWQgKyBjb25zdHMuaWQuVUwgKyBcIl90bXBcIik7XG5cdFx0XHRcdFx0Y3VyTm9kZS5hZGRDbGFzcyhzZXR0aW5nLnRyZWVPYmouYXR0cihcImNsYXNzXCIpKTtcblx0XHRcdFx0XHRjdXJOb2RlLmFwcGVuZFRvKGJvZHkpO1xuXG5cdFx0XHRcdFx0dG1wQXJyb3cgPSAkJChcIjxzcGFuIGNsYXNzPSd0bXB6VHJlZU1vdmVfYXJyb3cnPjwvc3Bhbj5cIiwgc2V0dGluZyk7XG5cdFx0XHRcdFx0dG1wQXJyb3cuYXR0cihcImlkXCIsIFwielRyZWVNb3ZlX2Fycm93X3RtcFwiKTtcblx0XHRcdFx0XHR0bXBBcnJvdy5hcHBlbmRUbyhib2R5KTtcblxuXHRcdFx0XHRcdHNldHRpbmcudHJlZU9iai50cmlnZ2VyKGNvbnN0cy5ldmVudC5EUkFHLCBbZXZlbnQsIHNldHRpbmcudHJlZUlkLCBub2Rlc10pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJvb3QuZHJhZ0ZsYWcgPT0gMSkge1xuXHRcdFx0XHRcdGlmICh0bXBUYXJnZXQgJiYgdG1wQXJyb3cuYXR0cihcImlkXCIpID09IGV2ZW50LnRhcmdldC5pZCAmJiB0bXBUYXJnZXROb2RlSWQgJiYgKGV2ZW50LmNsaWVudFggKyBkb2Muc2Nyb2xsTGVmdCgpKzIpID4gKCQoXCIjXCIgKyB0bXBUYXJnZXROb2RlSWQgKyBjb25zdHMuaWQuQSwgdG1wVGFyZ2V0KS5vZmZzZXQoKS5sZWZ0KSkge1xuXHRcdFx0XHRcdFx0dmFyIHhUID0gJChcIiNcIiArIHRtcFRhcmdldE5vZGVJZCArIGNvbnN0cy5pZC5BLCB0bXBUYXJnZXQpO1xuXHRcdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ID0gKHhULmxlbmd0aCA+IDApID8geFQuZ2V0KDApIDogZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodG1wVGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHR0bXBUYXJnZXQucmVtb3ZlQ2xhc3MoY29uc3RzLm5vZGUuVE1QVEFSR0VUX1RSRUUpO1xuXHRcdFx0XHRcdFx0aWYgKHRtcFRhcmdldE5vZGVJZCkgJChcIiNcIiArIHRtcFRhcmdldE5vZGVJZCArIGNvbnN0cy5pZC5BLCB0bXBUYXJnZXQpLnJlbW92ZUNsYXNzKGNvbnN0cy5ub2RlLlRNUFRBUkdFVF9OT0RFICsgXCJfXCIgKyBjb25zdHMubW92ZS5UWVBFX1BSRVYpXG5cdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhjb25zdHMubm9kZS5UTVBUQVJHRVRfTk9ERSArIFwiX1wiICsgX2NvbnN0cy5tb3ZlLlRZUEVfTkVYVCkucmVtb3ZlQ2xhc3MoY29uc3RzLm5vZGUuVE1QVEFSR0VUX05PREUgKyBcIl9cIiArIF9jb25zdHMubW92ZS5UWVBFX0lOTkVSKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG1wVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHR0bXBUYXJnZXROb2RlSWQgPSBudWxsO1xuXG5cdFx0XHRcdFx0Ly9qdWRnZSBkcmFnICYgZHJvcCBpbiBtdWx0aSB6dHJlZVxuXHRcdFx0XHRcdGlzT3RoZXJUcmVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGFyZ2V0U2V0dGluZyA9IHNldHRpbmc7XG5cdFx0XHRcdFx0dmFyIHNldHRpbmdzID0gZGF0YS5nZXRTZXR0aW5ncygpO1xuXHRcdFx0XHRcdGZvciAodmFyIHMgaW4gc2V0dGluZ3MpIHtcblx0XHRcdFx0XHRcdGlmIChzZXR0aW5nc1tzXS50cmVlSWQgJiYgc2V0dGluZ3Nbc10uZWRpdC5lbmFibGUgJiYgc2V0dGluZ3Nbc10udHJlZUlkICE9IHNldHRpbmcudHJlZUlkXG5cdFx0XHRcdFx0XHRcdCYmIChldmVudC50YXJnZXQuaWQgPT0gc2V0dGluZ3Nbc10udHJlZUlkIHx8ICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKFwiI1wiICsgc2V0dGluZ3Nbc10udHJlZUlkKS5sZW5ndGg+MCkpIHtcblx0XHRcdFx0XHRcdFx0aXNPdGhlclRyZWUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRTZXR0aW5nID0gc2V0dGluZ3Nbc107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGRvY1Njcm9sbFRvcCA9IGRvYy5zY3JvbGxUb3AoKSxcblx0XHRcdFx0XHRkb2NTY3JvbGxMZWZ0ID0gZG9jLnNjcm9sbExlZnQoKSxcblx0XHRcdFx0XHR0cmVlT2Zmc2V0ID0gdGFyZ2V0U2V0dGluZy50cmVlT2JqLm9mZnNldCgpLFxuXHRcdFx0XHRcdHNjcm9sbEhlaWdodCA9IHRhcmdldFNldHRpbmcudHJlZU9iai5nZXQoMCkuc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0XHRcdHNjcm9sbFdpZHRoID0gdGFyZ2V0U2V0dGluZy50cmVlT2JqLmdldCgwKS5zY3JvbGxXaWR0aCxcblx0XHRcdFx0XHRkVG9wID0gKGV2ZW50LmNsaWVudFkgKyBkb2NTY3JvbGxUb3AgLSB0cmVlT2Zmc2V0LnRvcCksXG5cdFx0XHRcdFx0ZEJvdHRvbSA9ICh0YXJnZXRTZXR0aW5nLnRyZWVPYmouaGVpZ2h0KCkgKyB0cmVlT2Zmc2V0LnRvcCAtIGV2ZW50LmNsaWVudFkgLSBkb2NTY3JvbGxUb3ApLFxuXHRcdFx0XHRcdGRMZWZ0ID0gKGV2ZW50LmNsaWVudFggKyBkb2NTY3JvbGxMZWZ0IC0gdHJlZU9mZnNldC5sZWZ0KSxcblx0XHRcdFx0XHRkUmlnaHQgPSAodGFyZ2V0U2V0dGluZy50cmVlT2JqLndpZHRoKCkgKyB0cmVlT2Zmc2V0LmxlZnQgLSBldmVudC5jbGllbnRYIC0gZG9jU2Nyb2xsTGVmdCksXG5cdFx0XHRcdFx0aXNUb3AgPSAoZFRvcCA8IHNldHRpbmcuZWRpdC5kcmFnLmJvcmRlck1heCAmJiBkVG9wID4gc2V0dGluZy5lZGl0LmRyYWcuYm9yZGVyTWluKSxcblx0XHRcdFx0XHRpc0JvdHRvbSA9IChkQm90dG9tIDwgc2V0dGluZy5lZGl0LmRyYWcuYm9yZGVyTWF4ICYmIGRCb3R0b20gPiBzZXR0aW5nLmVkaXQuZHJhZy5ib3JkZXJNaW4pLFxuXHRcdFx0XHRcdGlzTGVmdCA9IChkTGVmdCA8IHNldHRpbmcuZWRpdC5kcmFnLmJvcmRlck1heCAmJiBkTGVmdCA+IHNldHRpbmcuZWRpdC5kcmFnLmJvcmRlck1pbiksXG5cdFx0XHRcdFx0aXNSaWdodCA9IChkUmlnaHQgPCBzZXR0aW5nLmVkaXQuZHJhZy5ib3JkZXJNYXggJiYgZFJpZ2h0ID4gc2V0dGluZy5lZGl0LmRyYWcuYm9yZGVyTWluKSxcblx0XHRcdFx0XHRpc1RyZWVJbm5lciA9IGRUb3AgPiBzZXR0aW5nLmVkaXQuZHJhZy5ib3JkZXJNaW4gJiYgZEJvdHRvbSA+IHNldHRpbmcuZWRpdC5kcmFnLmJvcmRlck1pbiAmJiBkTGVmdCA+IHNldHRpbmcuZWRpdC5kcmFnLmJvcmRlck1pbiAmJiBkUmlnaHQgPiBzZXR0aW5nLmVkaXQuZHJhZy5ib3JkZXJNaW4sXG5cdFx0XHRcdFx0aXNUcmVlVG9wID0gKGlzVG9wICYmIHRhcmdldFNldHRpbmcudHJlZU9iai5zY3JvbGxUb3AoKSA8PSAwKSxcblx0XHRcdFx0XHRpc1RyZWVCb3R0b20gPSAoaXNCb3R0b20gJiYgKHRhcmdldFNldHRpbmcudHJlZU9iai5zY3JvbGxUb3AoKSArIHRhcmdldFNldHRpbmcudHJlZU9iai5oZWlnaHQoKSsxMCkgPj0gc2Nyb2xsSGVpZ2h0KSxcblx0XHRcdFx0XHRpc1RyZWVMZWZ0ID0gKGlzTGVmdCAmJiB0YXJnZXRTZXR0aW5nLnRyZWVPYmouc2Nyb2xsTGVmdCgpIDw9IDApLFxuXHRcdFx0XHRcdGlzVHJlZVJpZ2h0ID0gKGlzUmlnaHQgJiYgKHRhcmdldFNldHRpbmcudHJlZU9iai5zY3JvbGxMZWZ0KCkgKyB0YXJnZXRTZXR0aW5nLnRyZWVPYmoud2lkdGgoKSsxMCkgPj0gc2Nyb2xsV2lkdGgpO1xuXG5cdFx0XHRcdFx0aWYgKGV2ZW50LnRhcmdldCAmJiB0b29scy5pc0NoaWxkT3JTZWxmKGV2ZW50LnRhcmdldCwgdGFyZ2V0U2V0dGluZy50cmVlSWQpKSB7XG5cdFx0XHRcdFx0XHQvL2dldCBub2RlIDxsaT4gZG9tXG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0T2JqID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHRhcmdldE9iaiAmJiB0YXJnZXRPYmoudGFnTmFtZSAmJiAhdG9vbHMuZXFzKHRhcmdldE9iai50YWdOYW1lLCBcImxpXCIpICYmIHRhcmdldE9iai5pZCAhPSB0YXJnZXRTZXR0aW5nLnRyZWVJZCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRPYmogPSB0YXJnZXRPYmoucGFyZW50Tm9kZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGNhbk1vdmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Ly9kb24ndCBtb3ZlIHRvIHNlbGYgb3IgY2hpbGRyZW4gb2Ygc2VsZlxuXHRcdFx0XHRcdFx0Zm9yIChpPTAsIGw9bm9kZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0bXBOb2RlID0gbm9kZXNbaV07XG5cdFx0XHRcdFx0XHRcdGlmICh0YXJnZXRPYmouaWQgPT09IHRtcE5vZGUudElkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FuTW92ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCQkKHRtcE5vZGUsIHNldHRpbmcpLmZpbmQoXCIjXCIgKyB0YXJnZXRPYmouaWQpLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRjYW5Nb3ZlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjYW5Nb3ZlICYmIGV2ZW50LnRhcmdldCAmJiB0b29scy5pc0NoaWxkT3JTZWxmKGV2ZW50LnRhcmdldCwgdGFyZ2V0T2JqLmlkICsgY29uc3RzLmlkLkEpKSB7XG5cdFx0XHRcdFx0XHRcdHRtcFRhcmdldCA9ICQodGFyZ2V0T2JqKTtcblx0XHRcdFx0XHRcdFx0dG1wVGFyZ2V0Tm9kZUlkID0gdGFyZ2V0T2JqLmlkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vdGhlIG1vdXNlIG11c3QgYmUgaW4gelRyZWVcblx0XHRcdFx0XHR0bXBOb2RlID0gbm9kZXNbMF07XG5cdFx0XHRcdFx0aWYgKGlzVHJlZUlubmVyICYmIHRvb2xzLmlzQ2hpbGRPclNlbGYoZXZlbnQudGFyZ2V0LCB0YXJnZXRTZXR0aW5nLnRyZWVJZCkpIHtcblx0XHRcdFx0XHRcdC8vanVkZ2UgbW91c2UgbW92ZSBpbiByb290IG9mIHp0cmVlXG5cdFx0XHRcdFx0XHRpZiAoIXRtcFRhcmdldCAmJiAoZXZlbnQudGFyZ2V0LmlkID09IHRhcmdldFNldHRpbmcudHJlZUlkIHx8IGlzVHJlZVRvcCB8fCBpc1RyZWVCb3R0b20gfHwgaXNUcmVlTGVmdCB8fCBpc1RyZWVSaWdodCkgJiYgKGlzT3RoZXJUcmVlIHx8ICghaXNPdGhlclRyZWUgJiYgdG1wTm9kZS5wYXJlbnRUSWQpKSkge1xuXHRcdFx0XHRcdFx0XHR0bXBUYXJnZXQgPSB0YXJnZXRTZXR0aW5nLnRyZWVPYmo7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL2F1dG8gc2Nyb2xsIHRvcFxuXHRcdFx0XHRcdFx0aWYgKGlzVG9wKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFNldHRpbmcudHJlZU9iai5zY3JvbGxUb3AodGFyZ2V0U2V0dGluZy50cmVlT2JqLnNjcm9sbFRvcCgpLTEwKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNCb3R0b20pICB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFNldHRpbmcudHJlZU9iai5zY3JvbGxUb3AodGFyZ2V0U2V0dGluZy50cmVlT2JqLnNjcm9sbFRvcCgpKzEwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpc0xlZnQpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0U2V0dGluZy50cmVlT2JqLnNjcm9sbExlZnQodGFyZ2V0U2V0dGluZy50cmVlT2JqLnNjcm9sbExlZnQoKS0xMCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzUmlnaHQpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0U2V0dGluZy50cmVlT2JqLnNjcm9sbExlZnQodGFyZ2V0U2V0dGluZy50cmVlT2JqLnNjcm9sbExlZnQoKSsxMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL2F1dG8gc2Nyb2xsIGxlZnRcblx0XHRcdFx0XHRcdGlmICh0bXBUYXJnZXQgJiYgdG1wVGFyZ2V0ICE9IHRhcmdldFNldHRpbmcudHJlZU9iaiAmJiB0bXBUYXJnZXQub2Zmc2V0KCkubGVmdCA8IHRhcmdldFNldHRpbmcudHJlZU9iai5vZmZzZXQoKS5sZWZ0KSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFNldHRpbmcudHJlZU9iai5zY3JvbGxMZWZ0KHRhcmdldFNldHRpbmcudHJlZU9iai5zY3JvbGxMZWZ0KCkrIHRtcFRhcmdldC5vZmZzZXQoKS5sZWZ0IC0gdGFyZ2V0U2V0dGluZy50cmVlT2JqLm9mZnNldCgpLmxlZnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1ck5vZGUuY3NzKHtcblx0XHRcdFx0XHRcdFwidG9wXCI6IChldmVudC5jbGllbnRZICsgZG9jU2Nyb2xsVG9wICsgMykgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHRcImxlZnRcIjogKGV2ZW50LmNsaWVudFggKyBkb2NTY3JvbGxMZWZ0ICsgMykgKyBcInB4XCJcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHZhciBkWCA9IDA7XG5cdFx0XHRcdFx0dmFyIGRZID0gMDtcblx0XHRcdFx0XHRpZiAodG1wVGFyZ2V0ICYmIHRtcFRhcmdldC5hdHRyKFwiaWRcIikhPXRhcmdldFNldHRpbmcudHJlZUlkKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG1wVGFyZ2V0Tm9kZSA9IHRtcFRhcmdldE5vZGVJZCA9PSBudWxsID8gbnVsbDogZGF0YS5nZXROb2RlQ2FjaGUodGFyZ2V0U2V0dGluZywgdG1wVGFyZ2V0Tm9kZUlkKSxcblx0XHRcdFx0XHRcdGlzQ29weSA9ICgoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJiBzZXR0aW5nLmVkaXQuZHJhZy5pc01vdmUgJiYgc2V0dGluZy5lZGl0LmRyYWcuaXNDb3B5KSB8fCAoIXNldHRpbmcuZWRpdC5kcmFnLmlzTW92ZSAmJiBzZXR0aW5nLmVkaXQuZHJhZy5pc0NvcHkpLFxuXHRcdFx0XHRcdFx0aXNQcmV2ID0gISEocHJlTm9kZSAmJiB0bXBUYXJnZXROb2RlSWQgPT09IHByZU5vZGUudElkKSxcblx0XHRcdFx0XHRcdGlzTmV4dCA9ICEhKG5leHROb2RlICYmIHRtcFRhcmdldE5vZGVJZCA9PT0gbmV4dE5vZGUudElkKSxcblx0XHRcdFx0XHRcdGlzSW5uZXIgPSAodG1wTm9kZS5wYXJlbnRUSWQgJiYgdG1wTm9kZS5wYXJlbnRUSWQgPT0gdG1wVGFyZ2V0Tm9kZUlkKSxcblx0XHRcdFx0XHRcdGNhblByZXYgPSAoaXNDb3B5IHx8ICFpc05leHQpICYmIHRvb2xzLmFwcGx5KHRhcmdldFNldHRpbmcuZWRpdC5kcmFnLnByZXYsIFt0YXJnZXRTZXR0aW5nLnRyZWVJZCwgbm9kZXMsIHRtcFRhcmdldE5vZGVdLCAhIXRhcmdldFNldHRpbmcuZWRpdC5kcmFnLnByZXYpLFxuXHRcdFx0XHRcdFx0Y2FuTmV4dCA9IChpc0NvcHkgfHwgIWlzUHJldikgJiYgdG9vbHMuYXBwbHkodGFyZ2V0U2V0dGluZy5lZGl0LmRyYWcubmV4dCwgW3RhcmdldFNldHRpbmcudHJlZUlkLCBub2RlcywgdG1wVGFyZ2V0Tm9kZV0sICEhdGFyZ2V0U2V0dGluZy5lZGl0LmRyYWcubmV4dCksXG5cdFx0XHRcdFx0XHRjYW5Jbm5lciA9IChpc0NvcHkgfHwgIWlzSW5uZXIpICYmICEodGFyZ2V0U2V0dGluZy5kYXRhLmtlZXAubGVhZiAmJiAhdG1wVGFyZ2V0Tm9kZS5pc1BhcmVudCkgJiYgdG9vbHMuYXBwbHkodGFyZ2V0U2V0dGluZy5lZGl0LmRyYWcuaW5uZXIsIFt0YXJnZXRTZXR0aW5nLnRyZWVJZCwgbm9kZXMsIHRtcFRhcmdldE5vZGVdLCAhIXRhcmdldFNldHRpbmcuZWRpdC5kcmFnLmlubmVyKTtcblx0XHRcdFx0XHRcdGlmICghY2FuUHJldiAmJiAhY2FuTmV4dCAmJiAhY2FuSW5uZXIpIHtcblx0XHRcdFx0XHRcdFx0dG1wVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dG1wVGFyZ2V0Tm9kZUlkID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0bW92ZVR5cGUgPSBjb25zdHMubW92ZS5UWVBFX0lOTkVSO1xuXHRcdFx0XHRcdFx0XHR0bXBBcnJvdy5jc3Moe1xuXHRcdFx0XHRcdFx0XHRcdFwiZGlzcGxheVwiOlwibm9uZVwiXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRpZiAod2luZG93LnpUcmVlTW92ZVRpbWVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHdpbmRvdy56VHJlZU1vdmVUaW1lcik7XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnpUcmVlTW92ZVRhcmdldE5vZGVUSWQgPSBudWxsXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0bXBUYXJnZXRBID0gJChcIiNcIiArIHRtcFRhcmdldE5vZGVJZCArIGNvbnN0cy5pZC5BLCB0bXBUYXJnZXQpLFxuXHRcdFx0XHRcdFx0XHR0bXBOZXh0QSA9IHRtcFRhcmdldE5vZGUuaXNMYXN0Tm9kZSA/IG51bGwgOiAkKFwiI1wiICsgdG1wVGFyZ2V0Tm9kZS5nZXROZXh0Tm9kZSgpLnRJZCArIGNvbnN0cy5pZC5BLCB0bXBUYXJnZXQubmV4dCgpKSxcblx0XHRcdFx0XHRcdFx0dG1wVG9wID0gdG1wVGFyZ2V0QS5vZmZzZXQoKS50b3AsXG5cdFx0XHRcdFx0XHRcdHRtcExlZnQgPSB0bXBUYXJnZXRBLm9mZnNldCgpLmxlZnQsXG5cdFx0XHRcdFx0XHRcdHByZXZQZXJjZW50ID0gY2FuUHJldiA/IChjYW5Jbm5lciA/IDAuMjUgOiAoY2FuTmV4dCA/IDAuNSA6IDEpICkgOiAtMSxcblx0XHRcdFx0XHRcdFx0bmV4dFBlcmNlbnQgPSBjYW5OZXh0ID8gKGNhbklubmVyID8gMC43NSA6IChjYW5QcmV2ID8gMC41IDogMCkgKSA6IC0xLFxuXHRcdFx0XHRcdFx0XHRkWV9wZXJjZW50ID0gKGV2ZW50LmNsaWVudFkgKyBkb2NTY3JvbGxUb3AgLSB0bXBUb3ApL3RtcFRhcmdldEEuaGVpZ2h0KCk7XG5cdFx0XHRcdFx0XHRcdGlmICgocHJldlBlcmNlbnQ9PTEgfHxkWV9wZXJjZW50PD1wcmV2UGVyY2VudCAmJiBkWV9wZXJjZW50Pj0tLjIpICYmIGNhblByZXYpIHtcblx0XHRcdFx0XHRcdFx0XHRkWCA9IDEgLSB0bXBBcnJvdy53aWR0aCgpO1xuXHRcdFx0XHRcdFx0XHRcdGRZID0gdG1wVG9wIC0gdG1wQXJyb3cuaGVpZ2h0KCkvMjtcblx0XHRcdFx0XHRcdFx0XHRtb3ZlVHlwZSA9IGNvbnN0cy5tb3ZlLlRZUEVfUFJFVjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgobmV4dFBlcmNlbnQ9PTAgfHwgZFlfcGVyY2VudD49bmV4dFBlcmNlbnQgJiYgZFlfcGVyY2VudDw9MS4yKSAmJiBjYW5OZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZFggPSAxIC0gdG1wQXJyb3cud2lkdGgoKTtcblx0XHRcdFx0XHRcdFx0XHRkWSA9ICh0bXBOZXh0QSA9PSBudWxsIHx8ICh0bXBUYXJnZXROb2RlLmlzUGFyZW50ICYmIHRtcFRhcmdldE5vZGUub3BlbikpID8gKHRtcFRvcCArIHRtcFRhcmdldEEuaGVpZ2h0KCkgLSB0bXBBcnJvdy5oZWlnaHQoKS8yKSA6ICh0bXBOZXh0QS5vZmZzZXQoKS50b3AgLSB0bXBBcnJvdy5oZWlnaHQoKS8yKTtcblx0XHRcdFx0XHRcdFx0XHRtb3ZlVHlwZSA9IGNvbnN0cy5tb3ZlLlRZUEVfTkVYVDtcblx0XHRcdFx0XHRcdFx0fWVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGRYID0gNSAtIHRtcEFycm93LndpZHRoKCk7XG5cdFx0XHRcdFx0XHRcdFx0ZFkgPSB0bXBUb3A7XG5cdFx0XHRcdFx0XHRcdFx0bW92ZVR5cGUgPSBjb25zdHMubW92ZS5UWVBFX0lOTkVSO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRtcEFycm93LmNzcyh7XG5cdFx0XHRcdFx0XHRcdFx0XCJkaXNwbGF5XCI6XCJibG9ja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwidG9wXCI6IGRZICsgXCJweFwiLFxuXHRcdFx0XHRcdFx0XHRcdFwibGVmdFwiOiAodG1wTGVmdCArIGRYKSArIFwicHhcIlxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0dG1wVGFyZ2V0QS5hZGRDbGFzcyhjb25zdHMubm9kZS5UTVBUQVJHRVRfTk9ERSArIFwiX1wiICsgbW92ZVR5cGUpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChwcmVUbXBUYXJnZXROb2RlSWQgIT0gdG1wVGFyZ2V0Tm9kZUlkIHx8IHByZVRtcE1vdmVUeXBlICE9IG1vdmVUeXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAodG1wVGFyZ2V0Tm9kZSAmJiB0bXBUYXJnZXROb2RlLmlzUGFyZW50ICYmIG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3RhcnRUaW1lciA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHdpbmRvdy56VHJlZU1vdmVUaW1lciAmJiB3aW5kb3cuelRyZWVNb3ZlVGFyZ2V0Tm9kZVRJZCAhPT0gdG1wVGFyZ2V0Tm9kZS50SWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCh3aW5kb3cuelRyZWVNb3ZlVGltZXIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2luZG93LnpUcmVlTW92ZVRhcmdldE5vZGVUSWQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdH1lbHNlIGlmICh3aW5kb3cuelRyZWVNb3ZlVGltZXIgJiYgd2luZG93LnpUcmVlTW92ZVRhcmdldE5vZGVUSWQgPT09IHRtcFRhcmdldE5vZGUudElkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFRpbWVyID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChzdGFydFRpbWVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuelRyZWVNb3ZlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobW92ZVR5cGUgIT0gY29uc3RzLm1vdmUuVFlQRV9JTk5FUikgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodG1wVGFyZ2V0Tm9kZSAmJiB0bXBUYXJnZXROb2RlLmlzUGFyZW50ICYmICF0bXBUYXJnZXROb2RlLm9wZW4gJiYgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRhcmdldFNldHRpbmcuZWRpdC5kcmFnLmF1dG9PcGVuVGltZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCYmIHRvb2xzLmFwcGx5KHRhcmdldFNldHRpbmcuY2FsbGJhY2suYmVmb3JlRHJhZ09wZW4sIFt0YXJnZXRTZXR0aW5nLnRyZWVJZCwgdG1wVGFyZ2V0Tm9kZV0sIHRydWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmlldy5zd2l0Y2hOb2RlKHRhcmdldFNldHRpbmcsIHRtcFRhcmdldE5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YXJnZXRTZXR0aW5nLmVkaXQuZHJhZy5hdXRvRXhwYW5kVHJpZ2dlcikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0U2V0dGluZy50cmVlT2JqLnRyaWdnZXIoY29uc3RzLmV2ZW50LkVYUEFORCwgW3RhcmdldFNldHRpbmcudHJlZUlkLCB0bXBUYXJnZXROb2RlXSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LCB0YXJnZXRTZXR0aW5nLmVkaXQuZHJhZy5hdXRvT3BlblRpbWUrNTApO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2luZG93LnpUcmVlTW92ZVRhcmdldE5vZGVUSWQgPSB0bXBUYXJnZXROb2RlLnRJZDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bW92ZVR5cGUgPSBjb25zdHMubW92ZS5UWVBFX0lOTkVSO1xuXHRcdFx0XHRcdFx0aWYgKHRtcFRhcmdldCAmJiB0b29scy5hcHBseSh0YXJnZXRTZXR0aW5nLmVkaXQuZHJhZy5pbm5lciwgW3RhcmdldFNldHRpbmcudHJlZUlkLCBub2RlcywgbnVsbF0sICEhdGFyZ2V0U2V0dGluZy5lZGl0LmRyYWcuaW5uZXIpKSB7XG5cdFx0XHRcdFx0XHRcdHRtcFRhcmdldC5hZGRDbGFzcyhjb25zdHMubm9kZS5UTVBUQVJHRVRfVFJFRSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0bXBUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG1wQXJyb3cuY3NzKHtcblx0XHRcdFx0XHRcdFx0XCJkaXNwbGF5XCI6XCJub25lXCJcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYgKHdpbmRvdy56VHJlZU1vdmVUaW1lcikge1xuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQod2luZG93LnpUcmVlTW92ZVRpbWVyKTtcblx0XHRcdFx0XHRcdFx0d2luZG93LnpUcmVlTW92ZVRhcmdldE5vZGVUSWQgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcmVUbXBUYXJnZXROb2RlSWQgPSB0bXBUYXJnZXROb2RlSWQ7XG5cdFx0XHRcdFx0cHJlVG1wTW92ZVR5cGUgPSBtb3ZlVHlwZTtcblxuXHRcdFx0XHRcdHNldHRpbmcudHJlZU9iai50cmlnZ2VyKGNvbnN0cy5ldmVudC5EUkFHTU9WRSwgW2V2ZW50LCBzZXR0aW5nLnRyZWVJZCwgbm9kZXNdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGRvYy5iaW5kKFwibW91c2V1cFwiLCBfZG9jTW91c2VVcCk7XG5cdFx0XHRmdW5jdGlvbiBfZG9jTW91c2VVcChldmVudCkge1xuXHRcdFx0XHRpZiAod2luZG93LnpUcmVlTW92ZVRpbWVyKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHdpbmRvdy56VHJlZU1vdmVUaW1lcik7XG5cdFx0XHRcdFx0d2luZG93LnpUcmVlTW92ZVRhcmdldE5vZGVUSWQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByZVRtcFRhcmdldE5vZGVJZCA9IG51bGw7XG5cdFx0XHRcdHByZVRtcE1vdmVUeXBlID0gbnVsbDtcblx0XHRcdFx0ZG9jLnVuYmluZChcIm1vdXNlbW92ZVwiLCBfZG9jTW91c2VNb3ZlKTtcblx0XHRcdFx0ZG9jLnVuYmluZChcIm1vdXNldXBcIiwgX2RvY01vdXNlVXApO1xuXHRcdFx0XHRkb2MudW5iaW5kKFwic2VsZWN0c3RhcnRcIiwgX2RvY1NlbGVjdCk7XG5cdFx0XHRcdGJvZHkuY3NzKFwiY3Vyc29yXCIsIFwiYXV0b1wiKTtcblx0XHRcdFx0aWYgKHRtcFRhcmdldCkge1xuXHRcdFx0XHRcdHRtcFRhcmdldC5yZW1vdmVDbGFzcyhjb25zdHMubm9kZS5UTVBUQVJHRVRfVFJFRSk7XG5cdFx0XHRcdFx0aWYgKHRtcFRhcmdldE5vZGVJZCkgJChcIiNcIiArIHRtcFRhcmdldE5vZGVJZCArIGNvbnN0cy5pZC5BLCB0bXBUYXJnZXQpLnJlbW92ZUNsYXNzKGNvbnN0cy5ub2RlLlRNUFRBUkdFVF9OT0RFICsgXCJfXCIgKyBjb25zdHMubW92ZS5UWVBFX1BSRVYpXG5cdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhjb25zdHMubm9kZS5UTVBUQVJHRVRfTk9ERSArIFwiX1wiICsgX2NvbnN0cy5tb3ZlLlRZUEVfTkVYVCkucmVtb3ZlQ2xhc3MoY29uc3RzLm5vZGUuVE1QVEFSR0VUX05PREUgKyBcIl9cIiArIF9jb25zdHMubW92ZS5UWVBFX0lOTkVSKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b29scy5zaG93SWZhbWVNYXNrKHNldHRpbmcsIGZhbHNlKTtcblxuXHRcdFx0XHRyb290cy5zaG93SG92ZXJEb20gPSB0cnVlO1xuXHRcdFx0XHRpZiAocm9vdC5kcmFnRmxhZyA9PSAwKSByZXR1cm47XG5cdFx0XHRcdHJvb3QuZHJhZ0ZsYWcgPSAwO1xuXG5cdFx0XHRcdHZhciBpLCBsLCB0bXBOb2RlO1xuXHRcdFx0XHRmb3IgKGk9MCwgbD1ub2Rlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0dG1wTm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0XHRcdGlmICh0bXBOb2RlLmlzUGFyZW50ICYmIHJvb3QuZHJhZ05vZGVTaG93QmVmb3JlW3RtcE5vZGUudElkXSAmJiAhdG1wTm9kZS5vcGVuKSB7XG5cdFx0XHRcdFx0XHR2aWV3LmV4cGFuZENvbGxhcHNlTm9kZShzZXR0aW5nLCB0bXBOb2RlLCAhdG1wTm9kZS5vcGVuKTtcblx0XHRcdFx0XHRcdGRlbGV0ZSByb290LmRyYWdOb2RlU2hvd0JlZm9yZVt0bXBOb2RlLnRJZF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1ck5vZGUpIGN1ck5vZGUucmVtb3ZlKCk7XG5cdFx0XHRcdGlmICh0bXBBcnJvdykgdG1wQXJyb3cucmVtb3ZlKCk7XG5cblx0XHRcdFx0dmFyIGlzQ29weSA9ICgoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJiBzZXR0aW5nLmVkaXQuZHJhZy5pc01vdmUgJiYgc2V0dGluZy5lZGl0LmRyYWcuaXNDb3B5KSB8fCAoIXNldHRpbmcuZWRpdC5kcmFnLmlzTW92ZSAmJiBzZXR0aW5nLmVkaXQuZHJhZy5pc0NvcHkpO1xuXHRcdFx0XHRpZiAoIWlzQ29weSAmJiB0bXBUYXJnZXQgJiYgdG1wVGFyZ2V0Tm9kZUlkICYmIG5vZGVzWzBdLnBhcmVudFRJZCAmJiB0bXBUYXJnZXROb2RlSWQ9PW5vZGVzWzBdLnBhcmVudFRJZCAmJiBtb3ZlVHlwZSA9PSBjb25zdHMubW92ZS5UWVBFX0lOTkVSKSB7XG5cdFx0XHRcdFx0dG1wVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodG1wVGFyZ2V0KSB7XG5cdFx0XHRcdFx0dmFyIGRyYWdUYXJnZXROb2RlID0gdG1wVGFyZ2V0Tm9kZUlkID09IG51bGwgPyBudWxsOiBkYXRhLmdldE5vZGVDYWNoZSh0YXJnZXRTZXR0aW5nLCB0bXBUYXJnZXROb2RlSWQpO1xuXHRcdFx0XHRcdGlmICh0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZURyb3AsIFt0YXJnZXRTZXR0aW5nLnRyZWVJZCwgbm9kZXMsIGRyYWdUYXJnZXROb2RlLCBtb3ZlVHlwZSwgaXNDb3B5XSwgdHJ1ZSkgPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHZpZXcuc2VsZWN0Tm9kZXMoc291cmNlU2V0dGluZywgbm9kZXMpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgbmV3Tm9kZXMgPSBpc0NvcHkgPyB0b29scy5jbG9uZShub2RlcykgOiBub2RlcztcblxuXHRcdFx0XHRcdGZ1bmN0aW9uIGRyb3BDYWxsYmFjaygpIHtcblx0XHRcdFx0XHRcdGlmIChpc090aGVyVHJlZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWlzQ29weSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvcih2YXIgaT0wLCBsPW5vZGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZpZXcucmVtb3ZlTm9kZShzZXR0aW5nLCBub2Rlc1tpXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChtb3ZlVHlwZSA9PSBjb25zdHMubW92ZS5UWVBFX0lOTkVSKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmlldy5hZGROb2Rlcyh0YXJnZXRTZXR0aW5nLCBkcmFnVGFyZ2V0Tm9kZSwgbmV3Tm9kZXMpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHZpZXcuYWRkTm9kZXModGFyZ2V0U2V0dGluZywgZHJhZ1RhcmdldE5vZGUuZ2V0UGFyZW50Tm9kZSgpLCBuZXdOb2Rlcyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfUFJFVikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yIChpPTAsIGw9bmV3Tm9kZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2aWV3Lm1vdmVOb2RlKHRhcmdldFNldHRpbmcsIGRyYWdUYXJnZXROb2RlLCBuZXdOb2Rlc1tpXSwgbW92ZVR5cGUsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yIChpPS0xLCBsPW5ld05vZGVzLmxlbmd0aC0xOyBpPGw7IGwtLSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2aWV3Lm1vdmVOb2RlKHRhcmdldFNldHRpbmcsIGRyYWdUYXJnZXROb2RlLCBuZXdOb2Rlc1tsXSwgbW92ZVR5cGUsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpc0NvcHkgJiYgbW92ZVR5cGUgPT0gY29uc3RzLm1vdmUuVFlQRV9JTk5FUikge1xuXHRcdFx0XHRcdFx0XHRcdHZpZXcuYWRkTm9kZXModGFyZ2V0U2V0dGluZywgZHJhZ1RhcmdldE5vZGUsIG5ld05vZGVzKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNDb3B5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2aWV3LmFkZE5vZGVzKHRhcmdldFNldHRpbmcsIGRyYWdUYXJnZXROb2RlLmdldFBhcmVudE5vZGUoKSwgbmV3Tm9kZXMpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAobW92ZVR5cGUgIT0gY29uc3RzLm1vdmUuVFlQRV9ORVhUKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGk9MCwgbD1uZXdOb2Rlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZpZXcubW92ZU5vZGUodGFyZ2V0U2V0dGluZywgZHJhZ1RhcmdldE5vZGUsIG5ld05vZGVzW2ldLCBtb3ZlVHlwZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGk9LTEsIGw9bmV3Tm9kZXMubGVuZ3RoLTE7IGk8bDsgbC0tKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZpZXcubW92ZU5vZGUodGFyZ2V0U2V0dGluZywgZHJhZ1RhcmdldE5vZGUsIG5ld05vZGVzW2xdLCBtb3ZlVHlwZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmlldy5zZWxlY3ROb2Rlcyh0YXJnZXRTZXR0aW5nLCBuZXdOb2Rlcyk7XG5cdFx0XHRcdFx0XHQkJChuZXdOb2Rlc1swXSwgc2V0dGluZykuZm9jdXMoKS5ibHVyKCk7XG5cblx0XHRcdFx0XHRcdHNldHRpbmcudHJlZU9iai50cmlnZ2VyKGNvbnN0cy5ldmVudC5EUk9QLCBbZXZlbnQsIHRhcmdldFNldHRpbmcudHJlZUlkLCBuZXdOb2RlcywgZHJhZ1RhcmdldE5vZGUsIG1vdmVUeXBlLCBpc0NvcHldKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobW92ZVR5cGUgPT0gY29uc3RzLm1vdmUuVFlQRV9JTk5FUiAmJiB0b29scy5jYW5Bc3luYyh0YXJnZXRTZXR0aW5nLCBkcmFnVGFyZ2V0Tm9kZSkpIHtcblx0XHRcdFx0XHRcdHZpZXcuYXN5bmNOb2RlKHRhcmdldFNldHRpbmcsIGRyYWdUYXJnZXROb2RlLCBmYWxzZSwgZHJvcENhbGxiYWNrKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZHJvcENhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlldy5zZWxlY3ROb2Rlcyhzb3VyY2VTZXR0aW5nLCBub2Rlcyk7XG5cdFx0XHRcdFx0c2V0dGluZy50cmVlT2JqLnRyaWdnZXIoY29uc3RzLmV2ZW50LkRST1AsIFtldmVudCwgc2V0dGluZy50cmVlSWQsIG5vZGVzLCBudWxsLCBudWxsLCBudWxsXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZG9jLmJpbmQoXCJzZWxlY3RzdGFydFwiLCBfZG9jU2VsZWN0KTtcblx0XHRcdGZ1bmN0aW9uIF9kb2NTZWxlY3QoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Bdm9pZCBGaXJlRm94J3MgQnVnXG5cdFx0XHQvL0lmIHpUcmVlIERpdiBDU1Mgc2V0ICdvdmVyZmxvdycsIHNvIGRyYWcgbm9kZSBvdXRzaWRlIG9mIHpUcmVlLCBhbmQgZXZlbnQudGFyZ2V0IGlzIGVycm9yLlxuXHRcdFx0aWYoZXZlbnRNb3VzZURvd24ucHJldmVudERlZmF1bHQpIHtcblx0XHRcdFx0ZXZlbnRNb3VzZURvd24ucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblx0Ly9tZXRob2Qgb2YgdG9vbHMgZm9yIHpUcmVlXG5cdF90b29scyA9IHtcblx0XHRnZXRBYnM6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdHZhciBvUmVjdCA9IG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcblx0XHRcdHNjcm9sbFRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wK2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG5cdFx0XHRzY3JvbGxMZWZ0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0K2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuXHRcdFx0cmV0dXJuIFtvUmVjdC5sZWZ0K3Njcm9sbExlZnQsb1JlY3QudG9wK3Njcm9sbFRvcF07XG5cdFx0fSxcblx0XHRpbnB1dEZvY3VzOiBmdW5jdGlvbihpbnB1dE9iaikge1xuXHRcdFx0aWYgKGlucHV0T2JqLmdldCgwKSkge1xuXHRcdFx0XHRpbnB1dE9iai5mb2N1cygpO1xuXHRcdFx0XHR0b29scy5zZXRDdXJzb3JQb3NpdGlvbihpbnB1dE9iai5nZXQoMCksIGlucHV0T2JqLnZhbCgpLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbnB1dFNlbGVjdDogZnVuY3Rpb24oaW5wdXRPYmopIHtcblx0XHRcdGlmIChpbnB1dE9iai5nZXQoMCkpIHtcblx0XHRcdFx0aW5wdXRPYmouZm9jdXMoKTtcblx0XHRcdFx0aW5wdXRPYmouc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZXRDdXJzb3JQb3NpdGlvbjogZnVuY3Rpb24ob2JqLCBwb3Mpe1xuXHRcdFx0aWYob2JqLnNldFNlbGVjdGlvblJhbmdlKSB7XG5cdFx0XHRcdG9iai5mb2N1cygpO1xuXHRcdFx0XHRvYmouc2V0U2VsZWN0aW9uUmFuZ2UocG9zLHBvcyk7XG5cdFx0XHR9IGVsc2UgaWYgKG9iai5jcmVhdGVUZXh0UmFuZ2UpIHtcblx0XHRcdFx0dmFyIHJhbmdlID0gb2JqLmNyZWF0ZVRleHRSYW5nZSgpO1xuXHRcdFx0XHRyYW5nZS5jb2xsYXBzZSh0cnVlKTtcblx0XHRcdFx0cmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgcG9zKTtcblx0XHRcdFx0cmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBwb3MpO1xuXHRcdFx0XHRyYW5nZS5zZWxlY3QoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNob3dJZmFtZU1hc2s6IGZ1bmN0aW9uKHNldHRpbmcsIHNob3dTaWduKSB7XG5cdFx0XHR2YXIgcm9vdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRcdC8vY2xlYXIgZnVsbCBtYXNrXG5cdFx0XHR3aGlsZSAocm9vdC5kcmFnTWFza0xpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRyb290LmRyYWdNYXNrTGlzdFswXS5yZW1vdmUoKTtcblx0XHRcdFx0cm9vdC5kcmFnTWFza0xpc3Quc2hpZnQoKTtcblx0XHRcdH1cblx0XHRcdGlmIChzaG93U2lnbikge1xuXHRcdFx0XHQvL3Nob3cgbWFza1xuXHRcdFx0XHR2YXIgaWZyYW1lTGlzdCA9ICQkKFwiaWZyYW1lXCIsIHNldHRpbmcpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGlmcmFtZUxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIG9iaiA9IGlmcmFtZUxpc3QuZ2V0KGkpLFxuXHRcdFx0XHRcdHIgPSB0b29scy5nZXRBYnMob2JqKSxcblx0XHRcdFx0XHRkcmFnTWFzayA9ICQkKFwiPGRpdiBpZD0nelRyZWVNYXNrX1wiICsgaSArIFwiJyBjbGFzcz0nelRyZWVNYXNrJyBzdHlsZT0ndG9wOlwiICsgclsxXSArIFwicHg7IGxlZnQ6XCIgKyByWzBdICsgXCJweDsgd2lkdGg6XCIgKyBvYmoub2Zmc2V0V2lkdGggKyBcInB4OyBoZWlnaHQ6XCIgKyBvYmoub2Zmc2V0SGVpZ2h0ICsgXCJweDsnPjwvZGl2PlwiLCBzZXR0aW5nKTtcblx0XHRcdFx0XHRkcmFnTWFzay5hcHBlbmRUbygkJChcImJvZHlcIiwgc2V0dGluZykpO1xuXHRcdFx0XHRcdHJvb3QuZHJhZ01hc2tMaXN0LnB1c2goZHJhZ01hc2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHQvL21ldGhvZCBvZiBvcGVyYXRlIHp0cmVlIGRvbVxuXHRfdmlldyA9IHtcblx0XHRhZGRFZGl0QnRuOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHRpZiAobm9kZS5lZGl0TmFtZUZsYWcgfHwgJCQobm9kZSwgY29uc3RzLmlkLkVESVQsIHNldHRpbmcpLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF0b29scy5hcHBseShzZXR0aW5nLmVkaXQuc2hvd1JlbmFtZUJ0biwgW3NldHRpbmcudHJlZUlkLCBub2RlXSwgc2V0dGluZy5lZGl0LnNob3dSZW5hbWVCdG4pKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBhT2JqID0gJCQobm9kZSwgY29uc3RzLmlkLkEsIHNldHRpbmcpLFxuXHRcdFx0ZWRpdFN0ciA9IFwiPHNwYW4gY2xhc3M9J1wiICsgY29uc3RzLmNsYXNzTmFtZS5CVVRUT04gKyBcIiBlZGl0JyBpZD0nXCIgKyBub2RlLnRJZCArIGNvbnN0cy5pZC5FRElUICsgXCInIHRpdGxlPSdcIit0b29scy5hcHBseShzZXR0aW5nLmVkaXQucmVuYW1lVGl0bGUsIFtzZXR0aW5nLnRyZWVJZCwgbm9kZV0sIHNldHRpbmcuZWRpdC5yZW5hbWVUaXRsZSkrXCInIHRyZWVOb2RlXCIrY29uc3RzLmlkLkVESVQrXCIgc3R5bGU9J2Rpc3BsYXk6bm9uZTsnPjwvc3Bhbj5cIjtcblx0XHRcdGFPYmouYXBwZW5kKGVkaXRTdHIpO1xuXG5cdFx0XHQkJChub2RlLCBjb25zdHMuaWQuRURJVCwgc2V0dGluZykuYmluZCgnY2xpY2snLFxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIXRvb2xzLnVDYW5EbyhzZXR0aW5nKSB8fCB0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZUVkaXROYW1lLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHZpZXcuZWRpdE5vZGUoc2V0dGluZywgbm9kZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCkuc2hvdygpO1xuXHRcdH0sXG5cdFx0YWRkUmVtb3ZlQnRuOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHRpZiAobm9kZS5lZGl0TmFtZUZsYWcgfHwgJCQobm9kZSwgY29uc3RzLmlkLlJFTU9WRSwgc2V0dGluZykubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRvb2xzLmFwcGx5KHNldHRpbmcuZWRpdC5zaG93UmVtb3ZlQnRuLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCBzZXR0aW5nLmVkaXQuc2hvd1JlbW92ZUJ0bikpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGFPYmogPSAkJChub2RlLCBjb25zdHMuaWQuQSwgc2V0dGluZyksXG5cdFx0XHRyZW1vdmVTdHIgPSBcIjxzcGFuIGNsYXNzPSdcIiArIGNvbnN0cy5jbGFzc05hbWUuQlVUVE9OICsgXCIgcmVtb3ZlJyBpZD0nXCIgKyBub2RlLnRJZCArIGNvbnN0cy5pZC5SRU1PVkUgKyBcIicgdGl0bGU9J1wiK3Rvb2xzLmFwcGx5KHNldHRpbmcuZWRpdC5yZW1vdmVUaXRsZSwgW3NldHRpbmcudHJlZUlkLCBub2RlXSwgc2V0dGluZy5lZGl0LnJlbW92ZVRpdGxlKStcIicgdHJlZU5vZGVcIitjb25zdHMuaWQuUkVNT1ZFK1wiIHN0eWxlPSdkaXNwbGF5Om5vbmU7Jz48L3NwYW4+XCI7XG5cdFx0XHRhT2JqLmFwcGVuZChyZW1vdmVTdHIpO1xuXG5cdFx0XHQkJChub2RlLCBjb25zdHMuaWQuUkVNT1ZFLCBzZXR0aW5nKS5iaW5kKCdjbGljaycsXG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICghdG9vbHMudUNhbkRvKHNldHRpbmcpIHx8IHRvb2xzLmFwcGx5KHNldHRpbmcuY2FsbGJhY2suYmVmb3JlUmVtb3ZlLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdLCB0cnVlKSA9PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHZpZXcucmVtb3ZlTm9kZShzZXR0aW5nLCBub2RlKTtcblx0XHRcdFx0XHRzZXR0aW5nLnRyZWVPYmoudHJpZ2dlcihjb25zdHMuZXZlbnQuUkVNT1ZFLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0KS5iaW5kKCdtb3VzZWRvd24nLFxuXHRcdFx0XHRmdW5jdGlvbihldmVudE1vdXNlRG93bikge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCkuc2hvdygpO1xuXHRcdH0sXG5cdFx0YWRkSG92ZXJEb206IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdGlmIChkYXRhLmdldFJvb3RzKCkuc2hvd0hvdmVyRG9tKSB7XG5cdFx0XHRcdG5vZGUuaXNIb3ZlciA9IHRydWU7XG5cdFx0XHRcdGlmIChzZXR0aW5nLmVkaXQuZW5hYmxlKSB7XG5cdFx0XHRcdFx0dmlldy5hZGRFZGl0QnRuKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRcdHZpZXcuYWRkUmVtb3ZlQnRuKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvb2xzLmFwcGx5KHNldHRpbmcudmlldy5hZGRIb3ZlckRvbSwgW3NldHRpbmcudHJlZUlkLCBub2RlXSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjYW5jZWxDdXJFZGl0Tm9kZTogZnVuY3Rpb24gKHNldHRpbmcsIGZvcmNlTmFtZSwgaXNDYW5jZWwpIHtcblx0XHRcdHZhciByb290ID0gZGF0YS5nZXRSb290KHNldHRpbmcpLFxuXHRcdFx0bmFtZUtleSA9IHNldHRpbmcuZGF0YS5rZXkubmFtZSxcblx0XHRcdG5vZGUgPSByb290LmN1ckVkaXROb2RlO1xuXG5cdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHR2YXIgaW5wdXRPYmogPSByb290LmN1ckVkaXRJbnB1dCxcblx0XHRcdFx0bmV3TmFtZSA9IGZvcmNlTmFtZSA/IGZvcmNlTmFtZTooaXNDYW5jZWwgPyBub2RlW25hbWVLZXldOiBpbnB1dE9iai52YWwoKSk7XG5cdFx0XHRcdGlmICh0b29scy5hcHBseShzZXR0aW5nLmNhbGxiYWNrLmJlZm9yZVJlbmFtZSwgW3NldHRpbmcudHJlZUlkLCBub2RlLCBuZXdOYW1lLCBpc0NhbmNlbF0sIHRydWUpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlW25hbWVLZXldID0gbmV3TmFtZTtcblx0XHRcdFx0XHRzZXR0aW5nLnRyZWVPYmoudHJpZ2dlcihjb25zdHMuZXZlbnQuUkVOQU1FLCBbc2V0dGluZy50cmVlSWQsIG5vZGUsIGlzQ2FuY2VsXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGFPYmogPSAkJChub2RlLCBjb25zdHMuaWQuQSwgc2V0dGluZyk7XG5cdFx0XHRcdGFPYmoucmVtb3ZlQ2xhc3MoY29uc3RzLm5vZGUuQ1VSU0VMRUNURURfRURJVCk7XG5cdFx0XHRcdGlucHV0T2JqLnVuYmluZCgpO1xuXHRcdFx0XHR2aWV3LnNldE5vZGVOYW1lKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0XHRub2RlLmVkaXROYW1lRmxhZyA9IGZhbHNlO1xuXHRcdFx0XHRyb290LmN1ckVkaXROb2RlID0gbnVsbDtcblx0XHRcdFx0cm9vdC5jdXJFZGl0SW5wdXQgPSBudWxsO1xuXHRcdFx0XHR2aWV3LnNlbGVjdE5vZGUoc2V0dGluZywgbm9kZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0cm9vdC5ub1NlbGVjdGlvbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdGVkaXROb2RlOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHR2YXIgcm9vdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRcdHZpZXcuZWRpdE5vZGVCbHVyID0gZmFsc2U7XG5cdFx0XHRpZiAoZGF0YS5pc1NlbGVjdGVkTm9kZShzZXR0aW5nLCBub2RlKSAmJiByb290LmN1ckVkaXROb2RlID09IG5vZGUgJiYgbm9kZS5lZGl0TmFtZUZsYWcpIHtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHt0b29scy5pbnB1dEZvY3VzKHJvb3QuY3VyRWRpdElucHV0KTt9LCAwKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5hbWVLZXkgPSBzZXR0aW5nLmRhdGEua2V5Lm5hbWU7XG5cdFx0XHRub2RlLmVkaXROYW1lRmxhZyA9IHRydWU7XG5cdFx0XHR2aWV3LnJlbW92ZVRyZWVEb20oc2V0dGluZywgbm9kZSk7XG5cdFx0XHR2aWV3LmNhbmNlbEN1ckVkaXROb2RlKHNldHRpbmcpO1xuXHRcdFx0dmlldy5zZWxlY3ROb2RlKHNldHRpbmcsIG5vZGUsIGZhbHNlKTtcblx0XHRcdCQkKG5vZGUsIGNvbnN0cy5pZC5TUEFOLCBzZXR0aW5nKS5odG1sKFwiPGlucHV0IHR5cGU9dGV4dCBjbGFzcz0ncmVuYW1lJyBpZD0nXCIgKyBub2RlLnRJZCArIGNvbnN0cy5pZC5JTlBVVCArIFwiJyB0cmVlTm9kZVwiICsgY29uc3RzLmlkLklOUFVUICsgXCIgPlwiKTtcblx0XHRcdHZhciBpbnB1dE9iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5JTlBVVCwgc2V0dGluZyk7XG5cdFx0XHRpbnB1dE9iai5hdHRyKFwidmFsdWVcIiwgbm9kZVtuYW1lS2V5XSk7XG5cdFx0XHRpZiAoc2V0dGluZy5lZGl0LmVkaXROYW1lU2VsZWN0QWxsKSB7XG5cdFx0XHRcdHRvb2xzLmlucHV0U2VsZWN0KGlucHV0T2JqKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvb2xzLmlucHV0Rm9jdXMoaW5wdXRPYmopO1xuXHRcdFx0fVxuXG5cdFx0XHRpbnB1dE9iai5iaW5kKCdibHVyJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYgKCF2aWV3LmVkaXROb2RlQmx1cikge1xuXHRcdFx0XHRcdHZpZXcuY2FuY2VsQ3VyRWRpdE5vZGUoc2V0dGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLmJpbmQoJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRpZiAoZXZlbnQua2V5Q29kZT09XCIxM1wiKSB7XG5cdFx0XHRcdFx0dmlldy5lZGl0Tm9kZUJsdXIgPSB0cnVlO1xuXHRcdFx0XHRcdHZpZXcuY2FuY2VsQ3VyRWRpdE5vZGUoc2V0dGluZyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZT09XCIyN1wiKSB7XG5cdFx0XHRcdFx0dmlldy5jYW5jZWxDdXJFZGl0Tm9kZShzZXR0aW5nLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkuYmluZCgnY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9KS5iaW5kKCdkYmxjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0pO1xuXG5cdFx0XHQkJChub2RlLCBjb25zdHMuaWQuQSwgc2V0dGluZykuYWRkQ2xhc3MoY29uc3RzLm5vZGUuQ1VSU0VMRUNURURfRURJVCk7XG5cdFx0XHRyb290LmN1ckVkaXRJbnB1dCA9IGlucHV0T2JqO1xuXHRcdFx0cm9vdC5ub1NlbGVjdGlvbiA9IGZhbHNlO1xuXHRcdFx0cm9vdC5jdXJFZGl0Tm9kZSA9IG5vZGU7XG5cdFx0fSxcblx0XHRtb3ZlTm9kZTogZnVuY3Rpb24oc2V0dGluZywgdGFyZ2V0Tm9kZSwgbm9kZSwgbW92ZVR5cGUsIGFuaW1hdGVGbGFnLCBpc1NpbGVudCkge1xuXHRcdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyksXG5cdFx0XHRjaGlsZEtleSA9IHNldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW47XG5cdFx0XHRpZiAodGFyZ2V0Tm9kZSA9PSBub2RlKSByZXR1cm47XG5cdFx0XHRpZiAoc2V0dGluZy5kYXRhLmtlZXAubGVhZiAmJiB0YXJnZXROb2RlICYmICF0YXJnZXROb2RlLmlzUGFyZW50ICYmIG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVIpIHJldHVybjtcblx0XHRcdHZhciBvbGRQYXJlbnROb2RlID0gKG5vZGUucGFyZW50VElkID8gbm9kZS5nZXRQYXJlbnROb2RlKCk6IHJvb3QpLFxuXHRcdFx0dGFyZ2V0Tm9kZUlzUm9vdCA9ICh0YXJnZXROb2RlID09PSBudWxsIHx8IHRhcmdldE5vZGUgPT0gcm9vdCk7XG5cdFx0XHRpZiAodGFyZ2V0Tm9kZUlzUm9vdCAmJiB0YXJnZXROb2RlID09PSBudWxsKSB0YXJnZXROb2RlID0gcm9vdDtcblx0XHRcdGlmICh0YXJnZXROb2RlSXNSb290KSBtb3ZlVHlwZSA9IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVI7XG5cdFx0XHR2YXIgdGFyZ2V0UGFyZW50Tm9kZSA9ICh0YXJnZXROb2RlLnBhcmVudFRJZCA/IHRhcmdldE5vZGUuZ2V0UGFyZW50Tm9kZSgpIDogcm9vdCk7XG5cblx0XHRcdGlmIChtb3ZlVHlwZSAhPSBjb25zdHMubW92ZS5UWVBFX1BSRVYgJiYgbW92ZVR5cGUgIT0gY29uc3RzLm1vdmUuVFlQRV9ORVhUKSB7XG5cdFx0XHRcdG1vdmVUeXBlID0gY29uc3RzLm1vdmUuVFlQRV9JTk5FUjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfSU5ORVIpIHtcblx0XHRcdFx0aWYgKHRhcmdldE5vZGVJc1Jvb3QpIHtcblx0XHRcdFx0XHQvL3BhcmVudFRJZCBvZiByb290IG5vZGUgaXMgbnVsbFxuXHRcdFx0XHRcdG5vZGUucGFyZW50VElkID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIXRhcmdldE5vZGUuaXNQYXJlbnQpIHtcblx0XHRcdFx0XHRcdHRhcmdldE5vZGUuaXNQYXJlbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Tm9kZS5vcGVuID0gISF0YXJnZXROb2RlLm9wZW47XG5cdFx0XHRcdFx0XHR2aWV3LnNldE5vZGVMaW5lSWNvcyhzZXR0aW5nLCB0YXJnZXROb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZS5wYXJlbnRUSWQgPSB0YXJnZXROb2RlLnRJZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL21vdmUgbm9kZSBEb21cblx0XHRcdHZhciB0YXJnZXRPYmosIHRhcmdldF91bE9iajtcblx0XHRcdGlmICh0YXJnZXROb2RlSXNSb290KSB7XG5cdFx0XHRcdHRhcmdldE9iaiA9IHNldHRpbmcudHJlZU9iajtcblx0XHRcdFx0dGFyZ2V0X3VsT2JqID0gdGFyZ2V0T2JqO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCFpc1NpbGVudCAmJiBtb3ZlVHlwZSA9PSBjb25zdHMubW92ZS5UWVBFX0lOTkVSKSB7XG5cdFx0XHRcdFx0dmlldy5leHBhbmRDb2xsYXBzZU5vZGUoc2V0dGluZywgdGFyZ2V0Tm9kZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFpc1NpbGVudCkge1xuXHRcdFx0XHRcdHZpZXcuZXhwYW5kQ29sbGFwc2VOb2RlKHNldHRpbmcsIHRhcmdldE5vZGUuZ2V0UGFyZW50Tm9kZSgpLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0T2JqID0gJCQodGFyZ2V0Tm9kZSwgc2V0dGluZyk7XG5cdFx0XHRcdHRhcmdldF91bE9iaiA9ICQkKHRhcmdldE5vZGUsIGNvbnN0cy5pZC5VTCwgc2V0dGluZyk7XG5cdFx0XHRcdGlmICghIXRhcmdldE9iai5nZXQoMCkgJiYgIXRhcmdldF91bE9iai5nZXQoMCkpIHtcblx0XHRcdFx0XHR2YXIgdWxzdHIgPSBbXTtcblx0XHRcdFx0XHR2aWV3Lm1ha2VVbEh0bWwoc2V0dGluZywgdGFyZ2V0Tm9kZSwgdWxzdHIsICcnKTtcblx0XHRcdFx0XHR0YXJnZXRPYmouYXBwZW5kKHVsc3RyLmpvaW4oJycpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXRfdWxPYmogPSAkJCh0YXJnZXROb2RlLCBjb25zdHMuaWQuVUwsIHNldHRpbmcpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5vZGVEb20gPSAkJChub2RlLCBzZXR0aW5nKTtcblx0XHRcdGlmICghbm9kZURvbS5nZXQoMCkpIHtcblx0XHRcdFx0bm9kZURvbSA9IHZpZXcuYXBwZW5kTm9kZXMoc2V0dGluZywgbm9kZS5sZXZlbCwgW25vZGVdLCBudWxsLCBmYWxzZSwgdHJ1ZSkuam9pbignJyk7XG5cdFx0XHR9IGVsc2UgaWYgKCF0YXJnZXRPYmouZ2V0KDApKSB7XG5cdFx0XHRcdG5vZGVEb20ucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGFyZ2V0X3VsT2JqLmdldCgwKSAmJiBtb3ZlVHlwZSA9PSBjb25zdHMubW92ZS5UWVBFX0lOTkVSKSB7XG5cdFx0XHRcdHRhcmdldF91bE9iai5hcHBlbmQobm9kZURvbSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldE9iai5nZXQoMCkgJiYgbW92ZVR5cGUgPT0gY29uc3RzLm1vdmUuVFlQRV9QUkVWKSB7XG5cdFx0XHRcdHRhcmdldE9iai5iZWZvcmUobm9kZURvbSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldE9iai5nZXQoMCkgJiYgbW92ZVR5cGUgPT0gY29uc3RzLm1vdmUuVFlQRV9ORVhUKSB7XG5cdFx0XHRcdHRhcmdldE9iai5hZnRlcihub2RlRG9tKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9yZXBhaXIgdGhlIGRhdGEgYWZ0ZXIgbW92ZVxuXHRcdFx0dmFyIGksbCxcblx0XHRcdHRtcFNyY0luZGV4ID0gLTEsXG5cdFx0XHR0bXBUYXJnZXRJbmRleCA9IDAsXG5cdFx0XHRvbGROZWlnaGJvciA9IG51bGwsXG5cdFx0XHRuZXdOZWlnaGJvciA9IG51bGwsXG5cdFx0XHRvbGRMZXZlbCA9IG5vZGUubGV2ZWw7XG5cdFx0XHRpZiAobm9kZS5pc0ZpcnN0Tm9kZSkge1xuXHRcdFx0XHR0bXBTcmNJbmRleCA9IDA7XG5cdFx0XHRcdGlmIChvbGRQYXJlbnROb2RlW2NoaWxkS2V5XS5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdG9sZE5laWdoYm9yID0gb2xkUGFyZW50Tm9kZVtjaGlsZEtleV1bMV07XG5cdFx0XHRcdFx0b2xkTmVpZ2hib3IuaXNGaXJzdE5vZGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKG5vZGUuaXNMYXN0Tm9kZSkge1xuXHRcdFx0XHR0bXBTcmNJbmRleCA9IG9sZFBhcmVudE5vZGVbY2hpbGRLZXldLmxlbmd0aCAtMTtcblx0XHRcdFx0b2xkTmVpZ2hib3IgPSBvbGRQYXJlbnROb2RlW2NoaWxkS2V5XVt0bXBTcmNJbmRleCAtIDFdO1xuXHRcdFx0XHRvbGROZWlnaGJvci5pc0xhc3ROb2RlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBvbGRQYXJlbnROb2RlW2NoaWxkS2V5XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAob2xkUGFyZW50Tm9kZVtjaGlsZEtleV1baV0udElkID09IG5vZGUudElkKSB7XG5cdFx0XHRcdFx0XHR0bXBTcmNJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0bXBTcmNJbmRleCA+PSAwKSB7XG5cdFx0XHRcdG9sZFBhcmVudE5vZGVbY2hpbGRLZXldLnNwbGljZSh0bXBTcmNJbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobW92ZVR5cGUgIT0gY29uc3RzLm1vdmUuVFlQRV9JTk5FUikge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gdGFyZ2V0UGFyZW50Tm9kZVtjaGlsZEtleV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRhcmdldFBhcmVudE5vZGVbY2hpbGRLZXldW2ldLnRJZCA9PSB0YXJnZXROb2RlLnRJZCkgdG1wVGFyZ2V0SW5kZXggPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobW92ZVR5cGUgPT0gY29uc3RzLm1vdmUuVFlQRV9JTk5FUikge1xuXHRcdFx0XHRpZiAoIXRhcmdldE5vZGVbY2hpbGRLZXldKSB0YXJnZXROb2RlW2NoaWxkS2V5XSA9IG5ldyBBcnJheSgpO1xuXHRcdFx0XHRpZiAodGFyZ2V0Tm9kZVtjaGlsZEtleV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdG5ld05laWdoYm9yID0gdGFyZ2V0Tm9kZVtjaGlsZEtleV1bdGFyZ2V0Tm9kZVtjaGlsZEtleV0ubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0bmV3TmVpZ2hib3IuaXNMYXN0Tm9kZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldE5vZGVbY2hpbGRLZXldLnNwbGljZSh0YXJnZXROb2RlW2NoaWxkS2V5XS5sZW5ndGgsIDAsIG5vZGUpO1xuXHRcdFx0XHRub2RlLmlzTGFzdE5vZGUgPSB0cnVlO1xuXHRcdFx0XHRub2RlLmlzRmlyc3ROb2RlID0gKHRhcmdldE5vZGVbY2hpbGRLZXldLmxlbmd0aCA9PSAxKTtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Tm9kZS5pc0ZpcnN0Tm9kZSAmJiBtb3ZlVHlwZSA9PSBjb25zdHMubW92ZS5UWVBFX1BSRVYpIHtcblx0XHRcdFx0dGFyZ2V0UGFyZW50Tm9kZVtjaGlsZEtleV0uc3BsaWNlKHRtcFRhcmdldEluZGV4LCAwLCBub2RlKTtcblx0XHRcdFx0bmV3TmVpZ2hib3IgPSB0YXJnZXROb2RlO1xuXHRcdFx0XHRuZXdOZWlnaGJvci5pc0ZpcnN0Tm9kZSA9IGZhbHNlO1xuXHRcdFx0XHRub2RlLnBhcmVudFRJZCA9IHRhcmdldE5vZGUucGFyZW50VElkO1xuXHRcdFx0XHRub2RlLmlzRmlyc3ROb2RlID0gdHJ1ZTtcblx0XHRcdFx0bm9kZS5pc0xhc3ROb2RlID0gZmFsc2U7XG5cblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Tm9kZS5pc0xhc3ROb2RlICYmIG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfTkVYVCkge1xuXHRcdFx0XHR0YXJnZXRQYXJlbnROb2RlW2NoaWxkS2V5XS5zcGxpY2UodG1wVGFyZ2V0SW5kZXggKyAxLCAwLCBub2RlKTtcblx0XHRcdFx0bmV3TmVpZ2hib3IgPSB0YXJnZXROb2RlO1xuXHRcdFx0XHRuZXdOZWlnaGJvci5pc0xhc3ROb2RlID0gZmFsc2U7XG5cdFx0XHRcdG5vZGUucGFyZW50VElkID0gdGFyZ2V0Tm9kZS5wYXJlbnRUSWQ7XG5cdFx0XHRcdG5vZGUuaXNGaXJzdE5vZGUgPSBmYWxzZTtcblx0XHRcdFx0bm9kZS5pc0xhc3ROb2RlID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKG1vdmVUeXBlID09IGNvbnN0cy5tb3ZlLlRZUEVfUFJFVikge1xuXHRcdFx0XHRcdHRhcmdldFBhcmVudE5vZGVbY2hpbGRLZXldLnNwbGljZSh0bXBUYXJnZXRJbmRleCwgMCwgbm9kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0UGFyZW50Tm9kZVtjaGlsZEtleV0uc3BsaWNlKHRtcFRhcmdldEluZGV4ICsgMSwgMCwgbm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5wYXJlbnRUSWQgPSB0YXJnZXROb2RlLnBhcmVudFRJZDtcblx0XHRcdFx0bm9kZS5pc0ZpcnN0Tm9kZSA9IGZhbHNlO1xuXHRcdFx0XHRub2RlLmlzTGFzdE5vZGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGRhdGEuZml4UElkS2V5VmFsdWUoc2V0dGluZywgbm9kZSk7XG5cdFx0XHRkYXRhLnNldFNvbk5vZGVMZXZlbChzZXR0aW5nLCBub2RlLmdldFBhcmVudE5vZGUoKSwgbm9kZSk7XG5cblx0XHRcdC8vcmVwYWlyIG5vZGUgd2hhdCBiZWVuIG1vdmVkXG5cdFx0XHR2aWV3LnNldE5vZGVMaW5lSWNvcyhzZXR0aW5nLCBub2RlKTtcblx0XHRcdHZpZXcucmVwYWlyTm9kZUxldmVsQ2xhc3Moc2V0dGluZywgbm9kZSwgb2xkTGV2ZWwpXG5cblx0XHRcdC8vcmVwYWlyIG5vZGUncyBvbGQgcGFyZW50Tm9kZSBkb21cblx0XHRcdGlmICghc2V0dGluZy5kYXRhLmtlZXAucGFyZW50ICYmIG9sZFBhcmVudE5vZGVbY2hpbGRLZXldLmxlbmd0aCA8IDEpIHtcblx0XHRcdFx0Ly9vbGQgcGFyZW50Tm9kZSBoYXMgbm8gY2hpbGQgbm9kZXNcblx0XHRcdFx0b2xkUGFyZW50Tm9kZS5pc1BhcmVudCA9IGZhbHNlO1xuXHRcdFx0XHRvbGRQYXJlbnROb2RlLm9wZW4gPSBmYWxzZTtcblx0XHRcdFx0dmFyIHRtcF91bE9iaiA9ICQkKG9sZFBhcmVudE5vZGUsIGNvbnN0cy5pZC5VTCwgc2V0dGluZyksXG5cdFx0XHRcdHRtcF9zd2l0Y2hPYmogPSAkJChvbGRQYXJlbnROb2RlLCBjb25zdHMuaWQuU1dJVENILCBzZXR0aW5nKSxcblx0XHRcdFx0dG1wX2ljb09iaiA9ICQkKG9sZFBhcmVudE5vZGUsIGNvbnN0cy5pZC5JQ09OLCBzZXR0aW5nKTtcblx0XHRcdFx0dmlldy5yZXBsYWNlU3dpdGNoQ2xhc3Mob2xkUGFyZW50Tm9kZSwgdG1wX3N3aXRjaE9iaiwgY29uc3RzLmZvbGRlci5ET0NVKTtcblx0XHRcdFx0dmlldy5yZXBsYWNlSWNvQ2xhc3Mob2xkUGFyZW50Tm9kZSwgdG1wX2ljb09iaiwgY29uc3RzLmZvbGRlci5ET0NVKTtcblx0XHRcdFx0dG1wX3VsT2JqLmNzcyhcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKG9sZE5laWdoYm9yKSB7XG5cdFx0XHRcdC8vb2xkIG5laWdib3Igbm9kZVxuXHRcdFx0XHR2aWV3LnNldE5vZGVMaW5lSWNvcyhzZXR0aW5nLCBvbGROZWlnaGJvcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vbmV3IG5laWdib3Igbm9kZVxuXHRcdFx0aWYgKG5ld05laWdoYm9yKSB7XG5cdFx0XHRcdHZpZXcuc2V0Tm9kZUxpbmVJY29zKHNldHRpbmcsIG5ld05laWdoYm9yKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9yZXBhaXIgY2hlY2tib3ggLyByYWRpb1xuXHRcdFx0aWYgKCEhc2V0dGluZy5jaGVjayAmJiBzZXR0aW5nLmNoZWNrLmVuYWJsZSAmJiB2aWV3LnJlcGFpckNoa0NsYXNzKSB7XG5cdFx0XHRcdHZpZXcucmVwYWlyQ2hrQ2xhc3Moc2V0dGluZywgb2xkUGFyZW50Tm9kZSk7XG5cdFx0XHRcdHZpZXcucmVwYWlyUGFyZW50Q2hrQ2xhc3NXaXRoU2VsZihzZXR0aW5nLCBvbGRQYXJlbnROb2RlKTtcblx0XHRcdFx0aWYgKG9sZFBhcmVudE5vZGUgIT0gbm9kZS5wYXJlbnQpXG5cdFx0XHRcdFx0dmlldy5yZXBhaXJQYXJlbnRDaGtDbGFzc1dpdGhTZWxmKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2V4cGFuZCBwYXJlbnRzIGFmdGVyIG1vdmVcblx0XHRcdGlmICghaXNTaWxlbnQpIHtcblx0XHRcdFx0dmlldy5leHBhbmRDb2xsYXBzZVBhcmVudE5vZGUoc2V0dGluZywgbm9kZS5nZXRQYXJlbnROb2RlKCksIHRydWUsIGFuaW1hdGVGbGFnKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbW92ZUVkaXRCdG46IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRcdCQkKG5vZGUsIGNvbnN0cy5pZC5FRElULCBzZXR0aW5nKS51bmJpbmQoKS5yZW1vdmUoKTtcblx0XHR9LFxuXHRcdHJlbW92ZVJlbW92ZUJ0bjogZnVuY3Rpb24oc2V0dGluZywgbm9kZSkge1xuXHRcdFx0JCQobm9kZSwgY29uc3RzLmlkLlJFTU9WRSwgc2V0dGluZykudW5iaW5kKCkucmVtb3ZlKCk7XG5cdFx0fSxcblx0XHRyZW1vdmVUcmVlRG9tOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0XHRub2RlLmlzSG92ZXIgPSBmYWxzZTtcblx0XHRcdHZpZXcucmVtb3ZlRWRpdEJ0bihzZXR0aW5nLCBub2RlKTtcblx0XHRcdHZpZXcucmVtb3ZlUmVtb3ZlQnRuKHNldHRpbmcsIG5vZGUpO1xuXHRcdFx0dG9vbHMuYXBwbHkoc2V0dGluZy52aWV3LnJlbW92ZUhvdmVyRG9tLCBbc2V0dGluZy50cmVlSWQsIG5vZGVdKTtcblx0XHR9LFxuXHRcdHJlcGFpck5vZGVMZXZlbENsYXNzOiBmdW5jdGlvbihzZXR0aW5nLCBub2RlLCBvbGRMZXZlbCkge1xuXHRcdFx0aWYgKG9sZExldmVsID09PSBub2RlLmxldmVsKSByZXR1cm47XG5cdFx0XHR2YXIgbGlPYmogPSAkJChub2RlLCBzZXR0aW5nKSxcblx0XHRcdGFPYmogPSAkJChub2RlLCBjb25zdHMuaWQuQSwgc2V0dGluZyksXG5cdFx0XHR1bE9iaiA9ICQkKG5vZGUsIGNvbnN0cy5pZC5VTCwgc2V0dGluZyksXG5cdFx0XHRvbGRDbGFzcyA9IGNvbnN0cy5jbGFzc05hbWUuTEVWRUwgKyBvbGRMZXZlbCxcblx0XHRcdG5ld0NsYXNzID0gY29uc3RzLmNsYXNzTmFtZS5MRVZFTCArIG5vZGUubGV2ZWw7XG5cdFx0XHRsaU9iai5yZW1vdmVDbGFzcyhvbGRDbGFzcyk7XG5cdFx0XHRsaU9iai5hZGRDbGFzcyhuZXdDbGFzcyk7XG5cdFx0XHRhT2JqLnJlbW92ZUNsYXNzKG9sZENsYXNzKTtcblx0XHRcdGFPYmouYWRkQ2xhc3MobmV3Q2xhc3MpO1xuXHRcdFx0dWxPYmoucmVtb3ZlQ2xhc3Mob2xkQ2xhc3MpO1xuXHRcdFx0dWxPYmouYWRkQ2xhc3MobmV3Q2xhc3MpO1xuXHRcdH0sXG5cdFx0c2VsZWN0Tm9kZXMgOiBmdW5jdGlvbihzZXR0aW5nLCBub2Rlcykge1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBsPW5vZGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0dmlldy5zZWxlY3ROb2RlKHNldHRpbmcsIG5vZGVzW2ldLCBpPjApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfeiA9IHtcblx0XHR0b29sczogX3Rvb2xzLFxuXHRcdHZpZXc6IF92aWV3LFxuXHRcdGV2ZW50OiBfZXZlbnQsXG5cdFx0ZGF0YTogX2RhdGFcblx0fTtcblx0JC5leHRlbmQodHJ1ZSwgJC5mbi56VHJlZS5jb25zdHMsIF9jb25zdHMpO1xuXHQkLmV4dGVuZCh0cnVlLCAkLmZuLnpUcmVlLl96LCBfeik7XG5cblx0dmFyIHp0ID0gJC5mbi56VHJlZSxcblx0dG9vbHMgPSB6dC5fei50b29scyxcblx0Y29uc3RzID0genQuY29uc3RzLFxuXHR2aWV3ID0genQuX3oudmlldyxcblx0ZGF0YSA9IHp0Ll96LmRhdGEsXG5cdGV2ZW50ID0genQuX3ouZXZlbnQsXG5cdCQkID0gdG9vbHMuJDtcblxuXHRkYXRhLmV4U2V0dGluZyhfc2V0dGluZyk7XG5cdGRhdGEuYWRkSW5pdEJpbmQoX2JpbmRFdmVudCk7XG5cdGRhdGEuYWRkSW5pdFVuQmluZChfdW5iaW5kRXZlbnQpO1xuXHRkYXRhLmFkZEluaXRDYWNoZShfaW5pdENhY2hlKTtcblx0ZGF0YS5hZGRJbml0Tm9kZShfaW5pdE5vZGUpO1xuXHRkYXRhLmFkZEluaXRQcm94eShfZXZlbnRQcm94eSk7XG5cdGRhdGEuYWRkSW5pdFJvb3QoX2luaXRSb290KTtcblx0ZGF0YS5hZGRaVHJlZVRvb2xzKF96VHJlZVRvb2xzKTtcblxuXHR2YXIgX2NhbmNlbFByZVNlbGVjdGVkTm9kZSA9IHZpZXcuY2FuY2VsUHJlU2VsZWN0ZWROb2RlO1xuXHR2aWV3LmNhbmNlbFByZVNlbGVjdGVkTm9kZSA9IGZ1bmN0aW9uIChzZXR0aW5nLCBub2RlKSB7XG5cdFx0dmFyIGxpc3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZykuY3VyU2VsZWN0ZWRMaXN0O1xuXHRcdGZvciAodmFyIGk9MCwgaj1saXN0Lmxlbmd0aDsgaTxqOyBpKyspIHtcblx0XHRcdGlmICghbm9kZSB8fCBub2RlID09PSBsaXN0W2ldKSB7XG5cdFx0XHRcdHZpZXcucmVtb3ZlVHJlZURvbShzZXR0aW5nLCBsaXN0W2ldKTtcblx0XHRcdFx0aWYgKG5vZGUpIGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoX2NhbmNlbFByZVNlbGVjdGVkTm9kZSkgX2NhbmNlbFByZVNlbGVjdGVkTm9kZS5hcHBseSh2aWV3LCBhcmd1bWVudHMpO1xuXHR9XG5cblx0dmFyIF9jcmVhdGVOb2RlcyA9IHZpZXcuY3JlYXRlTm9kZXM7XG5cdHZpZXcuY3JlYXRlTm9kZXMgPSBmdW5jdGlvbihzZXR0aW5nLCBsZXZlbCwgbm9kZXMsIHBhcmVudE5vZGUpIHtcblx0XHRpZiAoX2NyZWF0ZU5vZGVzKSB7XG5cdFx0XHRfY3JlYXRlTm9kZXMuYXBwbHkodmlldywgYXJndW1lbnRzKTtcblx0XHR9XG5cdFx0aWYgKCFub2RlcykgcmV0dXJuO1xuXHRcdGlmICh2aWV3LnJlcGFpclBhcmVudENoa0NsYXNzV2l0aFNlbGYpIHtcblx0XHRcdHZpZXcucmVwYWlyUGFyZW50Q2hrQ2xhc3NXaXRoU2VsZihzZXR0aW5nLCBwYXJlbnROb2RlKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgX21ha2VOb2RlVXJsID0gdmlldy5tYWtlTm9kZVVybDtcblx0dmlldy5tYWtlTm9kZVVybCA9IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUpIHtcblx0XHRyZXR1cm4gc2V0dGluZy5lZGl0LmVuYWJsZSA/IG51bGwgOiAoX21ha2VOb2RlVXJsLmFwcGx5KHZpZXcsIGFyZ3VtZW50cykpO1xuXHR9XG5cblx0dmFyIF9yZW1vdmVOb2RlID0gdmlldy5yZW1vdmVOb2RlO1xuXHR2aWV3LnJlbW92ZU5vZGUgPSBmdW5jdGlvbihzZXR0aW5nLCBub2RlKSB7XG5cdFx0dmFyIHJvb3QgPSBkYXRhLmdldFJvb3Qoc2V0dGluZyk7XG5cdFx0aWYgKHJvb3QuY3VyRWRpdE5vZGUgPT09IG5vZGUpIHJvb3QuY3VyRWRpdE5vZGUgPSBudWxsO1xuXHRcdGlmIChfcmVtb3ZlTm9kZSkge1xuXHRcdFx0X3JlbW92ZU5vZGUuYXBwbHkodmlldywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgX3NlbGVjdE5vZGUgPSB2aWV3LnNlbGVjdE5vZGU7XG5cdHZpZXcuc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uKHNldHRpbmcsIG5vZGUsIGFkZEZsYWcpIHtcblx0XHR2YXIgcm9vdCA9IGRhdGEuZ2V0Um9vdChzZXR0aW5nKTtcblx0XHRpZiAoZGF0YS5pc1NlbGVjdGVkTm9kZShzZXR0aW5nLCBub2RlKSAmJiByb290LmN1ckVkaXROb2RlID09IG5vZGUgJiYgbm9kZS5lZGl0TmFtZUZsYWcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKF9zZWxlY3ROb2RlKSBfc2VsZWN0Tm9kZS5hcHBseSh2aWV3LCBhcmd1bWVudHMpO1xuXHRcdHZpZXcuYWRkSG92ZXJEb20oc2V0dGluZywgbm9kZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR2YXIgX3VDYW5EbyA9IHRvb2xzLnVDYW5Ebztcblx0dG9vbHMudUNhbkRvID0gZnVuY3Rpb24oc2V0dGluZywgZSkge1xuXHRcdHZhciByb290ID0gZGF0YS5nZXRSb290KHNldHRpbmcpO1xuXHRcdGlmIChlICYmICh0b29scy5lcXMoZS50eXBlLCBcIm1vdXNlb3ZlclwiKSB8fCB0b29scy5lcXMoZS50eXBlLCBcIm1vdXNlb3V0XCIpIHx8IHRvb2xzLmVxcyhlLnR5cGUsIFwibW91c2Vkb3duXCIpIHx8IHRvb2xzLmVxcyhlLnR5cGUsIFwibW91c2V1cFwiKSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAocm9vdC5jdXJFZGl0Tm9kZSkge1xuXHRcdFx0dmlldy5lZGl0Tm9kZUJsdXIgPSBmYWxzZTtcblx0XHRcdHJvb3QuY3VyRWRpdElucHV0LmZvY3VzKCk7XG5cdFx0fVxuXHRcdHJldHVybiAoIXJvb3QuY3VyRWRpdE5vZGUpICYmIChfdUNhbkRvID8gX3VDYW5Eby5hcHBseSh2aWV3LCBhcmd1bWVudHMpIDogdHJ1ZSk7XG5cdH1cbn0pKGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9qcy9wbHVnaW5zL3p0cmVlL2pxdWVyeS56dHJlZS5hbGwubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n')},function(module,exports){eval('/**\n * \t构造Ztree 说明。\n * \n * \t快速构造默认配置的ztree\n * \tnew ZtreeCreator(\'treeId\',url).initZtree(param); \n * \ttreeId:树的Id，url：请求的url ， \n *\tinitZtree(param,level,call); \n *\t\tparma 异步请求提供参数，\n *   \t\tlevel展开层级（可略，默认展开全部），\n *   \t\tcall 回调提供Ztree初始化对象  \n *\n *\n *　完整例子\n *\tvar ztreeCreator = new ZtreeCreator(\'groupTree\',url)\n *\t\t\t.setCallback({beforeClick:beforeClick,onClick:zTreeOnLeftClick,onRightClick:zTreeOnRightClick})\n *\t\t\t.initZtree(params,function(treeObj){groupTree=treeObj}); \n *\n  ****/\nwindow.ZtreeCreator = function(treeId,url,initJson){\n\t\n\tif(!treeId) alert("构造Ztree必须提供 treeId");\n\tthis.treeId = treeId;\n\t\n\tvar _treeObj;\n\tvar outLookStyle =false;\n\t\n\t \n\t/**初始化树**/\t\n\tthis.initZtree = function(param,level,callBack){\n\t\tif(!url && !_setting.async.url) alert("构造Ztree必须提供 请求地址！");\n\t\tif (jQuery.isFunction(param)) {\n\t\t\tcallBack = param;\n\t\t\tparam = {}; \n\t\t}\n\t\t\n\t\tif (jQuery.isFunction(level)) {\n\t\t\tcallBack = level; \n\t\t\tlevel = false;\n\t\t}\n\t\tif(!param) param = {};\n\t\t\n\t\t// 通过json初始化树\n\t\tif(initJson){\n\t\t\tpushJsonToBuildTree(initJson,level,callBack);\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t//如果异步加载\n\t\tif(_setting.async.url){\n\t\t\t_treeObj=jQuery.fn.zTree.init(jQuery("#"+treeId), _setting);\n\t\t\treturn this;\n\t\t}\n\t\t//一次性加载\n\t\tjQuery.post(url,param,function(result){\n\t\t\tif(Object.prototype.toString.call(result) === "[object String]"){\n\t\t\t\tresult =eval(\'(\' + result + \')\');\n\t\t\t}\n\t\t\t\n\t\t\tif(result && result.code){\n\t\t\t\tresult = result.data;\n\t\t\t}\n\t\t\tpushJsonToBuildTree(result,level,callBack);\n\t\t});\n\t\treturn this;\n\t}\n\t function pushJsonToBuildTree(json,level,callBack){\n\t\t_treeObj = jQuery.fn.zTree.init(jQuery("#"+treeId),_setting,json);\n\t\t//展开层级\n\t\tif(level){\n\t\t\t_treeObj.expandAll(false);\n\t\t\texpandTree(_treeObj,_treeObj.getNodes(),level);\n\t\t}\n\t\telse{ _treeObj.expandAll(true); }\n\t\t\n\t\tif(jQuery.isFunction(callBack)) callBack(_treeObj,treeId); \n\t\t\n\t\tif(outLookStyle){\n\t\t\ttry{\n\t\t\t\tvar curMenu = _treeObj.getNodes()[0].children[0].children[0];\n\t\t\t}catch(e){}\n\t\t\t_treeObj.selectNode(curMenu);\n\t\t}\n\t}\n\t\n\tthis.getTreeObj = function(){\n\t\tif(!_treeObj) alert(treeId+"尚未初始化");\n\t\treturn _treeObj;\n\t};\n\t\n\t\n\t/**设置树展示的标识key  {idKey:"idKEY名称",pIdKey:"",name:"显示名称",title,rootPid}\n\t * idKey 默认 id\n\t * pIdKey 默认 parentId\n\t * name 默认 name\n\t * title 默认 name\n\t * */\n\tthis.setDataKey = function(keys){\n\t\tif(!keys) return this;\n\t\tif(keys.idKey) _setting.data.simpleData.idKey = keys.idKey;\n\t\tif(keys.pIdKey) _setting.data.simpleData.pIdKey = keys.pIdKey;\n\t\tif(keys.name) _setting.data.key.name = keys.name;\n\t\tif(keys.title) _setting.data.key.title = keys.title;\n\t\tif(keys.rootPId) _setting.data.simpleData.rootPId=keys.rootPId;\n\t\t\n\t\treturn this;\n\t}\n\tthis.setChildKey = function(key){\n\t\tif(!key)key = "children";\n\t\t_setting.data.simpleData.enable = false;\n\t\t_setting.data.key.children =key;\n\t\treturn this;\n\t}\n\t\n\t/** 设置选择框的方式默认没有选择框\n\t * 如果需要选择框，不需要级联 则传 true\n\t * param  true   or  { "Y": "p", "N": "s" }\n\t */\n\tthis.setCheckboxType = function(type){\n\t\t_setting.check.enable = true\n\t\tif(type instanceof Object){\n\t\t\t_setting.check.chkboxType = type;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**这里支持Ztree 所有的回调方法，请查API\n\t * eg:传入参数{beforeClick：beforeClick,onClick:onClick,beforeCheck:beforeCheck}\n\t **/\n\tthis.setCallback = function(callBack){\n\t\tif(callBack instanceof Object) \n\t\tfor(call in callBack){\n\t\t\tif(!jQuery.isFunction(callBack[call])) alert(call+" :is not a function");\n\t\t\t_setting.callback[call]\t= callBack[call];\n\t\t}\n\t\treturn this; \n\t}\n\t\n\t/** 异步加载 */\n\tthis.setAsync = function(conf){\n\t\t_setting.async = conf;\n\t\treturn this; \n\t}\n\t\n\t/**是否显示图标配置项**/\n\tthis.setShowIcon = function(call){\n\t\t_setting.view.showIcon = call;\n\t\treturn this; \n\t}\n\t/**设置一些特殊的值请参照 Ztree _setting 格式 ***/\n\tthis.setSetingParam = function(param){\n\t\tif(param instanceof Object) \n\t\tfor(p in param){\n\t\t\t_setting[p]\t= param[p];\n\t\t}\n\t\treturn this; \n\t}\n\tthis.setOutLookStyle =function(){\n\t\t//设置一些参数 \n\t\tthis.setSetingParam({view :{showLine: false, showIcon: true,\n\t\t\t\tselectedMulti: false, dblClickExpand: false,\n\t\t\t\taddDiyDom: function(treeId, treeNode){\n\t\t\t\t\t\tvar spaceWidth = 15;\n\t\t\t\t\t\tvar switchObj = jQuery("#" + treeNode.tId + "_switch"),\n\t\t\t\t\t\ticoObj = jQuery("#" + treeNode.tId + "_ico");\n\t\t\t\t\t\tswitchObj.remove();\n\t\t\t\t\t\tif(!treeNode.children ||treeNode.children.length==0){\n\t\t\t\t\t\t\tswitchObj.removeClass("switch");\n\t\t\t\t\t\t}\n\t\t\t\t\t\ticoObj.before(switchObj);\n\t\t\t\t\t\tif (treeNode.level > 0){\n\t\t\t\t\t\t\tvar spaceStr = "<span style=\'display: inline-block;width:" + (spaceWidth * treeNode.level)+ "px\'></span>";\n\t\t\t\t\t\t\tswitchObj.before(spaceStr);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}});\n\t\t\n\t\tjQuery("#"+treeId).addClass("showIcon"); \n\t\toutLookStyle =true;\n\t\treturn this;\n\t}\n\t/***\n\t * 注意。isShowIn!= treeId，当前情况treeId可以随意写。只要唯一即可\n\t * isShowIn,被显示在某个元素下面，比如 input框，做成累似comboTree的样子\n\t * width,height 设置出现 那个 combox的宽高\n\t * TODO 如果是input 设置 autoSetValue = true ， 扩展回显和自动填值功能。\n\t */\n\tvar _isShowIn,_menuContent;\n\tthis.makeCombTree = function(isShowIn,width,height){\n\t\theight = height? height:300;\n\t\twidth = width || jQuery("#"+isShowIn).outerWidth() || 163;\n\t\t_menuContent = treeId+"MenuContent";\n\t\t_isShowIn = isShowIn; \n\t\tvar menuContent =\'<div id="\'+_menuContent+\'" style="width:\'+width+\'px; height:\'+height+\'px;overflow-y:scroll; position:absolute;z-index: 9999;display:none;background-color:#F5F5F5">\'\n\t\t\t\t\t+\'<ul id="\'+treeId+\'" class="ztree" ></ul></div>\';\n\t\tjQuery("#"+isShowIn).after(menuContent); \n\t\tjQuery("#"+isShowIn).bind("click",this.showMenu);  \n\t\treturn this;\n\t}\n\t// 可以添加一个目标对象，如果是添加了点击事件的，则默认\n\tthis.showMenu = function(target){\n\t\tif(!target || target.currentTarget) {\n\t\t\ttarget = jQuery(this);\n\t\t}\n\n\t\tvar btnOffset =  target.offset();\n\t\tbtnOffset.top = btnOffset.top + target.outerHeight();\n\t\t\n\t\tjQuery("#"+_menuContent).css({left:btnOffset.left + "px", top:btnOffset.top + target.outerHeight() + "px"}).slideDown("fast");\n\t\tjQuery("#"+_menuContent).offset(btnOffset);\n\t\t\n\t\tjQuery("body").bind("mousedown",onBodyDown);\n\t}\n\tthis.hideMenu =function(){\n\t\thideMenu(); \n\t}\n\t\n\tvar onBodyDown = function (event){\n\t\tif (!(event.target.id == _isShowIn || event.target.id == _menuContent || jQuery(event.target).parents("#"+_menuContent).length>0)){\n\t\t\thideMenu();\n\t\t}\n\t}\n\tvar hideMenu = function(){\n\t\tjQuery("#"+_menuContent).fadeOut("fast");\n\t\tjQuery("body").unbind("mousedown", onBodyDown);\n\t}\n\t\n\t/**_setting 私有 配置项**/ \n\tvar _setting = {\n\t\t\tdata: {\n\t\t\t\tkey:{\n\t\t\t\t\tname: "name",\n\t\t\t\t\ttitle: "name"\n\t\t\t\t},\n\t\t\t\tsimpleData: {\n\t\t\t\t\tenable: true,\n\t\t\t\t\tidKey: "id",\n\t\t\t\t\tpIdKey: "parentId",\n\t\t\t\t\trootPId:0\n\t\t\t\t}\n\t\t\t},\n\t\t\tasync: {enable: false},\n\t\t\tedit: {\n\t\t\t\t\tdrag: {isCopy:true},\n\t\t\t\t\tenable: true,\n\t\t\t\t\tshowRemoveBtn: false,\n\t\t\t\t\tshowRenameBtn: false\n\t\t\t\t},\n\t\t\tview:{\n\t\t\t\tnameIsHTML: true,\n\t\t\t\tselectedMulti: true,\n\t\t\t\tshowIconFont:true,\n\t\t\t    showIcon: null\n\t\t\t},\n\t\t\tcheck: {\n\t\t\t\tenable: false,\n\t\t\t\tchkboxType: { "Y": "", "N": "" }\n\t\t\t},\n\t\t\tcallback:{\n\t\t\t\tbeforeClick: null,\n\t\t\t\tonClick: null,\n\t\t\t\tonRightClick: null,\n\t\t\t\tbeforeDrop: null,\n\t\t\t\tonDrop: null\n\t\t\t}\n\t\t}\n\t\t\n\t\t/***设置展开层级*/\n\t function expandTree(treeObj,nodes,level){\n\t\t\tvar thelevel=level-1;  \n            for(var i=0;i<nodes.length;i++)\n            {\n            \tvar node =nodes[i];\n                treeObj.expandNode(node, true, false, false);  \n                if(thelevel>0 && node.children && node.children.length>0)\n                {\n                    expandTree(treeObj, node.children,thelevel);   \n                }  \n            }  \n\t}\n\t\n\t};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvcGx1Z2lucy96dHJlZS96dHJlZUNyZWF0b3IuanM/ODRjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EO0FBQ0E7QUFDQSwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdGQUFnRjtBQUNuRyx5Q0FBeUMsa0JBQWtCLEU7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGM7QUFDQTs7QUFFQTtBQUNBLG9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywwQkFBMEI7O0FBRWpDLDREOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsMEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7QUFDQSx3RUFBd0UscUJBQXFCLGtCQUFrQixtQkFBbUIsY0FBYyxhQUFhO0FBQzdKO0FBQ0EsMEM7QUFDQSxtRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLDRFQUE0RTtBQUM1Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBLDZEO0FBQ0E7QUFDQTtBQUNBLGdFO0FBQ0EsaUI7QUFDQSxhO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFx05p6E6YCgWnRyZWUg6K+05piO44CCXG4gKiBcbiAqIFx05b+r6YCf5p6E6YCg6buY6K6k6YWN572u55qEenRyZWVcbiAqIFx0bmV3IFp0cmVlQ3JlYXRvcigndHJlZUlkJyx1cmwpLmluaXRadHJlZShwYXJhbSk7IFxuICogXHR0cmVlSWQ65qCR55qESWTvvIx1cmzvvJror7fmsYLnmoR1cmwg77yMIFxuICpcdGluaXRadHJlZShwYXJhbSxsZXZlbCxjYWxsKTsgXG4gKlx0XHRwYXJtYSDlvILmraXor7fmsYLmj5Dkvpvlj4LmlbDvvIxcbiAqICAgXHRcdGxldmVs5bGV5byA5bGC57qn77yI5Y+v55Wl77yM6buY6K6k5bGV5byA5YWo6YOo77yJ77yMXG4gKiAgIFx0XHRjYWxsIOWbnuiwg+aPkOS+m1p0cmVl5Yid5aeL5YyW5a+56LGhICBcbiAqXG4gKlxuICrjgIDlrozmlbTkvovlrZBcbiAqXHR2YXIgenRyZWVDcmVhdG9yID0gbmV3IFp0cmVlQ3JlYXRvcignZ3JvdXBUcmVlJyx1cmwpXG4gKlx0XHRcdC5zZXRDYWxsYmFjayh7YmVmb3JlQ2xpY2s6YmVmb3JlQ2xpY2ssb25DbGljazp6VHJlZU9uTGVmdENsaWNrLG9uUmlnaHRDbGljazp6VHJlZU9uUmlnaHRDbGlja30pXG4gKlx0XHRcdC5pbml0WnRyZWUocGFyYW1zLGZ1bmN0aW9uKHRyZWVPYmope2dyb3VwVHJlZT10cmVlT2JqfSk7IFxuICpcbiAgKioqKi9cbndpbmRvdy5adHJlZUNyZWF0b3IgPSBmdW5jdGlvbih0cmVlSWQsdXJsLGluaXRKc29uKXtcblx0XG5cdGlmKCF0cmVlSWQpIGFsZXJ0KFwi5p6E6YCgWnRyZWXlv4Xpobvmj5DkvpsgdHJlZUlkXCIpO1xuXHR0aGlzLnRyZWVJZCA9IHRyZWVJZDtcblx0XG5cdHZhciBfdHJlZU9iajtcblx0dmFyIG91dExvb2tTdHlsZSA9ZmFsc2U7XG5cdFxuXHQgXG5cdC8qKuWIneWni+WMluagkSoqL1x0XG5cdHRoaXMuaW5pdFp0cmVlID0gZnVuY3Rpb24ocGFyYW0sbGV2ZWwsY2FsbEJhY2spe1xuXHRcdGlmKCF1cmwgJiYgIV9zZXR0aW5nLmFzeW5jLnVybCkgYWxlcnQoXCLmnoTpgKBadHJlZeW/hemhu+aPkOS+myDor7fmsYLlnLDlnYDvvIFcIik7XG5cdFx0aWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHBhcmFtKSkge1xuXHRcdFx0Y2FsbEJhY2sgPSBwYXJhbTtcblx0XHRcdHBhcmFtID0ge307IFxuXHRcdH1cblx0XHRcblx0XHRpZiAoalF1ZXJ5LmlzRnVuY3Rpb24obGV2ZWwpKSB7XG5cdFx0XHRjYWxsQmFjayA9IGxldmVsOyBcblx0XHRcdGxldmVsID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKCFwYXJhbSkgcGFyYW0gPSB7fTtcblx0XHRcblx0XHQvLyDpgJrov4dqc29u5Yid5aeL5YyW5qCRXG5cdFx0aWYoaW5pdEpzb24pe1xuXHRcdFx0cHVzaEpzb25Ub0J1aWxkVHJlZShpbml0SnNvbixsZXZlbCxjYWxsQmFjayk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0Ly/lpoLmnpzlvILmraXliqDovb1cblx0XHRpZihfc2V0dGluZy5hc3luYy51cmwpe1xuXHRcdFx0X3RyZWVPYmo9alF1ZXJ5LmZuLnpUcmVlLmluaXQoalF1ZXJ5KFwiI1wiK3RyZWVJZCksIF9zZXR0aW5nKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHQvL+S4gOasoeaAp+WKoOi9vVxuXHRcdGpRdWVyeS5wb3N0KHVybCxwYXJhbSxmdW5jdGlvbihyZXN1bHQpe1xuXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlc3VsdCkgPT09IFwiW29iamVjdCBTdHJpbmddXCIpe1xuXHRcdFx0XHRyZXN1bHQgPWV2YWwoJygnICsgcmVzdWx0ICsgJyknKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYocmVzdWx0ICYmIHJlc3VsdC5jb2RlKXtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LmRhdGE7XG5cdFx0XHR9XG5cdFx0XHRwdXNoSnNvblRvQnVpbGRUcmVlKHJlc3VsdCxsZXZlbCxjYWxsQmFjayk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0IGZ1bmN0aW9uIHB1c2hKc29uVG9CdWlsZFRyZWUoanNvbixsZXZlbCxjYWxsQmFjayl7XG5cdFx0X3RyZWVPYmogPSBqUXVlcnkuZm4uelRyZWUuaW5pdChqUXVlcnkoXCIjXCIrdHJlZUlkKSxfc2V0dGluZyxqc29uKTtcblx0XHQvL+WxleW8gOWxgue6p1xuXHRcdGlmKGxldmVsKXtcblx0XHRcdF90cmVlT2JqLmV4cGFuZEFsbChmYWxzZSk7XG5cdFx0XHRleHBhbmRUcmVlKF90cmVlT2JqLF90cmVlT2JqLmdldE5vZGVzKCksbGV2ZWwpO1xuXHRcdH1cblx0XHRlbHNleyBfdHJlZU9iai5leHBhbmRBbGwodHJ1ZSk7IH1cblx0XHRcblx0XHRpZihqUXVlcnkuaXNGdW5jdGlvbihjYWxsQmFjaykpIGNhbGxCYWNrKF90cmVlT2JqLHRyZWVJZCk7IFxuXHRcdFxuXHRcdGlmKG91dExvb2tTdHlsZSl7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdHZhciBjdXJNZW51ID0gX3RyZWVPYmouZ2V0Tm9kZXMoKVswXS5jaGlsZHJlblswXS5jaGlsZHJlblswXTtcblx0XHRcdH1jYXRjaChlKXt9XG5cdFx0XHRfdHJlZU9iai5zZWxlY3ROb2RlKGN1ck1lbnUpO1xuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5nZXRUcmVlT2JqID0gZnVuY3Rpb24oKXtcblx0XHRpZighX3RyZWVPYmopIGFsZXJ0KHRyZWVJZCtcIuWwmuacquWIneWni+WMllwiKTtcblx0XHRyZXR1cm4gX3RyZWVPYmo7XG5cdH07XG5cdFxuXHRcblx0Lyoq6K6+572u5qCR5bGV56S655qE5qCH6K+Ga2V5ICB7aWRLZXk6XCJpZEtFWeWQjeensFwiLHBJZEtleTpcIlwiLG5hbWU6XCLmmL7npLrlkI3np7BcIix0aXRsZSxyb290UGlkfVxuXHQgKiBpZEtleSDpu5jorqQgaWRcblx0ICogcElkS2V5IOm7mOiupCBwYXJlbnRJZFxuXHQgKiBuYW1lIOm7mOiupCBuYW1lXG5cdCAqIHRpdGxlIOm7mOiupCBuYW1lXG5cdCAqICovXG5cdHRoaXMuc2V0RGF0YUtleSA9IGZ1bmN0aW9uKGtleXMpe1xuXHRcdGlmKCFrZXlzKSByZXR1cm4gdGhpcztcblx0XHRpZihrZXlzLmlkS2V5KSBfc2V0dGluZy5kYXRhLnNpbXBsZURhdGEuaWRLZXkgPSBrZXlzLmlkS2V5O1xuXHRcdGlmKGtleXMucElkS2V5KSBfc2V0dGluZy5kYXRhLnNpbXBsZURhdGEucElkS2V5ID0ga2V5cy5wSWRLZXk7XG5cdFx0aWYoa2V5cy5uYW1lKSBfc2V0dGluZy5kYXRhLmtleS5uYW1lID0ga2V5cy5uYW1lO1xuXHRcdGlmKGtleXMudGl0bGUpIF9zZXR0aW5nLmRhdGEua2V5LnRpdGxlID0ga2V5cy50aXRsZTtcblx0XHRpZihrZXlzLnJvb3RQSWQpIF9zZXR0aW5nLmRhdGEuc2ltcGxlRGF0YS5yb290UElkPWtleXMucm9vdFBJZDtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0aGlzLnNldENoaWxkS2V5ID0gZnVuY3Rpb24oa2V5KXtcblx0XHRpZigha2V5KWtleSA9IFwiY2hpbGRyZW5cIjtcblx0XHRfc2V0dGluZy5kYXRhLnNpbXBsZURhdGEuZW5hYmxlID0gZmFsc2U7XG5cdFx0X3NldHRpbmcuZGF0YS5rZXkuY2hpbGRyZW4gPWtleTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRcblx0LyoqIOiuvue9rumAieaLqeahhueahOaWueW8j+m7mOiupOayoeaciemAieaLqeahhlxuXHQgKiDlpoLmnpzpnIDopoHpgInmi6nmoYbvvIzkuI3pnIDopoHnuqfogZQg5YiZ5LygIHRydWVcblx0ICogcGFyYW0gIHRydWUgICBvciAgeyBcIllcIjogXCJwXCIsIFwiTlwiOiBcInNcIiB9XG5cdCAqL1xuXHR0aGlzLnNldENoZWNrYm94VHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuXHRcdF9zZXR0aW5nLmNoZWNrLmVuYWJsZSA9IHRydWVcblx0XHRpZih0eXBlIGluc3RhbmNlb2YgT2JqZWN0KXtcblx0XHRcdF9zZXR0aW5nLmNoZWNrLmNoa2JveFR5cGUgPSB0eXBlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRcblx0Lyoq6L+Z6YeM5pSv5oyBWnRyZWUg5omA5pyJ55qE5Zue6LCD5pa55rOV77yM6K+35p+lQVBJXG5cdCAqIGVnOuS8oOWFpeWPguaVsHtiZWZvcmVDbGlja++8mmJlZm9yZUNsaWNrLG9uQ2xpY2s6b25DbGljayxiZWZvcmVDaGVjazpiZWZvcmVDaGVja31cblx0ICoqL1xuXHR0aGlzLnNldENhbGxiYWNrID0gZnVuY3Rpb24oY2FsbEJhY2spe1xuXHRcdGlmKGNhbGxCYWNrIGluc3RhbmNlb2YgT2JqZWN0KSBcblx0XHRmb3IoY2FsbCBpbiBjYWxsQmFjayl7XG5cdFx0XHRpZighalF1ZXJ5LmlzRnVuY3Rpb24oY2FsbEJhY2tbY2FsbF0pKSBhbGVydChjYWxsK1wiIDppcyBub3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdF9zZXR0aW5nLmNhbGxiYWNrW2NhbGxdXHQ9IGNhbGxCYWNrW2NhbGxdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpczsgXG5cdH1cblx0XG5cdC8qKiDlvILmraXliqDovb0gKi9cblx0dGhpcy5zZXRBc3luYyA9IGZ1bmN0aW9uKGNvbmYpe1xuXHRcdF9zZXR0aW5nLmFzeW5jID0gY29uZjtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH1cblx0XG5cdC8qKuaYr+WQpuaYvuekuuWbvuagh+mFjee9rumhuSoqL1xuXHR0aGlzLnNldFNob3dJY29uID0gZnVuY3Rpb24oY2FsbCl7XG5cdFx0X3NldHRpbmcudmlldy5zaG93SWNvbiA9IGNhbGw7XG5cdFx0cmV0dXJuIHRoaXM7IFxuXHR9XG5cdC8qKuiuvue9ruS4gOS6m+eJueauiueahOWAvOivt+WPgueFpyBadHJlZSBfc2V0dGluZyDmoLzlvI8gKioqL1xuXHR0aGlzLnNldFNldGluZ1BhcmFtID0gZnVuY3Rpb24ocGFyYW0pe1xuXHRcdGlmKHBhcmFtIGluc3RhbmNlb2YgT2JqZWN0KSBcblx0XHRmb3IocCBpbiBwYXJhbSl7XG5cdFx0XHRfc2V0dGluZ1twXVx0PSBwYXJhbVtwXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7IFxuXHR9XG5cdHRoaXMuc2V0T3V0TG9va1N0eWxlID1mdW5jdGlvbigpe1xuXHRcdC8v6K6+572u5LiA5Lqb5Y+C5pWwIFxuXHRcdHRoaXMuc2V0U2V0aW5nUGFyYW0oe3ZpZXcgOntzaG93TGluZTogZmFsc2UsIHNob3dJY29uOiB0cnVlLFxuXHRcdFx0XHRzZWxlY3RlZE11bHRpOiBmYWxzZSwgZGJsQ2xpY2tFeHBhbmQ6IGZhbHNlLFxuXHRcdFx0XHRhZGREaXlEb206IGZ1bmN0aW9uKHRyZWVJZCwgdHJlZU5vZGUpe1xuXHRcdFx0XHRcdFx0dmFyIHNwYWNlV2lkdGggPSAxNTtcblx0XHRcdFx0XHRcdHZhciBzd2l0Y2hPYmogPSBqUXVlcnkoXCIjXCIgKyB0cmVlTm9kZS50SWQgKyBcIl9zd2l0Y2hcIiksXG5cdFx0XHRcdFx0XHRpY29PYmogPSBqUXVlcnkoXCIjXCIgKyB0cmVlTm9kZS50SWQgKyBcIl9pY29cIik7XG5cdFx0XHRcdFx0XHRzd2l0Y2hPYmoucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRpZighdHJlZU5vZGUuY2hpbGRyZW4gfHx0cmVlTm9kZS5jaGlsZHJlbi5sZW5ndGg9PTApe1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2hPYmoucmVtb3ZlQ2xhc3MoXCJzd2l0Y2hcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpY29PYmouYmVmb3JlKHN3aXRjaE9iaik7XG5cdFx0XHRcdFx0XHRpZiAodHJlZU5vZGUubGV2ZWwgPiAwKXtcblx0XHRcdFx0XHRcdFx0dmFyIHNwYWNlU3RyID0gXCI8c3BhbiBzdHlsZT0nZGlzcGxheTogaW5saW5lLWJsb2NrO3dpZHRoOlwiICsgKHNwYWNlV2lkdGggKiB0cmVlTm9kZS5sZXZlbCkrIFwicHgnPjwvc3Bhbj5cIjtcblx0XHRcdFx0XHRcdFx0c3dpdGNoT2JqLmJlZm9yZShzcGFjZVN0cik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH19KTtcblx0XHRcblx0XHRqUXVlcnkoXCIjXCIrdHJlZUlkKS5hZGRDbGFzcyhcInNob3dJY29uXCIpOyBcblx0XHRvdXRMb29rU3R5bGUgPXRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqKlxuXHQgKiDms6jmhI/jgIJpc1Nob3dJbiE9IHRyZWVJZO+8jOW9k+WJjeaDheWGtXRyZWVJZOWPr+S7pemaj+aEj+WGmeOAguWPquimgeWUr+S4gOWNs+WPr1xuXHQgKiBpc1Nob3dJbizooqvmmL7npLrlnKjmn5DkuKrlhYPntKDkuIvpnaLvvIzmr5TlpoIgaW5wdXTmoYbvvIzlgZrmiJDntK/kvLxjb21ib1RyZWXnmoTmoLflrZBcblx0ICogd2lkdGgsaGVpZ2h0IOiuvue9ruWHuueOsCDpgqPkuKogY29tYm9455qE5a696auYXG5cdCAqIFRPRE8g5aaC5p6c5pivaW5wdXQg6K6+572uIGF1dG9TZXRWYWx1ZSA9IHRydWUg77yMIOaJqeWxleWbnuaYvuWSjOiHquWKqOWhq+WAvOWKn+iDveOAglxuXHQgKi9cblx0dmFyIF9pc1Nob3dJbixfbWVudUNvbnRlbnQ7XG5cdHRoaXMubWFrZUNvbWJUcmVlID0gZnVuY3Rpb24oaXNTaG93SW4sd2lkdGgsaGVpZ2h0KXtcblx0XHRoZWlnaHQgPSBoZWlnaHQ/IGhlaWdodDozMDA7XG5cdFx0d2lkdGggPSB3aWR0aCB8fCBqUXVlcnkoXCIjXCIraXNTaG93SW4pLm91dGVyV2lkdGgoKSB8fCAxNjM7XG5cdFx0X21lbnVDb250ZW50ID0gdHJlZUlkK1wiTWVudUNvbnRlbnRcIjtcblx0XHRfaXNTaG93SW4gPSBpc1Nob3dJbjsgXG5cdFx0dmFyIG1lbnVDb250ZW50ID0nPGRpdiBpZD1cIicrX21lbnVDb250ZW50KydcIiBzdHlsZT1cIndpZHRoOicrd2lkdGgrJ3B4OyBoZWlnaHQ6JytoZWlnaHQrJ3B4O292ZXJmbG93LXk6c2Nyb2xsOyBwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OiA5OTk5O2Rpc3BsYXk6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNGNUY1RjVcIj4nXG5cdFx0XHRcdFx0Kyc8dWwgaWQ9XCInK3RyZWVJZCsnXCIgY2xhc3M9XCJ6dHJlZVwiID48L3VsPjwvZGl2Pic7XG5cdFx0alF1ZXJ5KFwiI1wiK2lzU2hvd0luKS5hZnRlcihtZW51Q29udGVudCk7IFxuXHRcdGpRdWVyeShcIiNcIitpc1Nob3dJbikuYmluZChcImNsaWNrXCIsdGhpcy5zaG93TWVudSk7ICBcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvLyDlj6/ku6Xmt7vliqDkuIDkuKrnm67moIflr7nosaHvvIzlpoLmnpzmmK/mt7vliqDkuobngrnlh7vkuovku7bnmoTvvIzliJnpu5jorqRcblx0dGhpcy5zaG93TWVudSA9IGZ1bmN0aW9uKHRhcmdldCl7XG5cdFx0aWYoIXRhcmdldCB8fCB0YXJnZXQuY3VycmVudFRhcmdldCkge1xuXHRcdFx0dGFyZ2V0ID0galF1ZXJ5KHRoaXMpO1xuXHRcdH1cblxuXHRcdHZhciBidG5PZmZzZXQgPSAgdGFyZ2V0Lm9mZnNldCgpO1xuXHRcdGJ0bk9mZnNldC50b3AgPSBidG5PZmZzZXQudG9wICsgdGFyZ2V0Lm91dGVySGVpZ2h0KCk7XG5cdFx0XG5cdFx0alF1ZXJ5KFwiI1wiK19tZW51Q29udGVudCkuY3NzKHtsZWZ0OmJ0bk9mZnNldC5sZWZ0ICsgXCJweFwiLCB0b3A6YnRuT2Zmc2V0LnRvcCArIHRhcmdldC5vdXRlckhlaWdodCgpICsgXCJweFwifSkuc2xpZGVEb3duKFwiZmFzdFwiKTtcblx0XHRqUXVlcnkoXCIjXCIrX21lbnVDb250ZW50KS5vZmZzZXQoYnRuT2Zmc2V0KTtcblx0XHRcblx0XHRqUXVlcnkoXCJib2R5XCIpLmJpbmQoXCJtb3VzZWRvd25cIixvbkJvZHlEb3duKTtcblx0fVxuXHR0aGlzLmhpZGVNZW51ID1mdW5jdGlvbigpe1xuXHRcdGhpZGVNZW51KCk7IFxuXHR9XG5cdFxuXHR2YXIgb25Cb2R5RG93biA9IGZ1bmN0aW9uIChldmVudCl7XG5cdFx0aWYgKCEoZXZlbnQudGFyZ2V0LmlkID09IF9pc1Nob3dJbiB8fCBldmVudC50YXJnZXQuaWQgPT0gX21lbnVDb250ZW50IHx8IGpRdWVyeShldmVudC50YXJnZXQpLnBhcmVudHMoXCIjXCIrX21lbnVDb250ZW50KS5sZW5ndGg+MCkpe1xuXHRcdFx0aGlkZU1lbnUoKTtcblx0XHR9XG5cdH1cblx0dmFyIGhpZGVNZW51ID0gZnVuY3Rpb24oKXtcblx0XHRqUXVlcnkoXCIjXCIrX21lbnVDb250ZW50KS5mYWRlT3V0KFwiZmFzdFwiKTtcblx0XHRqUXVlcnkoXCJib2R5XCIpLnVuYmluZChcIm1vdXNlZG93blwiLCBvbkJvZHlEb3duKTtcblx0fVxuXHRcblx0LyoqX3NldHRpbmcg56eB5pyJIOmFjee9rumhuSoqLyBcblx0dmFyIF9zZXR0aW5nID0ge1xuXHRcdFx0ZGF0YToge1xuXHRcdFx0XHRrZXk6e1xuXHRcdFx0XHRcdG5hbWU6IFwibmFtZVwiLFxuXHRcdFx0XHRcdHRpdGxlOiBcIm5hbWVcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzaW1wbGVEYXRhOiB7XG5cdFx0XHRcdFx0ZW5hYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGlkS2V5OiBcImlkXCIsXG5cdFx0XHRcdFx0cElkS2V5OiBcInBhcmVudElkXCIsXG5cdFx0XHRcdFx0cm9vdFBJZDowXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhc3luYzoge2VuYWJsZTogZmFsc2V9LFxuXHRcdFx0ZWRpdDoge1xuXHRcdFx0XHRcdGRyYWc6IHtpc0NvcHk6dHJ1ZX0sXG5cdFx0XHRcdFx0ZW5hYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHNob3dSZW1vdmVCdG46IGZhbHNlLFxuXHRcdFx0XHRcdHNob3dSZW5hbWVCdG46IGZhbHNlXG5cdFx0XHRcdH0sXG5cdFx0XHR2aWV3Ontcblx0XHRcdFx0bmFtZUlzSFRNTDogdHJ1ZSxcblx0XHRcdFx0c2VsZWN0ZWRNdWx0aTogdHJ1ZSxcblx0XHRcdFx0c2hvd0ljb25Gb250OnRydWUsXG5cdFx0XHQgICAgc2hvd0ljb246IG51bGxcblx0XHRcdH0sXG5cdFx0XHRjaGVjazoge1xuXHRcdFx0XHRlbmFibGU6IGZhbHNlLFxuXHRcdFx0XHRjaGtib3hUeXBlOiB7IFwiWVwiOiBcIlwiLCBcIk5cIjogXCJcIiB9XG5cdFx0XHR9LFxuXHRcdFx0Y2FsbGJhY2s6e1xuXHRcdFx0XHRiZWZvcmVDbGljazogbnVsbCxcblx0XHRcdFx0b25DbGljazogbnVsbCxcblx0XHRcdFx0b25SaWdodENsaWNrOiBudWxsLFxuXHRcdFx0XHRiZWZvcmVEcm9wOiBudWxsLFxuXHRcdFx0XHRvbkRyb3A6IG51bGxcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0LyoqKuiuvue9ruWxleW8gOWxgue6pyovXG5cdCBmdW5jdGlvbiBleHBhbmRUcmVlKHRyZWVPYmosbm9kZXMsbGV2ZWwpe1xuXHRcdFx0dmFyIHRoZWxldmVsPWxldmVsLTE7ICBcbiAgICAgICAgICAgIGZvcih2YXIgaT0wO2k8bm9kZXMubGVuZ3RoO2krKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgIFx0dmFyIG5vZGUgPW5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIHRyZWVPYmouZXhwYW5kTm9kZShub2RlLCB0cnVlLCBmYWxzZSwgZmFsc2UpOyAgXG4gICAgICAgICAgICAgICAgaWYodGhlbGV2ZWw+MCAmJiBub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoPjApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRUcmVlKHRyZWVPYmosIG5vZGUuY2hpbGRyZW4sdGhlbGV2ZWwpOyAgIFxuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfSAgXG5cdH1cblx0XG5cdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9qcy9wbHVnaW5zL3p0cmVlL3p0cmVlQ3JlYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL3BsdWdpbnMvYm9vdHN0cmFwLXRhYmxlL2Jvb3RzdHJhcC10YWJsZS5taW4uY3NzP2E5MDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2Nzcy9wbHVnaW5zL2Jvb3RzdHJhcC10YWJsZS9ib290c3RyYXAtdGFibGUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2V4dGVuZHMvbGlzdC5jc3M/NGViMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvY3NzL2V4dGVuZHMvbGlzdC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37\n")}]);